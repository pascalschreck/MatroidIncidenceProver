(* dans la couche 0 *)
Lemma LP1 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP1M : rk(P1 ::  nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
assert(HP1m : rk(P1 ::  nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP2M : rk(P2 ::  nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
assert(HP2m : rk(P2 ::  nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P5P6P7M3 : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: nil) (P2 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (nil) 1 2 0 HP2Mtmp HP1P5P6P7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P7m3 : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6m3 : rk(P1 :: P2 :: P5 :: P6 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P5P6M3 : rk(P1 :: P2 :: P5 :: P6 :: nil) <= 3).
{
	assert(HP1P2P5P6P7Mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6P7eq HP1P2P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P5P6P7Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P6m2 : rk(P1 :: P5 :: P6 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P1 :: P5 :: P6 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P1 :: P5 :: P6 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P6M2 : rk(P1 :: P5 :: P6 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2m2 : rk(P1 :: P2 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6eq HP1P2P5P6m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: nil) (P1 :: P5 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P1 :: P5 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P1 :: P5 :: P6 :: nil) ((P1 :: P2 :: nil) ++ (P1 :: P5 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6mtmp;try rewrite HT2 in HP1P2P5P6mtmp.
	assert(HT := rule_2 (P1 :: P2 :: nil) (P1 :: P5 :: P6 :: nil) (P1 :: nil) 3 1 2 HP1P2P5P6mtmp HP1mtmp HP1P5P6Mtmp Hincl);apply HT.
}


assert(HP1P2M : rk(P1 :: P2 ::  nil) <= 2) by (solve_hyps_max HP1P2eq HP1P2M2).
assert(HP1P2m : rk(P1 :: P2 ::  nil) >= 1) by (solve_hyps_min HP1P2eq HP1P2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP3M : rk(P3 ::  nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
assert(HP3m : rk(P3 ::  nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3m2 : rk(P1 :: P2 :: P3 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P1 :: P2 :: P3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P1 :: P2 :: P3 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3M2 : rk(P1 :: P2 :: P3 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P6P7m2 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P5P6P7M3 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) (P1 :: P2 :: P3 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P5 :: P6 :: P7 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P1 :: nil) 2 2 1 HP1P2P3Mtmp HP1P5P6P7Mtmp HP1mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P5P6P7m3 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P6m2 : rk(P2 :: P6 :: nil) >= 2).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P5P6P7eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P7eq HP1P2P5P6P7m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P2 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: nil) (P2 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P6 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7mtmp;try rewrite HT2 in HP1P2P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P6 :: nil) 3 1 2 HP1P2P5P6P7mtmp HP6mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P5P6P7M3 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3Mtmp : rk(P3 :: nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: nil) (P3 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P1 :: P5 :: P6 :: P7 :: nil) ((P3 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (nil) 1 2 0 HP3Mtmp HP1P5P6P7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P6P7m2 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) >= 2).
{
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6Mtmp : rk(P2 :: P6 :: nil) <= 2) by (solve_hyps_max HP2P6eq HP2P6M2).
	try assert(HP1P2P3P5P6P7eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P3P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5P6P7eq HP1P2P3P5P6P7m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P2 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) (P2 :: P6 :: P1 :: P3 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P1 :: P3 :: P5 :: P6 :: P7 :: nil) ((P2 :: P6 :: nil) ++ (P1 :: P3 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7mtmp;try rewrite HT2 in HP1P2P3P5P6P7mtmp.
	assert(HT := rule_4 (P2 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil) (P6 :: nil) 3 1 2 HP1P2P3P5P6P7mtmp HP6mtmp HP2P6Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P6P7m3 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P6m3 : rk(P1 :: P3 :: P5 :: P6 :: nil) >= 3).
{
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: nil) 3 3 HP1P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P3P5P6M3 : rk(P1 :: P3 :: P5 :: P6 :: nil) <= 3).
{
	assert(HP1P3P5P6P7Mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6P7eq HP1P3P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P3P5P6P7Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3m2 : rk(P1 :: P3 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6eq : rk(P1 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP1P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6mtmp : rk(P1 :: P3 :: P5 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6eq HP1P3P5P6m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P3 :: nil) (P1 :: P5 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P1 :: P5 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P1 :: P5 :: P6 :: nil) ((P1 :: P3 :: nil) ++ (P1 :: P5 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6mtmp;try rewrite HT2 in HP1P3P5P6mtmp.
	assert(HT := rule_2 (P1 :: P3 :: nil) (P1 :: P5 :: P6 :: nil) (P1 :: nil) 3 1 2 HP1P3P5P6mtmp HP1mtmp HP1P5P6Mtmp Hincl);apply HT.
}


assert(HP1P3M : rk(P1 :: P3 ::  nil) <= 2) by (solve_hyps_max HP1P3eq HP1P3M2).
assert(HP1P3m : rk(P1 :: P3 ::  nil) >= 1) by (solve_hyps_min HP1P3eq HP1P3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP2P3M : rk(P2 :: P3 ::  nil) <= 2) by (solve_hyps_max HP2P3eq HP2P3M2).
assert(HP2P3m : rk(P2 :: P3 ::  nil) >= 1) by (solve_hyps_min HP2P3eq HP2P3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P3 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P3 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3M2 : rk(P1 :: P2 :: P3 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P2P3M : rk(P1 :: P2 :: P3 ::  nil) <= 3) by (solve_hyps_max HP1P2P3eq HP1P2P3M3).
assert(HP1P2P3m : rk(P1 :: P2 :: P3 ::  nil) >= 1) by (solve_hyps_min HP1P2P3eq HP1P2P3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP4M : rk(P4 ::  nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
assert(HP4m : rk(P4 ::  nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4m2 : rk(P1 :: P2 :: P4 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P1 :: P2 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P1 :: P2 :: P4 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4M2 : rk(P1 :: P2 :: P4 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P6P7m2 : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P5P6P7M3 : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) (P1 :: P2 :: P4 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P5 :: P6 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P1 :: nil) 2 2 1 HP1P2P4Mtmp HP1P5P6P7Mtmp HP1mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P5P6P7m3 : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P4P5P6P7M3 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P7 :: nil) (P4 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P1 :: P5 :: P6 :: P7 :: nil) ((P4 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (nil) 1 2 0 HP4Mtmp HP1P5P6P7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P6P7m2 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: nil) >= 2).
{
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6Mtmp : rk(P2 :: P6 :: nil) <= 2) by (solve_hyps_max HP2P6eq HP2P6M2).
	try assert(HP1P2P4P5P6P7eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P4P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5P6P7eq HP1P2P4P5P6P7m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P2 :: P6 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) (P2 :: P6 :: P1 :: P4 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P1 :: P4 :: P5 :: P6 :: P7 :: nil) ((P2 :: P6 :: nil) ++ (P1 :: P4 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7mtmp;try rewrite HT2 in HP1P2P4P5P6P7mtmp.
	assert(HT := rule_4 (P2 :: P6 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil) (P6 :: nil) 3 1 2 HP1P2P4P5P6P7mtmp HP6mtmp HP2P6Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P6P7m3 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7m3 : rk(P1 :: P4 :: P5 :: P7 :: nil) >= 3).
{
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: nil) 3 3 HP1P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P4P5P7M3 : rk(P1 :: P4 :: P5 :: P7 :: nil) <= 3).
{
	assert(HP1P4P5P6P7Mtmp : rk(P1 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P4P5P6P7eq HP1P4P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P4P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5P6P7M1. try clear HP1P4P5P6P7M2. try clear HP1P4P5P6P7M3. try clear HP1P4P5P6P7m4. try clear HP1P4P5P6P7m3. try clear HP1P4P5P6P7m2. try clear HP1P4P5P6P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P7m2 : rk(P1 :: P5 :: P7 :: nil) >= 2).
{
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P7 :: nil) (P1 :: P5 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P7 :: nil) (P1 :: P5 :: P7 :: nil) 2 2 HP5P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P7M2 : rk(P1 :: P5 :: P7 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4m2 : rk(P1 :: P4 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7eq : rk(P1 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP1P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7mtmp : rk(P1 :: P4 :: P5 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P5P7eq HP1P4P5P7m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P4 :: nil) (P1 :: P5 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P4 :: P1 :: P5 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P1 :: P5 :: P7 :: nil) ((P1 :: P4 :: nil) ++ (P1 :: P5 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7mtmp;try rewrite HT2 in HP1P4P5P7mtmp.
	assert(HT := rule_2 (P1 :: P4 :: nil) (P1 :: P5 :: P7 :: nil) (P1 :: nil) 3 1 2 HP1P4P5P7mtmp HP1mtmp HP1P5P7Mtmp Hincl);apply HT.
}


assert(HP1P4M : rk(P1 :: P4 ::  nil) <= 2) by (solve_hyps_max HP1P4eq HP1P4M2).
assert(HP1P4m : rk(P1 :: P4 ::  nil) >= 1) by (solve_hyps_min HP1P4eq HP1P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP2P4M : rk(P2 :: P4 ::  nil) <= 2) by (solve_hyps_max HP2P4eq HP2P4M2).
assert(HP2P4m : rk(P2 :: P4 ::  nil) >= 1) by (solve_hyps_min HP2P4eq HP2P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4M2 : rk(P1 :: P2 :: P4 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P2P4M : rk(P1 :: P2 :: P4 ::  nil) <= 3) by (solve_hyps_max HP1P2P4eq HP1P2P4M3).
assert(HP1P2P4m : rk(P1 :: P2 :: P4 ::  nil) >= 1) by (solve_hyps_min HP1P2P4eq HP1P2P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP3P4M : rk(P3 :: P4 ::  nil) <= 2) by (solve_hyps_max HP3P4eq HP3P4M2).
assert(HP3P4m : rk(P3 :: P4 ::  nil) >= 1) by (solve_hyps_min HP3P4eq HP3P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4m2 : rk(P1 :: P3 :: P4 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P4M2 : rk(P1 :: P3 :: P4 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P3P4M : rk(P1 :: P3 :: P4 ::  nil) <= 3) by (solve_hyps_max HP1P3P4eq HP1P3P4M3).
assert(HP1P3P4m : rk(P1 :: P3 :: P4 ::  nil) >= 1) by (solve_hyps_min HP1P3P4eq HP1P3P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P4 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P4 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4m2 : rk(P2 :: P3 :: P4 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P4M2 : rk(P2 :: P3 :: P4 :: nil) <= 2).
{
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P4 :: nil) 2 2 HP1P2P3P4Mtmp Hcomp Hincl);apply HT.
}


assert(HP2P3P4M : rk(P2 :: P3 :: P4 ::  nil) <= 3) by (solve_hyps_max HP2P3P4eq HP2P3P4M3).
assert(HP2P3P4m : rk(P2 :: P3 :: P4 ::  nil) >= 1) by (solve_hyps_min HP2P3P4eq HP2P3P4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP5M : rk(P5 ::  nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
assert(HP5m : rk(P5 ::  nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5m2 : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P5M3 : rk(P1 :: P2 :: P3 :: P5 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P5 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P5m3 : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5m2 : rk(P1 :: P5 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P1 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P5 :: nil) (P1 :: nil) 3 1 2 HP1P2P3P5mtmp HP1mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP1P5M : rk(P1 :: P5 ::  nil) <= 2) by (solve_hyps_max HP1P5eq HP1P5M2).
assert(HP1P5m : rk(P1 :: P5 ::  nil) >= 1) by (solve_hyps_min HP1P5eq HP1P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P5 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5m2 : rk(P2 :: P5 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P2 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P5 :: nil) (P2 :: nil) 3 1 2 HP1P2P3P5mtmp HP2mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP2P5M : rk(P2 :: P5 ::  nil) <= 2) by (solve_hyps_max HP2P5eq HP2P5M2).
assert(HP2P5m : rk(P2 :: P5 ::  nil) >= 1) by (solve_hyps_min HP2P5eq HP2P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP1P2P5M : rk(P1 :: P2 :: P5 ::  nil) <= 3) by (solve_hyps_max HP1P2P5eq HP1P2P5M3).
assert(HP1P2P5m : rk(P1 :: P2 :: P5 ::  nil) >= 1) by (solve_hyps_min HP1P2P5eq HP1P2P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5m2 : rk(P3 :: P5 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P3 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P3 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P3 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P3 :: P5 :: nil) (P3 :: nil) 3 1 2 HP1P2P3P5mtmp HP3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP3P5M : rk(P3 :: P5 ::  nil) <= 2) by (solve_hyps_max HP3P5eq HP3P5M2).
assert(HP3P5m : rk(P3 :: P5 ::  nil) >= 1) by (solve_hyps_min HP3P5eq HP3P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5m2 : rk(P1 :: P3 :: P5 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3Mtmp : rk(P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP2P3eq HP2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P2 :: P3 :: nil) (P1 :: P3 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P1 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P1 :: P3 :: P5 :: nil) ((P2 :: P3 :: nil) ++ (P1 :: P3 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P2 :: P3 :: nil) (P1 :: P3 :: P5 :: nil) (P3 :: nil) 3 1 2 HP1P2P3P5mtmp HP3mtmp HP2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5m3 : rk(P1 :: P3 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hincl : incl (P1 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P3 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P1 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P3 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P3 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: nil) 3 2 2 HP1P2P3P5mtmp HP1P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP1P3P5M : rk(P1 :: P3 :: P5 ::  nil) <= 3) by (solve_hyps_max HP1P3P5eq HP1P3P5M3).
assert(HP1P3P5m : rk(P1 :: P3 :: P5 ::  nil) >= 1) by (solve_hyps_min HP1P3P5eq HP1P3P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5m2 : rk(P2 :: P3 :: P5 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5m3 : rk(P2 :: P3 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5eq HP1P2P3P5m3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P3 :: P2 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P3 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P3 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5mtmp;try rewrite HT2 in HP1P2P3P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: nil) 3 2 2 HP1P2P3P5mtmp HP2P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP2P3P5M : rk(P2 :: P3 :: P5 ::  nil) <= 3) by (solve_hyps_max HP2P3P5eq HP2P3P5M3).
assert(HP2P3P5m : rk(P2 :: P3 :: P5 ::  nil) >= 1) by (solve_hyps_min HP2P3P5eq HP2P3P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P5 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5m2 : rk(P1 :: P2 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P5M3 : rk(P1 :: P2 :: P4 :: P5 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P4 :: nil) (P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P5 :: nil) (nil) 2 1 0 HP1P2P4Mtmp HP5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5m3 : rk(P1 :: P2 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5m2 : rk(P4 :: P5 :: nil) >= 2).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P5eq : rk(P1 :: P2 :: P4 :: P5 :: nil) = 3) by (apply LP1P2P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5mtmp : rk(P1 :: P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5eq HP1P2P4P5m3).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: nil) (P1 :: P2 :: P4 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P4 :: P5 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5mtmp;try rewrite HT2 in HP1P2P4P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P4 :: P5 :: nil) (P4 :: nil) 3 1 2 HP1P2P4P5mtmp HP4mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP4P5M : rk(P4 :: P5 ::  nil) <= 2) by (solve_hyps_max HP4P5eq HP4P5M2).
assert(HP4P5m : rk(P4 :: P5 ::  nil) >= 1) by (solve_hyps_min HP4P5eq HP4P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P4P5M3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5Mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5eq HP1P2P3P5M3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: nil) (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P5 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P3 :: P5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P5 :: nil) (P2 :: P3 :: nil) 2 3 2 HP2P3P4Mtmp HP1P2P3P5Mtmp HP2P3mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5m2 : rk(P1 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) = 3) by (apply LP1P2P3P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P5eq HP1P2P3P4P5m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: nil) (P1 :: P2 :: P3 :: P1 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P4 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5mtmp;try rewrite HT2 in HP1P2P3P4P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P5 :: nil) (P1 :: nil) 3 1 2 HP1P2P3P4P5mtmp HP1mtmp HP1P2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5m3 : rk(P1 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P5eq : rk(P1 :: P2 :: P4 :: P5 :: nil) = 3) by (apply LP1P2P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5mtmp : rk(P1 :: P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5eq HP1P2P4P5m3).
	try assert(HP1P4eq : rk(P1 :: P4 :: nil) = 2) by (apply LP1P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hincl : incl (P1 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: nil) (P1 :: P2 :: P4 :: P1 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P4 :: P5 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5mtmp;try rewrite HT2 in HP1P2P4P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: nil) 3 2 2 HP1P2P4P5mtmp HP1P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP1P4P5M : rk(P1 :: P4 :: P5 ::  nil) <= 3) by (solve_hyps_max HP1P4P5eq HP1P4P5M3).
assert(HP1P4P5m : rk(P1 :: P4 :: P5 ::  nil) >= 1) by (solve_hyps_min HP1P4P5eq HP1P4P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5m2 : rk(P2 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5m3 : rk(P2 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P5eq : rk(P1 :: P2 :: P4 :: P5 :: nil) = 3) by (apply LP1P2P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5mtmp : rk(P1 :: P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5eq HP1P2P4P5m3).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: nil) (P1 :: P2 :: P4 :: P2 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P2 :: P4 :: P5 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P2 :: P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5mtmp;try rewrite HT2 in HP1P2P4P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: nil) 3 2 2 HP1P2P4P5mtmp HP2P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P2P4P5M1. try clear HP1P2P4P5M2. try clear HP1P2P4P5M3. try clear HP1P2P4P5m4. try clear HP1P2P4P5m3. try clear HP1P2P4P5m2. try clear HP1P2P4P5m1. 

assert(HP2P4P5M : rk(P2 :: P4 :: P5 ::  nil) <= 3) by (solve_hyps_max HP2P4P5eq HP2P4P5M3).
assert(HP2P4P5m : rk(P2 :: P4 :: P5 ::  nil) >= 1) by (solve_hyps_min HP2P4P5eq HP2P4P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P5 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P5 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P5m2 : rk(P1 :: P3 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P5M3 : rk(P1 :: P3 :: P4 :: P5 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P3 :: P4 :: nil) (P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P5 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P5 :: nil) (nil) 2 1 0 HP1P3P4Mtmp HP5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5m3 : rk(P1 :: P3 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) = 3) by (apply LP1P2P3P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P5eq HP1P2P3P4P5m3).
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hincl : incl (P1 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: nil) (P1 :: P2 :: P3 :: P1 :: P3 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P3 :: P4 :: P5 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5mtmp;try rewrite HT2 in HP1P2P3P4P5mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: nil) (P1 :: P3 :: nil) 3 2 2 HP1P2P3P4P5mtmp HP1P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5M1. try clear HP1P2P3P4P5M2. try clear HP1P2P3P4P5M3. try clear HP1P2P3P4P5m4. try clear HP1P2P3P4P5m3. try clear HP1P2P3P4P5m2. try clear HP1P2P3P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5m2 : rk(P3 :: P4 :: P5 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5m3 : rk(P3 :: P4 :: P5 :: nil) >= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P3P4P5eq : rk(P1 :: P3 :: P4 :: P5 :: nil) = 3) by (apply LP1P3P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5mtmp : rk(P1 :: P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P4P5eq HP1P3P4P5m3).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: nil) (P1 :: P3 :: P4 :: P3 :: P4 :: P5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P3 :: P4 :: P5 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P3 :: P4 :: P5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5mtmp;try rewrite HT2 in HP1P3P4P5mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: nil) 3 2 2 HP1P3P4P5mtmp HP3P4mtmp HP1P3P4Mtmp Hincl); apply HT.
}
try clear HP1P3P4P5M1. try clear HP1P3P4P5M2. try clear HP1P3P4P5M3. try clear HP1P3P4P5m4. try clear HP1P3P4P5m3. try clear HP1P3P4P5m2. try clear HP1P3P4P5m1. 

assert(HP3P4P5M : rk(P3 :: P4 :: P5 ::  nil) <= 3) by (solve_hyps_max HP3P4P5eq HP3P4P5M3).
assert(HP3P4P5m : rk(P3 :: P4 :: P5 ::  nil) >= 1) by (solve_hyps_min HP3P4P5eq HP3P4P5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P6 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP6M : rk(P6 ::  nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
assert(HP6m : rk(P6 ::  nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P6 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P6m2 : rk(P1 :: P2 :: P3 :: P6 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P6M3 : rk(P1 :: P2 :: P3 :: P6 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P6 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P6 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP6Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P6m3 : rk(P1 :: P2 :: P3 :: P6 :: nil) >= 3).
{
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: nil) 3 3 HP1P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6m2 : rk(P1 :: P6 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P3P6eq HP1P2P3P6m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P1 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6mtmp;try rewrite HT2 in HP1P2P3P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P6 :: nil) (P1 :: nil) 3 1 2 HP1P2P3P6mtmp HP1mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP1P6M : rk(P1 :: P6 ::  nil) <= 2) by (solve_hyps_max HP1P6eq HP1P6M2).
assert(HP1P6m : rk(P1 :: P6 ::  nil) >= 1) by (solve_hyps_min HP1P6eq HP1P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P6 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P6m2 : rk(P2 :: P6 :: nil) >= 2).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P5P6P7eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P7eq HP1P2P5P6P7m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P2 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: nil) (P2 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P6 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7mtmp;try rewrite HT2 in HP1P2P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P6 :: nil) 3 1 2 HP1P2P5P6P7mtmp HP6mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


assert(HP2P6M : rk(P2 :: P6 ::  nil) <= 2) by (solve_hyps_max HP2P6eq HP2P6M2).
assert(HP2P6m : rk(P2 :: P6 ::  nil) >= 1) by (solve_hyps_min HP2P6eq HP2P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6m2 : rk(P1 :: P2 :: P6 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6Mtmp : rk(P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP5P6eq HP5P6M2).
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6eq HP1P2P5P6m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P2 :: P6 :: nil) (P5 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P6 :: P5 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P5 :: P6 :: nil) ((P1 :: P2 :: P6 :: nil) ++ (P5 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6mtmp;try rewrite HT2 in HP1P2P5P6mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P6 :: nil) (P5 :: P6 :: nil) (P6 :: nil) 3 1 2 HP1P2P5P6mtmp HP6mtmp HP5P6Mtmp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6m3 : rk(P1 :: P2 :: P6 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P3P6eq HP1P2P3P6m3).
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hincl : incl (P1 :: P2 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P1 :: P2 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P2 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P2 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6mtmp;try rewrite HT2 in HP1P2P3P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: nil) 3 2 2 HP1P2P3P6mtmp HP1P2mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP1P2P6M : rk(P1 :: P2 :: P6 ::  nil) <= 3) by (solve_hyps_max HP1P2P6eq HP1P2P6M3).
assert(HP1P2P6m : rk(P1 :: P2 :: P6 ::  nil) >= 1) by (solve_hyps_min HP1P2P6eq HP1P2P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP1P3P6M : rk(P1 :: P3 :: P6 ::  nil) <= 3) by (solve_hyps_max HP1P3P6eq HP1P3P6M3).
assert(HP1P3P6m : rk(P1 :: P3 :: P6 ::  nil) >= 1) by (solve_hyps_min HP1P3P6eq HP1P3P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P6m2 : rk(P2 :: P3 :: P6 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6m3 : rk(P2 :: P3 :: P6 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P3P6eq HP1P2P3P6m3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P3 :: P2 :: P3 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P3 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P3 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6mtmp;try rewrite HT2 in HP1P2P3P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: nil) 3 2 2 HP1P2P3P6mtmp HP2P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


assert(HP2P3P6M : rk(P2 :: P3 :: P6 ::  nil) <= 3) by (solve_hyps_max HP2P3P6eq HP2P3P6M3).
assert(HP2P3P6m : rk(P2 :: P3 :: P6 ::  nil) >= 1) by (solve_hyps_min HP2P3P6eq HP2P3P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P6 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P6m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P4P6M3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6Mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P3P6eq HP1P2P3P6M3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: nil) (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P6 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P3 :: P6 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P6 :: nil) (P2 :: P3 :: nil) 2 3 2 HP2P3P4Mtmp HP1P2P3P6Mtmp HP2P3mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P6m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P6m2 : rk(P1 :: P2 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P6M3 : rk(P1 :: P2 :: P4 :: P6 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P4 :: nil) (P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: nil) (P1 :: P2 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P6 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P6 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P6 :: nil) (nil) 2 1 0 HP1P2P4Mtmp HP6Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P6m3 : rk(P1 :: P2 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P6eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) = 3) by (apply LP1P2P3P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P6eq HP1P2P3P4P6m3).
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hincl : incl (P1 :: P2 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: nil) (P1 :: P2 :: P3 :: P1 :: P2 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P2 :: P4 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P2 :: P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6mtmp;try rewrite HT2 in HP1P2P3P4P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P2 :: P4 :: P6 :: nil) (P1 :: P2 :: nil) 3 2 2 HP1P2P3P4P6mtmp HP1P2mtmp HP1P2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6m2 : rk(P4 :: P6 :: nil) >= 2).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P6eq : rk(P1 :: P2 :: P4 :: P6 :: nil) = 3) by (apply LP1P2P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P6mtmp : rk(P1 :: P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P4P6eq HP1P2P4P6m3).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: nil) (P1 :: P2 :: P4 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P4 :: P6 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6mtmp;try rewrite HT2 in HP1P2P4P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P4 :: P6 :: nil) (P4 :: nil) 3 1 2 HP1P2P4P6mtmp HP4mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP4P6M : rk(P4 :: P6 ::  nil) <= 2) by (solve_hyps_max HP4P6eq HP4P6M2).
assert(HP4P6m : rk(P4 :: P6 ::  nil) >= 1) by (solve_hyps_min HP4P6eq HP4P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6m2 : rk(P1 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P6eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) = 3) by (apply LP1P2P3P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P6eq HP1P2P3P4P6m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: nil) (P1 :: P2 :: P3 :: P1 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P4 :: P6 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6mtmp;try rewrite HT2 in HP1P2P3P4P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P6 :: nil) (P1 :: nil) 3 1 2 HP1P2P3P4P6mtmp HP1mtmp HP1P2P3Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P6M1. try clear HP1P2P3P4P6M2. try clear HP1P2P3P4P6M3. try clear HP1P2P3P4P6m4. try clear HP1P2P3P4P6m3. try clear HP1P2P3P4P6m2. try clear HP1P2P3P4P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6m3 : rk(P1 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P6eq : rk(P1 :: P2 :: P4 :: P6 :: nil) = 3) by (apply LP1P2P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P6mtmp : rk(P1 :: P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P4P6eq HP1P2P4P6m3).
	try assert(HP1P4eq : rk(P1 :: P4 :: nil) = 2) by (apply LP1P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hincl : incl (P1 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: nil) (P1 :: P2 :: P4 :: P1 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P4 :: P6 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6mtmp;try rewrite HT2 in HP1P2P4P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: nil) 3 2 2 HP1P2P4P6mtmp HP1P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P4M1. try clear HP1P4M2. try clear HP1P4M3. try clear HP1P4m4. try clear HP1P4m3. try clear HP1P4m2. try clear HP1P4m1. 

assert(HP1P4P6M : rk(P1 :: P4 :: P6 ::  nil) <= 3) by (solve_hyps_max HP1P4P6eq HP1P4P6M3).
assert(HP1P4P6m : rk(P1 :: P4 :: P6 ::  nil) >= 1) by (solve_hyps_min HP1P4P6eq HP1P4P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P6m2 : rk(P2 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6m3 : rk(P2 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P6eq : rk(P1 :: P2 :: P4 :: P6 :: nil) = 3) by (apply LP1P2P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P6mtmp : rk(P1 :: P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P4P6eq HP1P2P4P6m3).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: nil) (P1 :: P2 :: P4 :: P2 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P2 :: P4 :: P6 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P2 :: P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6mtmp;try rewrite HT2 in HP1P2P4P6mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: nil) 3 2 2 HP1P2P4P6mtmp HP2P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P2P4P6M1. try clear HP1P2P4P6M2. try clear HP1P2P4P6M3. try clear HP1P2P4P6m4. try clear HP1P2P4P6m3. try clear HP1P2P4P6m2. try clear HP1P2P4P6m1. 

assert(HP2P4P6M : rk(P2 :: P4 :: P6 ::  nil) <= 3) by (solve_hyps_max HP2P4P6eq HP2P4P6M3).
assert(HP2P4P6m : rk(P2 :: P4 :: P6 ::  nil) >= 1) by (solve_hyps_min HP2P4P6eq HP2P4P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P6m2 : rk(P1 :: P3 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P6M3 : rk(P1 :: P3 :: P4 :: P6 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P3 :: P4 :: nil) (P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P6 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P6 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P6 :: nil) (nil) 2 1 0 HP1P3P4Mtmp HP6Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P6m3 : rk(P1 :: P3 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P6m2 : rk(P3 :: P4 :: P6 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P6m3 : rk(P3 :: P4 :: P6 :: nil) >= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P3P4P6eq : rk(P1 :: P3 :: P4 :: P6 :: nil) = 3) by (apply LP1P3P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P6mtmp : rk(P1 :: P3 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P4P6eq HP1P3P4P6m3).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P6 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: nil) (P1 :: P3 :: P4 :: P3 :: P4 :: P6 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P3 :: P4 :: P6 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P3 :: P4 :: P6 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P6mtmp;try rewrite HT2 in HP1P3P4P6mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P6 :: nil) (P3 :: P4 :: nil) 3 2 2 HP1P3P4P6mtmp HP3P4mtmp HP1P3P4Mtmp Hincl); apply HT.
}
try clear HP1P3P4P6M1. try clear HP1P3P4P6M2. try clear HP1P3P4P6M3. try clear HP1P3P4P6m4. try clear HP1P3P4P6m3. try clear HP1P3P4P6m2. try clear HP1P3P4P6m1. 

assert(HP3P4P6M : rk(P3 :: P4 :: P6 ::  nil) <= 3) by (solve_hyps_max HP3P4P6eq HP3P4P6M3).
assert(HP3P4P6m : rk(P3 :: P4 :: P6 ::  nil) >= 1) by (solve_hyps_min HP3P4P6eq HP3P4P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 :: P6 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP5P6M : rk(P5 :: P6 ::  nil) <= 2) by (solve_hyps_max HP5P6eq HP5P6M2).
assert(HP5P6m : rk(P5 :: P6 ::  nil) >= 1) by (solve_hyps_min HP5P6eq HP5P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 :: P6 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6M2 : rk(P1 :: P5 :: P6 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P5P6M : rk(P1 :: P5 :: P6 ::  nil) <= 3) by (solve_hyps_max HP1P5P6eq HP1P5P6M3).
assert(HP1P5P6m : rk(P1 :: P5 :: P6 ::  nil) >= 1) by (solve_hyps_min HP1P5P6eq HP1P5P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P5P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P5 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P6m2 : rk(P2 :: P3 :: P5 :: P6 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P6m3 : rk(P2 :: P3 :: P5 :: P6 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P3P5P6P7eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P3P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5P6P7eq HP1P2P3P5P6P7m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P2 :: P3 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) (P2 :: P3 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P3 :: P5 :: P6 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7mtmp;try rewrite HT2 in HP1P2P3P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P2P3P5P6P7mtmp HP5P6mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P5P6M3 : rk(P2 :: P3 :: P5 :: P6 :: nil) <= 3).
{
	assert(HP1P2P3P5P6P7Mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5P6P7eq HP1P2P3P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P3P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP2P3P5P6M : rk(P2 :: P3 :: P5 :: P6 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P5P6m : rk(P2 :: P3 :: P5 :: P6 ::  nil) >= 1) by (solve_hyps_min HP2P3P5P6eq HP2P3P5P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P5P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P5 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5P6m2 : rk(P2 :: P4 :: P5 :: P6 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P6m3 : rk(P2 :: P4 :: P5 :: P6 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P4P5P6P7eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P4P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5P6P7eq HP1P2P4P5P6P7m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P2 :: P4 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) (P2 :: P4 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P4 :: P5 :: P6 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7mtmp;try rewrite HT2 in HP1P2P4P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P2P4P5P6P7mtmp HP5P6mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P5P6M3 : rk(P2 :: P4 :: P5 :: P6 :: nil) <= 3).
{
	assert(HP1P2P4P5P6P7Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P5P6P7eq HP1P2P4P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P4 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P4P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP2P4P5P6M : rk(P2 :: P4 :: P5 :: P6 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P5P6m : rk(P2 :: P4 :: P5 :: P6 ::  nil) >= 1) by (solve_hyps_min HP2P4P5P6eq HP2P4P5P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P5P6 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P5 :: P6 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P5P6P7m2 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P5P6P7M3 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) (P1 :: P3 :: P4 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P1 :: P5 :: P6 :: P7 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P1 :: nil) 2 2 1 HP1P3P4Mtmp HP1P5P6P7Mtmp HP1mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P5P6P7m3 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P6m2 : rk(P3 :: P4 :: P5 :: P6 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P6m3 : rk(P3 :: P4 :: P5 :: P6 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P3P4P5P6P7eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P4P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P4P5P6P7eq HP1P3P4P5P6P7m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P3 :: P4 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) (P3 :: P4 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P6 :: P1 :: P5 :: P6 :: P7 :: nil) ((P3 :: P4 :: P5 :: P6 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7mtmp;try rewrite HT2 in HP1P3P4P5P6P7mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P5 :: P6 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P3P4P5P6P7mtmp HP5P6mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P4P5P6M3 : rk(P3 :: P4 :: P5 :: P6 :: nil) <= 3).
{
	assert(HP1P3P4P5P6P7Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P4P5P6P7eq HP1P3P4P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P4 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P3P4P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP3P4P5P6M : rk(P3 :: P4 :: P5 :: P6 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P4P5P6m : rk(P3 :: P4 :: P5 :: P6 ::  nil) >= 1) by (solve_hyps_min HP3P4P5P6eq HP3P4P5P6m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P7 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP7M : rk(P7 ::  nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
assert(HP7m : rk(P7 ::  nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P7m2 : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P7M3 : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7Mtmp : rk(P7 :: nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P4 :: nil) (P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P7 :: nil) (nil) 2 1 0 HP1P2P4Mtmp HP7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P7m3 : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 3).
{
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: nil) 3 3 HP1P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P7m2 : rk(P1 :: P7 :: nil) >= 2).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P7eq HP1P2P4P7m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P1 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7mtmp;try rewrite HT2 in HP1P2P4P7mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P7 :: nil) (P1 :: nil) 3 1 2 HP1P2P4P7mtmp HP1mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP1P7M : rk(P1 :: P7 ::  nil) <= 2) by (solve_hyps_max HP1P7eq HP1P7M2).
assert(HP1P7m : rk(P1 :: P7 ::  nil) >= 1) by (solve_hyps_min HP1P7eq HP1P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P7m2 : rk(P2 :: P7 :: nil) >= 2).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P5P6P7eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P7eq HP1P2P5P6P7m3).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P2 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: nil) (P2 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7mtmp;try rewrite HT2 in HP1P2P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P7 :: nil) 3 1 2 HP1P2P5P6P7mtmp HP7mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


assert(HP2P7M : rk(P2 :: P7 ::  nil) <= 2) by (solve_hyps_max HP2P7eq HP2P7M2).
assert(HP2P7m : rk(P2 :: P7 ::  nil) >= 1) by (solve_hyps_min HP2P7eq HP2P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P7 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P7m3 : rk(P1 :: P2 :: P5 :: P7 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7m2 : rk(P1 :: P2 :: P7 :: nil) >= 2).
{
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7Mtmp : rk(P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P7eq HP5P7M2).
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P5P7eq HP1P2P5P7m3).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P2 :: P7 :: nil) (P5 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P7 :: P5 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P5 :: P7 :: nil) ((P1 :: P2 :: P7 :: nil) ++ (P5 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7mtmp;try rewrite HT2 in HP1P2P5P7mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P7 :: nil) (P5 :: P7 :: nil) (P7 :: nil) 3 1 2 HP1P2P5P7mtmp HP7mtmp HP5P7Mtmp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7m3 : rk(P1 :: P2 :: P7 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P7eq HP1P2P4P7m3).
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hincl : incl (P1 :: P2 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P1 :: P2 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P2 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P2 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7mtmp;try rewrite HT2 in HP1P2P4P7mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: nil) 3 2 2 HP1P2P4P7mtmp HP1P2mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

assert(HP1P2P7M : rk(P1 :: P2 :: P7 ::  nil) <= 3) by (solve_hyps_max HP1P2P7eq HP1P2P7M3).
assert(HP1P2P7m : rk(P1 :: P2 :: P7 ::  nil) >= 1) by (solve_hyps_min HP1P2P7eq HP1P2P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P7m2 : rk(P3 :: P7 :: nil) >= 2).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P3P5P6P7eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P7eq HP1P3P5P6P7m3).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P3 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: nil) (P3 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil) ((P3 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7mtmp;try rewrite HT2 in HP1P3P5P6P7mtmp.
	assert(HT := rule_2 (P3 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P7 :: nil) 3 1 2 HP1P3P5P6P7mtmp HP7mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


assert(HP3P7M : rk(P3 :: P7 ::  nil) <= 2) by (solve_hyps_max HP3P7eq HP3P7M2).
assert(HP3P7m : rk(P3 :: P7 ::  nil) >= 1) by (solve_hyps_min HP3P7eq HP3P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P7 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P7m2 : rk(P1 :: P3 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P7M3 : rk(P1 :: P3 :: P4 :: P7 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7Mtmp : rk(P7 :: nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P3 :: P4 :: nil) (P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P7 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P7 :: nil) (nil) 2 1 0 HP1P3P4Mtmp HP7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P4P7m3 : rk(P1 :: P3 :: P4 :: P7 :: nil) >= 3).
{
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P7 :: nil) 3 3 HP1P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P6P7m3 : rk(P1 :: P3 :: P6 :: P7 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7m2 : rk(P1 :: P3 :: P7 :: nil) >= 2).
{
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7Mtmp : rk(P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP6P7eq HP6P7M2).
	try assert(HP1P3P6P7eq : rk(P1 :: P3 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7mtmp : rk(P1 :: P3 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P6P7eq HP1P3P6P7m3).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P3 :: P7 :: nil) (P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P3 :: P7 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P7 :: P6 :: P7 :: nil) ((P1 :: P3 :: P7 :: nil) ++ (P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P6P7mtmp;try rewrite HT2 in HP1P3P6P7mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P7 :: nil) (P6 :: P7 :: nil) (P7 :: nil) 3 1 2 HP1P3P6P7mtmp HP7mtmp HP6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7m3 : rk(P1 :: P3 :: P7 :: nil) >= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P3P4P7eq : rk(P1 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7mtmp : rk(P1 :: P3 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P4P7eq HP1P3P4P7m3).
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hincl : incl (P1 :: P3 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P1 :: P3 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P1 :: P3 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P1 :: P3 :: P7 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P1 :: P3 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P7mtmp;try rewrite HT2 in HP1P3P4P7mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: nil) (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: nil) 3 2 2 HP1P3P4P7mtmp HP1P3mtmp HP1P3P4Mtmp Hincl); apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

assert(HP1P3P7M : rk(P1 :: P3 :: P7 ::  nil) <= 3) by (solve_hyps_max HP1P3P7eq HP1P3P7M3).
assert(HP1P3P7m : rk(P1 :: P3 :: P7 ::  nil) >= 1) by (solve_hyps_min HP1P3P7eq HP1P3P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P7 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P7m2 : rk(P1 :: P2 :: P3 :: P7 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P7M3 : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7Mtmp : rk(P7 :: nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P7 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P7m2 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P4P7M3 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P7 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P3 :: P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P7 :: nil) (P2 :: P3 :: nil) 2 3 2 HP2P3P4Mtmp HP1P2P3P7Mtmp HP2P3mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P4P7m3 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) >= 3).
{
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: nil) 3 3 HP1P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P7m2 : rk(P2 :: P3 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P7M3 : rk(P2 :: P3 :: P4 :: P7 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7Mtmp : rk(P7 :: nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P3 :: P4 :: nil) (P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P7 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P7 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P7 :: nil) (nil) 2 1 0 HP2P3P4Mtmp HP7Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P7m3 : rk(P2 :: P3 :: P4 :: P7 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P7eq : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P7mtmp : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P7eq HP1P2P3P4P7m3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P7 :: nil) (P1 :: P2 :: P3 :: P2 :: P3 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P3 :: P4 :: P7 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P3 :: P4 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P7mtmp;try rewrite HT2 in HP1P2P3P4P7mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P3 :: nil) 3 2 2 HP1P2P3P4P7mtmp HP2P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P7m2 : rk(P2 :: P3 :: P7 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P7m3 : rk(P2 :: P3 :: P7 :: nil) >= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P7eq : rk(P2 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP2P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P7mtmp : rk(P2 :: P3 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P4P7eq HP2P3P4P7m3).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P2 :: P3 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P3 :: P4 :: P2 :: P3 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P2 :: P3 :: P7 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P2 :: P3 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P7mtmp;try rewrite HT2 in HP2P3P4P7mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: nil) 3 2 2 HP2P3P4P7mtmp HP2P3mtmp HP2P3P4Mtmp Hincl); apply HT.
}


assert(HP2P3P7M : rk(P2 :: P3 :: P7 ::  nil) <= 3) by (solve_hyps_max HP2P3P7eq HP2P3P7M3).
assert(HP2P3P7m : rk(P2 :: P3 :: P7 ::  nil) >= 1) by (solve_hyps_min HP2P3P7eq HP2P3P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P7m2 : rk(P4 :: P7 :: nil) >= 2).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P7eq HP1P2P4P7m3).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P4 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P4 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P4 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7mtmp;try rewrite HT2 in HP1P2P4P7mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P4 :: P7 :: nil) (P4 :: nil) 3 1 2 HP1P2P4P7mtmp HP4mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP4P7M : rk(P4 :: P7 ::  nil) <= 2) by (solve_hyps_max HP4P7eq HP4P7M2).
assert(HP4P7m : rk(P4 :: P7 ::  nil) >= 1) by (solve_hyps_min HP4P7eq HP4P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P7 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P7m2 : rk(P2 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P7m3 : rk(P2 :: P4 :: P7 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P7eq HP1P2P4P7m3).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P2 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P2 :: P4 :: P7 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P2 :: P4 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7mtmp;try rewrite HT2 in HP1P2P4P7mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: nil) 3 2 2 HP1P2P4P7mtmp HP2P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}


assert(HP2P4P7M : rk(P2 :: P4 :: P7 ::  nil) <= 3) by (solve_hyps_max HP2P4P7eq HP2P4P7M3).
assert(HP2P4P7m : rk(P2 :: P4 :: P7 ::  nil) >= 1) by (solve_hyps_min HP2P4P7eq HP2P4P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P7 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P7m2 : rk(P3 :: P4 :: P7 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P7m3 : rk(P3 :: P4 :: P7 :: nil) >= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P3P4P7eq : rk(P1 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7mtmp : rk(P1 :: P3 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P4P7eq HP1P3P4P7m3).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P3 :: P4 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P3 :: P4 :: P7 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P3 :: P4 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P7mtmp;try rewrite HT2 in HP1P3P4P7mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: nil) (P3 :: P4 :: P7 :: nil) (P3 :: P4 :: nil) 3 2 2 HP1P3P4P7mtmp HP3P4mtmp HP1P3P4Mtmp Hincl); apply HT.
}


assert(HP3P4P7M : rk(P3 :: P4 :: P7 ::  nil) <= 3) by (solve_hyps_max HP3P4P7eq HP3P4P7M3).
assert(HP3P4P7m : rk(P3 :: P4 :: P7 ::  nil) >= 1) by (solve_hyps_min HP3P4P7eq HP3P4P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP5P7M : rk(P5 :: P7 ::  nil) <= 2) by (solve_hyps_max HP5P7eq HP5P7M2).
assert(HP5P7m : rk(P5 :: P7 ::  nil) >= 1) by (solve_hyps_min HP5P7eq HP5P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P7M2 : rk(P1 :: P5 :: P7 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P5P7M : rk(P1 :: P5 :: P7 ::  nil) <= 3) by (solve_hyps_max HP1P5P7eq HP1P5P7M3).
assert(HP1P5P7m : rk(P1 :: P5 :: P7 ::  nil) >= 1) by (solve_hyps_min HP1P5P7eq HP1P5P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP6P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P6 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP6P7M : rk(P6 :: P7 ::  nil) <= 2) by (solve_hyps_max HP6P7eq HP6P7M2).
assert(HP6P7m : rk(P6 :: P7 ::  nil) >= 1) by (solve_hyps_min HP6P7eq HP6P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P6P7 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P6 :: P7 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P6P7m2 : rk(P1 :: P6 :: P7 :: nil) >= 2).
{
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P7M2 : rk(P1 :: P6 :: P7 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}


assert(HP1P6P7M : rk(P1 :: P6 :: P7 ::  nil) <= 3) by (solve_hyps_max HP1P6P7eq HP1P6P7M3).
assert(HP1P6P7m : rk(P1 :: P6 :: P7 ::  nil) >= 1) by (solve_hyps_min HP1P6P7eq HP1P6P7m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P8 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

assert(HP8M : rk(P8 ::  nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
assert(HP8m : rk(P8 ::  nil) >= 1) by (solve_hyps_min HP8eq HP8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P6P7P8m2 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P6P7P8m3 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P4 :: P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P4 :: nil) ++ (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P4 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 1 HP1P2P3P4P5P6P7P8mtmp Hmtmp HP4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P6P7P8m4 : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 2 HP1P2P3P4P5P6P7P8mtmp HP2P3mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P5P6P7P8m3 : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3Mtmp : rk(P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP2P3eq HP2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P2 :: P3 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: nil) ++ (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP2mtmp HP2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P6P7P8m2 : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4Mtmp : rk(P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P4eq HP2P4M2).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m3).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P2 :: P4 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P4 :: nil) ++ (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P4 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: nil) 3 1 2 HP1P2P4P5P6P7P8mtmp HP2mtmp HP2P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P6P7P8m3 : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P4 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP1mtmp HP1P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P6P7P8m4 : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5Mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5eq HP1P2P3P5M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P5 :: nil) ++ (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P3P5P6P7P8mtmp HP1P2P5mtmp HP1P2P3P5Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P7P8m3 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P7P8m4 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6Mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6eq HP1P2P5P6M3).
	try assert(HP1P2P5P6P7P8eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P7P8eq HP1P2P5P6P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7P8mtmp;try rewrite HT2 in HP1P2P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P5P6P7P8mtmp HP1P2P5mtmp HP1P2P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P7P8m2 : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6Mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P3P6eq HP1P2P3P6M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P6 :: P1 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P6 :: P1 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P6 :: nil) ++ (P1 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P5P6P7P8mtmp HP1mtmp HP1P2P3P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P7P8m3 : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P7eq : rk(P2 :: P7 :: nil) = 2) by (apply LP2P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P7Mtmp : rk(P2 :: P7 :: nil) <= 2) by (solve_hyps_max HP2P7eq HP2P7M2).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P2 :: P7 :: nil) (P1 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P2 :: P7 :: P1 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P1 :: P5 :: P7 :: P8 :: nil) ((P2 :: P7 :: nil) ++ (P1 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P7 :: nil) (P1 :: P5 :: P7 :: P8 :: nil) (P7 :: nil) 4 1 2 HP1P2P5P7P8mtmp HP7mtmp HP2P7Mtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P8M3 : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P5P7Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P8m2 : rk(P1 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P7P8eq HP1P5P7P8m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P7P8mtmp;try rewrite HT2 in HP1P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P8 :: nil) (P1 :: nil) 3 1 2 HP1P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP1P8M : rk(P1 :: P8 ::  nil) <= 2) by (solve_hyps_max HP1P8eq HP1P8M2).
assert(HP1P8m : rk(P1 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P8eq HP1P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P8m2 : rk(P2 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P2 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P8 :: nil) (nil) 4 0 2 HP1P2P5P7P8mtmp Hmtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP2P8M : rk(P2 :: P8 ::  nil) <= 2) by (solve_hyps_max HP2P8eq HP2P8M2).
assert(HP2P8m : rk(P2 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P8eq HP2P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P6P8m3 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P8m2 : rk(P1 :: P2 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6P8eq : rk(P1 :: P2 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P2P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P8eq HP1P2P5P6P8m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P2 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P2 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P8mtmp;try rewrite HT2 in HP1P2P5P6P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P8 :: nil) (P1 :: nil) 3 1 2 HP1P2P5P6P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P5P6P8M1. try clear HP1P2P5P6P8M2. try clear HP1P2P5P6P8M3. try clear HP1P2P5P6P8m4. try clear HP1P2P5P6P8m3. try clear HP1P2P5P6P8m2. try clear HP1P2P5P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P8m3 : rk(P1 :: P2 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P2 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P2 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP1P2P8M : rk(P1 :: P2 :: P8 ::  nil) <= 3) by (solve_hyps_max HP1P2P8eq HP1P2P8M3).
assert(HP1P2P8m : rk(P1 :: P2 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P2P8eq HP1P2P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P7P8m2 : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P7P8m3 : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P7P8m4 : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6Mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6eq HP1P2P5P6M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P3P5P6P7P8mtmp HP1P2P5mtmp HP1P2P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P5P6P7P8m2 : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P6P7P8m4 : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 2 HP1P2P3P4P5P6P7P8mtmp HP2P3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P6P7P8m2 : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P6P7P8m3 : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P4 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P4 :: nil) ++ (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P4 :: nil) (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 1 HP2P3P4P5P6P7P8mtmp Hmtmp HP4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P6P7P8m4 : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 2 HP2P3P4P5P6P7P8mtmp HP2P3mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P7P8m2 : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P7P8m3 : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP2P3P5P6P7P8eq : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P6P7P8mtmp : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P6P7P8eq HP2P3P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P6 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) ((P6 :: nil) ++ (P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P6P7P8mtmp;try rewrite HT2 in HP2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P6 :: nil) (P2 :: P3 :: P5 :: P7 :: P8 :: nil) (nil) 4 0 1 HP2P3P5P6P7P8mtmp Hmtmp HP6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P7P8m4 : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P3P5P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P7P8eq HP1P2P3P5P7P8m4).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P3 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P7P8mtmp;try rewrite HT2 in HP1P2P3P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: nil) 4 2 2 HP1P2P3P5P7P8mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P7m2 : rk(P2 :: P3 :: P5 :: P7 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P7m3 : rk(P2 :: P3 :: P5 :: P7 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P3P5P6P7eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P3P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P3P5P6P7eq HP1P2P3P5P6P7m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P2 :: P3 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) (P2 :: P3 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P3 :: P5 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7mtmp;try rewrite HT2 in HP1P2P3P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P2P3P5P6P7mtmp HP5P7mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P5P7M3 : rk(P2 :: P3 :: P5 :: P7 :: nil) <= 3).
{
	assert(HP1P2P3P5P6P7Mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5P6P7eq HP1P2P3P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P3 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P3P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P5P6P7M1. try clear HP1P2P3P5P6P7M2. try clear HP1P2P3P5P6P7M3. try clear HP1P2P3P5P6P7m4. try clear HP1P2P3P5P6P7m3. try clear HP1P2P3P5P6P7m2. try clear HP1P2P3P5P6P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P8m2 : rk(P3 :: P8 :: nil) >= 2).
{
	try assert(HP2P3P5P7eq : rk(P2 :: P3 :: P5 :: P7 :: nil) = 3) by (apply LP2P3P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7Mtmp : rk(P2 :: P3 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P3P5P7eq HP2P3P5P7M3).
	try assert(HP2P3P5P7P8eq : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7P8mtmp : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P7P8eq HP2P3P5P7P8m4).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P2 :: P3 :: P5 :: P7 :: nil) (P3 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P7 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P7 :: P3 :: P8 :: nil) ((P2 :: P3 :: P5 :: P7 :: nil) ++ (P3 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P7P8mtmp;try rewrite HT2 in HP2P3P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P7 :: nil) (P3 :: P8 :: nil) (P3 :: nil) 4 1 3 HP2P3P5P7P8mtmp HP3mtmp HP2P3P5P7Mtmp Hincl); apply HT.
}


assert(HP3P8M : rk(P3 :: P8 ::  nil) <= 2) by (solve_hyps_max HP3P8eq HP3P8M2).
assert(HP3P8m : rk(P3 :: P8 ::  nil) >= 1) by (solve_hyps_min HP3P8eq HP3P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P6P7P8m2 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4Mtmp : rk(P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P4eq HP2P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P4 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P4 :: nil) ++ (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P4 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P2P3P4P5P6P7P8mtmp Hmtmp HP2P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P6P7P8m3 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP1mtmp HP1P2P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P6P7P8m4 : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P6eq : rk(P1 :: P2 :: P3 :: P6 :: nil) = 3) by (apply LP1P2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6Mtmp : rk(P1 :: P2 :: P3 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P3P6eq HP1P2P3P6M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P6 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P6 :: P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P6 :: nil) ++ (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P6 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P2P3P5P6P7P8mtmp HP1P3P6mtmp HP1P2P3P6Mtmp Hincl); apply HT.
}
try clear HP1P2P3P6M1. try clear HP1P2P3P6M2. try clear HP1P2P3P6M3. try clear HP1P2P3P6m4. try clear HP1P2P3P6m3. try clear HP1P2P3P6m2. try clear HP1P2P3P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P6P7P8m2 : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5Mtmp : rk(P1 :: P2 :: P5 :: nil) <= 3) by (solve_hyps_max HP1P2P5eq HP1P2P5M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P5 :: nil) (P1 :: P3 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P1 :: P3 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P1 :: P3 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: nil) ++ (P1 :: P3 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: nil) (P1 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P5P6P7P8mtmp HP1mtmp HP1P2P5Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P6P7P8m3 : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P6P7P8m4 : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P5P6eq : rk(P1 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP1P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6Mtmp : rk(P1 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6eq HP1P3P5P6M3).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P1 :: P3 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P6 :: P1 :: P3 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P3P5P6P7P8mtmp HP1P3P6mtmp HP1P3P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P6P8m3 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P8m2 : rk(P1 :: P3 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P8eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P3P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P8eq HP1P3P5P6P8m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P3 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8mtmp;try rewrite HT2 in HP1P3P5P6P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P8 :: nil) (P1 :: nil) 3 1 2 HP1P3P5P6P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P8m3 : rk(P1 :: P3 :: P8 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P3P6P7P8eq : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7P8mtmp : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P6P7P8eq HP1P3P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P1 :: P3 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P1 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P1 :: P3 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P1 :: P3 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P6P7P8mtmp;try rewrite HT2 in HP1P3P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P1 :: P3 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P3P6P7P8mtmp HP1mtmp HP1P6P7Mtmp Hincl); apply HT.
}


assert(HP1P3P8M : rk(P1 :: P3 :: P8 ::  nil) <= 3) by (solve_hyps_max HP1P3P8eq HP1P3P8M3).
assert(HP1P3P8m : rk(P1 :: P3 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P3P8eq HP1P3P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P8m2 : rk(P2 :: P3 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P8m3 : rk(P2 :: P3 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P5P7eq : rk(P2 :: P3 :: P5 :: P7 :: nil) = 3) by (apply LP2P3P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7Mtmp : rk(P2 :: P3 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P3P5P7eq HP2P3P5P7M3).
	try assert(HP2P3P5P7P8eq : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7P8mtmp : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P7P8eq HP2P3P5P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P5 :: P7 :: nil) (P2 :: P3 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P7 :: P2 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P7 :: P2 :: P3 :: P8 :: nil) ((P2 :: P3 :: P5 :: P7 :: nil) ++ (P2 :: P3 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P7P8mtmp;try rewrite HT2 in HP2P3P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P7 :: nil) (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP2P3P5P7P8mtmp HP2P3mtmp HP2P3P5P7Mtmp Hincl); apply HT.
}


assert(HP2P3P8M : rk(P2 :: P3 :: P8 ::  nil) <= 3) by (solve_hyps_max HP2P3P8eq HP2P3P8M3).
assert(HP2P3P8m : rk(P2 :: P3 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P3P8eq HP2P3P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P5P6P7P8m4 : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 2 HP1P2P3P4P5P6P7P8mtmp HP2P4mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5P7P8m2 : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5P7P8m3 : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P5P7P8m4 : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6Mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6eq HP1P2P5P6M3).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P4P5P6P7P8mtmp HP1P2P5mtmp HP1P2P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P6P7P8m3 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3Mtmp : rk(P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP2P3eq HP2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P2 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P3 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP3mtmp HP2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P6P7P8m4 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P3 :: P4 :: nil) 4 2 2 HP1P2P3P4P5P6P7P8mtmp HP3P4mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P7P8m2 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6Mtmp : rk(P1 :: P3 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P3P6eq HP1P3P6M3).
	try assert(HP1P3P4P5P6P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P6P7P8eq HP1P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P3 :: P6 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P6 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P3 :: P6 :: nil) ++ (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P6 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P3P4P5P6P7P8mtmp HP1mtmp HP1P3P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P7P8m3 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P7eq : rk(P2 :: P7 :: nil) = 2) by (apply LP2P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P7Mtmp : rk(P2 :: P7 :: nil) <= 2) by (solve_hyps_max HP2P7eq HP2P7M2).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P2 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P2 :: P7 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil) ((P2 :: P7 :: nil) ++ (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P7 :: nil) 4 1 2 HP1P2P4P5P7P8mtmp HP7mtmp HP2P7Mtmp Hincl); apply HT.
}
try clear HP2P7M1. try clear HP2P7M2. try clear HP2P7M3. try clear HP2P7m4. try clear HP2P7m3. try clear HP2P7m2. try clear HP2P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P7P8m4 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7Mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P7eq HP1P2P4P7M3).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P1 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: P7 :: nil) ++ (P1 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P2P4P5P7P8mtmp HP1P4P7mtmp HP1P2P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8m2 : rk(P4 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P8eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7P8mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8eq HP1P4P5P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P4 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8mtmp;try rewrite HT2 in HP1P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P4 :: P8 :: nil) (nil) 4 0 2 HP1P4P5P7P8mtmp Hmtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP4P8M : rk(P4 :: P8 ::  nil) <= 2) by (solve_hyps_max HP4P8eq HP4P8M2).
assert(HP4P8m : rk(P4 :: P8 ::  nil) >= 1) by (solve_hyps_min HP4P8eq HP4P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P8m2 : rk(P1 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7Mtmp : rk(P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P7eq HP5P7M2).
	try assert(HP1P4P5P7P8eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7P8mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8eq HP1P4P5P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: P7 :: nil) (P1 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: P1 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P7 :: P1 :: P4 :: P8 :: nil) ((P5 :: P7 :: nil) ++ (P1 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8mtmp;try rewrite HT2 in HP1P4P5P7P8mtmp.
	assert(HT := rule_4 (P5 :: P7 :: nil) (P1 :: P4 :: P8 :: nil) (nil) 4 0 2 HP1P4P5P7P8mtmp Hmtmp HP5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P8m3 : rk(P1 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P8eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7P8mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8eq HP1P4P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P4 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8mtmp;try rewrite HT2 in HP1P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P4 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P4P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP1P4P8M : rk(P1 :: P4 :: P8 ::  nil) <= 3) by (solve_hyps_max HP1P4P8eq HP1P4P8M3).
assert(HP1P4P8m : rk(P1 :: P4 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P4P8eq HP1P4P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P6P7P8m3 : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP2mtmp HP1P2P3Mtmp Hincl); apply HT.
}
try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P6P7P8m4 : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 2 HP2P3P4P5P6P7P8mtmp HP2P4mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5P7P8m2 : rk(P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P7P8m3 : rk(P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP2P4P5P6P7P8eq : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P6P7P8mtmp : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P6P7P8eq HP2P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P6 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) ((P6 :: nil) ++ (P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P6P7P8mtmp;try rewrite HT2 in HP2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P6 :: nil) (P2 :: P4 :: P5 :: P7 :: P8 :: nil) (nil) 4 0 1 HP2P4P5P6P7P8mtmp Hmtmp HP6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P7P8m4 : rk(P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: nil) 4 2 2 HP1P2P4P5P7P8mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5P7m2 : rk(P2 :: P4 :: P5 :: P7 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P7m3 : rk(P2 :: P4 :: P5 :: P7 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P2P4P5P6P7eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P2P4P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5P6P7eq HP1P2P4P5P6P7m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P2 :: P4 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) (P2 :: P4 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil) ((P2 :: P4 :: P5 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7mtmp;try rewrite HT2 in HP1P2P4P5P6P7mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P2P4P5P6P7mtmp HP5P7mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P5P7M3 : rk(P2 :: P4 :: P5 :: P7 :: nil) <= 3).
{
	assert(HP1P2P4P5P6P7Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P5P6P7eq HP1P2P4P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P4P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P4P5P6P7M1. try clear HP1P2P4P5P6P7M2. try clear HP1P2P4P5P6P7M3. try clear HP1P2P4P5P6P7m4. try clear HP1P2P4P5P6P7m3. try clear HP1P2P4P5P6P7m2. try clear HP1P2P4P5P6P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P8m2 : rk(P2 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P8m3 : rk(P2 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP2P4P5P7eq : rk(P2 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP2P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P7Mtmp : rk(P2 :: P4 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P4P5P7eq HP2P4P5P7M3).
	try assert(HP2P4P5P7P8eq : rk(P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P7P8mtmp : rk(P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P7P8eq HP2P4P5P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P2 :: P4 :: P5 :: P7 :: nil) (P2 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P2 :: P4 :: P5 :: P7 :: P2 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P7 :: P2 :: P4 :: P8 :: nil) ((P2 :: P4 :: P5 :: P7 :: nil) ++ (P2 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P7P8mtmp;try rewrite HT2 in HP2P4P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P4 :: P5 :: P7 :: nil) (P2 :: P4 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 3 HP2P4P5P7P8mtmp HP2P4mtmp HP2P4P5P7Mtmp Hincl); apply HT.
}
try clear HP2P4P5P7M1. try clear HP2P4P5P7M2. try clear HP2P4P5P7M3. try clear HP2P4P5P7m4. try clear HP2P4P5P7m3. try clear HP2P4P5P7m2. try clear HP2P4P5P7m1. try clear HP2P4P5P7P8M1. try clear HP2P4P5P7P8M2. try clear HP2P4P5P7P8M3. try clear HP2P4P5P7P8m4. try clear HP2P4P5P7P8m3. try clear HP2P4P5P7P8m2. try clear HP2P4P5P7P8m1. 

assert(HP2P4P8M : rk(P2 :: P4 :: P8 ::  nil) <= 3) by (solve_hyps_max HP2P4P8eq HP2P4P8M3).
assert(HP2P4P8m : rk(P2 :: P4 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P4P8eq HP2P4P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5P7P8m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5P7P8m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P5P7P8m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P6eq : rk(P1 :: P2 :: P5 :: P6 :: nil) = 3) by (apply LP1P2P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6Mtmp : rk(P1 :: P2 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6eq HP1P2P5P6M3).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P3P4P5P6P7P8mtmp HP1P2P5mtmp HP1P2P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P5P6M1. try clear HP1P2P5P6M2. try clear HP1P2P5P6M3. try clear HP1P2P5P6m4. try clear HP1P2P5P6m3. try clear HP1P2P5P6m2. try clear HP1P2P5P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P5P7P8m2 : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P7P8m3 : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP1P3P4P5P6P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P6P7P8eq HP1P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P6 :: P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P6 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P6 :: nil) (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (nil) 4 0 1 HP1P3P4P5P6P7P8mtmp Hmtmp HP6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P7P8m4 : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7Mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P7eq HP1P2P4P7M3).
	try assert(HP1P2P3P4P5P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P7P8eq HP1P2P3P4P5P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: P7 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P2P3P4P5P7P8mtmp HP1P4P7mtmp HP1P2P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P6P7P8m3 : rk(P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P3 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP3mtmp HP1P2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P6P7P8m4 : rk(P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P3 :: P4 :: nil) 4 2 2 HP2P3P4P5P6P7P8mtmp HP3P4mtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P7P8m2 : rk(P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P7P8m3 : rk(P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP3P4P5P6P7P8eq : rk(P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P5P6P7P8mtmp : rk(P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P6P7P8eq HP3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P6 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P6 :: nil) ++ (P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P6P7P8mtmp;try rewrite HT2 in HP3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P6 :: nil) (P3 :: P4 :: P5 :: P7 :: P8 :: nil) (nil) 4 0 1 HP3P4P5P6P7P8mtmp Hmtmp HP6Mtmp Hincl); apply HT.
}
try clear HP3P4P5P6P7P8M1. try clear HP3P4P5P6P7P8M2. try clear HP3P4P5P6P7P8M3. try clear HP3P4P5P6P7P8m4. try clear HP3P4P5P6P7P8m3. try clear HP3P4P5P6P7P8m2. try clear HP3P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P7P8m4 : rk(P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P4P5P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P7P8eq HP1P3P4P5P7P8m4).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P7P8mtmp;try rewrite HT2 in HP1P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: nil) 4 2 2 HP1P3P4P5P7P8mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P7m2 : rk(P3 :: P4 :: P5 :: P7 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P7m3 : rk(P3 :: P4 :: P5 :: P7 :: nil) >= 3).
{
	try assert(HP1P5P6P7eq : rk(P1 :: P5 :: P6 :: P7 :: nil) = 2) by (apply LP1P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	try assert(HP1P3P4P5P6P7eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P4P5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P4P5P6P7eq HP1P3P4P5P6P7m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P3 :: P4 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) (P3 :: P4 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P7 :: P1 :: P5 :: P6 :: P7 :: nil) ((P3 :: P4 :: P5 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7mtmp;try rewrite HT2 in HP1P3P4P5P6P7mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P5 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P3P4P5P6P7mtmp HP5P7mtmp HP1P5P6P7Mtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P7M3 : rk(P3 :: P4 :: P5 :: P7 :: nil) <= 3).
{
	assert(HP1P3P4P5P6P7Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P4P5P6P7eq HP1P3P4P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P4 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P3P4P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P4P5P6P7M1. try clear HP1P3P4P5P6P7M2. try clear HP1P3P4P5P6P7M3. try clear HP1P3P4P5P6P7m4. try clear HP1P3P4P5P6P7m3. try clear HP1P3P4P5P6P7m2. try clear HP1P3P4P5P6P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P8m2 : rk(P3 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P8m3 : rk(P3 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP3P4P5P7eq : rk(P3 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP3P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P5P7Mtmp : rk(P3 :: P4 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP3P4P5P7eq HP3P4P5P7M3).
	try assert(HP3P4P5P7P8eq : rk(P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P5P7P8mtmp : rk(P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P7P8eq HP3P4P5P7P8m4).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P3 :: P4 :: P5 :: P7 :: nil) (P3 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P3 :: P4 :: P5 :: P7 :: P3 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P7 :: P3 :: P4 :: P8 :: nil) ((P3 :: P4 :: P5 :: P7 :: nil) ++ (P3 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P7P8mtmp;try rewrite HT2 in HP3P4P5P7P8mtmp.
	assert(HT := rule_4 (P3 :: P4 :: P5 :: P7 :: nil) (P3 :: P4 :: P8 :: nil) (P3 :: P4 :: nil) 4 2 3 HP3P4P5P7P8mtmp HP3P4mtmp HP3P4P5P7Mtmp Hincl); apply HT.
}
try clear HP3P4P5P7M1. try clear HP3P4P5P7M2. try clear HP3P4P5P7M3. try clear HP3P4P5P7m4. try clear HP3P4P5P7m3. try clear HP3P4P5P7m2. try clear HP3P4P5P7m1. try clear HP3P4P5P7P8M1. try clear HP3P4P5P7P8M2. try clear HP3P4P5P7P8M3. try clear HP3P4P5P7P8m4. try clear HP3P4P5P7P8m3. try clear HP3P4P5P7P8m2. try clear HP3P4P5P7P8m1. 

assert(HP3P4P8M : rk(P3 :: P4 :: P8 ::  nil) <= 3) by (solve_hyps_max HP3P4P8eq HP3P4P8M3).
assert(HP3P4P8m : rk(P3 :: P4 :: P8 ::  nil) >= 1) by (solve_hyps_min HP3P4P8eq HP3P4P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P8m2 : rk(P5 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P7P8eq HP1P5P7P8m3).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P5 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P7P8mtmp;try rewrite HT2 in HP1P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P5 :: P8 :: nil) (P5 :: nil) 3 1 2 HP1P5P7P8mtmp HP5mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP5P8M : rk(P5 :: P8 ::  nil) <= 2) by (solve_hyps_max HP5P8eq HP5P8M2).
assert(HP5P8m : rk(P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP5P8eq HP5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7M3 : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3).
{
	assert(HP1P2P5P6P7Mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P6P7eq HP1P2P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P2P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P6P7M1. try clear HP1P2P5P6P7M2. try clear HP1P2P5P6P7M3. try clear HP1P2P5P6P7m4. try clear HP1P2P5P6P7m3. try clear HP1P2P5P6P7m2. try clear HP1P2P5P6P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P8m3 : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P8m4 : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7Mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7eq HP1P2P5P7M3).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P5 :: P8 :: nil) ((P1 :: P2 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P5P7P8mtmp HP1P2P5mtmp HP1P2P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P8m2 : rk(P1 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P5P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P7P8eq HP1P2P3P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P1 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P1 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P1 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P7P8mtmp;try rewrite HT2 in HP1P2P3P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P5 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P5P7P8mtmp HP1mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P8m3 : rk(P1 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP2P8eq : rk(P2 :: P8 :: nil) = 2) by (apply LP2P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P8Mtmp : rk(P2 :: P8 :: nil) <= 2) by (solve_hyps_max HP2P8eq HP2P8M2).
	try assert(HP1P2P5P8eq : rk(P1 :: P2 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8mtmp : rk(P8 :: nil) >= 1) by (solve_hyps_min HP8eq HP8m1).
	assert(Hincl : incl (P8 :: nil) (list_inter (P2 :: P8 :: nil) (P1 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: nil) (P2 :: P8 :: P1 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P1 :: P5 :: P8 :: nil) ((P2 :: P8 :: nil) ++ (P1 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8mtmp;try rewrite HT2 in HP1P2P5P8mtmp.
	assert(HT := rule_4 (P2 :: P8 :: nil) (P1 :: P5 :: P8 :: nil) (P8 :: nil) 4 1 2 HP1P2P5P8mtmp HP8mtmp HP2P8Mtmp Hincl); apply HT.
}
try clear HP2P8M1. try clear HP2P8M2. try clear HP2P8M3. try clear HP2P8m4. try clear HP2P8m3. try clear HP2P8m2. try clear HP2P8m1. try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

assert(HP1P5P8M : rk(P1 :: P5 :: P8 ::  nil) <= 3) by (solve_hyps_max HP1P5P8eq HP1P5P8M3).
assert(HP1P5P8m : rk(P1 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P5P8eq HP1P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P8m4 : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7Mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7eq HP1P2P5P7M3).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P5 :: P8 :: nil) ((P1 :: P2 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P5P7P8mtmp HP1P2P5mtmp HP1P2P5P7Mtmp Hincl); apply HT.
}


assert(HP1P2P5P8M : rk(P1 :: P2 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P5P8m : rk(P1 :: P2 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P7P8m2 : rk(P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4Mtmp : rk(P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P4eq HP2P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P4 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P4 :: nil) ++ (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P4 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 2 HP2P3P4P5P6P7P8mtmp Hmtmp HP2P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P7P8m3 : rk(P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P3 :: nil) 4 1 2 HP2P3P4P5P6P7P8mtmp HP3mtmp HP2P3P4Mtmp Hincl); apply HT.
}
try clear HP3M1. try clear HP3M2. try clear HP3M3. try clear HP3m4. try clear HP3m3. try clear HP3m2. try clear HP3m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P7P8m4 : rk(P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: nil) 4 2 2 HP1P3P5P6P7P8mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP5P6P7m2 : rk(P5 :: P6 :: P7 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P7M2 : rk(P5 :: P6 :: P7 :: nil) <= 2).
{
	assert(HP1P5P6P7Mtmp : rk(P1 :: P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P6P7eq HP1P5P6P7M2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P7 :: nil) 2 2 HP1P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P6P7M1. try clear HP1P5P6P7M2. try clear HP1P5P6P7M3. try clear HP1P5P6P7m4. try clear HP1P5P6P7m3. try clear HP1P5P6P7m2. try clear HP1P5P6P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P8m2 : rk(P3 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P8eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P3P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P8eq HP1P3P5P6P8m3).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8mtmp;try rewrite HT2 in HP1P3P5P6P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P8 :: nil) (P5 :: nil) 3 1 2 HP1P3P5P6P8mtmp HP5mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P8m3 : rk(P3 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP5P6P7eq : rk(P5 :: P6 :: P7 :: nil) = 2) by (apply LP5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7Mtmp : rk(P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P6P7eq HP5P6P7M2).
	try assert(HP3P5P6P7P8eq : rk(P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P5P6P7P8mtmp : rk(P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P5P6P7P8eq HP3P5P6P7P8m4).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P5 :: P6 :: P7 :: nil) (P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P7 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P7 :: P3 :: P5 :: P8 :: nil) ((P5 :: P6 :: P7 :: nil) ++ (P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P6P7P8mtmp;try rewrite HT2 in HP3P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: P7 :: nil) (P3 :: P5 :: P8 :: nil) (P5 :: nil) 4 1 2 HP3P5P6P7P8mtmp HP5mtmp HP5P6P7Mtmp Hincl); apply HT.
}
try clear HP3P5P6P7P8M1. try clear HP3P5P6P7P8M2. try clear HP3P5P6P7P8M3. try clear HP3P5P6P7P8m4. try clear HP3P5P6P7P8m3. try clear HP3P5P6P7P8m2. try clear HP3P5P6P7P8m1. 

assert(HP3P5P8M : rk(P3 :: P5 :: P8 ::  nil) <= 3) by (solve_hyps_max HP3P5P8eq HP3P5P8M3).
assert(HP3P5P8m : rk(P3 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP3P5P8eq HP3P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P8m2 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P8m3 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P8m4 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7Mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7eq HP1P2P5P7M3).
	try assert(HP1P2P3P5P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P7P8eq HP1P2P3P5P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P3 :: P5 :: P8 :: nil) ((P1 :: P2 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P7P8mtmp;try rewrite HT2 in HP1P2P3P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P3P5P7P8mtmp HP1P2P5mtmp HP1P2P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P8m2 : rk(P1 :: P2 :: P3 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P8M3 : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P8m3 : rk(P1 :: P2 :: P3 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P3P5P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P7P8eq HP1P2P3P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P2 :: P3 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P2 :: P3 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P7P8mtmp;try rewrite HT2 in HP1P2P3P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P8m2 : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6Mtmp : rk(P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP5P6eq HP5P6M2).
	try assert(HP1P3P5P6P8eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P3P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P8eq HP1P3P5P6P8m3).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P5 :: P6 :: nil) (P1 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P1 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P1 :: P3 :: P5 :: P8 :: nil) ((P5 :: P6 :: nil) ++ (P1 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8mtmp;try rewrite HT2 in HP1P3P5P6P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: nil) (P1 :: P3 :: P5 :: P8 :: nil) (P5 :: nil) 3 1 2 HP1P3P5P6P8mtmp HP5mtmp HP5P6Mtmp Hincl); apply HT.
}
try clear HP1P3P5P6P8M1. try clear HP1P3P5P6P8M2. try clear HP1P3P5P6P8M3. try clear HP1P3P5P6P8m4. try clear HP1P3P5P6P8m3. try clear HP1P3P5P6P8m2. try clear HP1P3P5P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P8m3 : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P1 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P1 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P1 :: P3 :: P5 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P1 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P3P5P6P7P8mtmp HP1mtmp HP1P6P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P8m4 : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P5P8eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P3P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8eq HP1P2P3P5P8m4).
	try assert(HP1P3P8eq : rk(P1 :: P3 :: P8 :: nil) = 3) by (apply LP1P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P1 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P1 :: P3 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P1 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8mtmp;try rewrite HT2 in HP1P2P3P5P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P8 :: nil) 4 3 3 HP1P2P3P5P8mtmp HP1P3P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}


assert(HP1P3P5P8M : rk(P1 :: P3 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P5P8m : rk(P1 :: P3 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P8m2 : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P8m3 : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P5P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P7P8eq HP1P2P3P5P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P2 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P2 :: P3 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P2 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P7P8mtmp;try rewrite HT2 in HP1P2P3P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP1P2P3P5P7P8mtmp HP2P3mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}
try clear HP1P2P3P5P7P8M1. try clear HP1P2P3P5P7P8M2. try clear HP1P2P3P5P7P8M3. try clear HP1P2P3P5P7P8m4. try clear HP1P2P3P5P7P8m3. try clear HP1P2P3P5P7P8m2. try clear HP1P2P3P5P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P8m4 : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P5P8eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P3P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8eq HP1P2P3P5P8m4).
	try assert(HP2P3P8eq : rk(P2 :: P3 :: P8 :: nil) = 3) by (apply LP2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P2 :: P3 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8mtmp;try rewrite HT2 in HP1P2P3P5P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P8 :: nil) 4 3 3 HP1P2P3P5P8mtmp HP2P3P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}
try clear HP1P2P3P5P8M1. try clear HP1P2P3P5P8M2. try clear HP1P2P3P5P8M3. try clear HP1P2P3P5P8m4. try clear HP1P2P3P5P8m3. try clear HP1P2P3P5P8m2. try clear HP1P2P3P5P8m1. 

assert(HP2P3P5P8M : rk(P2 :: P3 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P5P8m : rk(P2 :: P3 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P3P5P8eq HP2P3P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P5 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P8m2 : rk(P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7Mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P7eq HP1P2P4P7M3).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: nil) (P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P4 :: P7 :: nil) ++ (P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: nil) (P4 :: P5 :: P8 :: nil) (P4 :: nil) 4 1 3 HP1P2P4P5P7P8mtmp HP4mtmp HP1P2P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P8m3 : rk(P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P8eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7P8mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8eq HP1P4P5P7P8m4).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P4 :: P5 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8mtmp;try rewrite HT2 in HP1P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P8 :: nil) (P5 :: nil) 4 1 2 HP1P4P5P7P8mtmp HP5mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP4P5P8M : rk(P4 :: P5 :: P8 ::  nil) <= 3) by (solve_hyps_max HP4P5P8eq HP4P5P8M3).
assert(HP4P5P8m : rk(P4 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP4P5P8eq HP4P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5P8m2 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P5P8m3 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P5P8m4 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7Mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7eq HP1P2P5P7M3).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P4P5P7P8mtmp HP1P2P5mtmp HP1P2P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P8m2 : rk(P1 :: P2 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P8M3 : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P4 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P2P4Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P8m3 : rk(P1 :: P2 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P2 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P2 :: P4 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P4P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P8m2 : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P4P5P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P7P8eq HP1P2P3P4P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P1 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P1 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P1 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P4P5P7P8mtmp HP1mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P8m3 : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7Mtmp : rk(P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P7eq HP5P7M2).
	try assert(HP1P4P5P7P8eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7P8mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8eq HP1P4P5P7P8m4).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P5 :: P7 :: nil) (P1 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: P1 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P7 :: P1 :: P4 :: P5 :: P8 :: nil) ((P5 :: P7 :: nil) ++ (P1 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8mtmp;try rewrite HT2 in HP1P4P5P7P8mtmp.
	assert(HT := rule_4 (P5 :: P7 :: nil) (P1 :: P4 :: P5 :: P8 :: nil) (P5 :: nil) 4 1 2 HP1P4P5P7P8mtmp HP5mtmp HP5P7Mtmp Hincl); apply HT.
}
try clear HP1P4P5P7P8M1. try clear HP1P4P5P7P8M2. try clear HP1P4P5P7P8M3. try clear HP1P4P5P7P8m4. try clear HP1P4P5P7P8m3. try clear HP1P4P5P7P8m2. try clear HP1P4P5P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P8m4 : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P5P8eq : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P4P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P8eq HP1P2P4P5P8m4).
	try assert(HP1P4P8eq : rk(P1 :: P4 :: P8 :: nil) = 3) by (apply LP1P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P8mtmp : rk(P1 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P4P8eq HP1P4P8m3).
	assert(Hincl : incl (P1 :: P4 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P1 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P1 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P1 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P8mtmp;try rewrite HT2 in HP1P2P4P5P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P8 :: nil) 4 3 3 HP1P2P4P5P8mtmp HP1P4P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}


assert(HP1P4P5P8M : rk(P1 :: P4 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P4P5P8m : rk(P1 :: P4 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5P8m2 : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P8m3 : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7Mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P7eq HP1P2P4P7M3).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P2 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P2 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P4 :: P7 :: nil) ++ (P2 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 3 HP1P2P4P5P7P8mtmp HP2P4mtmp HP1P2P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P8m4 : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P5P8eq : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P4P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P8eq HP1P2P4P5P8m4).
	try assert(HP2P4P8eq : rk(P2 :: P4 :: P8 :: nil) = 3) by (apply LP2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P8mtmp : rk(P2 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P4P8eq HP2P4P8m3).
	assert(Hincl : incl (P2 :: P4 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P2 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P8mtmp;try rewrite HT2 in HP1P2P4P5P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P8 :: nil) 4 3 3 HP1P2P4P5P8mtmp HP2P4P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}
try clear HP1P2P4P5P8M1. try clear HP1P2P4P5P8M2. try clear HP1P2P4P5P8M3. try clear HP1P2P4P5P8m4. try clear HP1P2P4P5P8m3. try clear HP1P2P4P5P8m2. try clear HP1P2P4P5P8m1. 

assert(HP2P4P5P8M : rk(P2 :: P4 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P5P8m : rk(P2 :: P4 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P4P5P8eq HP2P4P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P4P5P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P4 :: P5 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5P8m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P5P8m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P5P8m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P5P7eq : rk(P1 :: P2 :: P5 :: P7 :: nil) = 3) by (apply LP1P2P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7Mtmp : rk(P1 :: P2 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7eq HP1P2P5P7M3).
	try assert(HP1P2P3P4P5P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P7P8eq HP1P2P3P4P5P7P8m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P7 :: P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P3P4P5P7P8mtmp HP1P2P5mtmp HP1P2P5P7Mtmp Hincl); apply HT.
}
try clear HP1P2P5P7M1. try clear HP1P2P5P7M2. try clear HP1P2P5P7M3. try clear HP1P2P5P7m4. try clear HP1P2P5P7m3. try clear HP1P2P5P7m2. try clear HP1P2P5P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P5P8m2 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P8m3 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP3P4P7eq : rk(P3 :: P4 :: P7 :: nil) = 3) by (apply LP3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P7Mtmp : rk(P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP3P4P7eq HP3P4P7M3).
	try assert(HP1P3P4P5P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P7P8eq HP1P3P4P5P7P8m4).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P3 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P3 :: P4 :: P7 :: P1 :: P3 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P7 :: P1 :: P3 :: P4 :: P5 :: P8 :: nil) ((P3 :: P4 :: P7 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P7P8mtmp;try rewrite HT2 in HP1P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P3 :: P4 :: P7 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: nil) 4 2 3 HP1P3P4P5P7P8mtmp HP3P4mtmp HP3P4P7Mtmp Hincl); apply HT.
}
try clear HP3P4P7M1. try clear HP3P4P7M2. try clear HP3P4P7M3. try clear HP3P4P7m4. try clear HP3P4P7m3. try clear HP3P4P7m2. try clear HP3P4P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P8m4 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P4P5P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P8eq HP1P2P3P4P5P8m4).
	try assert(HP1P3P8eq : rk(P1 :: P3 :: P8 :: nil) = 3) by (apply LP1P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P1 :: P3 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P1 :: P3 :: P4 :: P5 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P8mtmp;try rewrite HT2 in HP1P2P3P4P5P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: nil) (P1 :: P3 :: P8 :: nil) 4 3 3 HP1P2P3P4P5P8mtmp HP1P3P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5P8M1. try clear HP1P2P3P4P5P8M2. try clear HP1P2P3P4P5P8M3. try clear HP1P2P3P4P5P8m4. try clear HP1P2P3P4P5P8m3. try clear HP1P2P3P4P5P8m2. try clear HP1P2P3P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P8m2 : rk(P1 :: P3 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P8M3 : rk(P1 :: P3 :: P4 :: P8 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P3 :: P4 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P8 :: nil) (P1 :: P3 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P8 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P3P4Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P3P4M1. try clear HP1P3P4M2. try clear HP1P3P4M3. try clear HP1P3P4m4. try clear HP1P3P4m3. try clear HP1P3P4m2. try clear HP1P3P4m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P8m3 : rk(P1 :: P3 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P4P5P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P7P8eq HP1P3P4P5P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P3 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P3 :: P4 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P3 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P7P8mtmp;try rewrite HT2 in HP1P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P3P4P5P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P8m2 : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P8m3 : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P4P7eq : rk(P1 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7Mtmp : rk(P1 :: P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P4P7eq HP1P3P4P7M3).
	try assert(HP1P3P4P5P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P7P8eq HP1P3P4P5P7P8m4).
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hincl : incl (P3 :: P4 :: nil) (list_inter (P1 :: P3 :: P4 :: P7 :: nil) (P3 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P3 :: P4 :: P7 :: P3 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P7 :: P3 :: P4 :: P5 :: P8 :: nil) ((P1 :: P3 :: P4 :: P7 :: nil) ++ (P3 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P7P8mtmp;try rewrite HT2 in HP1P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P7 :: nil) (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: nil) 4 2 3 HP1P3P4P5P7P8mtmp HP3P4mtmp HP1P3P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P8m4 : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P4P8eq : rk(P1 :: P3 :: P4 :: P8 :: nil) = 3) by (apply LP1P3P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P8Mtmp : rk(P1 :: P3 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P3P4P8eq HP1P3P4P8M3).
	try assert(HP1P3P4P5P8eq : rk(P1 :: P3 :: P4 :: P5 :: P8 :: nil) = 4) by (apply LP1P3P4P5P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P8eq HP1P3P4P5P8m4).
	try assert(HP3P4P8eq : rk(P3 :: P4 :: P8 :: nil) = 3) by (apply LP3P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P8mtmp : rk(P3 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P4P8eq HP3P4P8m3).
	assert(Hincl : incl (P3 :: P4 :: P8 :: nil) (list_inter (P1 :: P3 :: P4 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P8 :: nil) (P1 :: P3 :: P4 :: P8 :: P3 :: P4 :: P5 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P8 :: P3 :: P4 :: P5 :: P8 :: nil) ((P1 :: P3 :: P4 :: P8 :: nil) ++ (P3 :: P4 :: P5 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P8mtmp;try rewrite HT2 in HP1P3P4P5P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P8 :: nil) 4 3 3 HP1P3P4P5P8mtmp HP3P4P8mtmp HP1P3P4P8Mtmp Hincl); apply HT.
}
try clear HP3P4P8M1. try clear HP3P4P8M2. try clear HP3P4P8M3. try clear HP3P4P8m4. try clear HP3P4P8m3. try clear HP3P4P8m2. try clear HP3P4P8m1. try clear HP1P3P4P5P8M1. try clear HP1P3P4P5P8M2. try clear HP1P3P4P5P8M3. try clear HP1P3P4P5P8m4. try clear HP1P3P4P5P8m3. try clear HP1P3P4P5P8m2. try clear HP1P3P4P5P8m1. 

assert(HP3P4P5P8M : rk(P3 :: P4 :: P5 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P4P5P8m : rk(P3 :: P4 :: P5 :: P8 ::  nil) >= 1) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P6 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P7P8m2 : rk(P1 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P5eq : rk(P1 :: P2 :: P3 :: P5 :: nil) = 3) by (apply LP1P2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5Mtmp : rk(P1 :: P2 :: P3 :: P5 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5eq HP1P2P3P5M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P1 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: P1 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P5 :: nil) ++ (P1 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P5 :: nil) (P1 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P5P6P7P8mtmp HP1mtmp HP1P2P3P5Mtmp Hincl); apply HT.
}
try clear HP1P2P3P5M1. try clear HP1P2P3P5M2. try clear HP1P2P3P5M3. try clear HP1P2P3P5m4. try clear HP1P2P3P5m3. try clear HP1P2P3P5m2. try clear HP1P2P3P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P7P8m3 : rk(P1 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP3P7eq : rk(P3 :: P7 :: nil) = 2) by (apply LP3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P7Mtmp : rk(P3 :: P7 :: nil) <= 2) by (solve_hyps_max HP3P7eq HP3P7M2).
	try assert(HP1P3P6P7P8eq : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7P8mtmp : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P6P7P8eq HP1P3P6P7P8m4).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P3 :: P7 :: nil) (P1 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P6 :: P7 :: P8 :: nil) (P3 :: P7 :: P1 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P1 :: P6 :: P7 :: P8 :: nil) ((P3 :: P7 :: nil) ++ (P1 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P6P7P8mtmp;try rewrite HT2 in HP1P3P6P7P8mtmp.
	assert(HT := rule_4 (P3 :: P7 :: nil) (P1 :: P6 :: P7 :: P8 :: nil) (P7 :: nil) 4 1 2 HP1P3P6P7P8mtmp HP7mtmp HP3P7Mtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P7P8M3 : rk(P1 :: P6 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P6 :: P7 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P6 :: P7 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P6P7Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P8m2 : rk(P6 :: P8 :: nil) >= 2).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P6P7P8eq : rk(P1 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7P8mtmp : rk(P1 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P6P7P8eq HP1P6P7P8m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P6 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P7P8mtmp;try rewrite HT2 in HP1P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P6 :: P8 :: nil) (P6 :: nil) 3 1 2 HP1P6P7P8mtmp HP6mtmp HP1P6P7Mtmp Hincl); apply HT.
}


assert(HP6P8M : rk(P6 :: P8 ::  nil) <= 2) by (solve_hyps_max HP6P8eq HP6P8M2).
assert(HP6P8m : rk(P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP6P8eq HP6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P6 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P6P7M3 : rk(P1 :: P3 :: P6 :: P7 :: nil) <= 3).
{
	assert(HP1P3P5P6P7Mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6P7eq HP1P3P5P6P7M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P3 :: P5 :: P6 :: P7 :: nil) 3 3 HP1P3P5P6P7Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P6P7M1. try clear HP1P3P5P6P7M2. try clear HP1P3P5P6P7M3. try clear HP1P3P5P6P7m4. try clear HP1P3P5P6P7m3. try clear HP1P3P5P6P7m2. try clear HP1P3P5P6P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P6P8m3 : rk(P1 :: P3 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P6P8m4 : rk(P1 :: P3 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P6P7eq : rk(P1 :: P3 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7Mtmp : rk(P1 :: P3 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P6P7eq HP1P3P6P7M3).
	try assert(HP1P3P6P7P8eq : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7P8mtmp : rk(P1 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P6P7P8eq HP1P3P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P3 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: P7 :: P1 :: P3 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P6 :: P7 :: P1 :: P3 :: P6 :: P8 :: nil) ((P1 :: P3 :: P6 :: P7 :: nil) ++ (P1 :: P3 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P6P7P8mtmp;try rewrite HT2 in HP1P3P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P3 :: P6 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P3P6P7P8mtmp HP1P3P6mtmp HP1P3P6P7Mtmp Hincl); apply HT.
}
try clear HP1P3P6P7P8M1. try clear HP1P3P6P7P8M2. try clear HP1P3P6P7P8M3. try clear HP1P3P6P7P8m4. try clear HP1P3P6P7P8m3. try clear HP1P3P6P7P8m2. try clear HP1P3P6P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P6P7P8m2 : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P6P7P8m3 : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) ((P5 :: nil) ++ (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: nil) (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 1 HP1P2P3P5P6P7P8mtmp Hmtmp HP5Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P6P7P8m4 : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P5P6eq : rk(P1 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP1P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6Mtmp : rk(P1 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6eq HP1P3P5P6M3).
	try assert(HP1P2P3P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P6P7P8eq HP1P2P3P5P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P6 :: P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P2P3P5P6P7P8mtmp HP1P3P6mtmp HP1P3P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P3P5P6P7P8M1. try clear HP1P2P3P5P6P7P8M2. try clear HP1P2P3P5P6P7P8M3. try clear HP1P2P3P5P6P7P8m4. try clear HP1P2P3P5P6P7P8m3. try clear HP1P2P3P5P6P7P8m2. try clear HP1P2P3P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P8m2 : rk(P1 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P6P7P8eq : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P7P8eq HP1P2P3P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P1 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P1 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P1 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P7P8mtmp;try rewrite HT2 in HP1P2P3P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P6 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P6P7P8mtmp HP1mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P8m3 : rk(P1 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP3P8eq : rk(P3 :: P8 :: nil) = 2) by (apply LP3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P8Mtmp : rk(P3 :: P8 :: nil) <= 2) by (solve_hyps_max HP3P8eq HP3P8M2).
	try assert(HP1P3P6P8eq : rk(P1 :: P3 :: P6 :: P8 :: nil) = 4) by (apply LP1P3P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P8mtmp : rk(P1 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P6P8eq HP1P3P6P8m4).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8mtmp : rk(P8 :: nil) >= 1) by (solve_hyps_min HP8eq HP8m1).
	assert(Hincl : incl (P8 :: nil) (list_inter (P3 :: P8 :: nil) (P1 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P6 :: P8 :: nil) (P3 :: P8 :: P1 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P8 :: P1 :: P6 :: P8 :: nil) ((P3 :: P8 :: nil) ++ (P1 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P6P8mtmp;try rewrite HT2 in HP1P3P6P8mtmp.
	assert(HT := rule_4 (P3 :: P8 :: nil) (P1 :: P6 :: P8 :: nil) (P8 :: nil) 4 1 2 HP1P3P6P8mtmp HP8mtmp HP3P8Mtmp Hincl); apply HT.
}
try clear HP3P8M1. try clear HP3P8M2. try clear HP3P8M3. try clear HP3P8m4. try clear HP3P8m3. try clear HP3P8m2. try clear HP3P8m1. try clear HP1P3P6P8M1. try clear HP1P3P6P8M2. try clear HP1P3P6P8M3. try clear HP1P3P6P8m4. try clear HP1P3P6P8m3. try clear HP1P3P6P8m2. try clear HP1P3P6P8m1. 

assert(HP1P6P8M : rk(P1 :: P6 :: P8 ::  nil) <= 3) by (solve_hyps_max HP1P6P8eq HP1P6P8M3).
assert(HP1P6P8m : rk(P1 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P6P8eq HP1P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P6 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P6P8m2 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P6P8m3 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P6P8m4 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P6P7eq : rk(P1 :: P3 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7Mtmp : rk(P1 :: P3 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P6P7eq HP1P3P6P7M3).
	try assert(HP1P2P3P6P7P8eq : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P7P8eq HP1P2P3P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: P7 :: P1 :: P2 :: P3 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P6 :: P7 :: P1 :: P2 :: P3 :: P6 :: P8 :: nil) ((P1 :: P3 :: P6 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P7P8mtmp;try rewrite HT2 in HP1P2P3P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P2P3P6P7P8mtmp HP1P3P6mtmp HP1P3P6P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P8m2 : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P3P6eq : rk(P2 :: P3 :: P6 :: nil) = 3) by (apply LP2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P6Mtmp : rk(P2 :: P3 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P3P6eq HP2P3P6M3).
	try assert(HP1P2P3P6P8eq : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) = 3) by (apply LP1P2P3P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P3P6P8eq HP1P2P3P6P8m3).
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hincl : incl (P2 :: P6 :: nil) (list_inter (P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P6 :: P1 :: P2 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P6 :: P1 :: P2 :: P6 :: P8 :: nil) ((P2 :: P3 :: P6 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P8mtmp;try rewrite HT2 in HP1P2P3P6P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: nil) (P2 :: P6 :: nil) 3 2 3 HP1P2P3P6P8mtmp HP2P6mtmp HP2P3P6Mtmp Hincl); apply HT.
}
try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. try clear HP2P6M1. try clear HP2P6M2. try clear HP2P6M3. try clear HP2P6m4. try clear HP2P6m3. try clear HP2P6m2. try clear HP2P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P8m3 : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P6P7P8eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P7P8eq HP1P2P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P2 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P2 :: P6 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7P8mtmp;try rewrite HT2 in HP1P2P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P5P6P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P8m4 : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P6P8eq : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) = 4) by (apply LP1P2P3P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P8eq HP1P2P3P6P8m4).
	try assert(HP1P2P8eq : rk(P1 :: P2 :: P8 :: nil) = 3) by (apply LP1P2P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P1 :: P2 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P1 :: P2 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P8mtmp;try rewrite HT2 in HP1P2P3P6P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P8 :: nil) 4 3 3 HP1P2P3P6P8mtmp HP1P2P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}


assert(HP1P2P6P8M : rk(P1 :: P2 :: P6 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P6P8m : rk(P1 :: P2 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P6 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P6P8m2 : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P8m3 : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P6P7P8eq : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P7P8eq HP1P2P3P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P2 :: P3 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P2 :: P3 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P2 :: P3 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P7P8mtmp;try rewrite HT2 in HP1P2P3P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP1P2P3P6P7P8mtmp HP2P3mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}
try clear HP1P2P3P6P7P8M1. try clear HP1P2P3P6P7P8M2. try clear HP1P2P3P6P7P8M3. try clear HP1P2P3P6P7P8m4. try clear HP1P2P3P6P7P8m3. try clear HP1P2P3P6P7P8m2. try clear HP1P2P3P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P8m4 : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P6P8eq : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) = 4) by (apply LP1P2P3P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P6P8mtmp : rk(P1 :: P2 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P8eq HP1P2P3P6P8m4).
	try assert(HP2P3P8eq : rk(P2 :: P3 :: P8 :: nil) = 3) by (apply LP2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P2 :: P3 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P8mtmp;try rewrite HT2 in HP1P2P3P6P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P8 :: nil) 4 3 3 HP1P2P3P6P8mtmp HP2P3P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}
try clear HP1P2P3P6P8M1. try clear HP1P2P3P6P8M2. try clear HP1P2P3P6P8M3. try clear HP1P2P3P6P8m4. try clear HP1P2P3P6P8m3. try clear HP1P2P3P6P8m2. try clear HP1P2P3P6P8m1. 

assert(HP2P3P6P8M : rk(P2 :: P3 :: P6 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P6P8m : rk(P2 :: P3 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P3P6P8eq HP2P3P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP4P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P4 :: P6 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P6P7P8m2 : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P6P7P8m3 : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP1P3P4P5P6P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P6P7P8eq HP1P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) ((P5 :: nil) ++ (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: nil) (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 1 HP1P3P4P5P6P7P8mtmp Hmtmp HP5Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P6P7P8m4 : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P5P6eq : rk(P1 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP1P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6Mtmp : rk(P1 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6eq HP1P3P5P6M3).
	try assert(HP1P3P4P5P6P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P6P7P8eq HP1P3P4P5P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P6 :: P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P3P4P5P6P7P8mtmp HP1P3P6mtmp HP1P3P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P7P8m2 : rk(P1 :: P4 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5Mtmp : rk(P1 :: P2 :: P5 :: nil) <= 3) by (solve_hyps_max HP1P2P5eq HP1P2P5M3).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P5 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P5 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P5 :: nil) ++ (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P4P5P6P7P8mtmp HP1mtmp HP1P2P5Mtmp Hincl); apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P7P8m3 : rk(P1 :: P4 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP3P7eq : rk(P3 :: P7 :: nil) = 2) by (apply LP3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P7Mtmp : rk(P3 :: P7 :: nil) <= 2) by (solve_hyps_max HP3P7eq HP3P7M2).
	try assert(HP1P3P4P6P7P8eq : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P6P7P8eq HP1P3P4P6P7P8m4).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P3 :: P7 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P3 :: P7 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil) ((P3 :: P7 :: nil) ++ (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P6P7P8mtmp;try rewrite HT2 in HP1P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P3 :: P7 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil) (P7 :: nil) 4 1 2 HP1P3P4P6P7P8mtmp HP7mtmp HP3P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P7P8m4 : rk(P1 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P4P7eq : rk(P1 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7Mtmp : rk(P1 :: P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P4P7eq HP1P3P4P7M3).
	try assert(HP1P3P4P6P7P8eq : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P6P7P8eq HP1P3P4P6P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P3 :: P4 :: P7 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P4 :: P7 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P7 :: P1 :: P4 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P4 :: P7 :: nil) ++ (P1 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P6P7P8mtmp;try rewrite HT2 in HP1P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P7 :: nil) (P1 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P3P4P6P7P8mtmp HP1P4P7mtmp HP1P3P4P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8m2 : rk(P4 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP1P3P4P7eq : rk(P1 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7Mtmp : rk(P1 :: P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P4P7eq HP1P3P4P7M3).
	try assert(HP1P3P4P6P7P8eq : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P6P7P8eq HP1P3P4P6P7P8m4).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P3 :: P4 :: P7 :: nil) (P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P4 :: P7 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P7 :: P4 :: P6 :: P8 :: nil) ((P1 :: P3 :: P4 :: P7 :: nil) ++ (P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P6P7P8mtmp;try rewrite HT2 in HP1P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P7 :: nil) (P4 :: P6 :: P8 :: nil) (P4 :: nil) 4 1 3 HP1P3P4P6P7P8mtmp HP4mtmp HP1P3P4P7Mtmp Hincl); apply HT.
}
try clear HP1P3P4P7M1. try clear HP1P3P4P7M2. try clear HP1P3P4P7M3. try clear HP1P3P4P7m4. try clear HP1P3P4P7m3. try clear HP1P3P4P7m2. try clear HP1P3P4P7m1. try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. try clear HP1P3P4P6P7P8M1. try clear HP1P3P4P6P7P8M2. try clear HP1P3P4P6P7P8M3. try clear HP1P3P4P6P7P8m4. try clear HP1P3P4P6P7P8m3. try clear HP1P3P4P6P7P8m2. try clear HP1P3P4P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8m3 : rk(P4 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P4P6P7P8eq : rk(P1 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P6P7P8mtmp : rk(P1 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P6P7P8eq HP1P4P6P7P8m4).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P4 :: P6 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P6P7P8mtmp;try rewrite HT2 in HP1P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P4 :: P6 :: P8 :: nil) (P6 :: nil) 4 1 2 HP1P4P6P7P8mtmp HP6mtmp HP1P6P7Mtmp Hincl); apply HT.
}
try clear HP1P4P6P7P8M1. try clear HP1P4P6P7P8M2. try clear HP1P4P6P7P8M3. try clear HP1P4P6P7P8m4. try clear HP1P4P6P7P8m3. try clear HP1P4P6P7P8m2. try clear HP1P4P6P7P8m1. 

assert(HP4P6P8M : rk(P4 :: P6 :: P8 ::  nil) <= 3) by (solve_hyps_max HP4P6P8eq HP4P6P8M3).
assert(HP4P6P8m : rk(P4 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP4P6P8eq HP4P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P4P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P4 :: P6 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P6P7P8m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P6P7P8m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) ((P5 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 1 HP1P2P3P4P5P6P7P8mtmp Hmtmp HP5Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P6P7P8m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P5P6eq : rk(P1 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP1P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6Mtmp : rk(P1 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP1P3P5P6eq HP1P3P5P6M3).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) ((P1 :: P3 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P2P3P4P5P6P7P8mtmp HP1P3P6mtmp HP1P3P5P6Mtmp Hincl); apply HT.
}
try clear HP1P3P5P6M1. try clear HP1P3P5P6M2. try clear HP1P3P5P6M3. try clear HP1P3P5P6m4. try clear HP1P3P5P6m3. try clear HP1P3P5P6m2. try clear HP1P3P5P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P6P8m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P6P8m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P6P8m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P6P7eq : rk(P1 :: P3 :: P6 :: P7 :: nil) = 3) by (apply LP1P3P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6P7Mtmp : rk(P1 :: P3 :: P6 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P3P6P7eq HP1P3P6P7M3).
	try assert(HP1P2P3P4P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P7P8eq HP1P2P3P4P6P7P8m4).
	try assert(HP1P3P6eq : rk(P1 :: P3 :: P6 :: nil) = 3) by (apply LP1P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (list_inter (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P3 :: P6 :: P7 :: P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P6 :: P7 :: P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) ((P1 :: P3 :: P6 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P6 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) (P1 :: P3 :: P6 :: nil) 4 3 3 HP1P2P3P4P6P7P8mtmp HP1P3P6mtmp HP1P3P6P7Mtmp Hincl); apply HT.
}
try clear HP1P3P6P7M1. try clear HP1P3P6P7M2. try clear HP1P3P6P7M3. try clear HP1P3P6P7m4. try clear HP1P3P6P7m3. try clear HP1P3P6P7m2. try clear HP1P3P6P7m1. try clear HP1P3P6M1. try clear HP1P3P6M2. try clear HP1P3P6M3. try clear HP1P3P6m4. try clear HP1P3P6m3. try clear HP1P3P6m2. try clear HP1P3P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P6P8m2 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P6P8m3 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P4P7eq : rk(P2 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP2P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P7Mtmp : rk(P2 :: P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P3P4P7eq HP2P3P4P7M3).
	try assert(HP1P2P3P4P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P7P8eq HP1P2P3P4P6P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P2 :: P3 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P7 :: P1 :: P2 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P7 :: P1 :: P2 :: P4 :: P6 :: P8 :: nil) ((P2 :: P3 :: P4 :: P7 :: nil) ++ (P1 :: P2 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P7 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 3 HP1P2P3P4P6P7P8mtmp HP2P4mtmp HP2P3P4P7Mtmp Hincl); apply HT.
}
try clear HP2P3P4P7M1. try clear HP2P3P4P7M2. try clear HP2P3P4P7M3. try clear HP2P3P4P7m4. try clear HP2P3P4P7m3. try clear HP2P3P4P7m2. try clear HP2P3P4P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P6P8m4 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P4P6P8eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) = 4) by (apply LP1P2P3P4P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P8eq HP1P2P3P4P6P8m4).
	try assert(HP1P2P8eq : rk(P1 :: P2 :: P8 :: nil) = 3) by (apply LP1P2P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P1 :: P2 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P1 :: P2 :: P4 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P1 :: P2 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P8mtmp;try rewrite HT2 in HP1P2P3P4P6P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: nil) (P1 :: P2 :: P8 :: nil) 4 3 3 HP1P2P3P4P6P8mtmp HP1P2P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P6P8M1. try clear HP1P2P3P4P6P8M2. try clear HP1P2P3P4P6P8M3. try clear HP1P2P3P4P6P8m4. try clear HP1P2P3P4P6P8m3. try clear HP1P2P3P4P6P8m2. try clear HP1P2P3P4P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P6P7P8m2 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3Mtmp : rk(P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP2P3eq HP2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P3 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: nil) ++ (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P2P3P4P5P6P7P8mtmp Hmtmp HP2P3Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P6P7P8m3 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP1mtmp HP1P2P3Mtmp Hincl); apply HT.
}
try clear HP1P2P3M1. try clear HP1P2P3M2. try clear HP1P2P3M3. try clear HP1P2P3m4. try clear HP1P2P3m3. try clear HP1P2P3m2. try clear HP1P2P3m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P6P7P8m4 : rk(P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P7eq : rk(P1 :: P2 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7Mtmp : rk(P1 :: P2 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P4P7eq HP1P2P4P7M3).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: P7 :: nil) ++ (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: nil) (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P2P4P5P6P7P8mtmp HP1P4P7mtmp HP1P2P4P7Mtmp Hincl); apply HT.
}
try clear HP1P2P4P7M1. try clear HP1P2P4P7M2. try clear HP1P2P4P7M3. try clear HP1P2P4P7m4. try clear HP1P2P4P7m3. try clear HP1P2P4P7m2. try clear HP1P2P4P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P8m2 : rk(P1 :: P4 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P3P7eq : rk(P1 :: P2 :: P3 :: P7 :: nil) = 3) by (apply LP1P2P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P7Mtmp : rk(P1 :: P2 :: P3 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P7eq HP1P2P3P7M3).
	try assert(HP1P2P3P4P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P7P8eq HP1P2P3P4P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P1 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P1 :: P4 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P7 :: nil) ++ (P1 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P7 :: nil) (P1 :: P4 :: P6 :: P8 :: nil) (P1 :: nil) 4 1 3 HP1P2P3P4P6P7P8mtmp HP1mtmp HP1P2P3P7Mtmp Hincl); apply HT.
}
try clear HP1P2P3P7M1. try clear HP1P2P3P7M2. try clear HP1P2P3P7M3. try clear HP1P2P3P7m4. try clear HP1P2P3P7m3. try clear HP1P2P3P7m2. try clear HP1P2P3P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P8m3 : rk(P1 :: P4 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P6P7P8eq : rk(P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P6P7P8mtmp : rk(P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P6P7P8eq HP1P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P1 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P1 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P1 :: P4 :: P6 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P1 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P7P8mtmp;try rewrite HT2 in HP1P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P1 :: P4 :: P6 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P4P5P6P7P8mtmp HP1mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P4P5P6P7P8M1. try clear HP1P4P5P6P7P8M2. try clear HP1P4P5P6P7P8M3. try clear HP1P4P5P6P7P8m4. try clear HP1P4P5P6P7P8m3. try clear HP1P4P5P6P7P8m2. try clear HP1P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P8m4 : rk(P1 :: P4 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P6P8eq : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) = 4) by (apply LP1P2P4P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P6P8mtmp : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P6P8eq HP1P2P4P6P8m4).
	try assert(HP1P4P8eq : rk(P1 :: P4 :: P8 :: nil) = 3) by (apply LP1P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P8mtmp : rk(P1 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P4P8eq HP1P4P8m3).
	assert(Hincl : incl (P1 :: P4 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P1 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P1 :: P4 :: P6 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P1 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6P8mtmp;try rewrite HT2 in HP1P2P4P6P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P4 :: P6 :: P8 :: nil) (P1 :: P4 :: P8 :: nil) 4 3 3 HP1P2P4P6P8mtmp HP1P4P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}
try clear HP1P4P8M1. try clear HP1P4P8M2. try clear HP1P4P8M3. try clear HP1P4P8m4. try clear HP1P4P8m3. try clear HP1P4P8m2. try clear HP1P4P8m1. 

assert(HP1P4P6P8M : rk(P1 :: P4 :: P6 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P4P6P8m : rk(P1 :: P4 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P4P6P8eq HP1P4P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P6 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P6P8m2 : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P8m3 : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3P4P7eq : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) = 3) by (apply LP1P2P3P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P7Mtmp : rk(P1 :: P2 :: P3 :: P4 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P2P3P4P7eq HP1P2P3P4P7M3).
	try assert(HP1P2P3P4P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P7P8eq HP1P2P3P4P6P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P2 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P7 :: P2 :: P4 :: P6 :: P8 :: nil) ((P1 :: P2 :: P3 :: P4 :: P7 :: nil) ++ (P2 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P4 :: P7 :: nil) (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 3 HP1P2P3P4P6P7P8mtmp HP2P4mtmp HP1P2P3P4P7Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P7M1. try clear HP1P2P3P4P7M2. try clear HP1P2P3P4P7M3. try clear HP1P2P3P4P7m4. try clear HP1P2P3P4P7m3. try clear HP1P2P3P4P7m2. try clear HP1P2P3P4P7m1. try clear HP1P2P3P4P6P7P8M1. try clear HP1P2P3P4P6P7P8M2. try clear HP1P2P3P4P6P7P8M3. try clear HP1P2P3P4P6P7P8m4. try clear HP1P2P3P4P6P7P8m3. try clear HP1P2P3P4P6P7P8m2. try clear HP1P2P3P4P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P8m4 : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P6P8eq : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) = 4) by (apply LP1P2P4P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P6P8mtmp : rk(P1 :: P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P6P8eq HP1P2P4P6P8m4).
	try assert(HP2P4P8eq : rk(P2 :: P4 :: P8 :: nil) = 3) by (apply LP2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P8mtmp : rk(P2 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P4P8eq HP2P4P8m3).
	assert(Hincl : incl (P2 :: P4 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P6 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P2 :: P4 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6P8mtmp;try rewrite HT2 in HP1P2P4P6P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P8 :: nil) 4 3 3 HP1P2P4P6P8mtmp HP2P4P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}
try clear HP1P2P4P6P8M1. try clear HP1P2P4P6P8M2. try clear HP1P2P4P6P8M3. try clear HP1P2P4P6P8m4. try clear HP1P2P4P6P8m3. try clear HP1P2P4P6P8m2. try clear HP1P2P4P6P8m1. 

assert(HP2P4P6P8M : rk(P2 :: P4 :: P6 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P6P8m : rk(P2 :: P4 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 :: P6 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P7P8m2 : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m3).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P1 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 3 1 2 HP1P2P4P5P6P7P8mtmp HP1mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P2P4M1. try clear HP1P2P4M2. try clear HP1P2P4M3. try clear HP1P2P4m4. try clear HP1P2P4m3. try clear HP1P2P4m2. try clear HP1P2P4m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P7P8m3 : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P2P3P4eq : rk(P1 :: P2 :: P3 :: P4 :: nil) = 2) by (apply LP1P2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4Mtmp : rk(P1 :: P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P3P4eq HP1P2P3P4M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P1 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P1 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P4 :: nil) ++ (P1 :: P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P4 :: nil) (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP1mtmp HP1P2P3P4Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4M1. try clear HP1P2P3P4M2. try clear HP1P2P3P4M3. try clear HP1P2P3P4m4. try clear HP1P2P3P4m3. try clear HP1P2P3P4m2. try clear HP1P2P3P4m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P6P7P8m2 : rk(P5 :: P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P3 :: P4 :: nil) (P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: nil) (P5 :: P6 :: P7 :: P8 :: nil) (nil) 4 0 2 HP2P3P4P5P6P7P8mtmp Hmtmp HP2P3P4Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P6P7P8m3 : rk(P5 :: P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P5P6P7P8eq : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7P8mtmp : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P6P7P8eq HP1P5P6P7P8m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P5 :: P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P5 :: P6 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P5 :: P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P7P8mtmp;try rewrite HT2 in HP1P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P5P6P7P8mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP5P6P7P8M3 : rk(P5 :: P6 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP5P6P7eq : rk(P5 :: P6 :: P7 :: nil) = 2) by (apply LP5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7Mtmp : rk(P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P6P7eq HP5P6P7M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: P6 :: P7 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P7 :: P8 :: nil) ((P5 :: P6 :: P7 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: P6 :: P7 :: nil) (P8 :: nil) (nil) 2 1 0 HP5P6P7Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP5P6P8m2 : rk(P5 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P6P8m3 : rk(P5 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP5P6P7eq : rk(P5 :: P6 :: P7 :: nil) = 2) by (apply LP5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7Mtmp : rk(P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P6P7eq HP5P6P7M2).
	try assert(HP5P6P7P8eq : rk(P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7P8mtmp : rk(P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P7P8eq HP5P6P7P8m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P5 :: P6 :: P7 :: nil) (P5 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P7 :: P5 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P7 :: P5 :: P6 :: P8 :: nil) ((P5 :: P6 :: P7 :: nil) ++ (P5 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P6P7P8mtmp;try rewrite HT2 in HP5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: P7 :: nil) (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: nil) 3 2 2 HP5P6P7P8mtmp HP5P6mtmp HP5P6P7Mtmp Hincl); apply HT.
}
try clear HP5P6P7P8M1. try clear HP5P6P7P8M2. try clear HP5P6P7P8M3. try clear HP5P6P7P8m4. try clear HP5P6P7P8m3. try clear HP5P6P7P8m2. try clear HP5P6P7P8m1. 

assert(HP5P6P8M : rk(P5 :: P6 :: P8 ::  nil) <= 3) by (solve_hyps_max HP5P6P8eq HP5P6P8M3).
assert(HP5P6P8m : rk(P5 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP5P6P8eq HP5P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5P6P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 :: P6 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P6P8m2 : rk(P1 :: P5 :: P6 :: P8 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P8M3 : rk(P1 :: P5 :: P6 :: P8 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P8 :: nil) (P1 :: P5 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P5P6Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P7P8M3 : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP5P6P7eq : rk(P5 :: P6 :: P7 :: nil) = 2) by (apply LP5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7Mtmp : rk(P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P6P7eq HP5P6P7M2).
	try assert(HP1P5P6P8eq : rk(P1 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P8Mtmp : rk(P1 :: P5 :: P6 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P6P8eq HP1P5P6P8M3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P7 :: P1 :: P5 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P7 :: P1 :: P5 :: P6 :: P8 :: nil) ((P5 :: P6 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P8 :: nil) (P5 :: P6 :: nil) 2 3 2 HP5P6P7Mtmp HP1P5P6P8Mtmp HP5P6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P8m3 : rk(P1 :: P5 :: P6 :: P8 :: nil) >= 3).
{
	try assert(HP5P6P7eq : rk(P5 :: P6 :: P7 :: nil) = 2) by (apply LP5P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P7Mtmp : rk(P5 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP5P6P7eq HP5P6P7M2).
	try assert(HP1P5P6P7P8eq : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7P8mtmp : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P6P7P8eq HP1P5P6P7P8m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P7 :: P1 :: P5 :: P6 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P7 :: P1 :: P5 :: P6 :: P8 :: nil) ((P5 :: P6 :: P7 :: nil) ++ (P1 :: P5 :: P6 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P7P8mtmp;try rewrite HT2 in HP1P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: P7 :: nil) (P1 :: P5 :: P6 :: P8 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P5P6P7P8mtmp HP5P6mtmp HP5P6P7Mtmp Hincl); apply HT.
}
try clear HP5P6P7M1. try clear HP5P6P7M2. try clear HP5P6P7M3. try clear HP5P6P7m4. try clear HP5P6P7m3. try clear HP5P6P7m2. try clear HP5P6P7m1. 

assert(HP1P5P6P8M : rk(P1 :: P5 :: P6 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P5P6P8m : rk(P1 :: P5 :: P6 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P5P6P8eq HP1P5P6P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P7 :: P8 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P8m2 : rk(P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P7P8eq HP1P5P7P8m3).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P7P8mtmp;try rewrite HT2 in HP1P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P7 :: P8 :: nil) (P7 :: nil) 3 1 2 HP1P5P7P8mtmp HP7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


assert(HP7P8M : rk(P7 :: P8 ::  nil) <= 2) by (solve_hyps_max HP7P8eq HP7P8M2).
assert(HP7P8m : rk(P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP7P8eq HP7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P8m2 : rk(P2 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6P7P8eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P7P8eq HP1P2P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P2 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P2 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P2 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P2 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7P8mtmp;try rewrite HT2 in HP1P2P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P2 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P2P5P6P7P8mtmp Hmtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P8m3 : rk(P2 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P7P8eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P7P8mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8eq HP1P2P5P7P8m4).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P2 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8mtmp;try rewrite HT2 in HP1P2P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P7 :: P8 :: nil) (P7 :: nil) 4 1 2 HP1P2P5P7P8mtmp HP7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP7M1. try clear HP7M2. try clear HP7M3. try clear HP7m4. try clear HP7m3. try clear HP7m2. try clear HP7m1. try clear HP1P2P5P7P8M1. try clear HP1P2P5P7P8M2. try clear HP1P2P5P7P8M3. try clear HP1P2P5P7P8m4. try clear HP1P2P5P7P8m3. try clear HP1P2P5P7P8m2. try clear HP1P2P5P7P8m1. 

assert(HP2P7P8M : rk(P2 :: P7 :: P8 ::  nil) <= 3) by (solve_hyps_max HP2P7P8eq HP2P7P8M3).
assert(HP2P7P8m : rk(P2 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P7P8eq HP2P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P2P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P2 :: P7 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P4P7P8m2 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P7P8m3 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P4P5P6P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P6P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P6P7P8eq HP1P2P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P2 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P2 :: P4 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P4P5P6P7P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P4P5P6P7P8M1. try clear HP1P2P4P5P6P7P8M2. try clear HP1P2P4P5P6P7P8M3. try clear HP1P2P4P5P6P7P8m4. try clear HP1P2P4P5P6P7P8m3. try clear HP1P2P4P5P6P7P8m2. try clear HP1P2P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P7P8m4 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P4P5P7eq : rk(P1 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP1P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7Mtmp : rk(P1 :: P4 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P4P5P7eq HP1P4P5P7M3).
	try assert(HP1P2P4P5P7P8eq : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P5P7P8mtmp : rk(P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P7P8eq HP1P2P4P5P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P4 :: P5 :: P7 :: P1 :: P2 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P7 :: P1 :: P2 :: P4 :: P7 :: P8 :: nil) ((P1 :: P4 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P7P8mtmp;try rewrite HT2 in HP1P2P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P2P4P5P7P8mtmp HP1P4P7mtmp HP1P4P5P7Mtmp Hincl); apply HT.
}
try clear HP1P2P4P5P7P8M1. try clear HP1P2P4P5P7P8M2. try clear HP1P2P4P5P7P8M3. try clear HP1P2P4P5P7P8m4. try clear HP1P2P4P5P7P8m3. try clear HP1P2P4P5P7P8m2. try clear HP1P2P4P5P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P8m2 : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6Mtmp : rk(P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP5P6eq HP5P6M2).
	try assert(HP1P2P5P6P7P8eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P7P8eq HP1P2P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: P6 :: nil) (P1 :: P2 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P1 :: P2 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P1 :: P2 :: P7 :: P8 :: nil) ((P5 :: P6 :: nil) ++ (P1 :: P2 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7P8mtmp;try rewrite HT2 in HP1P2P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: nil) (P1 :: P2 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P2P5P6P7P8mtmp Hmtmp HP5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P8m3 : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6P7P8eq : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5P6P7P8mtmp : rk(P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P7P8eq HP1P2P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P2 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P2 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P7P8mtmp;try rewrite HT2 in HP1P2P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P5P6P7P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P5P6P7P8M1. try clear HP1P2P5P6P7P8M2. try clear HP1P2P5P6P7P8M3. try clear HP1P2P5P6P7P8m4. try clear HP1P2P5P6P7P8m3. try clear HP1P2P5P6P7P8m2. try clear HP1P2P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P8m4 : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P7P8eq : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7P8mtmp : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P7P8eq HP1P2P4P7P8m4).
	try assert(HP1P2P8eq : rk(P1 :: P2 :: P8 :: nil) = 3) by (apply LP1P2P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P1 :: P2 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P1 :: P2 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P1 :: P2 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7P8mtmp;try rewrite HT2 in HP1P2P4P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P8 :: nil) 4 3 3 HP1P2P4P7P8mtmp HP1P2P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}
try clear HP1P2P8M1. try clear HP1P2P8M2. try clear HP1P2P8M3. try clear HP1P2P8m4. try clear HP1P2P8m3. try clear HP1P2P8m2. try clear HP1P2P8m1. 

assert(HP1P2P7P8M : rk(P1 :: P2 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P7P8m : rk(P1 :: P2 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP3P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P7P8m2 : rk(P3 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P3P5P6P7P8mtmp Hmtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P7P8m3 : rk(P3 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P5P7eq : rk(P2 :: P3 :: P5 :: P7 :: nil) = 3) by (apply LP2P3P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7Mtmp : rk(P2 :: P3 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P3P5P7eq HP2P3P5P7M3).
	try assert(HP2P3P5P7P8eq : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7P8mtmp : rk(P2 :: P3 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P7P8eq HP2P3P5P7P8m4).
	try assert(HP3P7eq : rk(P3 :: P7 :: nil) = 2) by (apply LP3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hincl : incl (P3 :: P7 :: nil) (list_inter (P2 :: P3 :: P5 :: P7 :: nil) (P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P7 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P7 :: P3 :: P7 :: P8 :: nil) ((P2 :: P3 :: P5 :: P7 :: nil) ++ (P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P7P8mtmp;try rewrite HT2 in HP2P3P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P7 :: nil) (P3 :: P7 :: P8 :: nil) (P3 :: P7 :: nil) 4 2 3 HP2P3P5P7P8mtmp HP3P7mtmp HP2P3P5P7Mtmp Hincl); apply HT.
}
try clear HP3P7M1. try clear HP3P7M2. try clear HP3P7M3. try clear HP3P7m4. try clear HP3P7m3. try clear HP3P7m2. try clear HP3P7m1. try clear HP2P3P5P7P8M1. try clear HP2P3P5P7P8M2. try clear HP2P3P5P7P8M3. try clear HP2P3P5P7P8m4. try clear HP2P3P5P7P8m3. try clear HP2P3P5P7P8m2. try clear HP2P3P5P7P8m1. 

assert(HP3P7P8M : rk(P3 :: P7 :: P8 ::  nil) <= 3) by (solve_hyps_max HP3P7P8eq HP3P7P8M3).
assert(HP3P7P8m : rk(P3 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP3P7P8eq HP3P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P3P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P3 :: P7 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P4P7P8m2 : rk(P1 :: P3 :: P4 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P7P8m3 : rk(P1 :: P3 :: P4 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P4P5P6P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P6P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P6P7P8eq HP1P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P3 :: P4 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P3P4P5P6P7P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P3P4P5P6P7P8M1. try clear HP1P3P4P5P6P7P8M2. try clear HP1P3P4P5P6P7P8M3. try clear HP1P3P4P5P6P7P8m4. try clear HP1P3P4P5P6P7P8m3. try clear HP1P3P4P5P6P7P8m2. try clear HP1P3P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P7P8m4 : rk(P1 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P4P5P7eq : rk(P1 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP1P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7Mtmp : rk(P1 :: P4 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P4P5P7eq HP1P4P5P7M3).
	try assert(HP1P3P4P5P7P8eq : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P5P7P8mtmp : rk(P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P7P8eq HP1P3P4P5P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P4 :: P5 :: P7 :: P1 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P7 :: P1 :: P3 :: P4 :: P7 :: P8 :: nil) ((P1 :: P4 :: P5 :: P7 :: nil) ++ (P1 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P7P8mtmp;try rewrite HT2 in HP1P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P3P4P5P7P8mtmp HP1P4P7mtmp HP1P4P5P7Mtmp Hincl); apply HT.
}
try clear HP1P3P4P5P7P8M1. try clear HP1P3P4P5P7P8M2. try clear HP1P3P4P5P7P8M3. try clear HP1P3P4P5P7P8m4. try clear HP1P3P4P5P7P8m3. try clear HP1P3P4P5P7P8m2. try clear HP1P3P4P5P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P8m2 : rk(P1 :: P3 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6Mtmp : rk(P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP5P6eq HP5P6M2).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: P6 :: nil) (P1 :: P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P5 :: P6 :: P1 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P1 :: P3 :: P7 :: P8 :: nil) ((P5 :: P6 :: nil) ++ (P1 :: P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P5 :: P6 :: nil) (P1 :: P3 :: P7 :: P8 :: nil) (nil) 4 0 2 HP1P3P5P6P7P8mtmp Hmtmp HP5P6Mtmp Hincl); apply HT.
}
try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P8m3 : rk(P1 :: P3 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P7P8eq : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P5P6P7P8mtmp : rk(P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P7P8eq HP1P3P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P3 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P7P8mtmp;try rewrite HT2 in HP1P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P3P5P6P7P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P3P5P6P7P8M1. try clear HP1P3P5P6P7P8M2. try clear HP1P3P5P6P7P8M3. try clear HP1P3P5P6P7P8m4. try clear HP1P3P5P6P7P8m3. try clear HP1P3P5P6P7P8m2. try clear HP1P3P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P8m4 : rk(P1 :: P3 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P3P4P8eq : rk(P1 :: P3 :: P4 :: P8 :: nil) = 3) by (apply LP1P3P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P8Mtmp : rk(P1 :: P3 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P3P4P8eq HP1P3P4P8M3).
	try assert(HP1P3P4P7P8eq : rk(P1 :: P3 :: P4 :: P7 :: P8 :: nil) = 4) by (apply LP1P3P4P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4P7P8mtmp : rk(P1 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P4P7P8eq HP1P3P4P7P8m4).
	try assert(HP1P3P8eq : rk(P1 :: P3 :: P8 :: nil) = 3) by (apply LP1P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (list_inter (P1 :: P3 :: P4 :: P8 :: nil) (P1 :: P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: P3 :: P4 :: P8 :: P1 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P8 :: P1 :: P3 :: P7 :: P8 :: nil) ((P1 :: P3 :: P4 :: P8 :: nil) ++ (P1 :: P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P7P8mtmp;try rewrite HT2 in HP1P3P4P7P8mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P8 :: nil) (P1 :: P3 :: P7 :: P8 :: nil) (P1 :: P3 :: P8 :: nil) 4 3 3 HP1P3P4P7P8mtmp HP1P3P8mtmp HP1P3P4P8Mtmp Hincl); apply HT.
}
try clear HP1P3P4P8M1. try clear HP1P3P4P8M2. try clear HP1P3P4P8M3. try clear HP1P3P4P8m4. try clear HP1P3P4P8m3. try clear HP1P3P4P8m2. try clear HP1P3P4P8m1. try clear HP1P3P8M1. try clear HP1P3P8M2. try clear HP1P3P8M3. try clear HP1P3P8m4. try clear HP1P3P8m3. try clear HP1P3P8m2. try clear HP1P3P8m1. try clear HP1P3P4P7P8M1. try clear HP1P3P4P7P8M2. try clear HP1P3P4P7P8M3. try clear HP1P3P4P7P8m4. try clear HP1P3P4P7P8m3. try clear HP1P3P4P7P8m2. try clear HP1P3P4P7P8m1. 

assert(HP1P3P7P8M : rk(P1 :: P3 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P7P8m : rk(P1 :: P3 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P3P7P8eq HP1P3P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P3P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P3 :: P7 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P4P7P8m2 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P7P8m3 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P3P4P5P6P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P6P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P7P8eq HP1P2P3P4P5P6P7P8m4).
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1mtmp : rk(P1 :: nil) >= 1) by (solve_hyps_min HP1eq HP1m1).
	assert(Hincl : incl (P1 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: nil) 4 1 2 HP1P2P3P4P5P6P7P8mtmp HP1mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1M1. try clear HP1M2. try clear HP1M3. try clear HP1m4. try clear HP1m3. try clear HP1m2. try clear HP1m1. try clear HP1P2P3P4P5P6P7P8M1. try clear HP1P2P3P4P5P6P7P8M2. try clear HP1P2P3P4P5P6P7P8M3. try clear HP1P2P3P4P5P6P7P8m4. try clear HP1P2P3P4P5P6P7P8m3. try clear HP1P2P3P4P5P6P7P8m2. try clear HP1P2P3P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P7P8m4 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P4P5P7eq : rk(P1 :: P4 :: P5 :: P7 :: nil) = 3) by (apply LP1P4P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P5P7Mtmp : rk(P1 :: P4 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP1P4P5P7eq HP1P4P5P7M3).
	try assert(HP1P2P3P4P5P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P7P8eq HP1P2P3P4P5P7P8m4).
	try assert(HP1P4P7eq : rk(P1 :: P4 :: P7 :: nil) = 3) by (apply LP1P4P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4P7mtmp : rk(P1 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P4P7eq HP1P4P7m3).
	assert(Hincl : incl (P1 :: P4 :: P7 :: nil) (list_inter (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P4 :: P5 :: P7 :: P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P7 :: P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) ((P1 :: P4 :: P5 :: P7 :: nil) ++ (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P4 :: P5 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: P4 :: P7 :: nil) 4 3 3 HP1P2P3P4P5P7P8mtmp HP1P4P7mtmp HP1P4P5P7Mtmp Hincl); apply HT.
}
try clear HP1P4P5P7M1. try clear HP1P4P5P7M2. try clear HP1P4P5P7M3. try clear HP1P4P5P7m4. try clear HP1P4P5P7m3. try clear HP1P4P5P7m2. try clear HP1P4P5P7m1. try clear HP1P4P7M1. try clear HP1P4P7M2. try clear HP1P4P7M3. try clear HP1P4P7m4. try clear HP1P4P7m3. try clear HP1P4P7m2. try clear HP1P4P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P7P8m2 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P7P8m3 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P5P6eq : rk(P2 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP2P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P6Mtmp : rk(P2 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P3P5P6eq HP2P3P5P6M3).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) ((P2 :: P3 :: P5 :: P6 :: nil) ++ (P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP2P3P4P5P6P7P8mtmp HP2P3mtmp HP2P3P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P7P8m4 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P3P8eq : rk(P1 :: P2 :: P3 :: P8 :: nil) = 3) by (apply LP1P2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P8Mtmp : rk(P1 :: P2 :: P3 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8eq HP1P2P3P8M3).
	try assert(HP1P2P3P4P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P7P8eq HP1P2P3P4P7P8m4).
	try assert(HP2P3P8eq : rk(P2 :: P3 :: P8 :: nil) = 3) by (apply LP2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (list_inter (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P8 :: P2 :: P3 :: P4 :: P7 :: P8 :: nil) ((P1 :: P2 :: P3 :: P8 :: nil) ++ (P2 :: P3 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P7P8mtmp;try rewrite HT2 in HP1P2P3P4P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P2 :: P3 :: P8 :: nil) 4 3 3 HP1P2P3P4P7P8mtmp HP2P3P8mtmp HP1P2P3P8Mtmp Hincl); apply HT.
}
try clear HP1P2P3P8M1. try clear HP1P2P3P8M2. try clear HP1P2P3P8M3. try clear HP1P2P3P8m4. try clear HP1P2P3P8m3. try clear HP1P2P3P8m2. try clear HP1P2P3P8m1. try clear HP1P2P3P4P7P8M1. try clear HP1P2P3P4P7P8M2. try clear HP1P2P3P4P7P8M3. try clear HP1P2P3P4P7P8m4. try clear HP1P2P3P4P7P8m3. try clear HP1P2P3P4P7P8m2. try clear HP1P2P3P4P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P5P7P8m2 : rk(P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P7P8m3 : rk(P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP2P3P4P5P6P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P6P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P6P7P8eq HP2P3P4P5P6P7P8m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P6 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P6 :: nil) ++ (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P6P7P8mtmp;try rewrite HT2 in HP2P3P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P6 :: nil) (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (nil) 4 0 1 HP2P3P4P5P6P7P8mtmp Hmtmp HP6Mtmp Hincl); apply HT.
}
try clear HP2P3P4P5P6P7P8M1. try clear HP2P3P4P5P6P7P8M2. try clear HP2P3P4P5P6P7P8M3. try clear HP2P3P4P5P6P7P8m4. try clear HP2P3P4P5P6P7P8m3. try clear HP2P3P4P5P6P7P8m2. try clear HP2P3P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P7P8m4 : rk(P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P3P4P5P7P8eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3P4P5P7P8mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P7P8eq HP1P2P3P4P5P7P8m4).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P7P8mtmp;try rewrite HT2 in HP1P2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P5 :: P7 :: nil) 4 2 2 HP1P2P3P4P5P7P8mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5P7P8M1. try clear HP1P2P3P4P5P7P8M2. try clear HP1P2P3P4P5P7P8M3. try clear HP1P2P3P4P5P7P8m4. try clear HP1P2P3P4P5P7P8m3. try clear HP1P2P3P4P5P7P8m2. try clear HP1P2P3P4P5P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P8m2 : rk(P2 :: P3 :: P4 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P8M3 : rk(P2 :: P3 :: P4 :: P8 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P3 :: P4 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P8 :: nil) (P2 :: P3 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P8 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P8 :: nil) (nil) 2 1 0 HP2P3P4Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P4M1. try clear HP2P3P4M2. try clear HP2P3P4M3. try clear HP2P3P4m4. try clear HP2P3P4m3. try clear HP2P3P4m2. try clear HP2P3P4m1. try clear HP8M1. try clear HP8M2. try clear HP8M3. try clear HP8m4. try clear HP8m3. try clear HP8m2. try clear HP8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P8m3 : rk(P2 :: P3 :: P4 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P5P7eq : rk(P2 :: P3 :: P5 :: P7 :: nil) = 3) by (apply LP2P3P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P7Mtmp : rk(P2 :: P3 :: P5 :: P7 :: nil) <= 3) by (solve_hyps_max HP2P3P5P7eq HP2P3P5P7M3).
	try assert(HP2P3P4P5P7P8eq : rk(P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P5P7P8mtmp : rk(P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P7P8eq HP2P3P4P5P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P5 :: P7 :: nil) (P2 :: P3 :: P4 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P7 :: P2 :: P3 :: P4 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P7 :: P2 :: P3 :: P4 :: P8 :: nil) ((P2 :: P3 :: P5 :: P7 :: nil) ++ (P2 :: P3 :: P4 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P7P8mtmp;try rewrite HT2 in HP2P3P4P5P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P7 :: nil) (P2 :: P3 :: P4 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP2P3P4P5P7P8mtmp HP2P3mtmp HP2P3P5P7Mtmp Hincl); apply HT.
}
try clear HP2P3P5P7M1. try clear HP2P3P5P7M2. try clear HP2P3P5P7M3. try clear HP2P3P5P7m4. try clear HP2P3P5P7m3. try clear HP2P3P5P7m2. try clear HP2P3P5P7m1. try clear HP2P3P4P5P7P8M1. try clear HP2P3P4P5P7P8M2. try clear HP2P3P4P5P7P8M3. try clear HP2P3P4P5P7P8m4. try clear HP2P3P4P5P7P8m3. try clear HP2P3P4P5P7P8m2. try clear HP2P3P4P5P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P7P8m2 : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P7P8m3 : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P3P5P6eq : rk(P2 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP2P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P6Mtmp : rk(P2 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P3P5P6eq HP2P3P5P6M3).
	try assert(HP2P3P5P6P7P8eq : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P6P7P8mtmp : rk(P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P6P7P8eq HP2P3P5P6P7P8m4).
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hincl : incl (P2 :: P3 :: nil) (list_inter (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P7 :: P8 :: nil) ((P2 :: P3 :: P5 :: P6 :: nil) ++ (P2 :: P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P6P7P8mtmp;try rewrite HT2 in HP2P3P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: nil) 4 2 3 HP2P3P5P6P7P8mtmp HP2P3mtmp HP2P3P5P6Mtmp Hincl); apply HT.
}
try clear HP2P3P5P6M1. try clear HP2P3P5P6M2. try clear HP2P3P5P6M3. try clear HP2P3P5P6m4. try clear HP2P3P5P6m3. try clear HP2P3P5P6m2. try clear HP2P3P5P6m1. try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. try clear HP2P3P5P6P7P8M1. try clear HP2P3P5P6P7P8M2. try clear HP2P3P5P6P7P8M3. try clear HP2P3P5P6P7P8m4. try clear HP2P3P5P6P7P8m3. try clear HP2P3P5P6P7P8m2. try clear HP2P3P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P7P8m4 : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP2P3P4P8eq : rk(P2 :: P3 :: P4 :: P8 :: nil) = 3) by (apply LP2P3P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P8Mtmp : rk(P2 :: P3 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP2P3P4P8eq HP2P3P4P8M3).
	try assert(HP2P3P4P7P8eq : rk(P2 :: P3 :: P4 :: P7 :: P8 :: nil) = 4) by (apply LP2P3P4P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4P7P8mtmp : rk(P2 :: P3 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P4P7P8eq HP2P3P4P7P8m4).
	try assert(HP2P3P8eq : rk(P2 :: P3 :: P8 :: nil) = 3) by (apply LP2P3P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (list_inter (P2 :: P3 :: P4 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P8 :: P2 :: P3 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P8 :: P2 :: P3 :: P7 :: P8 :: nil) ((P2 :: P3 :: P4 :: P8 :: nil) ++ (P2 :: P3 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P7P8mtmp;try rewrite HT2 in HP2P3P4P7P8mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P8 :: nil) 4 3 3 HP2P3P4P7P8mtmp HP2P3P8mtmp HP2P3P4P8Mtmp Hincl); apply HT.
}
try clear HP2P3P4P8M1. try clear HP2P3P4P8M2. try clear HP2P3P4P8M3. try clear HP2P3P4P8m4. try clear HP2P3P4P8m3. try clear HP2P3P4P8m2. try clear HP2P3P4P8m1. try clear HP2P3P8M1. try clear HP2P3P8M2. try clear HP2P3P8M3. try clear HP2P3P8m4. try clear HP2P3P8m3. try clear HP2P3P8m2. try clear HP2P3P8m1. try clear HP2P3P4P7P8M1. try clear HP2P3P4P7P8M2. try clear HP2P3P4P7P8M3. try clear HP2P3P4P7P8m4. try clear HP2P3P4P7P8m3. try clear HP2P3P4P7P8m2. try clear HP2P3P4P7P8m1. 

assert(HP2P3P7P8M : rk(P2 :: P3 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P7P8m : rk(P2 :: P3 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P3P7P8eq HP2P3P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP2P4P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P2 :: P4 :: P7 :: P8 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P7P8m2 : rk(P2 :: P4 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P7P8m3 : rk(P2 :: P4 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP2P4P5P6eq : rk(P2 :: P4 :: P5 :: P6 :: nil) = 3) by (apply LP2P4P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P6Mtmp : rk(P2 :: P4 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P4P5P6eq HP2P4P5P6M3).
	try assert(HP2P4P5P6P7P8eq : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) = 4) by (apply LP2P4P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P6P7P8mtmp : rk(P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P6P7P8eq HP2P4P5P6P7P8m4).
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hincl : incl (P2 :: P4 :: nil) (list_inter (P2 :: P4 :: P5 :: P6 :: nil) (P2 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P6 :: P7 :: P8 :: nil) (P2 :: P4 :: P5 :: P6 :: P2 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P6 :: P2 :: P4 :: P7 :: P8 :: nil) ((P2 :: P4 :: P5 :: P6 :: nil) ++ (P2 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P6P7P8mtmp;try rewrite HT2 in HP2P4P5P6P7P8mtmp.
	assert(HT := rule_4 (P2 :: P4 :: P5 :: P6 :: nil) (P2 :: P4 :: P7 :: P8 :: nil) (P2 :: P4 :: nil) 4 2 3 HP2P4P5P6P7P8mtmp HP2P4mtmp HP2P4P5P6Mtmp Hincl); apply HT.
}
try clear HP2P4P5P6M1. try clear HP2P4P5P6M2. try clear HP2P4P5P6M3. try clear HP2P4P5P6m4. try clear HP2P4P5P6m3. try clear HP2P4P5P6m2. try clear HP2P4P5P6m1. try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. try clear HP2P4P5P6P7P8M1. try clear HP2P4P5P6P7P8M2. try clear HP2P4P5P6P7P8M3. try clear HP2P4P5P6P7P8m4. try clear HP2P4P5P6P7P8m3. try clear HP2P4P5P6P7P8m2. try clear HP2P4P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P7P8m4 : rk(P2 :: P4 :: P7 :: P8 :: nil) >= 4).
{
	try assert(HP1P2P4P8eq : rk(P1 :: P2 :: P4 :: P8 :: nil) = 3) by (apply LP1P2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P8Mtmp : rk(P1 :: P2 :: P4 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8eq HP1P2P4P8M3).
	try assert(HP1P2P4P7P8eq : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) = 4) by (apply LP1P2P4P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4P7P8mtmp : rk(P1 :: P2 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P4P7P8eq HP1P2P4P7P8m4).
	try assert(HP2P4P8eq : rk(P2 :: P4 :: P8 :: nil) = 3) by (apply LP2P4P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P8mtmp : rk(P2 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P4P8eq HP2P4P8m3).
	assert(Hincl : incl (P2 :: P4 :: P8 :: nil) (list_inter (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P8 :: P2 :: P4 :: P7 :: P8 :: nil) ((P1 :: P2 :: P4 :: P8 :: nil) ++ (P2 :: P4 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7P8mtmp;try rewrite HT2 in HP1P2P4P7P8mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P7 :: P8 :: nil) (P2 :: P4 :: P8 :: nil) 4 3 3 HP1P2P4P7P8mtmp HP2P4P8mtmp HP1P2P4P8Mtmp Hincl); apply HT.
}
try clear HP1P2P4P8M1. try clear HP1P2P4P8M2. try clear HP1P2P4P8M3. try clear HP1P2P4P8m4. try clear HP1P2P4P8m3. try clear HP1P2P4P8m2. try clear HP1P2P4P8m1. try clear HP2P4P8M1. try clear HP2P4P8M2. try clear HP2P4P8M3. try clear HP2P4P8m4. try clear HP2P4P8m3. try clear HP2P4P8m2. try clear HP2P4P8m1. try clear HP1P2P4P7P8M1. try clear HP1P2P4P7P8M2. try clear HP1P2P4P7P8M3. try clear HP1P2P4P7P8m4. try clear HP1P2P4P7P8m3. try clear HP1P2P4P7P8m2. try clear HP1P2P4P7P8m1. 

assert(HP2P4P7P8M : rk(P2 :: P4 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P7P8m : rk(P2 :: P4 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP2P4P7P8eq HP2P4P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP5P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P5 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P7P8m2 : rk(P5 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P5P6P7P8eq : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7P8mtmp : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P6P7P8eq HP1P5P6P7P8m3).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P7P8mtmp;try rewrite HT2 in HP1P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P5 :: P7 :: P8 :: nil) (P5 :: nil) 3 1 2 HP1P5P6P7P8mtmp HP5mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP5M1. try clear HP5M2. try clear HP5M3. try clear HP5m4. try clear HP5m3. try clear HP5m2. try clear HP5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P7P8m3 : rk(P5 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P7P8eq HP1P5P7P8m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P5 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P5 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P7P8mtmp;try rewrite HT2 in HP1P5P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P5 :: P7 :: P8 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P5P7P8mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. try clear HP1P5P7P8M1. try clear HP1P5P7P8M2. try clear HP1P5P7P8M3. try clear HP1P5P7P8m4. try clear HP1P5P7P8m3. try clear HP1P5P7P8m2. try clear HP1P5P7P8m1. 

assert(HP5P7P8M : rk(P5 :: P7 :: P8 ::  nil) <= 3) by (solve_hyps_max HP5P7P8eq HP5P7P8M3).
assert(HP5P7P8m : rk(P5 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP5P7P8eq HP5P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P5P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P5 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P8M3 : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) (P1 :: P5 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P5P7Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP8M1. try clear HP8M2. try clear HP8M3. try clear HP8m4. try clear HP8m3. try clear HP8m2. try clear HP8m1. 

assert(HP1P5P7P8M : rk(P1 :: P5 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P5P7P8m : rk(P1 :: P5 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P5P7P8eq HP1P5P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP6P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P6 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P7P8m2 : rk(P6 :: P7 :: P8 :: nil) >= 2).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P5P6P7P8eq : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P7P8mtmp : rk(P1 :: P5 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P6P7P8eq HP1P5P6P7P8m3).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P7 :: P8 :: nil) (P1 :: P5 :: P6 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P6 :: P7 :: P8 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P7P8mtmp;try rewrite HT2 in HP1P5P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P6 :: P7 :: P8 :: nil) (P6 :: nil) 3 1 2 HP1P5P6P7P8mtmp HP6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. try clear HP1P5P6P7P8M1. try clear HP1P5P6P7P8M2. try clear HP1P5P6P7P8M3. try clear HP1P5P6P7P8m4. try clear HP1P5P6P7P8m3. try clear HP1P5P6P7P8m2. try clear HP1P5P6P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P7P8m3 : rk(P6 :: P7 :: P8 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P6P7P8eq : rk(P1 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7P8mtmp : rk(P1 :: P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P6P7P8eq HP1P6P7P8m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P6 :: P7 :: P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P6 :: P7 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P6 :: P7 :: P8 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P7P8mtmp;try rewrite HT2 in HP1P6P7P8mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P6 :: P7 :: P8 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P6P7P8mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}
try clear HP1P6P7M1. try clear HP1P6P7M2. try clear HP1P6P7M3. try clear HP1P6P7m4. try clear HP1P6P7m3. try clear HP1P6P7m2. try clear HP1P6P7m1. try clear HP6P7M1. try clear HP6P7M2. try clear HP6P7M3. try clear HP6P7m4. try clear HP6P7m3. try clear HP6P7m2. try clear HP6P7m1. try clear HP1P6P7P8M1. try clear HP1P6P7P8M2. try clear HP1P6P7P8M3. try clear HP1P6P7P8m4. try clear HP1P6P7P8m3. try clear HP1P6P7P8m2. try clear HP1P6P7P8m1. 

assert(HP6P7P8M : rk(P6 :: P7 :: P8 ::  nil) <= 3) by (solve_hyps_max HP6P7P8eq HP6P7P8M3).
assert(HP6P7P8m : rk(P6 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP6P7P8eq HP6P7P8m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP1P6P7P8 : forall P1 P2 P3 P4 P5 P6 P7 P8 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P1 :: P6 :: P7 :: P8 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P7P8M3 : rk(P1 :: P6 :: P7 :: P8 :: nil) <= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P6 :: P7 :: nil) (P8 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) (P1 :: P6 :: P7 :: P8 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P8 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P8 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P6 :: P7 :: nil) (P8 :: nil) (nil) 2 1 0 HP1P6P7Mtmp HP8Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P6P7M1. try clear HP1P6P7M2. try clear HP1P6P7M3. try clear HP1P6P7m4. try clear HP1P6P7m3. try clear HP1P6P7m2. try clear HP1P6P7m1. try clear HP8M1. try clear HP8M2. try clear HP8M3. try clear HP8m4. try clear HP8m3. try clear HP8m2. try clear HP8m1. 

assert(HP1P6P7P8M : rk(P1 :: P6 :: P7 :: P8 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P6P7P8m : rk(P1 :: P6 :: P7 :: P8 ::  nil) >= 1) by (solve_hyps_min HP1P6P7P8eq HP1P6P7P8m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P9 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

assert(HP9M : rk(P9 ::  nil) <= 1) by (solve_hyps_max HP9eq HP9M1).
assert(HP9m : rk(P9 ::  nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP2P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P2 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P5P9M3 : rk(P2 :: P3 :: P5 :: P9 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P9 :: nil) (P2 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P9 :: nil) ((P2 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P3 :: P5 :: P9 :: nil) (nil) 1 2 0 HP2Mtmp HP3P5P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P9m2 : rk(P2 :: P3 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P5P9m3 : rk(P2 :: P3 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP2P3P5eq : rk(P2 :: P3 :: P5 :: nil) = 3) by (apply LP2P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P3P5M1. try clear HP2P3P5M2. try clear HP2P3P5M3. try clear HP2P3P5m4. try clear HP2P3P5m3. try clear HP2P3P5m2. try clear HP2P3P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P9m2 : rk(P2 :: P9 :: nil) >= 2).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP2P3P5P9eq : rk(P2 :: P3 :: P5 :: P9 :: nil) = 3) by (apply LP2P3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P3P5P9mtmp : rk(P2 :: P3 :: P5 :: P9 :: nil) >= 3) by (solve_hyps_min HP2P3P5P9eq HP2P3P5P9m3).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P2 :: P9 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P9 :: nil) (P2 :: P9 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P9 :: P3 :: P5 :: P9 :: nil) ((P2 :: P9 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P9mtmp;try rewrite HT2 in HP2P3P5P9mtmp.
	assert(HT := rule_2 (P2 :: P9 :: nil) (P3 :: P5 :: P9 :: nil) (P9 :: nil) 3 1 2 HP2P3P5P9mtmp HP9mtmp HP3P5P9Mtmp Hincl);apply HT.
}
try clear HP2P3P5P9M1. try clear HP2P3P5P9M2. try clear HP2P3P5P9M3. try clear HP2P3P5P9m4. try clear HP2P3P5P9m3. try clear HP2P3P5P9m2. try clear HP2P3P5P9m1. 

assert(HP2P9M : rk(P2 :: P9 ::  nil) <= 2) by (solve_hyps_max HP2P9eq HP2P9M2).
assert(HP2P9m : rk(P2 :: P9 ::  nil) >= 1) by (solve_hyps_min HP2P9eq HP2P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP1P2P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P1 :: P2 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P6P9M3 : rk(P1 :: P2 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P9 :: nil) (P1 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P9 :: nil) ((P1 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P2 :: P6 :: P9 :: nil) (nil) 1 2 0 HP1Mtmp HP2P6P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P6P9m2 : rk(P1 :: P2 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P6P9m3 : rk(P1 :: P2 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P6eq : rk(P1 :: P2 :: P6 :: nil) = 3) by (apply LP1P2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P9m2 : rk(P1 :: P2 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P9m3 : rk(P1 :: P2 :: P9 :: nil) >= 3).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP1P2P6P9eq : rk(P1 :: P2 :: P6 :: P9 :: nil) = 3) by (apply LP1P2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P6P9mtmp : rk(P1 :: P2 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P2P6P9eq HP1P2P6P9m3).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P1 :: P2 :: P9 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P9 :: nil) (P1 :: P2 :: P9 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P9 :: P2 :: P6 :: P9 :: nil) ((P1 :: P2 :: P9 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P9mtmp;try rewrite HT2 in HP1P2P6P9mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P9 :: nil) (P2 :: P6 :: P9 :: nil) (P2 :: P9 :: nil) 3 2 2 HP1P2P6P9mtmp HP2P9mtmp HP2P6P9Mtmp Hincl);apply HT.
}
try clear HP1P2P6P9M1. try clear HP1P2P6P9M2. try clear HP1P2P6P9M3. try clear HP1P2P6P9m4. try clear HP1P2P6P9m3. try clear HP1P2P6P9m2. try clear HP1P2P6P9m1. 

assert(HP1P2P9M : rk(P1 :: P2 :: P9 ::  nil) <= 3) by (solve_hyps_max HP1P2P9eq HP1P2P9M3).
assert(HP1P2P9m : rk(P1 :: P2 :: P9 ::  nil) >= 1) by (solve_hyps_min HP1P2P9eq HP1P2P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP3P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P3 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P6P9M3 : rk(P2 :: P3 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3Mtmp : rk(P3 :: nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P9 :: nil) (P3 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P2 :: P6 :: P9 :: nil) ((P3 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: nil) (P2 :: P6 :: P9 :: nil) (nil) 1 2 0 HP3Mtmp HP2P6P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P6P9m2 : rk(P2 :: P3 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP2P3eq : rk(P2 :: P3 :: nil) = 2) by (apply LP2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P6P9m3 : rk(P2 :: P3 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP2P3P6eq : rk(P2 :: P3 :: P6 :: nil) = 3) by (apply LP2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P9m2 : rk(P3 :: P9 :: nil) >= 2).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P3P6P9eq : rk(P2 :: P3 :: P6 :: P9 :: nil) = 3) by (apply LP2P3P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P3P6P9mtmp : rk(P2 :: P3 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP2P3P6P9eq HP2P3P6P9m3).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P9 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P9 :: nil) (P3 :: P9 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P9 :: P2 :: P6 :: P9 :: nil) ((P3 :: P9 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P6P9mtmp;try rewrite HT2 in HP2P3P6P9mtmp.
	assert(HT := rule_2 (P3 :: P9 :: nil) (P2 :: P6 :: P9 :: nil) (P9 :: nil) 3 1 2 HP2P3P6P9mtmp HP9mtmp HP2P6P9Mtmp Hincl);apply HT.
}
try clear HP2P3P6P9M1. try clear HP2P3P6P9M2. try clear HP2P3P6P9M3. try clear HP2P3P6P9m4. try clear HP2P3P6P9m3. try clear HP2P3P6P9m2. try clear HP2P3P6P9m1. 

assert(HP3P9M : rk(P3 :: P9 ::  nil) <= 2) by (solve_hyps_max HP3P9eq HP3P9M2).
assert(HP3P9m : rk(P3 :: P9 ::  nil) >= 1) by (solve_hyps_min HP3P9eq HP3P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP2P4P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P2 :: P4 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P6P9M3 : rk(P2 :: P4 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P9 :: nil) (P4 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P2 :: P6 :: P9 :: nil) ((P4 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P2 :: P6 :: P9 :: nil) (nil) 1 2 0 HP4Mtmp HP2P6P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P6P9m2 : rk(P2 :: P4 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P6P9m3 : rk(P2 :: P4 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP2P4P6eq : rk(P2 :: P4 :: P6 :: nil) = 3) by (apply LP2P4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P4P6M1. try clear HP2P4P6M2. try clear HP2P4P6M3. try clear HP2P4P6m4. try clear HP2P4P6m3. try clear HP2P4P6m2. try clear HP2P4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P9m2 : rk(P2 :: P4 :: P9 :: nil) >= 2).
{
	try assert(HP2P4eq : rk(P2 :: P4 :: nil) = 2) by (apply LP2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P9m3 : rk(P2 :: P4 :: P9 :: nil) >= 3).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P9eq : rk(P2 :: P4 :: P6 :: P9 :: nil) = 3) by (apply LP2P4P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P4P6P9mtmp : rk(P2 :: P4 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP2P4P6P9eq HP2P4P6P9m3).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P2 :: P4 :: P9 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P9 :: nil) (P2 :: P4 :: P9 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P9 :: P2 :: P6 :: P9 :: nil) ((P2 :: P4 :: P9 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P9mtmp;try rewrite HT2 in HP2P4P6P9mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P9 :: nil) (P2 :: P6 :: P9 :: nil) (P2 :: P9 :: nil) 3 2 2 HP2P4P6P9mtmp HP2P9mtmp HP2P6P9Mtmp Hincl);apply HT.
}
try clear HP2P9M1. try clear HP2P9M2. try clear HP2P9M3. try clear HP2P9m4. try clear HP2P9m3. try clear HP2P9m2. try clear HP2P9m1. try clear HP2P4P6P9M1. try clear HP2P4P6P9M2. try clear HP2P4P6P9M3. try clear HP2P4P6P9m4. try clear HP2P4P6P9m3. try clear HP2P4P6P9m2. try clear HP2P4P6P9m1. 

assert(HP2P4P9M : rk(P2 :: P4 :: P9 ::  nil) <= 3) by (solve_hyps_max HP2P4P9eq HP2P4P9M3).
assert(HP2P4P9m : rk(P2 :: P4 :: P9 ::  nil) >= 1) by (solve_hyps_min HP2P4P9eq HP2P4P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP3P4P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P3 :: P4 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P4P5P9M3 : rk(P3 :: P4 :: P5 :: P9 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P9 :: nil) (P4 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P3 :: P5 :: P9 :: nil) ((P4 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P3 :: P5 :: P9 :: nil) (nil) 1 2 0 HP4Mtmp HP3P5P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P9m2 : rk(P3 :: P4 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P9m3 : rk(P3 :: P4 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP3P4P5eq : rk(P3 :: P4 :: P5 :: nil) = 3) by (apply LP3P4P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP3P4P5M1. try clear HP3P4P5M2. try clear HP3P4P5M3. try clear HP3P4P5m4. try clear HP3P4P5m3. try clear HP3P4P5m2. try clear HP3P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P9m2 : rk(P3 :: P4 :: P9 :: nil) >= 2).
{
	try assert(HP3P4eq : rk(P3 :: P4 :: nil) = 2) by (apply LP3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P9m3 : rk(P3 :: P4 :: P9 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P9eq : rk(P3 :: P4 :: P5 :: P9 :: nil) = 3) by (apply LP3P4P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P4P5P9mtmp : rk(P3 :: P4 :: P5 :: P9 :: nil) >= 3) by (solve_hyps_min HP3P4P5P9eq HP3P4P5P9m3).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P4 :: P9 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P9 :: nil) (P3 :: P4 :: P9 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P9 :: P3 :: P5 :: P9 :: nil) ((P3 :: P4 :: P9 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P9mtmp;try rewrite HT2 in HP3P4P5P9mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P9 :: nil) (P3 :: P5 :: P9 :: nil) (P3 :: P9 :: nil) 3 2 2 HP3P4P5P9mtmp HP3P9mtmp HP3P5P9Mtmp Hincl);apply HT.
}
try clear HP3P9M1. try clear HP3P9M2. try clear HP3P9M3. try clear HP3P9m4. try clear HP3P9m3. try clear HP3P9m2. try clear HP3P9m1. try clear HP3P4P5P9M1. try clear HP3P4P5P9M2. try clear HP3P4P5P9M3. try clear HP3P4P5P9m4. try clear HP3P4P5P9m3. try clear HP3P4P5P9m2. try clear HP3P4P5P9m1. 

assert(HP3P4P9M : rk(P3 :: P4 :: P9 ::  nil) <= 3) by (solve_hyps_max HP3P4P9eq HP3P4P9M3).
assert(HP3P4P9m : rk(P3 :: P4 :: P9 ::  nil) >= 1) by (solve_hyps_min HP3P4P9eq HP3P4P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP5P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P5 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P6P9m2 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P6P9m3 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P5P6P9M3 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P9 :: nil) (P1 :: P5 :: P6 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P2 :: P6 :: P9 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P2 :: P6 :: P9 :: nil) (P6 :: nil) 2 2 1 HP1P5P6Mtmp HP2P6P9Mtmp HP6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P5P6P9M3 : rk(P2 :: P5 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P5 :: P6 :: P9 :: nil) (P5 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P2 :: P6 :: P9 :: nil) ((P5 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: nil) (P2 :: P6 :: P9 :: nil) (nil) 1 2 0 HP5Mtmp HP2P6P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P5P6P9m2 : rk(P2 :: P5 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP2P5eq : rk(P2 :: P5 :: nil) = 2) by (apply LP2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP2P5M1. try clear HP2P5M2. try clear HP2P5M3. try clear HP2P5m4. try clear HP2P5m3. try clear HP2P5m2. try clear HP2P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P6P9m3 : rk(P2 :: P5 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6P9eq : rk(P1 :: P2 :: P5 :: P6 :: P9 :: nil) = 3) by (apply LP1P2P5P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P6P9mtmp : rk(P1 :: P2 :: P5 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P9eq HP1P2P5P6P9m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P2 :: P5 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P9 :: nil) (P1 :: P5 :: P6 :: P2 :: P5 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P2 :: P5 :: P6 :: P9 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P2 :: P5 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P9mtmp;try rewrite HT2 in HP1P2P5P6P9mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P2 :: P5 :: P6 :: P9 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P2P5P6P9mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P2P5P6P9M1. try clear HP1P2P5P6P9M2. try clear HP1P2P5P6P9M3. try clear HP1P2P5P6P9m4. try clear HP1P2P5P6P9m3. try clear HP1P2P5P6P9m2. try clear HP1P2P5P6P9m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P9m2 : rk(P5 :: P9 :: nil) >= 2).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P5P6P9eq : rk(P2 :: P5 :: P6 :: P9 :: nil) = 3) by (apply LP2P5P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P5P6P9mtmp : rk(P2 :: P5 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP2P5P6P9eq HP2P5P6P9m3).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P5 :: P9 :: nil) (P2 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P5 :: P6 :: P9 :: nil) (P5 :: P9 :: P2 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P9 :: P2 :: P6 :: P9 :: nil) ((P5 :: P9 :: nil) ++ (P2 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P5P6P9mtmp;try rewrite HT2 in HP2P5P6P9mtmp.
	assert(HT := rule_2 (P5 :: P9 :: nil) (P2 :: P6 :: P9 :: nil) (P9 :: nil) 3 1 2 HP2P5P6P9mtmp HP9mtmp HP2P6P9Mtmp Hincl);apply HT.
}
try clear HP2P6P9M1. try clear HP2P6P9M2. try clear HP2P6P9M3. try clear HP2P6P9m4. try clear HP2P6P9m3. try clear HP2P6P9m2. try clear HP2P6P9m1. try clear HP2P5P6P9M1. try clear HP2P5P6P9M2. try clear HP2P5P6P9M3. try clear HP2P5P6P9m4. try clear HP2P5P6P9m3. try clear HP2P5P6P9m2. try clear HP2P5P6P9m1. 

assert(HP5P9M : rk(P5 :: P9 ::  nil) <= 2) by (solve_hyps_max HP5P9eq HP5P9M2).
assert(HP5P9m : rk(P5 :: P9 ::  nil) >= 1) by (solve_hyps_min HP5P9eq HP5P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP1P5P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P1 :: P5 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P5P9M3 : rk(P1 :: P3 :: P5 :: P9 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P9 :: nil) (P1 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P9 :: nil) ((P1 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P3 :: P5 :: P9 :: nil) (nil) 1 2 0 HP1Mtmp HP3P5P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1M1. try clear HP1M2. try clear HP1M3. try clear HP1m4. try clear HP1m3. try clear HP1m2. try clear HP1m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P9m2 : rk(P1 :: P3 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P9m3 : rk(P1 :: P3 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP1P3P5eq : rk(P1 :: P3 :: P5 :: nil) = 3) by (apply LP1P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P9m2 : rk(P1 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP1P5eq : rk(P1 :: P5 :: nil) = 2) by (apply LP1P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P9m3 : rk(P1 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP1P3P5P9eq : rk(P1 :: P3 :: P5 :: P9 :: nil) = 3) by (apply LP1P3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P3P5P9mtmp : rk(P1 :: P3 :: P5 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P3P5P9eq HP1P3P5P9m3).
	try assert(HP5P9eq : rk(P5 :: P9 :: nil) = 2) by (apply LP5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hincl : incl (P5 :: P9 :: nil) (list_inter (P1 :: P5 :: P9 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P9 :: nil) (P1 :: P5 :: P9 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P9 :: P3 :: P5 :: P9 :: nil) ((P1 :: P5 :: P9 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P9mtmp;try rewrite HT2 in HP1P3P5P9mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P9 :: nil) (P3 :: P5 :: P9 :: nil) (P5 :: P9 :: nil) 3 2 2 HP1P3P5P9mtmp HP5P9mtmp HP3P5P9Mtmp Hincl);apply HT.
}
try clear HP5P9M1. try clear HP5P9M2. try clear HP5P9M3. try clear HP5P9m4. try clear HP5P9m3. try clear HP5P9m2. try clear HP5P9m1. try clear HP1P3P5P9M1. try clear HP1P3P5P9M2. try clear HP1P3P5P9M3. try clear HP1P3P5P9m4. try clear HP1P3P5P9m3. try clear HP1P3P5P9m2. try clear HP1P3P5P9m1. 

assert(HP1P5P9M : rk(P1 :: P5 :: P9 ::  nil) <= 3) by (solve_hyps_max HP1P5P9eq HP1P5P9M3).
assert(HP1P5P9m : rk(P1 :: P5 :: P9 ::  nil) >= 1) by (solve_hyps_min HP1P5P9eq HP1P5P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP1P2P5P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P1 :: P2 :: P5 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P9m2 : rk(P1 :: P2 :: P3 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P5P9M3 : rk(P1 :: P2 :: P3 :: P5 :: P9 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P9 :: nil) (P1 :: P2 :: P3 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P3 :: P5 :: P9 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P3 :: P5 :: P9 :: nil) (P3 :: nil) 2 2 1 HP1P2P3Mtmp HP3P5P9Mtmp HP3mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P3M1. try clear HP1P2P3M2. try clear HP1P2P3M3. try clear HP1P2P3m4. try clear HP1P2P3m3. try clear HP1P2P3m2. try clear HP1P2P3m1. try clear HP3M1. try clear HP3M2. try clear HP3M3. try clear HP3m4. try clear HP3m3. try clear HP3m2. try clear HP3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P9m3 : rk(P1 :: P2 :: P3 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P9m2 : rk(P1 :: P2 :: P5 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P9m3 : rk(P1 :: P2 :: P5 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P5P9M3 : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3).
{
	assert(HP1P2P3P5P9Mtmp : rk(P1 :: P2 :: P3 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P3P5P9eq HP1P2P3P5P9M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P3 :: P5 :: P9 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P3 :: P5 :: P9 :: nil) 3 3 HP1P2P3P5P9Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P5P9M1. try clear HP1P2P3P5P9M2. try clear HP1P2P3P5P9M3. try clear HP1P2P3P5P9m4. try clear HP1P2P3P5P9m3. try clear HP1P2P3P5P9m2. try clear HP1P2P3P5P9m1. 

assert(HP1P2P5P9M : rk(P1 :: P2 :: P5 :: P9 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P5P9m : rk(P1 :: P2 :: P5 :: P9 ::  nil) >= 1) by (solve_hyps_min HP1P2P5P9eq HP1P2P5P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP3P5P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P3 :: P5 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

assert(HP3P5P9M : rk(P3 :: P5 :: P9 ::  nil) <= 3) by (solve_hyps_max HP3P5P9eq HP3P5P9M3).
assert(HP3P5P9m : rk(P3 :: P5 :: P9 ::  nil) >= 1) by (solve_hyps_min HP3P5P9eq HP3P5P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP6P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P6 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P6P9m2 : rk(P1 :: P3 :: P5 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P6P9m3 : rk(P1 :: P3 :: P5 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP1P3P5eq : rk(P1 :: P3 :: P5 :: nil) = 3) by (apply LP1P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P5P6P9M3 : rk(P1 :: P3 :: P5 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P9 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P9 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P9 :: nil) (P5 :: nil) 2 2 1 HP1P5P6Mtmp HP3P5P9Mtmp HP5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P5P6P9m2 : rk(P3 :: P5 :: P6 :: P9 :: nil) >= 2).
{
	try assert(HP3P5eq : rk(P3 :: P5 :: nil) = 2) by (apply LP3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P6P9M3 : rk(P3 :: P5 :: P6 :: P9 :: nil) <= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P9 :: nil) (P6 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P3 :: P5 :: P9 :: nil) ((P6 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P6 :: nil) (P3 :: P5 :: P9 :: nil) (nil) 1 2 0 HP6Mtmp HP3P5P9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P9m3 : rk(P3 :: P5 :: P6 :: P9 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P9eq : rk(P1 :: P3 :: P5 :: P6 :: P9 :: nil) = 3) by (apply LP1P3P5P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P3P5P6P9mtmp : rk(P1 :: P3 :: P5 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P9eq HP1P3P5P6P9m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P9 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P9 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P9mtmp;try rewrite HT2 in HP1P3P5P6P9mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P9 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P3P5P6P9mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. try clear HP1P3P5P6P9M1. try clear HP1P3P5P6P9M2. try clear HP1P3P5P6P9M3. try clear HP1P3P5P6P9m4. try clear HP1P3P5P6P9m3. try clear HP1P3P5P6P9m2. try clear HP1P3P5P6P9m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P9m2 : rk(P6 :: P9 :: nil) >= 2).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P6P9eq : rk(P3 :: P5 :: P6 :: P9 :: nil) = 3) by (apply LP3P5P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P6P9mtmp : rk(P3 :: P5 :: P6 :: P9 :: nil) >= 3) by (solve_hyps_min HP3P5P6P9eq HP3P5P6P9m3).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P6 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P9 :: nil) (P3 :: P5 :: P9 :: P6 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P6 :: P9 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P6 :: P9 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P6P9mtmp;try rewrite HT2 in HP3P5P6P9mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P6 :: P9 :: nil) (P9 :: nil) 3 1 2 HP3P5P6P9mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P6P9M1. try clear HP3P5P6P9M2. try clear HP3P5P6P9M3. try clear HP3P5P6P9m4. try clear HP3P5P6P9m3. try clear HP3P5P6P9m2. try clear HP3P5P6P9m1. 

assert(HP6P9M : rk(P6 :: P9 ::  nil) <= 2) by (solve_hyps_max HP6P9eq HP6P9M2).
assert(HP6P9m : rk(P6 :: P9 ::  nil) >= 1) by (solve_hyps_min HP6P9eq HP6P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP2P6P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

assert(HP2P6P9M : rk(P2 :: P6 :: P9 ::  nil) <= 3) by (solve_hyps_max HP2P6P9eq HP2P6P9M3).
assert(HP2P6P9m : rk(P2 :: P6 :: P9 ::  nil) >= 1) by (solve_hyps_min HP2P6P9eq HP2P6P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP1P2P7P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P1 :: P2 :: P7 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P7P9m2 : rk(P1 :: P5 :: P7 :: P9 :: nil) >= 2).
{
	try assert(HP1P5eq : rk(P1 :: P5 :: nil) = 2) by (apply LP1P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P5M1. try clear HP1P5M2. try clear HP1P5M3. try clear HP1P5m4. try clear HP1P5m3. try clear HP1P5m2. try clear HP1P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P9M3 : rk(P1 :: P5 :: P7 :: P9 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9Mtmp : rk(P9 :: nil) <= 1) by (solve_hyps_max HP9eq HP9M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P9 :: nil) (P1 :: P5 :: P7 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P9 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P9 :: nil) (nil) 2 1 0 HP1P5P7Mtmp HP9Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP9M1. try clear HP9M2. try clear HP9M3. try clear HP9m4. try clear HP9m3. try clear HP9m2. try clear HP9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P7P9m3 : rk(P1 :: P5 :: P7 :: P9 :: nil) >= 3).
{
	try assert(HP1P5P9eq : rk(P1 :: P5 :: P9 :: nil) = 3) by (apply LP1P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P7P9m2 : rk(P1 :: P2 :: P5 :: P7 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P5P7P9m3 : rk(P1 :: P2 :: P5 :: P7 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P5P7P9M3 : rk(P1 :: P2 :: P5 :: P7 :: P9 :: nil) <= 3).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P5P7P9eq : rk(P1 :: P5 :: P7 :: P9 :: nil) = 3) by (apply LP1P5P7P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P5P7P9Mtmp : rk(P1 :: P5 :: P7 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P5P7P9eq HP1P5P7P9M3).
	try assert(HP1P5P9eq : rk(P1 :: P5 :: P9 :: nil) = 3) by (apply LP1P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P5P9mtmp : rk(P1 :: P5 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P5P9eq HP1P5P9m3).
	assert(Hincl : incl (P1 :: P5 :: P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P5 :: P7 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P9 :: nil) (P1 :: P2 :: P5 :: P9 :: P1 :: P5 :: P7 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P1 :: P5 :: P7 :: P9 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P1 :: P5 :: P7 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P5 :: P7 :: P9 :: nil) (P1 :: P5 :: P9 :: nil) 3 3 3 HP1P2P5P9Mtmp HP1P5P7P9Mtmp HP1P5P9mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P5P9M1. try clear HP1P2P5P9M2. try clear HP1P2P5P9M3. try clear HP1P2P5P9m4. try clear HP1P2P5P9m3. try clear HP1P2P5P9m2. try clear HP1P2P5P9m1. try clear HP1P5P7P9M1. try clear HP1P5P7P9M2. try clear HP1P5P7P9M3. try clear HP1P5P7P9m4. try clear HP1P5P7P9m3. try clear HP1P5P7P9m2. try clear HP1P5P7P9m1. try clear HP1P5P9M1. try clear HP1P5P9M2. try clear HP1P5P9M3. try clear HP1P5P9m4. try clear HP1P5P9m3. try clear HP1P5P9m2. try clear HP1P5P9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P7P9m2 : rk(P1 :: P2 :: P7 :: P9 :: nil) >= 2).
{
	try assert(HP1P2eq : rk(P1 :: P2 :: nil) = 2) by (apply LP1P2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P7P9m3 : rk(P1 :: P2 :: P7 :: P9 :: nil) >= 3).
{
	try assert(HP1P2P7eq : rk(P1 :: P2 :: P7 :: nil) = 3) by (apply LP1P2P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P2P7M1. try clear HP1P2P7M2. try clear HP1P2P7M3. try clear HP1P2P7m4. try clear HP1P2P7m3. try clear HP1P2P7m2. try clear HP1P2P7m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P7P9M3 : rk(P1 :: P2 :: P7 :: P9 :: nil) <= 3).
{
	assert(HP1P2P5P7P9Mtmp : rk(P1 :: P2 :: P5 :: P7 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P7P9eq HP1P2P5P7P9M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P9 :: nil) (P1 :: P2 :: P5 :: P7 :: P9 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P7 :: P9 :: nil) (P1 :: P2 :: P5 :: P7 :: P9 :: nil) 3 3 HP1P2P5P7P9Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P7P9M1. try clear HP1P2P5P7P9M2. try clear HP1P2P5P7P9M3. try clear HP1P2P5P7P9m4. try clear HP1P2P5P7P9m3. try clear HP1P2P5P7P9m2. try clear HP1P2P5P7P9m1. 

assert(HP1P2P7P9M : rk(P1 :: P2 :: P7 :: P9 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P7P9m : rk(P1 :: P2 :: P7 :: P9 ::  nil) >= 1) by (solve_hyps_min HP1P2P7P9eq HP1P2P7P9m1).
intuition.
Qed.

(* dans la couche 1 *)
Lemma LP1P3P7P9 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P1 :: P3 :: P7 :: P9 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P7P9m2 : rk(P1 :: P3 :: P5 :: P7 :: P9 :: nil) >= 2).
{
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P5P7P9m3 : rk(P1 :: P3 :: P5 :: P7 :: P9 :: nil) >= 3).
{
	try assert(HP1P3P5eq : rk(P1 :: P3 :: P5 :: nil) = 3) by (apply LP1P3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P5P7P9M3 : rk(P1 :: P3 :: P5 :: P7 :: P9 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P9 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P9 :: nil) (P1 :: P5 :: P7 :: P3 :: P5 :: P9 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P5 :: P9 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P5 :: P9 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P9 :: nil) (P5 :: nil) 2 2 1 HP1P5P7Mtmp HP3P5P9Mtmp HP5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP3P5P9M1. try clear HP3P5P9M2. try clear HP3P5P9M3. try clear HP3P5P9m4. try clear HP3P5P9m3. try clear HP3P5P9m2. try clear HP3P5P9m1. try clear HP5M1. try clear HP5M2. try clear HP5M3. try clear HP5m4. try clear HP5m3. try clear HP5m2. try clear HP5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P7P9m2 : rk(P1 :: P3 :: P7 :: P9 :: nil) >= 2).
{
	try assert(HP1P3eq : rk(P1 :: P3 :: nil) = 2) by (apply LP1P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P7P9m3 : rk(P1 :: P3 :: P7 :: P9 :: nil) >= 3).
{
	try assert(HP1P3P7eq : rk(P1 :: P3 :: P7 :: nil) = 3) by (apply LP1P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
try clear HP1P3P7M1. try clear HP1P3P7M2. try clear HP1P3P7M3. try clear HP1P3P7m4. try clear HP1P3P7m3. try clear HP1P3P7m2. try clear HP1P3P7m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P3P7P9M3 : rk(P1 :: P3 :: P7 :: P9 :: nil) <= 3).
{
	assert(HP1P3P5P7P9Mtmp : rk(P1 :: P3 :: P5 :: P7 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P3P5P7P9eq HP1P3P5P7P9M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: P9 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P7 :: P9 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: nil) 3 3 HP1P3P5P7P9Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P7P9M1. try clear HP1P3P5P7P9M2. try clear HP1P3P5P7P9M3. try clear HP1P3P5P7P9m4. try clear HP1P3P5P7P9m3. try clear HP1P3P5P7P9m2. try clear HP1P3P5P7P9m1. 

assert(HP1P3P7P9M : rk(P1 :: P3 :: P7 :: P9 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P7P9m : rk(P1 :: P3 :: P7 :: P9 ::  nil) >= 1) by (solve_hyps_min HP1P3P7P9eq HP1P3P7P9m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P10 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

assert(HP10M : rk(P10 ::  nil) <= 1) by (solve_hyps_max HP10eq HP10M1).
assert(HP10m : rk(P10 ::  nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP2P10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P2 :: P10 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P5P10M3 : rk(P2 :: P4 :: P5 :: P10 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P4 :: P5 :: P10 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P10 :: nil) (P2 :: P4 :: P5 :: P10 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P10 :: nil) ((P2 :: nil) ++ (P4 :: P5 :: P10 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P4 :: P5 :: P10 :: nil) (nil) 1 2 0 HP2Mtmp HP4P5P10Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10m2 : rk(P2 :: P4 :: P5 :: P10 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10m3 : rk(P2 :: P4 :: P5 :: P10 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5M1. try clear HP2P4P5M2. try clear HP2P4P5M3. try clear HP2P4P5m4. try clear HP2P4P5m3. try clear HP2P4P5m2. try clear HP2P4P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P10m2 : rk(P2 :: P10 :: nil) >= 2).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP2P4P5P10eq : rk(P2 :: P4 :: P5 :: P10 :: nil) = 3) by (apply LP2P4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P4P5P10mtmp : rk(P2 :: P4 :: P5 :: P10 :: nil) >= 3) by (solve_hyps_min HP2P4P5P10eq HP2P4P5P10m3).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P2 :: P10 :: nil) (P4 :: P5 :: P10 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P10 :: nil) (P2 :: P10 :: P4 :: P5 :: P10 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P10 :: P4 :: P5 :: P10 :: nil) ((P2 :: P10 :: nil) ++ (P4 :: P5 :: P10 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P10mtmp;try rewrite HT2 in HP2P4P5P10mtmp.
	assert(HT := rule_2 (P2 :: P10 :: nil) (P4 :: P5 :: P10 :: nil) (P10 :: nil) 3 1 2 HP2P4P5P10mtmp HP10mtmp HP4P5P10Mtmp Hincl);apply HT.
}
try clear HP2P4P5P10M1. try clear HP2P4P5P10M2. try clear HP2P4P5P10M3. try clear HP2P4P5P10m4. try clear HP2P4P5P10m3. try clear HP2P4P5P10m2. try clear HP2P4P5P10m1. 

assert(HP2P10M : rk(P2 :: P10 ::  nil) <= 2) by (solve_hyps_max HP2P10eq HP2P10M2).
assert(HP2P10m : rk(P2 :: P10 ::  nil) >= 1) by (solve_hyps_min HP2P10eq HP2P10m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP4P10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P10 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P7P10M3 : rk(P2 :: P4 :: P7 :: P10 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P2 :: P7 :: P10 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P7 :: P10 :: nil) (P4 :: P2 :: P7 :: P10 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P2 :: P7 :: P10 :: nil) ((P4 :: nil) ++ (P2 :: P7 :: P10 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P2 :: P7 :: P10 :: nil) (nil) 1 2 0 HP4Mtmp HP2P7P10Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P7P10m2 : rk(P2 :: P4 :: P7 :: P10 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P10 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P10m3 : rk(P2 :: P4 :: P7 :: P10 :: nil) >= 3).
{
	assert(HP2P4P7mtmp : rk(P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P4P7eq HP2P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P10 :: nil) 3 3 HP2P4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P7M1. try clear HP2P4P7M2. try clear HP2P4P7M3. try clear HP2P4P7m4. try clear HP2P4P7m3. try clear HP2P4P7m2. try clear HP2P4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P10m2 : rk(P4 :: P10 :: nil) >= 2).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP2P4P7P10eq : rk(P2 :: P4 :: P7 :: P10 :: nil) = 3) by (apply LP2P4P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P4P7P10mtmp : rk(P2 :: P4 :: P7 :: P10 :: nil) >= 3) by (solve_hyps_min HP2P4P7P10eq HP2P4P7P10m3).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P4 :: P10 :: nil) (P2 :: P7 :: P10 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P7 :: P10 :: nil) (P4 :: P10 :: P2 :: P7 :: P10 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P10 :: P2 :: P7 :: P10 :: nil) ((P4 :: P10 :: nil) ++ (P2 :: P7 :: P10 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P7P10mtmp;try rewrite HT2 in HP2P4P7P10mtmp.
	assert(HT := rule_2 (P4 :: P10 :: nil) (P2 :: P7 :: P10 :: nil) (P10 :: nil) 3 1 2 HP2P4P7P10mtmp HP10mtmp HP2P7P10Mtmp Hincl);apply HT.
}
try clear HP2P7P10M1. try clear HP2P7P10M2. try clear HP2P7P10M3. try clear HP2P7P10m4. try clear HP2P7P10m3. try clear HP2P7P10m2. try clear HP2P7P10m1. try clear HP10M1. try clear HP10M2. try clear HP10M3. try clear HP10m4. try clear HP10m3. try clear HP10m2. try clear HP10m1. try clear HP2P4P7P10M1. try clear HP2P4P7P10M2. try clear HP2P4P7P10M3. try clear HP2P4P7P10m4. try clear HP2P4P7P10m3. try clear HP2P4P7P10m2. try clear HP2P4P7P10m1. 

assert(HP4P10M : rk(P4 :: P10 ::  nil) <= 2) by (solve_hyps_max HP4P10eq HP4P10M2).
assert(HP4P10m : rk(P4 :: P10 ::  nil) >= 1) by (solve_hyps_min HP4P10eq HP4P10m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP1P2P5P10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P1 :: P2 :: P5 :: P10 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P10m2 : rk(P1 :: P2 :: P4 :: P5 :: P10 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P5P10M3 : rk(P1 :: P2 :: P4 :: P5 :: P10 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P4 :: P5 :: P10 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P10 :: nil) (P1 :: P2 :: P4 :: P4 :: P5 :: P10 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P4 :: P5 :: P10 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P4 :: P5 :: P10 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P4 :: P5 :: P10 :: nil) (P4 :: nil) 2 2 1 HP1P2P4Mtmp HP4P5P10Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P4M1. try clear HP1P2P4M2. try clear HP1P2P4M3. try clear HP1P2P4m4. try clear HP1P2P4m3. try clear HP1P2P4m2. try clear HP1P2P4m1. try clear HP4P5P10M1. try clear HP4P5P10M2. try clear HP4P5P10M3. try clear HP4P5P10m4. try clear HP4P5P10m3. try clear HP4P5P10m2. try clear HP4P5P10m1. try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P10m3 : rk(P1 :: P2 :: P4 :: P5 :: P10 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P10m2 : rk(P1 :: P2 :: P5 :: P10 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P10 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P10m3 : rk(P1 :: P2 :: P5 :: P10 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P10 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P5P10M3 : rk(P1 :: P2 :: P5 :: P10 :: nil) <= 3).
{
	assert(HP1P2P4P5P10Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P10 :: nil) <= 3) by (solve_hyps_max HP1P2P4P5P10eq HP1P2P4P5P10M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P10 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P5 :: P10 :: nil) (P1 :: P2 :: P4 :: P5 :: P10 :: nil) 3 3 HP1P2P4P5P10Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P4P5P10M1. try clear HP1P2P4P5P10M2. try clear HP1P2P4P5P10M3. try clear HP1P2P4P5P10m4. try clear HP1P2P4P5P10m3. try clear HP1P2P4P5P10m2. try clear HP1P2P4P5P10m1. 

assert(HP1P2P5P10M : rk(P1 :: P2 :: P5 :: P10 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P5P10m : rk(P1 :: P2 :: P5 :: P10 ::  nil) >= 1) by (solve_hyps_min HP1P2P5P10eq HP1P2P5P10m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP4P5P10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

assert(HP4P5P10M : rk(P4 :: P5 :: P10 ::  nil) <= 3) by (solve_hyps_max HP4P5P10eq HP4P5P10M3).
assert(HP4P5P10m : rk(P4 :: P5 :: P10 ::  nil) >= 1) by (solve_hyps_min HP4P5P10eq HP4P5P10m1).
intuition.
Qed.

(* dans la couche 2 *)
Lemma LP2P7P10 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P2 :: P7 :: P10 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq .

assert(HP2P7P10M : rk(P2 :: P7 :: P10 ::  nil) <= 3) by (solve_hyps_max HP2P7P10eq HP2P7P10M3).
assert(HP2P7P10m : rk(P2 :: P7 :: P10 ::  nil) >= 1) by (solve_hyps_min HP2P7P10eq HP2P7P10m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P11 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

assert(HP11M : rk(P11 ::  nil) <= 1) by (solve_hyps_max HP11eq HP11M1).
assert(HP11m : rk(P11 ::  nil) >= 1) by (solve_hyps_min HP11eq HP11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP3P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P3 :: P11 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P4P6P11M3 : rk(P3 :: P4 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3Mtmp : rk(P3 :: nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P6 :: P11 :: nil) (P3 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P6 :: P11 :: nil) ((P3 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: nil) (P4 :: P6 :: P11 :: nil) (nil) 1 2 0 HP3Mtmp HP4P6P11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3M1. try clear HP3M2. try clear HP3M3. try clear HP3m4. try clear HP3m3. try clear HP3m2. try clear HP3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P6P11m2 : rk(P3 :: P4 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P6 :: P11 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P6P11m3 : rk(P3 :: P4 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP3P4P6mtmp : rk(P3 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP3P4P6eq HP3P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P6 :: nil) (P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P6 :: nil) (P3 :: P4 :: P6 :: P11 :: nil) 3 3 HP3P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P6M1. try clear HP3P4P6M2. try clear HP3P4P6M3. try clear HP3P4P6m4. try clear HP3P4P6m3. try clear HP3P4P6m2. try clear HP3P4P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P11m2 : rk(P3 :: P11 :: nil) >= 2).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP3P4P6P11eq : rk(P3 :: P4 :: P6 :: P11 :: nil) = 3) by (apply LP3P4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P6P11mtmp : rk(P3 :: P4 :: P6 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P4P6P11eq HP3P4P6P11m3).
	try assert(HP11eq : rk(P11 :: nil) = 1) by (apply LP11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP11mtmp : rk(P11 :: nil) >= 1) by (solve_hyps_min HP11eq HP11m1).
	assert(Hincl : incl (P11 :: nil) (list_inter (P3 :: P11 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P6 :: P11 :: nil) (P3 :: P11 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P11 :: P4 :: P6 :: P11 :: nil) ((P3 :: P11 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P6P11mtmp;try rewrite HT2 in HP3P4P6P11mtmp.
	assert(HT := rule_2 (P3 :: P11 :: nil) (P4 :: P6 :: P11 :: nil) (P11 :: nil) 3 1 2 HP3P4P6P11mtmp HP11mtmp HP4P6P11Mtmp Hincl);apply HT.
}


assert(HP3P11M : rk(P3 :: P11 ::  nil) <= 2) by (solve_hyps_max HP3P11eq HP3P11M2).
assert(HP3P11m : rk(P3 :: P11 ::  nil) >= 1) by (solve_hyps_min HP3P11eq HP3P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP4P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P4 :: P11 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P4P7P11M3 : rk(P3 :: P4 :: P7 :: P11 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P3 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P7 :: P11 :: nil) (P4 :: P3 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P3 :: P7 :: P11 :: nil) ((P4 :: nil) ++ (P3 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P3 :: P7 :: P11 :: nil) (nil) 1 2 0 HP4Mtmp HP3P7P11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P7P11m2 : rk(P3 :: P4 :: P7 :: P11 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P7 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P7 :: P11 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P7P11m3 : rk(P3 :: P4 :: P7 :: P11 :: nil) >= 3).
{
	assert(HP3P4P7mtmp : rk(P3 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP3P4P7eq HP3P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P7 :: nil) (P3 :: P4 :: P7 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P7 :: nil) (P3 :: P4 :: P7 :: P11 :: nil) 3 3 HP3P4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P7M1. try clear HP3P4P7M2. try clear HP3P4P7M3. try clear HP3P4P7m4. try clear HP3P4P7m3. try clear HP3P4P7m2. try clear HP3P4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P11m2 : rk(P4 :: P11 :: nil) >= 2).
{
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	try assert(HP3P4P7P11eq : rk(P3 :: P4 :: P7 :: P11 :: nil) = 3) by (apply LP3P4P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P7P11mtmp : rk(P3 :: P4 :: P7 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P4P7P11eq HP3P4P7P11m3).
	try assert(HP11eq : rk(P11 :: nil) = 1) by (apply LP11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP11mtmp : rk(P11 :: nil) >= 1) by (solve_hyps_min HP11eq HP11m1).
	assert(Hincl : incl (P11 :: nil) (list_inter (P4 :: P11 :: nil) (P3 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P7 :: P11 :: nil) (P4 :: P11 :: P3 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P11 :: P3 :: P7 :: P11 :: nil) ((P4 :: P11 :: nil) ++ (P3 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P7P11mtmp;try rewrite HT2 in HP3P4P7P11mtmp.
	assert(HT := rule_2 (P4 :: P11 :: nil) (P3 :: P7 :: P11 :: nil) (P11 :: nil) 3 1 2 HP3P4P7P11mtmp HP11mtmp HP3P7P11Mtmp Hincl);apply HT.
}
try clear HP3P4P7P11M1. try clear HP3P4P7P11M2. try clear HP3P4P7P11M3. try clear HP3P4P7P11m4. try clear HP3P4P7P11m3. try clear HP3P4P7P11m2. try clear HP3P4P7P11m1. 

assert(HP4P11M : rk(P4 :: P11 ::  nil) <= 2) by (solve_hyps_max HP4P11eq HP4P11M2).
assert(HP4P11m : rk(P4 :: P11 ::  nil) >= 1) by (solve_hyps_min HP4P11eq HP4P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP3P4P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P3 :: P4 :: P11 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P11m2 : rk(P3 :: P4 :: P11 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P11m3 : rk(P3 :: P4 :: P11 :: nil) >= 3).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP3P4P6P11eq : rk(P3 :: P4 :: P6 :: P11 :: nil) = 3) by (apply LP3P4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P6P11mtmp : rk(P3 :: P4 :: P6 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P4P6P11eq HP3P4P6P11m3).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P3 :: P4 :: P11 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P6 :: P11 :: nil) (P3 :: P4 :: P11 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P11 :: P4 :: P6 :: P11 :: nil) ((P3 :: P4 :: P11 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P6P11mtmp;try rewrite HT2 in HP3P4P6P11mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P11 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: P11 :: nil) 3 2 2 HP3P4P6P11mtmp HP4P11mtmp HP4P6P11Mtmp Hincl);apply HT.
}
try clear HP3P4P6P11M1. try clear HP3P4P6P11M2. try clear HP3P4P6P11M3. try clear HP3P4P6P11m4. try clear HP3P4P6P11m3. try clear HP3P4P6P11m2. try clear HP3P4P6P11m1. 

assert(HP3P4P11M : rk(P3 :: P4 :: P11 ::  nil) <= 3) by (solve_hyps_max HP3P4P11eq HP3P4P11M3).
assert(HP3P4P11m : rk(P3 :: P4 :: P11 ::  nil) >= 1) by (solve_hyps_min HP3P4P11eq HP3P4P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP3P5P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P3 :: P5 :: P11 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P11m2 : rk(P1 :: P3 :: P5 :: P7 :: P11 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P11 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P11m3 : rk(P1 :: P3 :: P5 :: P7 :: P11 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P11 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P5P7P11M3 : rk(P1 :: P3 :: P5 :: P7 :: P11 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P11 :: nil) (P1 :: P5 :: P7 :: P3 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P7 :: P11 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P3 :: P7 :: P11 :: nil) (P7 :: nil) 2 2 1 HP1P5P7Mtmp HP3P7P11Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP7M1. try clear HP7M2. try clear HP7M3. try clear HP7m4. try clear HP7m3. try clear HP7m2. try clear HP7m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P7P11M3 : rk(P3 :: P5 :: P7 :: P11 :: nil) <= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P3 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P7 :: P11 :: nil) (P5 :: P3 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P3 :: P7 :: P11 :: nil) ((P5 :: nil) ++ (P3 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: nil) (P3 :: P7 :: P11 :: nil) (nil) 1 2 0 HP5Mtmp HP3P7P11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P7P11m2 : rk(P3 :: P5 :: P7 :: P11 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P11 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P11m3 : rk(P3 :: P5 :: P7 :: P11 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P5P7P11eq : rk(P1 :: P3 :: P5 :: P7 :: P11 :: nil) = 3) by (apply LP1P3P5P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P3P5P7P11mtmp : rk(P1 :: P3 :: P5 :: P7 :: P11 :: nil) >= 3) by (solve_hyps_min HP1P3P5P7P11eq HP1P3P5P7P11m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P11 :: nil) (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P11 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P5 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P11mtmp;try rewrite HT2 in HP1P3P5P7P11mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P11 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P3P5P7P11mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. try clear HP1P3P5P7P11M1. try clear HP1P3P5P7P11M2. try clear HP1P3P5P7P11M3. try clear HP1P3P5P7P11m4. try clear HP1P3P5P7P11m3. try clear HP1P3P5P7P11m2. try clear HP1P3P5P7P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P11m2 : rk(P3 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P11 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P5P11m3 : rk(P3 :: P5 :: P11 :: nil) >= 3).
{
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	try assert(HP3P5P7P11eq : rk(P3 :: P5 :: P7 :: P11 :: nil) = 3) by (apply LP3P5P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P5P7P11mtmp : rk(P3 :: P5 :: P7 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P5P7P11eq HP3P5P7P11m3).
	try assert(HP3P11eq : rk(P3 :: P11 :: nil) = 2) by (apply LP3P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P11mtmp : rk(P3 :: P11 :: nil) >= 2) by (solve_hyps_min HP3P11eq HP3P11m2).
	assert(Hincl : incl (P3 :: P11 :: nil) (list_inter (P3 :: P5 :: P11 :: nil) (P3 :: P7 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P7 :: P11 :: nil) (P3 :: P5 :: P11 :: P3 :: P7 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P11 :: P3 :: P7 :: P11 :: nil) ((P3 :: P5 :: P11 :: nil) ++ (P3 :: P7 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P7P11mtmp;try rewrite HT2 in HP3P5P7P11mtmp.
	assert(HT := rule_2 (P3 :: P5 :: P11 :: nil) (P3 :: P7 :: P11 :: nil) (P3 :: P11 :: nil) 3 2 2 HP3P5P7P11mtmp HP3P11mtmp HP3P7P11Mtmp Hincl);apply HT.
}
try clear HP3P7P11M1. try clear HP3P7P11M2. try clear HP3P7P11M3. try clear HP3P7P11m4. try clear HP3P7P11m3. try clear HP3P7P11m2. try clear HP3P7P11m1. try clear HP3P11M1. try clear HP3P11M2. try clear HP3P11M3. try clear HP3P11m4. try clear HP3P11m3. try clear HP3P11m2. try clear HP3P11m1. try clear HP3P5P7P11M1. try clear HP3P5P7P11M2. try clear HP3P5P7P11M3. try clear HP3P5P7P11m4. try clear HP3P5P7P11m3. try clear HP3P5P7P11m2. try clear HP3P5P7P11m1. 

assert(HP3P5P11M : rk(P3 :: P5 :: P11 ::  nil) <= 3) by (solve_hyps_max HP3P5P11eq HP3P5P11M3).
assert(HP3P5P11m : rk(P3 :: P5 :: P11 ::  nil) >= 1) by (solve_hyps_min HP3P5P11eq HP3P5P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP1P3P5P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P1 :: P3 :: P5 :: P11 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P4P6P11m2 : rk(P1 :: P3 :: P4 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P6P11M3 : rk(P1 :: P3 :: P4 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP1P3P4eq : rk(P1 :: P3 :: P4 :: nil) = 2) by (apply LP1P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P4Mtmp : rk(P1 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P3P4eq HP1P3P4M2).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P3 :: P4 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P6 :: P11 :: nil) (P1 :: P3 :: P4 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P4 :: P6 :: P11 :: nil) ((P1 :: P3 :: P4 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P3 :: P4 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: nil) 2 2 1 HP1P3P4Mtmp HP4P6P11Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P3P4M1. try clear HP1P3P4M2. try clear HP1P3P4M3. try clear HP1P3P4m4. try clear HP1P3P4m3. try clear HP1P3P4m2. try clear HP1P3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P6P11m3 : rk(P1 :: P3 :: P4 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP1P3P6mtmp : rk(P1 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P3P6eq HP1P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil) 3 3 HP1P3P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P6M1. try clear HP1P3P6M2. try clear HP1P3P6M3. try clear HP1P3P6m4. try clear HP1P3P6m3. try clear HP1P3P6m2. try clear HP1P3P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P4P5P6P11m2 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P4P5P6P11m3 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P4P5P6P11M3 : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P4P6P11eq : rk(P1 :: P3 :: P4 :: P6 :: P11 :: nil) = 3) by (apply LP1P3P4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P3P4P6P11Mtmp : rk(P1 :: P3 :: P4 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP1P3P4P6P11eq HP1P3P4P6P11M3).
	try assert(HP1P6eq : rk(P1 :: P6 :: nil) = 2) by (apply LP1P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hincl : incl (P1 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) (P1 :: P5 :: P6 :: P1 :: P3 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P1 :: P3 :: P4 :: P6 :: P11 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P1 :: P3 :: P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P1 :: P3 :: P4 :: P6 :: P11 :: nil) (P1 :: P6 :: nil) 2 3 2 HP1P5P6Mtmp HP1P3P4P6P11Mtmp HP1P6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P3P4P6P11M1. try clear HP1P3P4P6P11M2. try clear HP1P3P4P6P11M3. try clear HP1P3P4P6P11m4. try clear HP1P3P4P6P11m3. try clear HP1P3P4P6P11m2. try clear HP1P3P4P6P11m1. try clear HP1P6M1. try clear HP1P6M2. try clear HP1P6M3. try clear HP1P6m4. try clear HP1P6m3. try clear HP1P6m2. try clear HP1P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P11m2 : rk(P1 :: P3 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P11 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P11m3 : rk(P1 :: P3 :: P5 :: P11 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P11 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P3P5P11M3 : rk(P1 :: P3 :: P5 :: P11 :: nil) <= 3).
{
	assert(HP1P3P4P5P6P11Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP1P3P4P5P6P11eq HP1P3P4P5P6P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P11 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P5 :: P11 :: nil) (P1 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP1P3P4P5P6P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P4P5P6P11M1. try clear HP1P3P4P5P6P11M2. try clear HP1P3P4P5P6P11M3. try clear HP1P3P4P5P6P11m4. try clear HP1P3P4P5P6P11m3. try clear HP1P3P4P5P6P11m2. try clear HP1P3P4P5P6P11m1. 

assert(HP1P3P5P11M : rk(P1 :: P3 :: P5 :: P11 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P5P11m : rk(P1 :: P3 :: P5 :: P11 ::  nil) >= 1) by (solve_hyps_min HP1P3P5P11eq HP1P3P5P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP3P4P5P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P3 :: P4 :: P5 :: P11 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P6P11m2 : rk(P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P6P11m3 : rk(P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P4P5P6P11M3 : rk(P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP3P4P5P6eq : rk(P3 :: P4 :: P5 :: P6 :: nil) = 3) by (apply LP3P4P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P4P5P6Mtmp : rk(P3 :: P4 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP3P4P5P6eq HP3P4P5P6M3).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6eq : rk(P4 :: P6 :: nil) = 2) by (apply LP4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hincl : incl (P4 :: P6 :: nil) (list_inter (P3 :: P4 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P6 :: P11 :: nil) (P3 :: P4 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil) ((P3 :: P4 :: P5 :: P6 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P4 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: P6 :: nil) 3 2 2 HP3P4P5P6Mtmp HP4P6P11Mtmp HP4P6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P4P5P6M1. try clear HP3P4P5P6M2. try clear HP3P4P5P6M3. try clear HP3P4P5P6m4. try clear HP3P4P5P6m3. try clear HP3P4P5P6m2. try clear HP3P4P5P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P11m2 : rk(P3 :: P4 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P11 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P11m3 : rk(P3 :: P4 :: P5 :: P11 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P11 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5M1. try clear HP3P4P5M2. try clear HP3P4P5M3. try clear HP3P4P5m4. try clear HP3P4P5m3. try clear HP3P4P5m2. try clear HP3P4P5m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P4P5P11M3 : rk(P3 :: P4 :: P5 :: P11 :: nil) <= 3).
{
	assert(HP3P4P5P6P11Mtmp : rk(P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP3P4P5P6P11eq HP3P4P5P6P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P11 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P4 :: P5 :: P11 :: nil) (P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP3P4P5P6P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5P6P11M1. try clear HP3P4P5P6P11M2. try clear HP3P4P5P6P11M3. try clear HP3P4P5P6P11m4. try clear HP3P4P5P6P11m3. try clear HP3P4P5P6P11m2. try clear HP3P4P5P6P11m1. 

assert(HP3P4P5P11M : rk(P3 :: P4 :: P5 :: P11 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P4P5P11m : rk(P3 :: P4 :: P5 :: P11 ::  nil) >= 1) by (solve_hyps_min HP3P4P5P11eq HP3P4P5P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP4P6P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P4 :: P6 :: P11 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

assert(HP4P6P11M : rk(P4 :: P6 :: P11 ::  nil) <= 3) by (solve_hyps_max HP4P6P11eq HP4P6P11M3).
assert(HP4P6P11m : rk(P4 :: P6 :: P11 ::  nil) >= 1) by (solve_hyps_min HP4P6P11eq HP4P6P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP3P7P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P3 :: P7 :: P11 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

assert(HP3P7P11M : rk(P3 :: P7 :: P11 ::  nil) <= 3) by (solve_hyps_max HP3P7P11eq HP3P7P11M3).
assert(HP3P7P11m : rk(P3 :: P7 :: P11 ::  nil) >= 1) by (solve_hyps_min HP3P7P11eq HP3P7P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP2P9P10P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P2 :: P9 :: P10 :: P11 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P11m2 : rk(P2 :: P3 :: P4 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P6P11M3 : rk(P2 :: P3 :: P4 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P6 :: P11 :: nil) (P2 :: P3 :: P4 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P4 :: P6 :: P11 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: nil) 2 2 1 HP2P3P4Mtmp HP4P6P11Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P4M1. try clear HP2P3P4M2. try clear HP2P3P4M3. try clear HP2P3P4m4. try clear HP2P3P4m3. try clear HP2P3P4m2. try clear HP2P3P4m1. try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P11m3 : rk(P2 :: P3 :: P4 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P6P11m2 : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P6P11m3 : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P5P6P11M3 : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP2P3P5P6eq : rk(P2 :: P3 :: P5 :: P6 :: nil) = 3) by (apply LP2P3P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P5P6Mtmp : rk(P2 :: P3 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P3P5P6eq HP2P3P5P6M3).
	try assert(HP2P3P4P6P11eq : rk(P2 :: P3 :: P4 :: P6 :: P11 :: nil) = 3) by (apply LP2P3P4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P3P4P6P11Mtmp : rk(P2 :: P3 :: P4 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P3P4P6P11eq HP2P3P4P6P11M3).
	try assert(HP2P3P6eq : rk(P2 :: P3 :: P6 :: nil) = 3) by (apply LP2P3P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (list_inter (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P6 :: P2 :: P3 :: P4 :: P6 :: P11 :: nil) ((P2 :: P3 :: P5 :: P6 :: nil) ++ (P2 :: P3 :: P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P5 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P11 :: nil) (P2 :: P3 :: P6 :: nil) 3 3 3 HP2P3P5P6Mtmp HP2P3P4P6P11Mtmp HP2P3P6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P5P6M1. try clear HP2P3P5P6M2. try clear HP2P3P5P6M3. try clear HP2P3P5P6m4. try clear HP2P3P5P6m3. try clear HP2P3P5P6m2. try clear HP2P3P5P6m1. try clear HP2P3P4P6P11M1. try clear HP2P3P4P6P11M2. try clear HP2P3P4P6P11M3. try clear HP2P3P4P6P11m4. try clear HP2P3P4P6P11m3. try clear HP2P3P4P6P11m2. try clear HP2P3P4P6P11m1. try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P11m2 : rk(P2 :: P3 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P11 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P11m3 : rk(P2 :: P3 :: P5 :: P11 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P11 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P3P5P11M3 : rk(P2 :: P3 :: P5 :: P11 :: nil) <= 3).
{
	assert(HP2P3P4P5P6P11Mtmp : rk(P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P3P4P5P6P11eq HP2P3P4P5P6P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P11 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P3 :: P5 :: P11 :: nil) (P2 :: P3 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP2P3P4P5P6P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P4P5P6P11M1. try clear HP2P3P4P5P6P11M2. try clear HP2P3P4P5P6P11M3. try clear HP2P3P4P5P6P11m4. try clear HP2P3P4P5P6P11m3. try clear HP2P3P4P5P6P11m2. try clear HP2P3P4P5P6P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P9P11m2 : rk(P3 :: P5 :: P9 :: P11 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P9 :: P11 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P9P11M3 : rk(P3 :: P5 :: P9 :: P11 :: nil) <= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP11eq : rk(P11 :: nil) = 1) by (apply LP11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP11Mtmp : rk(P11 :: nil) <= 1) by (solve_hyps_max HP11eq HP11M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: P5 :: P9 :: nil) (P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P9 :: P11 :: nil) (P3 :: P5 :: P9 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P11 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P5 :: P9 :: nil) (P11 :: nil) (nil) 2 1 0 HP3P5P9Mtmp HP11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P5P9M1. try clear HP3P5P9M2. try clear HP3P5P9M3. try clear HP3P5P9m4. try clear HP3P5P9m3. try clear HP3P5P9m2. try clear HP3P5P9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P5P9P11m3 : rk(P3 :: P5 :: P9 :: P11 :: nil) >= 3).
{
	try assert(HP3P5P11eq : rk(P3 :: P5 :: P11 :: nil) = 3) by (apply LP3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P9P11m2 : rk(P2 :: P3 :: P5 :: P9 :: P11 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P9P11m3 : rk(P2 :: P3 :: P5 :: P9 :: P11 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P5P9P11M3 : rk(P2 :: P3 :: P5 :: P9 :: P11 :: nil) <= 3).
{
	try assert(HP2P3P5P11eq : rk(P2 :: P3 :: P5 :: P11 :: nil) = 3) by (apply LP2P3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P3P5P11Mtmp : rk(P2 :: P3 :: P5 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P3P5P11eq HP2P3P5P11M3).
	try assert(HP3P5P9P11eq : rk(P3 :: P5 :: P9 :: P11 :: nil) = 3) by (apply LP3P5P9P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P5P9P11Mtmp : rk(P3 :: P5 :: P9 :: P11 :: nil) <= 3) by (solve_hyps_max HP3P5P9P11eq HP3P5P9P11M3).
	try assert(HP3P5P11eq : rk(P3 :: P5 :: P11 :: nil) = 3) by (apply LP3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P5P11mtmp : rk(P3 :: P5 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P5P11eq HP3P5P11m3).
	assert(Hincl : incl (P3 :: P5 :: P11 :: nil) (list_inter (P2 :: P3 :: P5 :: P11 :: nil) (P3 :: P5 :: P9 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P9 :: P11 :: nil) (P2 :: P3 :: P5 :: P11 :: P3 :: P5 :: P9 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P11 :: P3 :: P5 :: P9 :: P11 :: nil) ((P2 :: P3 :: P5 :: P11 :: nil) ++ (P3 :: P5 :: P9 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P5 :: P11 :: nil) (P3 :: P5 :: P9 :: P11 :: nil) (P3 :: P5 :: P11 :: nil) 3 3 3 HP2P3P5P11Mtmp HP3P5P9P11Mtmp HP3P5P11mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P5P11M1. try clear HP2P3P5P11M2. try clear HP2P3P5P11M3. try clear HP2P3P5P11m4. try clear HP2P3P5P11m3. try clear HP2P3P5P11m2. try clear HP2P3P5P11m1. try clear HP3P5P9P11M1. try clear HP3P5P9P11M2. try clear HP3P5P9P11M3. try clear HP3P5P9P11m4. try clear HP3P5P9P11m3. try clear HP3P5P9P11m2. try clear HP3P5P9P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P9P11m2 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P9P11m3 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5M1. try clear HP2P3P5M2. try clear HP2P3P5M3. try clear HP2P3P5m4. try clear HP2P3P5m3. try clear HP2P3P5m2. try clear HP2P3P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P5P9P11M3 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) <= 3).
{
	try assert(HP3P4P5P11eq : rk(P3 :: P4 :: P5 :: P11 :: nil) = 3) by (apply LP3P4P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P5P11Mtmp : rk(P3 :: P4 :: P5 :: P11 :: nil) <= 3) by (solve_hyps_max HP3P4P5P11eq HP3P4P5P11M3).
	try assert(HP2P3P5P9P11eq : rk(P2 :: P3 :: P5 :: P9 :: P11 :: nil) = 3) by (apply LP2P3P5P9P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P3P5P9P11Mtmp : rk(P2 :: P3 :: P5 :: P9 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P3P5P9P11eq HP2P3P5P9P11M3).
	try assert(HP3P5P11eq : rk(P3 :: P5 :: P11 :: nil) = 3) by (apply LP3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P5P11mtmp : rk(P3 :: P5 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P5P11eq HP3P5P11m3).
	assert(Hincl : incl (P3 :: P5 :: P11 :: nil) (list_inter (P3 :: P4 :: P5 :: P11 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) (P3 :: P4 :: P5 :: P11 :: P2 :: P3 :: P5 :: P9 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P11 :: P2 :: P3 :: P5 :: P9 :: P11 :: nil) ((P3 :: P4 :: P5 :: P11 :: nil) ++ (P2 :: P3 :: P5 :: P9 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P4 :: P5 :: P11 :: nil) (P2 :: P3 :: P5 :: P9 :: P11 :: nil) (P3 :: P5 :: P11 :: nil) 3 3 3 HP3P4P5P11Mtmp HP2P3P5P9P11Mtmp HP3P5P11mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P4P5P11M1. try clear HP3P4P5P11M2. try clear HP3P4P5P11M3. try clear HP3P4P5P11m4. try clear HP3P4P5P11m3. try clear HP3P4P5P11m2. try clear HP3P4P5P11m1. try clear HP2P3P5P9P11M1. try clear HP2P3P5P9P11M2. try clear HP2P3P5P9P11M3. try clear HP2P3P5P9P11m4. try clear HP2P3P5P9P11m3. try clear HP2P3P5P9P11m2. try clear HP2P3P5P9P11m1. try clear HP3P5P11M1. try clear HP3P5P11M2. try clear HP3P5P11M3. try clear HP3P5P11m4. try clear HP3P5P11m3. try clear HP3P5P11m2. try clear HP3P5P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P9P11m2 : rk(P2 :: P4 :: P9 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P9 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P9P11m3 : rk(P2 :: P4 :: P9 :: P11 :: nil) >= 3).
{
	assert(HP2P4P9mtmp : rk(P2 :: P4 :: P9 :: nil) >= 3) by (solve_hyps_min HP2P4P9eq HP2P4P9m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P9 :: nil) (P2 :: P4 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P9 :: nil) (P2 :: P4 :: P9 :: P11 :: nil) 3 3 HP2P4P9mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P9M1. try clear HP2P4P9M2. try clear HP2P4P9M3. try clear HP2P4P9m4. try clear HP2P4P9m3. try clear HP2P4P9m2. try clear HP2P4P9m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P4P9P11M3 : rk(P2 :: P4 :: P9 :: P11 :: nil) <= 3).
{
	assert(HP2P3P4P5P9P11Mtmp : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P3P4P5P9P11eq HP2P3P4P5P9P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P9 :: P11 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P4 :: P9 :: P11 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P11 :: nil) 3 3 HP2P3P4P5P9P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P4P5P9P11M1. try clear HP2P3P4P5P9P11M2. try clear HP2P3P4P5P9P11M3. try clear HP2P3P4P5P9P11m4. try clear HP2P3P4P5P9P11m3. try clear HP2P3P4P5P9P11m2. try clear HP2P3P4P5P9P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P6P11m2 : rk(P2 :: P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P6P11m3 : rk(P2 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P5P6P11M3 : rk(P2 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP2P4P5P6eq : rk(P2 :: P4 :: P5 :: P6 :: nil) = 3) by (apply LP2P4P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P4P5P6Mtmp : rk(P2 :: P4 :: P5 :: P6 :: nil) <= 3) by (solve_hyps_max HP2P4P5P6eq HP2P4P5P6M3).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6eq : rk(P4 :: P6 :: nil) = 2) by (apply LP4P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hincl : incl (P4 :: P6 :: nil) (list_inter (P2 :: P4 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P6 :: P11 :: nil) (P2 :: P4 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil) ((P2 :: P4 :: P5 :: P6 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P4 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: P6 :: nil) 3 2 2 HP2P4P5P6Mtmp HP4P6P11Mtmp HP4P6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P4P5P6M1. try clear HP2P4P5P6M2. try clear HP2P4P5P6M3. try clear HP2P4P5P6m4. try clear HP2P4P5P6m3. try clear HP2P4P5P6m2. try clear HP2P4P5P6m1. try clear HP4P6M1. try clear HP4P6M2. try clear HP4P6M3. try clear HP4P6m4. try clear HP4P6m3. try clear HP4P6m2. try clear HP4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P11m2 : rk(P2 :: P4 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P11m3 : rk(P2 :: P4 :: P5 :: P11 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P11 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P4P5P11M3 : rk(P2 :: P4 :: P5 :: P11 :: nil) <= 3).
{
	assert(HP2P4P5P6P11Mtmp : rk(P2 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P4P5P6P11eq HP2P4P5P6P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P11 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P4 :: P5 :: P11 :: nil) (P2 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP2P4P5P6P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5P6P11M1. try clear HP2P4P5P6P11M2. try clear HP2P4P5P6P11M3. try clear HP2P4P5P6P11m4. try clear HP2P4P5P6P11m3. try clear HP2P4P5P6P11m2. try clear HP2P4P5P6P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P6P11m2 : rk(P1 :: P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4M1. try clear HP1P4M2. try clear HP1P4M3. try clear HP1P4m4. try clear HP1P4m3. try clear HP1P4m2. try clear HP1P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P6P11m3 : rk(P1 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P11 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5M1. try clear HP1P4P5M2. try clear HP1P4P5M3. try clear HP1P4P5m4. try clear HP1P4P5m3. try clear HP1P4P5m2. try clear HP1P4P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P4P5P6P11M3 : rk(P1 :: P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P11 :: nil) (P1 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P4 :: P6 :: P11 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P4 :: P6 :: P11 :: nil) (P6 :: nil) 2 2 1 HP1P5P6Mtmp HP4P6P11Mtmp HP6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P6P11M3 : rk(P4 :: P5 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P6 :: P11 :: nil) (P5 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P4 :: P6 :: P11 :: nil) ((P5 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: nil) (P4 :: P6 :: P11 :: nil) (nil) 1 2 0 HP5Mtmp HP4P6P11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP5M1. try clear HP5M2. try clear HP5M3. try clear HP5m4. try clear HP5m3. try clear HP5m2. try clear HP5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P6P11m2 : rk(P4 :: P5 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P11 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P6P11m3 : rk(P4 :: P5 :: P6 :: P11 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P4P5P6P11eq : rk(P1 :: P4 :: P5 :: P6 :: P11 :: nil) = 3) by (apply LP1P4P5P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P4P5P6P11mtmp : rk(P1 :: P4 :: P5 :: P6 :: P11 :: nil) >= 3) by (solve_hyps_min HP1P4P5P6P11eq HP1P4P5P6P11m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P11 :: nil) (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P11 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P4 :: P5 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P11mtmp;try rewrite HT2 in HP1P4P5P6P11mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P11 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P4P5P6P11mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. try clear HP1P4P5P6P11M1. try clear HP1P4P5P6P11M2. try clear HP1P4P5P6P11M3. try clear HP1P4P5P6P11m4. try clear HP1P4P5P6P11m3. try clear HP1P4P5P6P11m2. try clear HP1P4P5P6P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P11m2 : rk(P4 :: P5 :: P11 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P11 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P5P11m3 : rk(P4 :: P5 :: P11 :: nil) >= 3).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P5P6P11eq : rk(P4 :: P5 :: P6 :: P11 :: nil) = 3) by (apply LP4P5P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P5P6P11mtmp : rk(P4 :: P5 :: P6 :: P11 :: nil) >= 3) by (solve_hyps_min HP4P5P6P11eq HP4P5P6P11m3).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P4 :: P5 :: P11 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P6 :: P11 :: nil) (P4 :: P5 :: P11 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P11 :: P4 :: P6 :: P11 :: nil) ((P4 :: P5 :: P11 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P6P11mtmp;try rewrite HT2 in HP4P5P6P11mtmp.
	assert(HT := rule_2 (P4 :: P5 :: P11 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: P11 :: nil) 3 2 2 HP4P5P6P11mtmp HP4P11mtmp HP4P6P11Mtmp Hincl);apply HT.
}
try clear HP4P5P6P11M1. try clear HP4P5P6P11M2. try clear HP4P5P6P11M3. try clear HP4P5P6P11m4. try clear HP4P5P6P11m3. try clear HP4P5P6P11m2. try clear HP4P5P6P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P10P11m2 : rk(P4 :: P5 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P11 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5M1. try clear HP4P5M2. try clear HP4P5M3. try clear HP4P5m4. try clear HP4P5m3. try clear HP4P5m2. try clear HP4P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P10P11M3 : rk(P4 :: P5 :: P10 :: P11 :: nil) <= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP11eq : rk(P11 :: nil) = 1) by (apply LP11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP11Mtmp : rk(P11 :: nil) <= 1) by (solve_hyps_max HP11eq HP11M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: P5 :: P10 :: nil) (P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P10 :: P11 :: nil) (P4 :: P5 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P11 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P5 :: P10 :: nil) (P11 :: nil) (nil) 2 1 0 HP4P5P10Mtmp HP11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4P5P10M1. try clear HP4P5P10M2. try clear HP4P5P10M3. try clear HP4P5P10m4. try clear HP4P5P10m3. try clear HP4P5P10m2. try clear HP4P5P10m1. try clear HP11M1. try clear HP11M2. try clear HP11M3. try clear HP11m4. try clear HP11m3. try clear HP11m2. try clear HP11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P5P10P11m3 : rk(P4 :: P5 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP4P5P11mtmp : rk(P4 :: P5 :: P11 :: nil) >= 3) by (solve_hyps_min HP4P5P11eq HP4P5P11m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P11 :: nil) (P4 :: P5 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P11 :: nil) (P4 :: P5 :: P10 :: P11 :: nil) 3 3 HP4P5P11mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10P11m2 : rk(P2 :: P4 :: P5 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10P11m3 : rk(P2 :: P4 :: P5 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P5P10P11M3 : rk(P2 :: P4 :: P5 :: P10 :: P11 :: nil) <= 3).
{
	try assert(HP2P4P5P11eq : rk(P2 :: P4 :: P5 :: P11 :: nil) = 3) by (apply LP2P4P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P4P5P11Mtmp : rk(P2 :: P4 :: P5 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P4P5P11eq HP2P4P5P11M3).
	try assert(HP4P5P10P11eq : rk(P4 :: P5 :: P10 :: P11 :: nil) = 3) by (apply LP4P5P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P5P10P11Mtmp : rk(P4 :: P5 :: P10 :: P11 :: nil) <= 3) by (solve_hyps_max HP4P5P10P11eq HP4P5P10P11M3).
	try assert(HP4P5P11eq : rk(P4 :: P5 :: P11 :: nil) = 3) by (apply LP4P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P5P11mtmp : rk(P4 :: P5 :: P11 :: nil) >= 3) by (solve_hyps_min HP4P5P11eq HP4P5P11m3).
	assert(Hincl : incl (P4 :: P5 :: P11 :: nil) (list_inter (P2 :: P4 :: P5 :: P11 :: nil) (P4 :: P5 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P10 :: P11 :: nil) (P2 :: P4 :: P5 :: P11 :: P4 :: P5 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P11 :: P4 :: P5 :: P10 :: P11 :: nil) ((P2 :: P4 :: P5 :: P11 :: nil) ++ (P4 :: P5 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P4 :: P5 :: P11 :: nil) (P4 :: P5 :: P10 :: P11 :: nil) (P4 :: P5 :: P11 :: nil) 3 3 3 HP2P4P5P11Mtmp HP4P5P10P11Mtmp HP4P5P11mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P4P5P11M1. try clear HP2P4P5P11M2. try clear HP2P4P5P11M3. try clear HP2P4P5P11m4. try clear HP2P4P5P11m3. try clear HP2P4P5P11m2. try clear HP2P4P5P11m1. try clear HP4P5P10P11M1. try clear HP4P5P10P11M2. try clear HP4P5P10P11M3. try clear HP4P5P10P11m4. try clear HP4P5P10P11m3. try clear HP4P5P10P11m2. try clear HP4P5P10P11m1. try clear HP4P5P11M1. try clear HP4P5P11M2. try clear HP4P5P11M3. try clear HP4P5P11m4. try clear HP4P5P11m3. try clear HP4P5P11m2. try clear HP4P5P11m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P6P11M3 : rk(P2 :: P4 :: P6 :: P11 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P11 :: nil) (P2 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P6 :: P11 :: nil) ((P2 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P4 :: P6 :: P11 :: nil) (nil) 1 2 0 HP2Mtmp HP4P6P11Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P11m2 : rk(P2 :: P4 :: P6 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P11m3 : rk(P2 :: P4 :: P6 :: P11 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P11 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6M1. try clear HP2P4P6M2. try clear HP2P4P6M3. try clear HP2P4P6m4. try clear HP2P4P6m3. try clear HP2P4P6m2. try clear HP2P4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P11m2 : rk(P2 :: P4 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P11m3 : rk(P2 :: P4 :: P11 :: nil) >= 3).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP2P4P6P11eq : rk(P2 :: P4 :: P6 :: P11 :: nil) = 3) by (apply LP2P4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P4P6P11mtmp : rk(P2 :: P4 :: P6 :: P11 :: nil) >= 3) by (solve_hyps_min HP2P4P6P11eq HP2P4P6P11m3).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P2 :: P4 :: P11 :: nil) (P4 :: P6 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P11 :: nil) (P2 :: P4 :: P11 :: P4 :: P6 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P11 :: P4 :: P6 :: P11 :: nil) ((P2 :: P4 :: P11 :: nil) ++ (P4 :: P6 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P11mtmp;try rewrite HT2 in HP2P4P6P11mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P11 :: nil) (P4 :: P6 :: P11 :: nil) (P4 :: P11 :: nil) 3 2 2 HP2P4P6P11mtmp HP4P11mtmp HP4P6P11Mtmp Hincl);apply HT.
}
try clear HP4P6P11M1. try clear HP4P6P11M2. try clear HP4P6P11M3. try clear HP4P6P11m4. try clear HP4P6P11m3. try clear HP4P6P11m2. try clear HP4P6P11m1. try clear HP4P11M1. try clear HP4P11M2. try clear HP4P11M3. try clear HP4P11m4. try clear HP4P11m3. try clear HP4P11m2. try clear HP4P11m1. try clear HP2P4P6P11M1. try clear HP2P4P6P11M2. try clear HP2P4P6P11M3. try clear HP2P4P6P11m4. try clear HP2P4P6P11m3. try clear HP2P4P6P11m2. try clear HP2P4P6P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P9P10P11m2 : rk(P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P9P10P11m3 : rk(P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5M1. try clear HP2P4P5M2. try clear HP2P4P5M3. try clear HP2P4P5m4. try clear HP2P4P5m3. try clear HP2P4P5m2. try clear HP2P4P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P4P5P9P10P11M3 : rk(P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) <= 3).
{
	try assert(HP2P4P9P11eq : rk(P2 :: P4 :: P9 :: P11 :: nil) = 3) by (apply LP2P4P9P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P4P9P11Mtmp : rk(P2 :: P4 :: P9 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P4P9P11eq HP2P4P9P11M3).
	try assert(HP2P4P5P10P11eq : rk(P2 :: P4 :: P5 :: P10 :: P11 :: nil) = 3) by (apply LP2P4P5P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P4P5P10P11Mtmp : rk(P2 :: P4 :: P5 :: P10 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P4P5P10P11eq HP2P4P5P10P11M3).
	try assert(HP2P4P11eq : rk(P2 :: P4 :: P11 :: nil) = 3) by (apply LP2P4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P4P11mtmp : rk(P2 :: P4 :: P11 :: nil) >= 3) by (solve_hyps_min HP2P4P11eq HP2P4P11m3).
	assert(Hincl : incl (P2 :: P4 :: P11 :: nil) (list_inter (P2 :: P4 :: P9 :: P11 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) (P2 :: P4 :: P9 :: P11 :: P2 :: P4 :: P5 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P9 :: P11 :: P2 :: P4 :: P5 :: P10 :: P11 :: nil) ((P2 :: P4 :: P9 :: P11 :: nil) ++ (P2 :: P4 :: P5 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P4 :: P9 :: P11 :: nil) (P2 :: P4 :: P5 :: P10 :: P11 :: nil) (P2 :: P4 :: P11 :: nil) 3 3 3 HP2P4P9P11Mtmp HP2P4P5P10P11Mtmp HP2P4P11mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P4P9P11M1. try clear HP2P4P9P11M2. try clear HP2P4P9P11M3. try clear HP2P4P9P11m4. try clear HP2P4P9P11m3. try clear HP2P4P9P11m2. try clear HP2P4P9P11m1. try clear HP2P4P5P10P11M1. try clear HP2P4P5P10P11M2. try clear HP2P4P5P10P11M3. try clear HP2P4P5P10P11m4. try clear HP2P4P5P10P11m3. try clear HP2P4P5P10P11m2. try clear HP2P4P5P10P11m1. try clear HP2P4P11M1. try clear HP2P4P11M2. try clear HP2P4P11M3. try clear HP2P4P11m4. try clear HP2P4P11m3. try clear HP2P4P11m2. try clear HP2P4P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P9P10P11m2 : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P9P10P11m3 : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P7P9P10P11m2 : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P9P10P11m3 : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P9P10P11eq : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) = 3) by (apply LP1P2P6P7P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P2P6P7P9P10P11mtmp : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P9P10P11eq HP1P2P6P7P9P10P11m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P9P10P11mtmp;try rewrite HT2 in HP1P2P6P7P9P10P11mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P9P10P11mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}
try clear HP1P2P6P7P9P10P11M1. try clear HP1P2P6P7P9P10P11M2. try clear HP1P2P6P7P9P10P11M3. try clear HP1P2P6P7P9P10P11m4. try clear HP1P2P6P7P9P10P11m3. try clear HP1P2P6P7P9P10P11m2. try clear HP1P2P6P7P9P10P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P9P10P11m2 : rk(P2 :: P7 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P9P10P11m3 : rk(P2 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P6P7P9P10P11eq : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) = 3) by (apply LP2P6P7P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P6P7P9P10P11mtmp : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3) by (solve_hyps_min HP2P6P7P9P10P11eq HP2P6P7P9P10P11m3).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: nil) (P2 :: P6 :: P9 :: P2 :: P7 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P7 :: P9 :: P10 :: P11 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P7 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P9P10P11mtmp;try rewrite HT2 in HP2P6P7P9P10P11mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: nil) (P2 :: P9 :: nil) 3 2 2 HP2P6P7P9P10P11mtmp HP2P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P7P9P10P11M1. try clear HP2P6P7P9P10P11M2. try clear HP2P6P7P9P10P11M3. try clear HP2P6P7P9P10P11m4. try clear HP2P6P7P9P10P11m3. try clear HP2P6P7P9P10P11m2. try clear HP2P6P7P9P10P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P9P10P11m2 : rk(P2 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P9 :: nil) (P2 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P9 :: nil) (P2 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P9mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P9P10P11m3 : rk(P2 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP2P7P9P10P11eq : rk(P2 :: P7 :: P9 :: P10 :: P11 :: nil) = 3) by (apply LP2P7P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P7P9P10P11mtmp : rk(P2 :: P7 :: P9 :: P10 :: P11 :: nil) >= 3) by (solve_hyps_min HP2P7P9P10P11eq HP2P7P9P10P11m3).
	try assert(HP2P10eq : rk(P2 :: P10 :: nil) = 2) by (apply LP2P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hincl : incl (P2 :: P10 :: nil) (list_inter (P2 :: P7 :: P10 :: nil) (P2 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P9 :: P10 :: P11 :: nil) (P2 :: P7 :: P10 :: P2 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P2 :: P9 :: P10 :: P11 :: nil) ((P2 :: P7 :: P10 :: nil) ++ (P2 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P9P10P11mtmp;try rewrite HT2 in HP2P7P9P10P11mtmp.
	assert(HT := rule_4 (P2 :: P7 :: P10 :: nil) (P2 :: P9 :: P10 :: P11 :: nil) (P2 :: P10 :: nil) 3 2 2 HP2P7P9P10P11mtmp HP2P10mtmp HP2P7P10Mtmp Hincl); apply HT.
}
try clear HP2P7P9P10P11M1. try clear HP2P7P9P10P11M2. try clear HP2P7P9P10P11M3. try clear HP2P7P9P10P11m4. try clear HP2P7P9P10P11m3. try clear HP2P7P9P10P11m2. try clear HP2P7P9P10P11m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P9P10P11M3 : rk(P2 :: P9 :: P10 :: P11 :: nil) <= 3).
{
	assert(HP2P4P5P9P10P11Mtmp : rk(P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P4P5P9P10P11eq HP2P4P5P9P10P11M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P9 :: P10 :: P11 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P9 :: P10 :: P11 :: nil) (P2 :: P4 :: P5 :: P9 :: P10 :: P11 :: nil) 3 3 HP2P4P5P9P10P11Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5P9P10P11M1. try clear HP2P4P5P9P10P11M2. try clear HP2P4P5P9P10P11M3. try clear HP2P4P5P9P10P11m4. try clear HP2P4P5P9P10P11m3. try clear HP2P4P5P9P10P11m2. try clear HP2P4P5P9P10P11m1. 

assert(HP2P9P10P11M : rk(P2 :: P9 :: P10 :: P11 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P9P10P11m : rk(P2 :: P9 :: P10 :: P11 ::  nil) >= 1) by (solve_hyps_min HP2P9P10P11eq HP2P9P10P11m1).
intuition.
Qed.

(* dans la couche 3 *)
Lemma LP2P8P9P10P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P2 :: P8 :: P9 :: P10 :: P11 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P7P8P9P10P11m2 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P7P8P9P10P11m3 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P9P10P11m4 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P8M1. try clear HP1P2P6P8M2. try clear HP1P2P6P8M3. try clear HP1P2P6P8m4. try clear HP1P2P6P8m3. try clear HP1P2P6P8m2. try clear HP1P2P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P6P7P8P9P10P11m2 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P6M1. try clear HP2P6M2. try clear HP2P6M3. try clear HP2P6m4. try clear HP2P6m3. try clear HP2P6m2. try clear HP2P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P9P10P11m3 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P8P9P10P11eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) = 3) by (apply LP1P2P6P7P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P2P6P7P8P9P10P11mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P8P9P10P11eq HP1P2P6P7P8P9P10P11m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P9P10P11mtmp;try rewrite HT2 in HP1P2P6P7P8P9P10P11mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P8P9P10P11mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}
try clear HP1P6P7M1. try clear HP1P6P7M2. try clear HP1P6P7M3. try clear HP1P6P7m4. try clear HP1P6P7m3. try clear HP1P6P7m2. try clear HP1P6P7m1. try clear HP6P7M1. try clear HP6P7M2. try clear HP6P7M3. try clear HP6P7m4. try clear HP6P7m3. try clear HP6P7m2. try clear HP6P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P9P10P11m4 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4).
{
	try assert(HP1P6P7P8eq : rk(P1 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7P8Mtmp : rk(P1 :: P6 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P6P7P8eq HP1P6P7P8M3).
	try assert(HP1P2P6P7P8P9P10P11eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) = 4) by (apply LP1P2P6P7P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P2P6P7P8P9P10P11mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P8P9P10P11eq HP1P2P6P7P8P9P10P11m4).
	try assert(HP6P7P8eq : rk(P6 :: P7 :: P8 :: nil) = 3) by (apply LP6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7P8mtmp : rk(P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP6P7P8eq HP6P7P8m3).
	assert(Hincl : incl (P6 :: P7 :: P8 :: nil) (list_inter (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) ((P1 :: P6 :: P7 :: P8 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P9P10P11mtmp;try rewrite HT2 in HP1P2P6P7P8P9P10P11mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P6 :: P7 :: P8 :: nil) 4 3 3 HP1P2P6P7P8P9P10P11mtmp HP6P7P8mtmp HP1P6P7P8Mtmp Hincl); apply HT.
}
try clear HP1P6P7P8M1. try clear HP1P6P7P8M2. try clear HP1P6P7P8M3. try clear HP1P6P7P8m4. try clear HP1P6P7P8m3. try clear HP1P6P7P8m2. try clear HP1P6P7P8m1. try clear HP6P7P8M1. try clear HP6P7P8M2. try clear HP6P7P8M3. try clear HP6P7P8m4. try clear HP6P7P8m3. try clear HP6P7P8m2. try clear HP6P7P8m1. try clear HP1P2P6P7P8P9P10P11M1. try clear HP1P2P6P7P8P9P10P11M2. try clear HP1P2P6P7P8P9P10P11M3. try clear HP1P2P6P7P8P9P10P11m4. try clear HP1P2P6P7P8P9P10P11m3. try clear HP1P2P6P7P8P9P10P11m2. try clear HP1P2P6P7P8P9P10P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P7P8P9P10P11m2 : rk(P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7M1. try clear HP2P7M2. try clear HP2P7M3. try clear HP2P7m4. try clear HP2P7m3. try clear HP2P7m2. try clear HP2P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P9P10P11m3 : rk(P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP2P7P8mtmp : rk(P2 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P7P8eq HP2P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) 3 3 HP2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7P8M1. try clear HP2P7P8M2. try clear HP2P7P8M3. try clear HP2P7P8m4. try clear HP2P7P8m3. try clear HP2P7P8m2. try clear HP2P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P8P9P10P11m4 : rk(P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P6P7P8P9P10P11eq : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) = 4) by (apply LP2P6P7P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P6P7P8P9P10P11mtmp : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4) by (solve_hyps_min HP2P6P7P8P9P10P11eq HP2P6P7P8P9P10P11m4).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P6 :: P9 :: P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P8P9P10P11mtmp;try rewrite HT2 in HP2P6P7P8P9P10P11mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P9 :: nil) 4 2 2 HP2P6P7P8P9P10P11mtmp HP2P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P9M1. try clear HP2P6P9M2. try clear HP2P6P9M3. try clear HP2P6P9m4. try clear HP2P6P9m3. try clear HP2P6P9m2. try clear HP2P6P9m1. try clear HP2P6P7P8P9P10P11M1. try clear HP2P6P7P8P9P10P11M2. try clear HP2P6P7P8P9P10P11M3. try clear HP2P6P7P8P9P10P11m4. try clear HP2P6P7P8P9P10P11m3. try clear HP2P6P7P8P9P10P11m2. try clear HP2P6P7P8P9P10P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P9P10P11m2 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P10P11m3 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P10P11m4 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P8P9P10P11m2 : rk(P2 :: P8 :: P9 :: P10 :: P11 :: nil) >= 2).
{
	assert(HP2P8mtmp : rk(P2 :: P8 :: nil) >= 2) by (solve_hyps_min HP2P8eq HP2P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P8 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P8 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil) 2 2 HP2P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P8M1. try clear HP2P8M2. try clear HP2P8M3. try clear HP2P8m4. try clear HP2P8m3. try clear HP2P8m2. try clear HP2P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P8P9P10P11m3 : rk(P2 :: P8 :: P9 :: P10 :: P11 :: nil) >= 3).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P10P11eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) = 4) by (apply LP1P2P5P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P2P5P8P9P10P11mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P10P11eq HP1P2P5P8P9P10P11m4).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: nil) (P1 :: P2 :: P5 :: P9 :: P2 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P2 :: P8 :: P9 :: P10 :: P11 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P2 :: P8 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P10P11mtmp;try rewrite HT2 in HP1P2P5P8P9P10P11mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P9 :: nil) 4 2 3 HP1P2P5P8P9P10P11mtmp HP2P9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P5P9M1. try clear HP1P2P5P9M2. try clear HP1P2P5P9M3. try clear HP1P2P5P9m4. try clear HP1P2P5P9m3. try clear HP1P2P5P9m2. try clear HP1P2P5P9m1. try clear HP2P9M1. try clear HP2P9M2. try clear HP2P9M3. try clear HP2P9m4. try clear HP2P9m3. try clear HP2P9m2. try clear HP2P9m1. try clear HP1P2P5P8P9P10P11M1. try clear HP1P2P5P8P9P10P11M2. try clear HP1P2P5P8P9P10P11M3. try clear HP1P2P5P8P9P10P11m4. try clear HP1P2P5P8P9P10P11m3. try clear HP1P2P5P8P9P10P11m2. try clear HP1P2P5P8P9P10P11m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P8P9P10P11m4 : rk(P2 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP2P7P8P9P10P11eq : rk(P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) = 4) by (apply LP2P7P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P7P8P9P10P11mtmp : rk(P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4) by (solve_hyps_min HP2P7P8P9P10P11eq HP2P7P8P9P10P11m4).
	try assert(HP2P10eq : rk(P2 :: P10 :: nil) = 2) by (apply LP2P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hincl : incl (P2 :: P10 :: nil) (list_inter (P2 :: P7 :: P10 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P7 :: P10 :: P2 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P2 :: P8 :: P9 :: P10 :: P11 :: nil) ((P2 :: P7 :: P10 :: nil) ++ (P2 :: P8 :: P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P8P9P10P11mtmp;try rewrite HT2 in HP2P7P8P9P10P11mtmp.
	assert(HT := rule_4 (P2 :: P7 :: P10 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P10 :: nil) 4 2 2 HP2P7P8P9P10P11mtmp HP2P10mtmp HP2P7P10Mtmp Hincl); apply HT.
}
try clear HP2P7P10M1. try clear HP2P7P10M2. try clear HP2P7P10M3. try clear HP2P7P10m4. try clear HP2P7P10m3. try clear HP2P7P10m2. try clear HP2P7P10m1. try clear HP2P10M1. try clear HP2P10M2. try clear HP2P10M3. try clear HP2P10m4. try clear HP2P10m3. try clear HP2P10m2. try clear HP2P10m1. try clear HP2P7P8P9P10P11M1. try clear HP2P7P8P9P10P11M2. try clear HP2P7P8P9P10P11M3. try clear HP2P7P8P9P10P11m4. try clear HP2P7P8P9P10P11m3. try clear HP2P7P8P9P10P11m2. try clear HP2P7P8P9P10P11m1. 

assert(HP2P8P9P10P11M : rk(P2 :: P8 :: P9 :: P10 :: P11 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P8P9P10P11m : rk(P2 :: P8 :: P9 :: P10 :: P11 ::  nil) >= 1) by (solve_hyps_min HP2P8P9P10P11eq HP2P8P9P10P11m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P12 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

assert(HP12M : rk(P12 ::  nil) <= 1) by (solve_hyps_max HP12eq HP12M1).
assert(HP12m : rk(P12 ::  nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P2P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P2 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P12m2 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P12m3 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P12m4 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P8P9P12m2 : rk(P1 :: P2 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P8P9P12m3 : rk(P1 :: P2 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P2P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P8M1. try clear HP1P2P8M2. try clear HP1P2P8M3. try clear HP1P2P8m4. try clear HP1P2P8m3. try clear HP1P2P8m2. try clear HP1P2P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P8P9P12m4 : rk(P1 :: P2 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P12eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P5P8P9P12mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P12eq HP1P2P5P8P9P12m4).
	try assert(HP1P2P9eq : rk(P1 :: P2 :: P9 :: nil) = 3) by (apply LP1P2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P9mtmp : rk(P1 :: P2 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P2P9eq HP1P2P9m3).
	assert(Hincl : incl (P1 :: P2 :: P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P5 :: P9 :: P1 :: P2 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P1 :: P2 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P1 :: P2 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P12mtmp;try rewrite HT2 in HP1P2P5P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P9 :: nil) 4 3 3 HP1P2P5P8P9P12mtmp HP1P2P9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P9M1. try clear HP1P2P9M2. try clear HP1P2P9M3. try clear HP1P2P9m4. try clear HP1P2P9m3. try clear HP1P2P9m2. try clear HP1P2P9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P12m2 : rk(P1 :: P2 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P12m3 : rk(P1 :: P2 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P2P8P9P12eq : rk(P1 :: P2 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P8P9P12mtmp : rk(P1 :: P2 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P8P9P12eq HP1P2P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P1 :: P2 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P8P9P12mtmp;try rewrite HT2 in HP1P2P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP1P2P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P2P8P9P12M1. try clear HP1P2P8P9P12M2. try clear HP1P2P8P9P12M3. try clear HP1P2P8P9P12m4. try clear HP1P2P8P9P12m3. try clear HP1P2P8P9P12m2. try clear HP1P2P8P9P12m1. 

assert(HP1P2P12M : rk(P1 :: P2 :: P12 ::  nil) <= 3) by (solve_hyps_max HP1P2P12eq HP1P2P12M3).
assert(HP1P2P12m : rk(P1 :: P2 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P2P12eq HP1P2P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP3P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P3 :: P12 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P9P12m2 : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P9P12m3 : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP3P5P8mtmp : rk(P3 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P5P8eq HP3P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P8P9P12M3 : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) <= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P5 :: P9 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: nil) 2 2 1 HP3P5P9Mtmp HP8P9P12Mtmp HP9mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P8P9P12M3 : rk(P3 :: P8 :: P9 :: P12 :: nil) <= 3).
{
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3Mtmp : rk(P3 :: nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P8 :: P9 :: P12 :: nil) ((P3 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: nil) (P8 :: P9 :: P12 :: nil) (nil) 1 2 0 HP3Mtmp HP8P9P12Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3M1. try clear HP3M2. try clear HP3M3. try clear HP3m4. try clear HP3m3. try clear HP3m2. try clear HP3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P8P9P12m2 : rk(P3 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P8mtmp : rk(P3 :: P8 :: nil) >= 2) by (solve_hyps_min HP3P8eq HP3P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P8 :: nil) (P3 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P8 :: nil) (P3 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P8P9P12m3 : rk(P3 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P8P9P12eq : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP3P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P8P9P12mtmp : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP3P5P8P9P12eq HP3P5P8P9P12m3).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P3 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P3 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P3 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P3 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P8P9P12mtmp;try rewrite HT2 in HP3P5P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P9 :: nil) 3 2 2 HP3P5P8P9P12mtmp HP3P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P12m2 : rk(P3 :: P12 :: nil) >= 2).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP3P8P9P12eq : rk(P3 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P8P9P12mtmp : rk(P3 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP3P8P9P12eq HP3P8P9P12m3).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P12 :: P8 :: P9 :: P12 :: nil) ((P3 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P8P9P12mtmp;try rewrite HT2 in HP3P8P9P12mtmp.
	assert(HT := rule_2 (P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 3 1 2 HP3P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}


assert(HP3P12M : rk(P3 :: P12 ::  nil) <= 2) by (solve_hyps_max HP3P12eq HP3P12M2).
assert(HP3P12m : rk(P3 :: P12 ::  nil) >= 1) by (solve_hyps_min HP3P12eq HP3P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P3P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P3 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P9P12m2 : rk(P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P9P12m3 : rk(P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P9P12m4 : rk(P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P8P9P12m2 : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P8P9P12m3 : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P3P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P8P9P12m4 : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP1P3P5P8P9P12eq : rk(P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P5P8P9P12mtmp : rk(P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8P9P12eq HP1P3P5P8P9P12m4).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P1 :: P3 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P1 :: P3 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P1 :: P3 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P8P9P12mtmp;try rewrite HT2 in HP1P3P5P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P1 :: P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P9 :: nil) 4 2 2 HP1P3P5P8P9P12mtmp HP3P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP1P3P5P8P9P12M1. try clear HP1P3P5P8P9P12M2. try clear HP1P3P5P8P9P12M3. try clear HP1P3P5P8P9P12m4. try clear HP1P3P5P8P9P12m3. try clear HP1P3P5P8P9P12m2. try clear HP1P3P5P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P12m2 : rk(P1 :: P3 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P12m3 : rk(P1 :: P3 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P3P8P9P12eq : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P8P9P12mtmp : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P8P9P12eq HP1P3P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P1 :: P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P8 :: P9 :: P12 :: nil) (P1 :: P3 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P3 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P8P9P12mtmp;try rewrite HT2 in HP1P3P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP1P3P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}


assert(HP1P3P12M : rk(P1 :: P3 :: P12 ::  nil) <= 3) by (solve_hyps_max HP1P3P12eq HP1P3P12M3).
assert(HP1P3P12m : rk(P1 :: P3 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P3P12eq HP1P3P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP2P3P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P3 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P9P12m2 : rk(P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P9P12m3 : rk(P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5M1. try clear HP2P3P5M2. try clear HP2P3P5M3. try clear HP2P3P5m4. try clear HP2P3P5m3. try clear HP2P3P5m2. try clear HP2P3P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P9P12m4 : rk(P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP2P3P5P8mtmp : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8eq HP2P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) 4 4 HP2P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5P8M1. try clear HP2P3P5P8M2. try clear HP2P3P5P8M3. try clear HP2P3P5P8m4. try clear HP2P3P5P8m3. try clear HP2P3P5P8m2. try clear HP2P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P8P9P12m2 : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P8P9P12m3 : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil) 3 3 HP2P3P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P8P9P12m4 : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP2P3P5P8P9P12eq : rk(P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P3P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P3P5P8P9P12mtmp : rk(P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8P9P12eq HP2P3P5P8P9P12m4).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P2 :: P3 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P2 :: P3 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P2 :: P3 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P8P9P12mtmp;try rewrite HT2 in HP2P3P5P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P2 :: P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P9 :: nil) 4 2 2 HP2P3P5P8P9P12mtmp HP3P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP2P3P5P8P9P12M1. try clear HP2P3P5P8P9P12M2. try clear HP2P3P5P8P9P12M3. try clear HP2P3P5P8P9P12m4. try clear HP2P3P5P8P9P12m3. try clear HP2P3P5P8P9P12m2. try clear HP2P3P5P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P12m2 : rk(P2 :: P3 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P12m3 : rk(P2 :: P3 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP2P3P8P9P12eq : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P3P8P9P12mtmp : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P8P9P12eq HP2P3P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P2 :: P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P8 :: P9 :: P12 :: nil) (P2 :: P3 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P12 :: P8 :: P9 :: P12 :: nil) ((P2 :: P3 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P8P9P12mtmp;try rewrite HT2 in HP2P3P8P9P12mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP2P3P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}


assert(HP2P3P12M : rk(P2 :: P3 :: P12 ::  nil) <= 3) by (solve_hyps_max HP2P3P12eq HP2P3P12M3).
assert(HP2P3P12m : rk(P2 :: P3 :: P12 ::  nil) >= 1) by (solve_hyps_min HP2P3P12eq HP2P3P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P5P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P5 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P9P12m2 : rk(P1 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P9P12m3 : rk(P1 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P5P8mtmp : rk(P1 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P8eq HP1P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P8M1. try clear HP1P5P8M2. try clear HP1P5P8M3. try clear HP1P5P8m4. try clear HP1P5P8m3. try clear HP1P5P8m2. try clear HP1P5P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P8P9P12m4 : rk(P1 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P12eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P5P8P9P12mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P12eq HP1P2P5P8P9P12m4).
	try assert(HP1P5P9eq : rk(P1 :: P5 :: P9 :: nil) = 3) by (apply LP1P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P5P9mtmp : rk(P1 :: P5 :: P9 :: nil) >= 3) by (solve_hyps_min HP1P5P9eq HP1P5P9m3).
	assert(Hincl : incl (P1 :: P5 :: P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P5 :: P9 :: P1 :: P5 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P1 :: P5 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P1 :: P5 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P12mtmp;try rewrite HT2 in HP1P2P5P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P9 :: nil) 4 3 3 HP1P2P5P8P9P12mtmp HP1P5P9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P5P9M1. try clear HP1P5P9M2. try clear HP1P5P9M3. try clear HP1P5P9m4. try clear HP1P5P9m3. try clear HP1P5P9m2. try clear HP1P5P9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P12m2 : rk(P1 :: P5 :: P12 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P12 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5M1. try clear HP1P5M2. try clear HP1P5M3. try clear HP1P5m4. try clear HP1P5m3. try clear HP1P5m2. try clear HP1P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P12m3 : rk(P1 :: P5 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P5P8P9P12eq : rk(P1 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P5P8P9P12mtmp : rk(P1 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P5P8P9P12eq HP1P5P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P1 :: P5 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P5 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P8P9P12mtmp;try rewrite HT2 in HP1P5P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP1P5P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P5P8P9P12M1. try clear HP1P5P8P9P12M2. try clear HP1P5P8P9P12M3. try clear HP1P5P8P9P12m4. try clear HP1P5P8P9P12m3. try clear HP1P5P8P9P12m2. try clear HP1P5P8P9P12m1. 

assert(HP1P5P12M : rk(P1 :: P5 :: P12 ::  nil) <= 3) by (solve_hyps_max HP1P5P12eq HP1P5P12M3).
assert(HP1P5P12m : rk(P1 :: P5 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P5P12eq HP1P5P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P2P5P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P2 :: P5 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P9P12m2 : rk(P1 :: P2 :: P5 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P9P12m3 : rk(P1 :: P2 :: P5 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P9 :: P12 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P9P12m4 : rk(P1 :: P2 :: P5 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P2P5P8P9P12eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P5P8P9P12mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P12eq HP1P2P5P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P5 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P5 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P12mtmp;try rewrite HT2 in HP1P2P5P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P5 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP1P2P5P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P12m2 : rk(P1 :: P2 :: P5 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P12m3 : rk(P1 :: P2 :: P5 :: P12 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P12 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P12m4 : rk(P1 :: P2 :: P5 :: P12 :: nil) >= 4).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P9P12eq : rk(P1 :: P2 :: P5 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P5P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P5P9P12mtmp : rk(P1 :: P2 :: P5 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P9P12eq HP1P2P5P9P12m4).
	try assert(HP1P2P5eq : rk(P1 :: P2 :: P5 :: nil) = 3) by (apply LP1P2P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P5 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P9 :: P12 :: nil) (P1 :: P2 :: P5 :: P9 :: P1 :: P2 :: P5 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P1 :: P2 :: P5 :: P12 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P1 :: P2 :: P5 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P9P12mtmp;try rewrite HT2 in HP1P2P5P9P12mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P1 :: P2 :: P5 :: P12 :: nil) (P1 :: P2 :: P5 :: nil) 4 3 3 HP1P2P5P9P12mtmp HP1P2P5mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. try clear HP1P2P5P9P12M1. try clear HP1P2P5P9P12M2. try clear HP1P2P5P9P12M3. try clear HP1P2P5P9P12m4. try clear HP1P2P5P9P12m3. try clear HP1P2P5P9P12m2. try clear HP1P2P5P9P12m1. 

assert(HP1P2P5P12M : rk(P1 :: P2 :: P5 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P5P12m : rk(P1 :: P2 :: P5 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P2P5P12eq HP1P2P5P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P6 :: P12 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P6P8P9P12m2 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P6P8P9P12m3 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P6P8P9P12m4 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P6P8P9P12m2 : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P8P9P12m3 : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P8P9P12eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP1P3P5P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P5P6P8P9P12mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P8P9P12eq HP1P3P5P6P8P9P12m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8P9P12mtmp;try rewrite HT2 in HP1P3P5P6P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P3P5P6P8P9P12mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P8P9P12m4 : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP1P5P6P8eq : rk(P1 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P8Mtmp : rk(P1 :: P5 :: P6 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P6P8eq HP1P5P6P8M3).
	try assert(HP1P3P5P6P8P9P12eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P5P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P5P6P8P9P12mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P8P9P12eq HP1P3P5P6P8P9P12m4).
	try assert(HP5P6P8eq : rk(P5 :: P6 :: P8 :: nil) = 3) by (apply LP5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (list_inter (P1 :: P5 :: P6 :: P8 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P6 :: P8 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P8 :: P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) ((P1 :: P5 :: P6 :: P8 :: nil) ++ (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8P9P12mtmp;try rewrite HT2 in HP1P3P5P6P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P8 :: nil) (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P5 :: P6 :: P8 :: nil) 4 3 3 HP1P3P5P6P8P9P12mtmp HP5P6P8mtmp HP1P5P6P8Mtmp Hincl); apply HT.
}
try clear HP1P5P6P8M1. try clear HP1P5P6P8M2. try clear HP1P5P6P8M3. try clear HP1P5P6P8m4. try clear HP1P5P6P8m3. try clear HP1P5P6P8m2. try clear HP1P5P6P8m1. try clear HP1P3P5P6P8P9P12M1. try clear HP1P3P5P6P8P9P12M2. try clear HP1P3P5P6P8P9P12M3. try clear HP1P3P5P6P8P9P12m4. try clear HP1P3P5P6P8P9P12m3. try clear HP1P3P5P6P8P9P12m2. try clear HP1P3P5P6P8P9P12m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP6P8P9P12M3 : rk(P6 :: P8 :: P9 :: P12 :: nil) <= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P8 :: P9 :: P12 :: nil) (P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P8 :: P9 :: P12 :: nil) ((P6 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P6 :: nil) (P8 :: P9 :: P12 :: nil) (nil) 1 2 0 HP6Mtmp HP8P9P12Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P8P9P12m2 : rk(P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP6P8mtmp : rk(P6 :: P8 :: nil) >= 2) by (solve_hyps_min HP6P8eq HP6P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P6 :: P8 :: nil) (P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P8 :: nil) (P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP6P8M1. try clear HP6P8M2. try clear HP6P8M3. try clear HP6P8m4. try clear HP6P8m3. try clear HP6P8m2. try clear HP6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P8P9P12m3 : rk(P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P6P8P9P12eq : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P5P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P6P8P9P12mtmp : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P5P6P8P9P12eq HP3P5P6P8P9P12m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P6 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P6P8P9P12mtmp;try rewrite HT2 in HP3P5P6P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P6 :: P8 :: P9 :: P12 :: nil) (P9 :: nil) 4 1 2 HP3P5P6P8P9P12mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP9M1. try clear HP9M2. try clear HP9M3. try clear HP9m4. try clear HP9m3. try clear HP9m2. try clear HP9m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP6P12m2 : rk(P6 :: P12 :: nil) >= 2).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP6P8P9P12eq : rk(P6 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP6P8P9P12mtmp : rk(P6 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP6P8P9P12eq HP6P8P9P12m3).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P8 :: P9 :: P12 :: nil) (P6 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P12 :: P8 :: P9 :: P12 :: nil) ((P6 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP6P8P9P12mtmp;try rewrite HT2 in HP6P8P9P12mtmp.
	assert(HT := rule_2 (P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 3 1 2 HP6P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP6P8P9P12M1. try clear HP6P8P9P12M2. try clear HP6P8P9P12M3. try clear HP6P8P9P12m4. try clear HP6P8P9P12m3. try clear HP6P8P9P12m2. try clear HP6P8P9P12m1. 

assert(HP6P12M : rk(P6 :: P12 ::  nil) <= 2) by (solve_hyps_max HP6P12eq HP6P12M2).
assert(HP6P12m : rk(P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP6P12eq HP6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P6 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P8P9P12m2 : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P9P12m3 : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P9P12m4 : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P8M1. try clear HP1P2P6P8M2. try clear HP1P2P6P8M3. try clear HP1P2P6P8m4. try clear HP1P2P6P8m3. try clear HP1P2P6P8m2. try clear HP1P2P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P8P9P12m2 : rk(P1 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P8P9P12m3 : rk(P1 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P6P8mtmp : rk(P1 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P6P8eq HP1P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P8 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: P8 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6P8M1. try clear HP1P6P8M2. try clear HP1P6P8M3. try clear HP1P6P8m4. try clear HP1P6P8m3. try clear HP1P6P8m2. try clear HP1P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P8P9P12m4 : rk(P1 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP1P2P6P8P9P12eq : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P6P8P9P12mtmp : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8P9P12eq HP1P2P6P8P9P12m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) (P2 :: P6 :: P9 :: P1 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P1 :: P6 :: P8 :: P9 :: P12 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P1 :: P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P8P9P12mtmp;try rewrite HT2 in HP1P2P6P8P9P12mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P1 :: P6 :: P8 :: P9 :: P12 :: nil) (P6 :: P9 :: nil) 4 2 2 HP1P2P6P8P9P12mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P12m2 : rk(P1 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P12 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6M1. try clear HP1P6M2. try clear HP1P6M3. try clear HP1P6m4. try clear HP1P6m3. try clear HP1P6m2. try clear HP1P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P12m3 : rk(P1 :: P6 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P6P8P9P12eq : rk(P1 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P6P8P9P12mtmp : rk(P1 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P6P8P9P12eq HP1P6P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P1 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P8 :: P9 :: P12 :: nil) (P1 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P6 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P8P9P12mtmp;try rewrite HT2 in HP1P6P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP1P6P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P6P8P9P12M1. try clear HP1P6P8P9P12M2. try clear HP1P6P8P9P12M3. try clear HP1P6P8P9P12m4. try clear HP1P6P8P9P12m3. try clear HP1P6P8P9P12m2. try clear HP1P6P8P9P12m1. 

assert(HP1P6P12M : rk(P1 :: P6 :: P12 ::  nil) <= 3) by (solve_hyps_max HP1P6P12eq HP1P6P12M3).
assert(HP1P6P12m : rk(P1 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P6P12eq HP1P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P2P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P2 :: P6 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P9P12m2 : rk(P1 :: P2 :: P6 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P9P12m3 : rk(P1 :: P2 :: P6 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P9 :: P12 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P9P12m4 : rk(P1 :: P2 :: P6 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P2P6P8P9P12eq : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P6P8P9P12mtmp : rk(P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8P9P12eq HP1P2P6P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P1 :: P2 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P6 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P8P9P12mtmp;try rewrite HT2 in HP1P2P6P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP1P2P6P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P2P6P8P9P12M1. try clear HP1P2P6P8P9P12M2. try clear HP1P2P6P8P9P12M3. try clear HP1P2P6P8P9P12m4. try clear HP1P2P6P8P9P12m3. try clear HP1P2P6P8P9P12m2. try clear HP1P2P6P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P12m2 : rk(P1 :: P2 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P12m3 : rk(P1 :: P2 :: P6 :: P12 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P12 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P12m4 : rk(P1 :: P2 :: P6 :: P12 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP1P2P6P9P12eq : rk(P1 :: P2 :: P6 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P6P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P6P9P12mtmp : rk(P1 :: P2 :: P6 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P6P9P12eq HP1P2P6P9P12m4).
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hincl : incl (P2 :: P6 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P1 :: P2 :: P6 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P9 :: P12 :: nil) (P2 :: P6 :: P9 :: P1 :: P2 :: P6 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P1 :: P2 :: P6 :: P12 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P1 :: P2 :: P6 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P9P12mtmp;try rewrite HT2 in HP1P2P6P9P12mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P1 :: P2 :: P6 :: P12 :: nil) (P2 :: P6 :: nil) 4 2 2 HP1P2P6P9P12mtmp HP2P6mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP1P2P6P9P12M1. try clear HP1P2P6P9P12M2. try clear HP1P2P6P9P12M3. try clear HP1P2P6P9P12m4. try clear HP1P2P6P9P12m3. try clear HP1P2P6P9P12m2. try clear HP1P2P6P9P12m1. 

assert(HP1P2P6P12M : rk(P1 :: P2 :: P6 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P6P12m : rk(P1 :: P2 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P2P6P12eq HP1P2P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP2P3P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P3 :: P6 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P8P9P12m2 : rk(P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P8P9P12m3 : rk(P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P8P9P12m4 : rk(P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP2P3P6P8mtmp : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P6P8eq HP2P3P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) 4 4 HP2P3P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6P8M1. try clear HP2P3P6P8M2. try clear HP2P3P6P8M3. try clear HP2P3P6P8m4. try clear HP2P3P6P8m3. try clear HP2P3P6P8m2. try clear HP2P3P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P9P12m2 : rk(P2 :: P3 :: P6 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P9 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P9P12m3 : rk(P2 :: P3 :: P6 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P9 :: P12 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P9P12m4 : rk(P2 :: P3 :: P6 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP2P3P6P8P9P12eq : rk(P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P3P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P3P6P8P9P12mtmp : rk(P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P6P8P9P12eq HP2P3P6P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P2 :: P3 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P8 :: P9 :: P12 :: nil) (P2 :: P3 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P2 :: P3 :: P6 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P6P8P9P12mtmp;try rewrite HT2 in HP2P3P6P8P9P12mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP2P3P6P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP2P3P6P8P9P12M1. try clear HP2P3P6P8P9P12M2. try clear HP2P3P6P8P9P12M3. try clear HP2P3P6P8P9P12m4. try clear HP2P3P6P8P9P12m3. try clear HP2P3P6P8P9P12m2. try clear HP2P3P6P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P12m2 : rk(P2 :: P3 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P12m3 : rk(P2 :: P3 :: P6 :: P12 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P12 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P12m4 : rk(P2 :: P3 :: P6 :: P12 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P3P6P9P12eq : rk(P2 :: P3 :: P6 :: P9 :: P12 :: nil) = 4) by (apply LP2P3P6P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P3P6P9P12mtmp : rk(P2 :: P3 :: P6 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P6P9P12eq HP2P3P6P9P12m4).
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hincl : incl (P2 :: P6 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P3 :: P6 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P9 :: P12 :: nil) (P2 :: P6 :: P9 :: P2 :: P3 :: P6 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P3 :: P6 :: P12 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P3 :: P6 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P6P9P12mtmp;try rewrite HT2 in HP2P3P6P9P12mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P3 :: P6 :: P12 :: nil) (P2 :: P6 :: nil) 4 2 2 HP2P3P6P9P12mtmp HP2P6mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P3P6P9P12M1. try clear HP2P3P6P9P12M2. try clear HP2P3P6P9P12M3. try clear HP2P3P6P9P12m4. try clear HP2P3P6P9P12m3. try clear HP2P3P6P9P12m2. try clear HP2P3P6P9P12m1. 

assert(HP2P3P6P12M : rk(P2 :: P3 :: P6 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P6P12m : rk(P2 :: P3 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP2P3P6P12eq HP2P3P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP4P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P4 :: P6 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P12m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P12m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P12m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6P8M1. try clear HP2P4P6P8M2. try clear HP2P4P6P8M3. try clear HP2P4P6P8m4. try clear HP2P4P6P8m3. try clear HP2P4P6P8m2. try clear HP2P4P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P12m2 : rk(P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P12m3 : rk(P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P8M1. try clear HP4P6P8M2. try clear HP4P6P8M3. try clear HP4P6P8m4. try clear HP4P6P8m3. try clear HP4P6P8m2. try clear HP4P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P12m4 : rk(P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P12eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P4P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P4P6P8P9P12mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P12eq HP2P4P6P8P9P12m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P12mtmp;try rewrite HT2 in HP2P4P6P8P9P12mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P12 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P12mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP6P9M1. try clear HP6P9M2. try clear HP6P9M3. try clear HP6P9m4. try clear HP6P9m3. try clear HP6P9m2. try clear HP6P9m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P12m2 : rk(P4 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P12 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6M1. try clear HP4P6M2. try clear HP4P6M3. try clear HP4P6m4. try clear HP4P6m3. try clear HP4P6m2. try clear HP4P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P6P12m3 : rk(P4 :: P6 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP4P6P8P9P12eq : rk(P4 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP4P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP4P6P8P9P12mtmp : rk(P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P12eq HP4P6P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P4 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P12 :: nil) (P4 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil) ((P4 :: P6 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P12mtmp;try rewrite HT2 in HP4P6P8P9P12mtmp.
	assert(HT := rule_2 (P4 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP4P6P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP4P6P8P9P12M1. try clear HP4P6P8P9P12M2. try clear HP4P6P8P9P12M3. try clear HP4P6P8P9P12m4. try clear HP4P6P8P9P12m3. try clear HP4P6P8P9P12m2. try clear HP4P6P8P9P12m1. 

assert(HP4P6P12M : rk(P4 :: P6 :: P12 ::  nil) <= 3) by (solve_hyps_max HP4P6P12eq HP4P6P12M3).
assert(HP4P6P12m : rk(P4 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP4P6P12eq HP4P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP2P4P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P4 :: P6 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P9P12m2 : rk(P2 :: P4 :: P6 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P9 :: P12 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P9P12m3 : rk(P2 :: P4 :: P6 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P9 :: P12 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P9P12m4 : rk(P2 :: P4 :: P6 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP2P4P6P8P9P12eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P4P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P4P6P8P9P12mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P12eq HP2P4P6P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P2 :: P4 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P12 :: nil) (P2 :: P4 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P6 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P2 :: P4 :: P6 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P12mtmp;try rewrite HT2 in HP2P4P6P8P9P12mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P6 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP2P4P6P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP2P4P6P8P9P12M1. try clear HP2P4P6P8P9P12M2. try clear HP2P4P6P8P9P12M3. try clear HP2P4P6P8P9P12m4. try clear HP2P4P6P8P9P12m3. try clear HP2P4P6P8P9P12m2. try clear HP2P4P6P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P12m2 : rk(P2 :: P4 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P12 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P12m3 : rk(P2 :: P4 :: P6 :: P12 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P12 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6M1. try clear HP2P4P6M2. try clear HP2P4P6M3. try clear HP2P4P6m4. try clear HP2P4P6m3. try clear HP2P4P6m2. try clear HP2P4P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P12m4 : rk(P2 :: P4 :: P6 :: P12 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P9P12eq : rk(P2 :: P4 :: P6 :: P9 :: P12 :: nil) = 4) by (apply LP2P4P6P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P4P6P9P12mtmp : rk(P2 :: P4 :: P6 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P4P6P9P12eq HP2P4P6P9P12m4).
	try assert(HP2P6eq : rk(P2 :: P6 :: nil) = 2) by (apply LP2P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hincl : incl (P2 :: P6 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P4 :: P6 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P9 :: P12 :: nil) (P2 :: P6 :: P9 :: P2 :: P4 :: P6 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P4 :: P6 :: P12 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P4 :: P6 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P9P12mtmp;try rewrite HT2 in HP2P4P6P9P12mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P4 :: P6 :: P12 :: nil) (P2 :: P6 :: nil) 4 2 2 HP2P4P6P9P12mtmp HP2P6mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P9M1. try clear HP2P6P9M2. try clear HP2P6P9M3. try clear HP2P6P9m4. try clear HP2P6P9m3. try clear HP2P6P9m2. try clear HP2P6P9m1. try clear HP2P6M1. try clear HP2P6M2. try clear HP2P6M3. try clear HP2P6m4. try clear HP2P6m3. try clear HP2P6m2. try clear HP2P6m1. try clear HP2P4P6P9P12M1. try clear HP2P4P6P9P12M2. try clear HP2P4P6P9P12M3. try clear HP2P4P6P9P12m4. try clear HP2P4P6P9P12m3. try clear HP2P4P6P9P12m2. try clear HP2P4P6P9P12m1. 

assert(HP2P4P6P12M : rk(P2 :: P4 :: P6 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P6P12m : rk(P2 :: P4 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP2P4P6P12eq HP2P4P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP5P6P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P5 :: P6 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P8P9P12m2 : rk(P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P8P9P12m3 : rk(P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil) 3 3 HP5P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP5P6P8M1. try clear HP5P6P8M2. try clear HP5P6P8M3. try clear HP5P6P8m4. try clear HP5P6P8m3. try clear HP5P6P8m2. try clear HP5P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P6P8P9P12m4 : rk(P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P6P8P9P12eq : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P5P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P6P8P9P12mtmp : rk(P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P5P6P8P9P12eq HP3P5P6P8P9P12m4).
	try assert(HP5P9eq : rk(P5 :: P9 :: nil) = 2) by (apply LP5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hincl : incl (P5 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P5 :: P6 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P5 :: P6 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P6P8P9P12mtmp;try rewrite HT2 in HP3P5P6P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P5 :: P9 :: nil) 4 2 2 HP3P5P6P8P9P12mtmp HP5P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P6P8P9P12M1. try clear HP3P5P6P8P9P12M2. try clear HP3P5P6P8P9P12M3. try clear HP3P5P6P8P9P12m4. try clear HP3P5P6P8P9P12m3. try clear HP3P5P6P8P9P12m2. try clear HP3P5P6P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P12m2 : rk(P5 :: P6 :: P12 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P12 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}
try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P6P12m3 : rk(P5 :: P6 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP5P6P8P9P12eq : rk(P5 :: P6 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP5P6P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP5P6P8P9P12mtmp : rk(P5 :: P6 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP5P6P8P9P12eq HP5P6P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P5 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P8 :: P9 :: P12 :: nil) (P5 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P12 :: P8 :: P9 :: P12 :: nil) ((P5 :: P6 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P6P8P9P12mtmp;try rewrite HT2 in HP5P6P8P9P12mtmp.
	assert(HT := rule_2 (P5 :: P6 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP5P6P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP5P6P8P9P12M1. try clear HP5P6P8P9P12M2. try clear HP5P6P8P9P12M3. try clear HP5P6P8P9P12m4. try clear HP5P6P8P9P12m3. try clear HP5P6P8P9P12m2. try clear HP5P6P8P9P12m1. 

assert(HP5P6P12M : rk(P5 :: P6 :: P12 ::  nil) <= 3) by (solve_hyps_max HP5P6P12eq HP5P6P12M3).
assert(HP5P6P12m : rk(P5 :: P6 :: P12 ::  nil) >= 1) by (solve_hyps_min HP5P6P12eq HP5P6P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P2P7P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P2 :: P7 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P8P9P12m2 : rk(P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P9P12m3 : rk(P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P9P12m4 : rk(P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7P8M1. try clear HP1P2P7P8M2. try clear HP1P2P7P8M3. try clear HP1P2P7P8m4. try clear HP1P2P7P8m3. try clear HP1P2P7P8m2. try clear HP1P2P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P9P12m2 : rk(P1 :: P2 :: P7 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P9 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P9P12m3 : rk(P1 :: P2 :: P7 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P9 :: P12 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P9P12m4 : rk(P1 :: P2 :: P7 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P2P7P8P9P12eq : rk(P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P7P8P9P12mtmp : rk(P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8P9P12eq HP1P2P7P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P1 :: P2 :: P7 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P7 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P7 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P8P9P12mtmp;try rewrite HT2 in HP1P2P7P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P7 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP1P2P7P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P2P7P8P9P12M1. try clear HP1P2P7P8P9P12M2. try clear HP1P2P7P8P9P12M3. try clear HP1P2P7P8P9P12m4. try clear HP1P2P7P8P9P12m3. try clear HP1P2P7P8P9P12m2. try clear HP1P2P7P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P12m2 : rk(P1 :: P2 :: P7 :: P12 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P12 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P12m3 : rk(P1 :: P2 :: P7 :: P12 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P12 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P12m4 : rk(P1 :: P2 :: P7 :: P12 :: nil) >= 4).
{
	try assert(HP1P2P7P9eq : rk(P1 :: P2 :: P7 :: P9 :: nil) = 3) by (apply LP1P2P7P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P7P9Mtmp : rk(P1 :: P2 :: P7 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P7P9eq HP1P2P7P9M3).
	try assert(HP1P2P7P9P12eq : rk(P1 :: P2 :: P7 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P7P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P7P9P12mtmp : rk(P1 :: P2 :: P7 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P7P9P12eq HP1P2P7P9P12m4).
	try assert(HP1P2P7eq : rk(P1 :: P2 :: P7 :: nil) = 3) by (apply LP1P2P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (list_inter (P1 :: P2 :: P7 :: P9 :: nil) (P1 :: P2 :: P7 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P9 :: P12 :: nil) (P1 :: P2 :: P7 :: P9 :: P1 :: P2 :: P7 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P9 :: P1 :: P2 :: P7 :: P12 :: nil) ((P1 :: P2 :: P7 :: P9 :: nil) ++ (P1 :: P2 :: P7 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P9P12mtmp;try rewrite HT2 in HP1P2P7P9P12mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P7 :: P9 :: nil) (P1 :: P2 :: P7 :: P12 :: nil) (P1 :: P2 :: P7 :: nil) 4 3 3 HP1P2P7P9P12mtmp HP1P2P7mtmp HP1P2P7P9Mtmp Hincl); apply HT.
}
try clear HP1P2P7P9M1. try clear HP1P2P7P9M2. try clear HP1P2P7P9M3. try clear HP1P2P7P9m4. try clear HP1P2P7P9m3. try clear HP1P2P7P9m2. try clear HP1P2P7P9m1. try clear HP1P2P7M1. try clear HP1P2P7M2. try clear HP1P2P7M3. try clear HP1P2P7m4. try clear HP1P2P7m3. try clear HP1P2P7m2. try clear HP1P2P7m1. try clear HP1P2P7P9P12M1. try clear HP1P2P7P9P12M2. try clear HP1P2P7P9P12M3. try clear HP1P2P7P9P12m4. try clear HP1P2P7P9P12m3. try clear HP1P2P7P9P12m2. try clear HP1P2P7P9P12m1. 

assert(HP1P2P7P12M : rk(P1 :: P2 :: P7 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P7P12m : rk(P1 :: P2 :: P7 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P2P7P12eq HP1P2P7P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP3P7P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P3 :: P7 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P7P8P9P12m2 : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P7P8P9P12m3 : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P7P8P9P12m4 : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P8M1. try clear HP1P3P5P8M2. try clear HP1P3P5P8M3. try clear HP1P3P5P8m4. try clear HP1P3P5P8m3. try clear HP1P3P5P8m2. try clear HP1P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P7P8P9P12m2 : rk(P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P8P9P12m3 : rk(P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P5P7P8P9P12eq : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP1P3P5P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P5P7P8P9P12mtmp : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP1P3P5P7P8P9P12eq HP1P3P5P7P8P9P12m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P8P9P12mtmp;try rewrite HT2 in HP1P3P5P7P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P3P5P7P8P9P12mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P8P9P12m4 : rk(P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8Mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P7P8eq HP1P5P7P8M3).
	try assert(HP1P3P5P7P8P9P12eq : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P5P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P5P7P8P9P12mtmp : rk(P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P5P7P8P9P12eq HP1P3P5P7P8P9P12m4).
	try assert(HP5P7P8eq : rk(P5 :: P7 :: P8 :: nil) = 3) by (apply LP5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7P8mtmp : rk(P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P7P8eq HP5P7P8m3).
	assert(Hincl : incl (P5 :: P7 :: P8 :: nil) (list_inter (P1 :: P5 :: P7 :: P8 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) (P1 :: P5 :: P7 :: P8 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) ((P1 :: P5 :: P7 :: P8 :: nil) ++ (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P8P9P12mtmp;try rewrite HT2 in HP1P3P5P7P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P8 :: nil) (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) (P5 :: P7 :: P8 :: nil) 4 3 3 HP1P3P5P7P8P9P12mtmp HP5P7P8mtmp HP1P5P7P8Mtmp Hincl); apply HT.
}
try clear HP1P5P7P8M1. try clear HP1P5P7P8M2. try clear HP1P5P7P8M3. try clear HP1P5P7P8m4. try clear HP1P5P7P8m3. try clear HP1P5P7P8m2. try clear HP1P5P7P8m1. try clear HP5P7P8M1. try clear HP5P7P8M2. try clear HP5P7P8M3. try clear HP5P7P8m4. try clear HP5P7P8m3. try clear HP5P7P8m2. try clear HP5P7P8m1. try clear HP1P3P5P7P8P9P12M1. try clear HP1P3P5P7P8P9P12M2. try clear HP1P3P5P7P8P9P12M3. try clear HP1P3P5P7P8P9P12m4. try clear HP1P3P5P7P8P9P12m3. try clear HP1P3P5P7P8P9P12m2. try clear HP1P3P5P7P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P8P9P12m2 : rk(P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P8P9P12m3 : rk(P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP3P7P8mtmp : rk(P3 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P7P8eq HP3P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: P8 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: P8 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil) 3 3 HP3P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7P8M1. try clear HP3P7P8M2. try clear HP3P7P8M3. try clear HP3P7P8m4. try clear HP3P7P8m3. try clear HP3P7P8m2. try clear HP3P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P7P8P9P12m4 : rk(P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P7P8P9P12eq : rk(P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P5P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P7P8P9P12mtmp : rk(P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P5P7P8P9P12eq HP3P5P7P8P9P12m4).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P7 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P3 :: P7 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P7P8P9P12mtmp;try rewrite HT2 in HP3P5P7P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P3 :: P7 :: P8 :: P9 :: P12 :: nil) (P3 :: P9 :: nil) 4 2 2 HP3P5P7P8P9P12mtmp HP3P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P7P8P9P12M1. try clear HP3P5P7P8P9P12M2. try clear HP3P5P7P8P9P12M3. try clear HP3P5P7P8P9P12m4. try clear HP3P5P7P8P9P12m3. try clear HP3P5P7P8P9P12m2. try clear HP3P5P7P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P12m2 : rk(P3 :: P7 :: P12 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7M1. try clear HP3P7M2. try clear HP3P7M3. try clear HP3P7m4. try clear HP3P7m3. try clear HP3P7m2. try clear HP3P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P7P12m3 : rk(P3 :: P7 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP3P7P8P9P12eq : rk(P3 :: P7 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P7P8P9P12mtmp : rk(P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P7P8P9P12eq HP3P7P8P9P12m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P3 :: P7 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P8 :: P9 :: P12 :: nil) (P3 :: P7 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P12 :: P8 :: P9 :: P12 :: nil) ((P3 :: P7 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P7P8P9P12mtmp;try rewrite HT2 in HP3P7P8P9P12mtmp.
	assert(HT := rule_2 (P3 :: P7 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P12 :: nil) 4 1 2 HP3P7P8P9P12mtmp HP12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP12M1. try clear HP12M2. try clear HP12M3. try clear HP12m4. try clear HP12m3. try clear HP12m2. try clear HP12m1. try clear HP3P7P8P9P12M1. try clear HP3P7P8P9P12M2. try clear HP3P7P8P9P12M3. try clear HP3P7P8P9P12m4. try clear HP3P7P8P9P12m3. try clear HP3P7P8P9P12m2. try clear HP3P7P8P9P12m1. 

assert(HP3P7P12M : rk(P3 :: P7 :: P12 ::  nil) <= 3) by (solve_hyps_max HP3P7P12eq HP3P7P12M3).
assert(HP3P7P12m : rk(P3 :: P7 :: P12 ::  nil) >= 1) by (solve_hyps_min HP3P7P12eq HP3P7P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P3P7P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P3 :: P7 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P8P9P12m2 : rk(P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P8P9P12m3 : rk(P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P8P9P12m4 : rk(P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP1P3P7P8mtmp : rk(P1 :: P3 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P7P8eq HP1P3P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: P8 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: P8 :: nil) (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) 4 4 HP1P3P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P7P8M1. try clear HP1P3P7P8M2. try clear HP1P3P7P8M3. try clear HP1P3P7P8m4. try clear HP1P3P7P8m3. try clear HP1P3P7P8m2. try clear HP1P3P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P9P12m2 : rk(P1 :: P3 :: P7 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P9 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P9P12m3 : rk(P1 :: P3 :: P7 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P9 :: P12 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P9P12m4 : rk(P1 :: P3 :: P7 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P3P7P8P9P12eq : rk(P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P7P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P7P8P9P12mtmp : rk(P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P7P8P9P12eq HP1P3P7P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P1 :: P3 :: P7 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P7 :: P8 :: P9 :: P12 :: nil) (P1 :: P3 :: P7 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P7 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P3 :: P7 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P7P8P9P12mtmp;try rewrite HT2 in HP1P3P7P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P7 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP1P3P7P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P3P7P8P9P12M1. try clear HP1P3P7P8P9P12M2. try clear HP1P3P7P8P9P12M3. try clear HP1P3P7P8P9P12m4. try clear HP1P3P7P8P9P12m3. try clear HP1P3P7P8P9P12m2. try clear HP1P3P7P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P12m2 : rk(P1 :: P3 :: P7 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P12m3 : rk(P1 :: P3 :: P7 :: P12 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P12 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P12m4 : rk(P1 :: P3 :: P7 :: P12 :: nil) >= 4).
{
	try assert(HP1P3P7P9eq : rk(P1 :: P3 :: P7 :: P9 :: nil) = 3) by (apply LP1P3P7P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P3P7P9Mtmp : rk(P1 :: P3 :: P7 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P3P7P9eq HP1P3P7P9M3).
	try assert(HP1P3P7P9P12eq : rk(P1 :: P3 :: P7 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P7P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P7P9P12mtmp : rk(P1 :: P3 :: P7 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P7P9P12eq HP1P3P7P9P12m4).
	try assert(HP1P3P7eq : rk(P1 :: P3 :: P7 :: nil) = 3) by (apply LP1P3P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (list_inter (P1 :: P3 :: P7 :: P9 :: nil) (P1 :: P3 :: P7 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P7 :: P9 :: P12 :: nil) (P1 :: P3 :: P7 :: P9 :: P1 :: P3 :: P7 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P7 :: P9 :: P1 :: P3 :: P7 :: P12 :: nil) ((P1 :: P3 :: P7 :: P9 :: nil) ++ (P1 :: P3 :: P7 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P7P9P12mtmp;try rewrite HT2 in HP1P3P7P9P12mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P7 :: P9 :: nil) (P1 :: P3 :: P7 :: P12 :: nil) (P1 :: P3 :: P7 :: nil) 4 3 3 HP1P3P7P9P12mtmp HP1P3P7mtmp HP1P3P7P9Mtmp Hincl); apply HT.
}
try clear HP1P3P7P9M1. try clear HP1P3P7P9M2. try clear HP1P3P7P9M3. try clear HP1P3P7P9m4. try clear HP1P3P7P9m3. try clear HP1P3P7P9m2. try clear HP1P3P7P9m1. try clear HP1P3P7M1. try clear HP1P3P7M2. try clear HP1P3P7M3. try clear HP1P3P7m4. try clear HP1P3P7m3. try clear HP1P3P7m2. try clear HP1P3P7m1. try clear HP1P3P7P9P12M1. try clear HP1P3P7P9P12M2. try clear HP1P3P7P9P12M3. try clear HP1P3P7P9P12m4. try clear HP1P3P7P9P12m3. try clear HP1P3P7P9P12m2. try clear HP1P3P7P9P12m1. 

assert(HP1P3P7P12M : rk(P1 :: P3 :: P7 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P7P12m : rk(P1 :: P3 :: P7 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P3P7P12eq HP1P3P7P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP3P8P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P3 :: P8 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P8P12m2 : rk(P3 :: P8 :: P12 :: nil) >= 2).
{
	assert(HP3P8mtmp : rk(P3 :: P8 :: nil) >= 2) by (solve_hyps_min HP3P8eq HP3P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P8 :: nil) (P3 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P8 :: nil) (P3 :: P8 :: P12 :: nil) 2 2 HP3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P8M1. try clear HP3P8M2. try clear HP3P8M3. try clear HP3P8m4. try clear HP3P8m3. try clear HP3P8m2. try clear HP3P8m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P8P12m3 : rk(P3 :: P8 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP3P8P9P12eq : rk(P3 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P8P9P12mtmp : rk(P3 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP3P8P9P12eq HP3P8P9P12m3).
	try assert(HP8P12eq : rk(P8 :: P12 :: nil) = 2) by (apply LP8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P12mtmp : rk(P8 :: P12 :: nil) >= 2) by (solve_hyps_min HP8P12eq HP8P12m2).
	assert(Hincl : incl (P8 :: P12 :: nil) (list_inter (P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P8 :: P9 :: P12 :: nil) (P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil) ((P3 :: P8 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P8P9P12mtmp;try rewrite HT2 in HP3P8P9P12mtmp.
	assert(HT := rule_2 (P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P8 :: P12 :: nil) 3 2 2 HP3P8P9P12mtmp HP8P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP3P8P9P12M1. try clear HP3P8P9P12M2. try clear HP3P8P9P12M3. try clear HP3P8P9P12m4. try clear HP3P8P9P12m3. try clear HP3P8P9P12m2. try clear HP3P8P9P12m1. 

assert(HP3P8P12M : rk(P3 :: P8 :: P12 ::  nil) <= 3) by (solve_hyps_max HP3P8P12eq HP3P8P12M3).
assert(HP3P8P12m : rk(P3 :: P8 :: P12 ::  nil) >= 1) by (solve_hyps_min HP3P8P12eq HP3P8P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP1P3P8P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P1 :: P3 :: P8 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P8P12m2 : rk(P1 :: P3 :: P8 :: P12 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P12 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P8P12m3 : rk(P1 :: P3 :: P8 :: P12 :: nil) >= 3).
{
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P12 :: nil) 3 3 HP1P3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P8M1. try clear HP1P3P8M2. try clear HP1P3P8M3. try clear HP1P3P8m4. try clear HP1P3P8m3. try clear HP1P3P8m2. try clear HP1P3P8m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P8P12m4 : rk(P1 :: P3 :: P8 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP1P3P8P9P12eq : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P3P8P9P12mtmp : rk(P1 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P3P8P9P12eq HP1P3P8P9P12m4).
	try assert(HP8P12eq : rk(P8 :: P12 :: nil) = 2) by (apply LP8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P12mtmp : rk(P8 :: P12 :: nil) >= 2) by (solve_hyps_min HP8P12eq HP8P12m2).
	assert(Hincl : incl (P8 :: P12 :: nil) (list_inter (P1 :: P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P8 :: P9 :: P12 :: nil) (P1 :: P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil) ((P1 :: P3 :: P8 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P8P9P12mtmp;try rewrite HT2 in HP1P3P8P9P12mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P8 :: P12 :: nil) 4 2 2 HP1P3P8P9P12mtmp HP8P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP1P3P8P9P12M1. try clear HP1P3P8P9P12M2. try clear HP1P3P8P9P12M3. try clear HP1P3P8P9P12m4. try clear HP1P3P8P9P12m3. try clear HP1P3P8P9P12m2. try clear HP1P3P8P9P12m1. 

assert(HP1P3P8P12M : rk(P1 :: P3 :: P8 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P8P12m : rk(P1 :: P3 :: P8 :: P12 ::  nil) >= 1) by (solve_hyps_min HP1P3P8P12eq HP1P3P8P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP2P3P8P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P3 :: P8 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P8P12m2 : rk(P2 :: P3 :: P8 :: P12 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P12 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P8P12m3 : rk(P2 :: P3 :: P8 :: P12 :: nil) >= 3).
{
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P12 :: nil) 3 3 HP2P3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P8M1. try clear HP2P3P8M2. try clear HP2P3P8M3. try clear HP2P3P8m4. try clear HP2P3P8m3. try clear HP2P3P8m2. try clear HP2P3P8m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P8P12m4 : rk(P2 :: P3 :: P8 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP2P3P8P9P12eq : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP2P3P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP2P3P8P9P12mtmp : rk(P2 :: P3 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P8P9P12eq HP2P3P8P9P12m4).
	try assert(HP8P12eq : rk(P8 :: P12 :: nil) = 2) by (apply LP8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P12mtmp : rk(P8 :: P12 :: nil) >= 2) by (solve_hyps_min HP8P12eq HP8P12m2).
	assert(Hincl : incl (P8 :: P12 :: nil) (list_inter (P2 :: P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P8 :: P9 :: P12 :: nil) (P2 :: P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil) ((P2 :: P3 :: P8 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P8P9P12mtmp;try rewrite HT2 in HP2P3P8P9P12mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P8 :: P12 :: nil) 4 2 2 HP2P3P8P9P12mtmp HP8P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP2P3P8P9P12M1. try clear HP2P3P8P9P12M2. try clear HP2P3P8P9P12M3. try clear HP2P3P8P9P12m4. try clear HP2P3P8P9P12m3. try clear HP2P3P8P9P12m2. try clear HP2P3P8P9P12m1. 

assert(HP2P3P8P12M : rk(P2 :: P3 :: P8 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P8P12m : rk(P2 :: P3 :: P8 :: P12 ::  nil) >= 1) by (solve_hyps_min HP2P3P8P12eq HP2P3P8P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP5P8P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P5 :: P8 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP5P8P9P12M3 : rk(P5 :: P8 :: P9 :: P12 :: nil) <= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P8 :: P9 :: P12 :: nil) (P5 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P8 :: P9 :: P12 :: nil) ((P5 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: nil) (P8 :: P9 :: P12 :: nil) (nil) 1 2 0 HP5Mtmp HP8P9P12Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP5M1. try clear HP5M2. try clear HP5M3. try clear HP5m4. try clear HP5m3. try clear HP5m2. try clear HP5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P8P9P12m2 : rk(P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP5P8mtmp : rk(P5 :: P8 :: nil) >= 2) by (solve_hyps_min HP5P8eq HP5P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P8 :: nil) (P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P8 :: nil) (P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P8P9P12m3 : rk(P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P12eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP1P2P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP1P2P5P8P9P12mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P12eq HP1P2P5P8P9P12m4).
	try assert(HP5P9eq : rk(P5 :: P9 :: nil) = 2) by (apply LP5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hincl : incl (P5 :: P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P5 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P12 :: nil) (P1 :: P2 :: P5 :: P9 :: P5 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P5 :: P8 :: P9 :: P12 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P5 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P12mtmp;try rewrite HT2 in HP1P2P5P8P9P12mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P5 :: P8 :: P9 :: P12 :: nil) (P5 :: P9 :: nil) 4 2 3 HP1P2P5P8P9P12mtmp HP5P9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P5P9M1. try clear HP1P2P5P9M2. try clear HP1P2P5P9M3. try clear HP1P2P5P9m4. try clear HP1P2P5P9m3. try clear HP1P2P5P9m2. try clear HP1P2P5P9m1. try clear HP5P9M1. try clear HP5P9M2. try clear HP5P9M3. try clear HP5P9m4. try clear HP5P9m3. try clear HP5P9m2. try clear HP5P9m1. try clear HP1P2P5P8P9P12M1. try clear HP1P2P5P8P9P12M2. try clear HP1P2P5P8P9P12M3. try clear HP1P2P5P8P9P12m4. try clear HP1P2P5P8P9P12m3. try clear HP1P2P5P8P9P12m2. try clear HP1P2P5P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P8P12m2 : rk(P5 :: P8 :: P12 :: nil) >= 2).
{
	assert(HP5P8mtmp : rk(P5 :: P8 :: nil) >= 2) by (solve_hyps_min HP5P8eq HP5P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P8 :: nil) (P5 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P8 :: nil) (P5 :: P8 :: P12 :: nil) 2 2 HP5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP5P8M1. try clear HP5P8M2. try clear HP5P8M3. try clear HP5P8m4. try clear HP5P8m3. try clear HP5P8m2. try clear HP5P8m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P8P12m3 : rk(P5 :: P8 :: P12 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP5P8P9P12eq : rk(P5 :: P8 :: P9 :: P12 :: nil) = 3) by (apply LP5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP5P8P9P12mtmp : rk(P5 :: P8 :: P9 :: P12 :: nil) >= 3) by (solve_hyps_min HP5P8P9P12eq HP5P8P9P12m3).
	try assert(HP8P12eq : rk(P8 :: P12 :: nil) = 2) by (apply LP8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P12mtmp : rk(P8 :: P12 :: nil) >= 2) by (solve_hyps_min HP8P12eq HP8P12m2).
	assert(Hincl : incl (P8 :: P12 :: nil) (list_inter (P5 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P8 :: P9 :: P12 :: nil) (P5 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P8 :: P12 :: P8 :: P9 :: P12 :: nil) ((P5 :: P8 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P8P9P12mtmp;try rewrite HT2 in HP5P8P9P12mtmp.
	assert(HT := rule_2 (P5 :: P8 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P8 :: P12 :: nil) 3 2 2 HP5P8P9P12mtmp HP8P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP8P12M1. try clear HP8P12M2. try clear HP8P12M3. try clear HP8P12m4. try clear HP8P12m3. try clear HP8P12m2. try clear HP8P12m1. try clear HP5P8P9P12M1. try clear HP5P8P9P12M2. try clear HP5P8P9P12M3. try clear HP5P8P9P12m4. try clear HP5P8P9P12m3. try clear HP5P8P9P12m2. try clear HP5P8P9P12m1. 

assert(HP5P8P12M : rk(P5 :: P8 :: P12 ::  nil) <= 3) by (solve_hyps_max HP5P8P12eq HP5P8P12M3).
assert(HP5P8P12m : rk(P5 :: P8 :: P12 ::  nil) >= 1) by (solve_hyps_min HP5P8P12eq HP5P8P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP3P5P8P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P3 :: P5 :: P8 :: P12 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P8P12m2 : rk(P3 :: P5 :: P8 :: P12 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P12 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P8P12m3 : rk(P3 :: P5 :: P8 :: P12 :: nil) >= 3).
{
	assert(HP3P5P8mtmp : rk(P3 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P5P8eq HP3P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P12 :: nil) 3 3 HP3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5P8M1. try clear HP3P5P8M2. try clear HP3P5P8M3. try clear HP3P5P8m4. try clear HP3P5P8m3. try clear HP3P5P8m2. try clear HP3P5P8m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P5P8P12M3 : rk(P3 :: P5 :: P8 :: P12 :: nil) <= 3).
{
	assert(HP3P5P8P9P12Mtmp : rk(P3 :: P5 :: P8 :: P9 :: P12 :: nil) <= 3) by (solve_hyps_max HP3P5P8P9P12eq HP3P5P8P9P12M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP3P5P8P9P12Mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5P8P9P12M1. try clear HP3P5P8P9P12M2. try clear HP3P5P8P9P12M3. try clear HP3P5P8P9P12m4. try clear HP3P5P8P9P12m3. try clear HP3P5P8P9P12m2. try clear HP3P5P8P9P12m1. 

assert(HP3P5P8P12M : rk(P3 :: P5 :: P8 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P5P8P12m : rk(P3 :: P5 :: P8 :: P12 ::  nil) >= 1) by (solve_hyps_min HP3P5P8P12eq HP3P5P8P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP8P9P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P8 :: P9 :: P12 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

assert(HP8P9P12M : rk(P8 :: P9 :: P12 ::  nil) <= 3) by (solve_hyps_max HP8P9P12eq HP8P9P12M3).
assert(HP8P9P12m : rk(P8 :: P9 :: P12 ::  nil) >= 1) by (solve_hyps_min HP8P9P12eq HP8P9P12m1).
intuition.
Qed.

(* dans la couche 4 *)
Lemma LP3P4P11P12 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P3 :: P4 :: P11 :: P12 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P12m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P12m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P12m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5P8M1. try clear HP3P4P5P8M2. try clear HP3P4P5P8M3. try clear HP3P4P5P8m4. try clear HP3P4P5P8m3. try clear HP3P4P5P8m2. try clear HP3P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P8P9P12m2 : rk(P3 :: P4 :: P8 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P8P9P12m3 : rk(P3 :: P4 :: P8 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP3P4P8mtmp : rk(P3 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P4P8eq HP3P4P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P8 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P8 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil) 3 3 HP3P4P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P8M1. try clear HP3P4P8M2. try clear HP3P4P8M3. try clear HP3P4P8m4. try clear HP3P4P8m3. try clear HP3P4P8m2. try clear HP3P4P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P8P9P12m4 : rk(P3 :: P4 :: P8 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P12eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P4P5P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P4P5P8P9P12mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P12eq HP3P4P5P8P9P12m4).
	try assert(HP3P9eq : rk(P3 :: P9 :: nil) = 2) by (apply LP3P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P9mtmp : rk(P3 :: P9 :: nil) >= 2) by (solve_hyps_min HP3P9eq HP3P9m2).
	assert(Hincl : incl (P3 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P12 :: nil) (P3 :: P5 :: P9 :: P3 :: P4 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P3 :: P4 :: P8 :: P9 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P3 :: P4 :: P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P12mtmp;try rewrite HT2 in HP3P4P5P8P9P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P3 :: P4 :: P8 :: P9 :: P12 :: nil) (P3 :: P9 :: nil) 4 2 2 HP3P4P5P8P9P12mtmp HP3P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P9M1. try clear HP3P9M2. try clear HP3P9M3. try clear HP3P9m4. try clear HP3P9m3. try clear HP3P9m2. try clear HP3P9m1. try clear HP3P4P5P8P9P12M1. try clear HP3P4P5P8P9P12M2. try clear HP3P4P5P8P9P12M3. try clear HP3P4P5P8P9P12m4. try clear HP3P4P5P8P9P12m3. try clear HP3P4P5P8P9P12m2. try clear HP3P4P5P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P9P12m2 : rk(P3 :: P4 :: P9 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P9 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P9P12m3 : rk(P3 :: P4 :: P9 :: P12 :: nil) >= 3).
{
	assert(HP3P4P9mtmp : rk(P3 :: P4 :: P9 :: nil) >= 3) by (solve_hyps_min HP3P4P9eq HP3P4P9m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P9 :: nil) (P3 :: P4 :: P9 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P9 :: nil) (P3 :: P4 :: P9 :: P12 :: nil) 3 3 HP3P4P9mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P9M1. try clear HP3P4P9M2. try clear HP3P4P9M3. try clear HP3P4P9m4. try clear HP3P4P9m3. try clear HP3P4P9m2. try clear HP3P4P9m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P9P12m4 : rk(P3 :: P4 :: P9 :: P12 :: nil) >= 4).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP3P4P8P9P12eq : rk(P3 :: P4 :: P8 :: P9 :: P12 :: nil) = 4) by (apply LP3P4P8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P4P8P9P12mtmp : rk(P3 :: P4 :: P8 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P8P9P12eq HP3P4P8P9P12m4).
	try assert(HP9P12eq : rk(P9 :: P12 :: nil) = 2) by (apply LP9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP9P12mtmp : rk(P9 :: P12 :: nil) >= 2) by (solve_hyps_min HP9P12eq HP9P12m2).
	assert(Hincl : incl (P9 :: P12 :: nil) (list_inter (P3 :: P4 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P8 :: P9 :: P12 :: nil) (P3 :: P4 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P9 :: P12 :: P8 :: P9 :: P12 :: nil) ((P3 :: P4 :: P9 :: P12 :: nil) ++ (P8 :: P9 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P8P9P12mtmp;try rewrite HT2 in HP3P4P8P9P12mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P9 :: P12 :: nil) (P8 :: P9 :: P12 :: nil) (P9 :: P12 :: nil) 4 2 2 HP3P4P8P9P12mtmp HP9P12mtmp HP8P9P12Mtmp Hincl);apply HT.
}
try clear HP8P9P12M1. try clear HP8P9P12M2. try clear HP8P9P12M3. try clear HP8P9P12m4. try clear HP8P9P12m3. try clear HP8P9P12m2. try clear HP8P9P12m1. try clear HP9P12M1. try clear HP9P12M2. try clear HP9P12M3. try clear HP9P12m4. try clear HP9P12m3. try clear HP9P12m2. try clear HP9P12m1. try clear HP3P4P8P9P12M1. try clear HP3P4P8P9P12M2. try clear HP3P4P8P9P12M3. try clear HP3P4P8P9P12m4. try clear HP3P4P8P9P12m3. try clear HP3P4P8P9P12m2. try clear HP3P4P8P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P9P11P12m2 : rk(P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P9P11P12m3 : rk(P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P4P5P9P11P12m4 : rk(P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) >= 4).
{
	assert(HP3P4P9P12mtmp : rk(P3 :: P4 :: P9 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P9P12eq HP3P4P9P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P9 :: P12 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P9 :: P12 :: nil) (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) 4 4 HP3P4P9P12mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P9P12M1. try clear HP3P4P9P12M2. try clear HP3P4P9P12M3. try clear HP3P4P9P12m4. try clear HP3P4P9P12m3. try clear HP3P4P9P12m2. try clear HP3P4P9P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P11P12m2 : rk(P3 :: P4 :: P5 :: P11 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P11P12m3 : rk(P3 :: P4 :: P5 :: P11 :: P12 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5M1. try clear HP3P4P5M2. try clear HP3P4P5M3. try clear HP3P4P5m4. try clear HP3P4P5m3. try clear HP3P4P5m2. try clear HP3P4P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P11P12m4 : rk(P3 :: P4 :: P5 :: P11 :: P12 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P9P11P12eq : rk(P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) = 4) by (apply LP3P4P5P9P11P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P4P5P9P11P12mtmp : rk(P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P5P9P11P12eq HP3P4P5P9P11P12m4).
	try assert(HP3P5eq : rk(P3 :: P5 :: nil) = 2) by (apply LP3P5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hincl : incl (P3 :: P5 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P9 :: P11 :: P12 :: nil) (P3 :: P5 :: P9 :: P3 :: P4 :: P5 :: P11 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P3 :: P4 :: P5 :: P11 :: P12 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P3 :: P4 :: P5 :: P11 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P9P11P12mtmp;try rewrite HT2 in HP3P4P5P9P11P12mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P3 :: P4 :: P5 :: P11 :: P12 :: nil) (P3 :: P5 :: nil) 4 2 2 HP3P4P5P9P11P12mtmp HP3P5mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P9M1. try clear HP3P5P9M2. try clear HP3P5P9M3. try clear HP3P5P9m4. try clear HP3P5P9m3. try clear HP3P5P9m2. try clear HP3P5P9m1. try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. try clear HP3P4P5P9P11P12M1. try clear HP3P4P5P9P11P12M2. try clear HP3P4P5P9P11P12M3. try clear HP3P4P5P9P11P12m4. try clear HP3P4P5P9P11P12m3. try clear HP3P4P5P9P11P12m2. try clear HP3P4P5P9P11P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P11P12m2 : rk(P3 :: P4 :: P11 :: P12 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: P12 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: P12 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P11P12m3 : rk(P3 :: P4 :: P11 :: P12 :: nil) >= 3).
{
	try assert(HP3P4P11eq : rk(P3 :: P4 :: P11 :: nil) = 3) by (apply LP3P4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P11P12m4 : rk(P3 :: P4 :: P11 :: P12 :: nil) >= 4).
{
	try assert(HP3P4P5P11eq : rk(P3 :: P4 :: P5 :: P11 :: nil) = 3) by (apply LP3P4P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P5P11Mtmp : rk(P3 :: P4 :: P5 :: P11 :: nil) <= 3) by (solve_hyps_max HP3P4P5P11eq HP3P4P5P11M3).
	try assert(HP3P4P5P11P12eq : rk(P3 :: P4 :: P5 :: P11 :: P12 :: nil) = 4) by (apply LP3P4P5P11P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P4P5P11P12mtmp : rk(P3 :: P4 :: P5 :: P11 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P5P11P12eq HP3P4P5P11P12m4).
	try assert(HP3P4P11eq : rk(P3 :: P4 :: P11 :: nil) = 3) by (apply LP3P4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P4P11mtmp : rk(P3 :: P4 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P4P11eq HP3P4P11m3).
	assert(Hincl : incl (P3 :: P4 :: P11 :: nil) (list_inter (P3 :: P4 :: P5 :: P11 :: nil) (P3 :: P4 :: P11 :: P12 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P11 :: P12 :: nil) (P3 :: P4 :: P5 :: P11 :: P3 :: P4 :: P11 :: P12 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P11 :: P3 :: P4 :: P11 :: P12 :: nil) ((P3 :: P4 :: P5 :: P11 :: nil) ++ (P3 :: P4 :: P11 :: P12 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P11P12mtmp;try rewrite HT2 in HP3P4P5P11P12mtmp.
	assert(HT := rule_4 (P3 :: P4 :: P5 :: P11 :: nil) (P3 :: P4 :: P11 :: P12 :: nil) (P3 :: P4 :: P11 :: nil) 4 3 3 HP3P4P5P11P12mtmp HP3P4P11mtmp HP3P4P5P11Mtmp Hincl); apply HT.
}
try clear HP3P4P5P11M1. try clear HP3P4P5P11M2. try clear HP3P4P5P11M3. try clear HP3P4P5P11m4. try clear HP3P4P5P11m3. try clear HP3P4P5P11m2. try clear HP3P4P5P11m1. try clear HP3P4P11M1. try clear HP3P4P11M2. try clear HP3P4P11M3. try clear HP3P4P11m4. try clear HP3P4P11m3. try clear HP3P4P11m2. try clear HP3P4P11m1. try clear HP3P4P5P11P12M1. try clear HP3P4P5P11P12M2. try clear HP3P4P5P11P12M3. try clear HP3P4P5P11P12m4. try clear HP3P4P5P11P12m3. try clear HP3P4P5P11P12m2. try clear HP3P4P5P11P12m1. 

assert(HP3P4P11P12M : rk(P3 :: P4 :: P11 :: P12 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P4P11P12m : rk(P3 :: P4 :: P11 :: P12 ::  nil) >= 1) by (solve_hyps_min HP3P4P11P12eq HP3P4P11P12m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P13 ::  nil) = 1.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

assert(HP13M : rk(P13 ::  nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
assert(HP13m : rk(P13 ::  nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP2P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P2 :: P13 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P12P14m2 : rk(P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P12P14m3 : rk(P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P7P12P14m4 : rk(P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P7P12eq : rk(P1 :: P2 :: P7 :: P12 :: nil) = 4) by (apply LP1P2P7P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P2P7P12M1. try clear HP1P2P7P12M2. try clear HP1P2P7P12M3. try clear HP1P2P7P12m4. try clear HP1P2P7P12m3. try clear HP1P2P7P12m2. try clear HP1P2P7P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P13P14m2 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P13P14m3 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P13P14m4 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P12P14M3 : rk(P2 :: P3 :: P12 :: P14 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P12 :: P14 :: nil) (P2 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P12 :: P14 :: nil) ((P2 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P3 :: P12 :: P14 :: nil) (nil) 1 2 0 HP2Mtmp HP3P12P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P12P14m2 : rk(P2 :: P3 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P12 :: P14 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P12P14m3 : rk(P2 :: P3 :: P12 :: P14 :: nil) >= 3).
{
	try assert(HP2P3P12eq : rk(P2 :: P3 :: P12 :: nil) = 3) by (apply LP2P3P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP2P3P12M1. try clear HP2P3P12M2. try clear HP2P3P12M3. try clear HP2P3P12m4. try clear HP2P3P12m3. try clear HP2P3P12m2. try clear HP2P3P12m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P14m2 : rk(P2 :: P14 :: nil) >= 2).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP2P3P12P14eq : rk(P2 :: P3 :: P12 :: P14 :: nil) = 3) by (apply LP2P3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P3P12P14mtmp : rk(P2 :: P3 :: P12 :: P14 :: nil) >= 3) by (solve_hyps_min HP2P3P12P14eq HP2P3P12P14m3).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P2 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P12 :: P14 :: nil) (P2 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P14 :: P3 :: P12 :: P14 :: nil) ((P2 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P12P14mtmp;try rewrite HT2 in HP2P3P12P14mtmp.
	assert(HT := rule_2 (P2 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P14 :: nil) 3 1 2 HP2P3P12P14mtmp HP14mtmp HP3P12P14Mtmp Hincl);apply HT.
}
try clear HP2P3P12P14M1. try clear HP2P3P12P14M2. try clear HP2P3P12P14M3. try clear HP2P3P12P14m4. try clear HP2P3P12P14m3. try clear HP2P3P12P14m2. try clear HP2P3P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P13P14m2 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P13P14m3 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP2P7P8mtmp : rk(P2 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P7P8eq HP2P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil) 3 3 HP2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7P8M1. try clear HP2P7P8M2. try clear HP2P7P8M3. try clear HP2P7P8m4. try clear HP2P7P8m3. try clear HP2P7P8m2. try clear HP2P7P8m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P8P13P14M3 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P13 :: P14 :: nil) (P2 :: P8 :: P13 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P7 :: P13 :: P14 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P8 :: P13 :: nil) (P7 :: P13 :: P14 :: nil) (P13 :: nil) 2 2 1 HP2P8P13Mtmp HP7P13P14Mtmp HP13mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P14m2 : rk(P1 :: P2 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P14m3 : rk(P1 :: P2 :: P14 :: nil) >= 3).
{
	try assert(HP2P7P8P13P14eq : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) = 3) by (apply LP2P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P7P8P13P14Mtmp : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) <= 3) by (solve_hyps_max HP2P7P8P13P14eq HP2P7P8P13P14M3).
	try assert(HP1P2P7P8P13P14eq : rk(P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P7P8P13P14mtmp : rk(P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8P13P14eq HP1P2P7P8P13P14m4).
	try assert(HP2P14eq : rk(P2 :: P14 :: nil) = 2) by (apply LP2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P14mtmp : rk(P2 :: P14 :: nil) >= 2) by (solve_hyps_min HP2P14eq HP2P14m2).
	assert(Hincl : incl (P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P14 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) (P1 :: P2 :: P14 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P14 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) ((P1 :: P2 :: P14 :: nil) ++ (P2 :: P7 :: P8 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P8P13P14mtmp;try rewrite HT2 in HP1P2P7P8P13P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P14 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil) (P2 :: P14 :: nil) 4 2 3 HP1P2P7P8P13P14mtmp HP2P14mtmp HP2P7P8P13P14Mtmp Hincl);apply HT.
}
try clear HP2P14M1. try clear HP2P14M2. try clear HP2P14M3. try clear HP2P14m4. try clear HP2P14m3. try clear HP2P14m2. try clear HP2P14m1. try clear HP1P2P7P8P13P14M1. try clear HP1P2P7P8P13P14M2. try clear HP1P2P7P8P13P14M3. try clear HP1P2P7P8P13P14m4. try clear HP1P2P7P8P13P14m3. try clear HP1P2P7P8P13P14m2. try clear HP1P2P7P8P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P12P14m2 : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P12P14M3 : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3mtmp : rk(P3 :: nil) >= 1) by (solve_hyps_min HP3eq HP3m1).
	assert(Hincl : incl (P3 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P12 :: P14 :: nil) (P1 :: P2 :: P3 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P3 :: P12 :: P14 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P3 :: P12 :: P14 :: nil) (P3 :: nil) 2 2 1 HP1P2P3Mtmp HP3P12P14Mtmp HP3mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P12P14m3 : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) >= 3).
{
	try assert(HP1P2P12eq : rk(P1 :: P2 :: P12 :: nil) = 3) by (apply LP1P2P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P2P12M1. try clear HP1P2P12M2. try clear HP1P2P12M3. try clear HP1P2P12m4. try clear HP1P2P12m3. try clear HP1P2P12m2. try clear HP1P2P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P14m2 : rk(P1 :: P2 :: P7 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P14m3 : rk(P1 :: P2 :: P7 :: P14 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P14 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P14m4 : rk(P1 :: P2 :: P7 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P3P12P14eq : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) = 3) by (apply LP1P2P3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P12P14Mtmp : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P2P3P12P14eq HP1P2P3P12P14M3).
	try assert(HP1P2P3P7P12P14eq : rk(P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) = 4) by (apply LP1P2P3P7P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P7P12P14mtmp : rk(P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P3P7P12P14eq HP1P2P3P7P12P14m4).
	try assert(HP1P2P14eq : rk(P1 :: P2 :: P14 :: nil) = 3) by (apply LP1P2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P14mtmp : rk(P1 :: P2 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P14eq HP1P2P14m3).
	assert(Hincl : incl (P1 :: P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P7 :: P14 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P7 :: P12 :: P14 :: nil) (P1 :: P2 :: P7 :: P14 :: P1 :: P2 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P14 :: P1 :: P2 :: P3 :: P12 :: P14 :: nil) ((P1 :: P2 :: P7 :: P14 :: nil) ++ (P1 :: P2 :: P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P7P12P14mtmp;try rewrite HT2 in HP1P2P3P7P12P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P7 :: P14 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil) (P1 :: P2 :: P14 :: nil) 4 3 3 HP1P2P3P7P12P14mtmp HP1P2P14mtmp HP1P2P3P12P14Mtmp Hincl);apply HT.
}
try clear HP1P2P3P7P12P14M1. try clear HP1P2P3P7P12P14M2. try clear HP1P2P3P7P12P14M3. try clear HP1P2P3P7P12P14m4. try clear HP1P2P3P7P12P14m3. try clear HP1P2P3P7P12P14m2. try clear HP1P2P3P7P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P13P14m2 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P13P14m3 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P7P13P14m4 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P2P7P14mtmp : rk(P1 :: P2 :: P7 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P7P14eq HP1P2P7P14m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P14 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P14 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: nil) 4 4 HP1P2P7P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7P14M1. try clear HP1P2P7P14M2. try clear HP1P2P7P14M3. try clear HP1P2P7P14m4. try clear HP1P2P7P14m3. try clear HP1P2P7P14m2. try clear HP1P2P7P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P8P12P13P14m2 : rk(P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P8P12P13P14m3 : rk(P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP2P3P8mtmp : rk(P2 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P3P8eq HP2P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P8 :: nil) (P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) 3 3 HP2P3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P8M1. try clear HP2P3P8M2. try clear HP2P3P8M3. try clear HP2P3P8m4. try clear HP2P3P8m3. try clear HP2P3P8m2. try clear HP2P3P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P8P12P13P14m4 : rk(P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP2P3P8P12eq : rk(P2 :: P3 :: P8 :: P12 :: nil) = 4) by (apply LP2P3P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP2P3P8P12M1. try clear HP2P3P8P12M2. try clear HP2P3P8P12M3. try clear HP2P3P8P12m4. try clear HP2P3P8P12m3. try clear HP2P3P8P12m2. try clear HP2P3P8P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P12P13P14m2 : rk(P3 :: P12 :: P13 :: P14 :: nil) >= 2).
{
	try assert(HP3P12eq : rk(P3 :: P12 :: nil) = 2) by (apply LP3P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P12P13P14M3 : rk(P3 :: P12 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13Mtmp : rk(P13 :: nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P13 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P12 :: P13 :: P14 :: nil) (P13 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P13 :: P3 :: P12 :: P14 :: nil) ((P13 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P13 :: nil) (P3 :: P12 :: P14 :: nil) (nil) 1 2 0 HP13Mtmp HP3P12P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P12P13P14m3 : rk(P3 :: P12 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P3P8P12P13P14eq : rk(P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) = 4) by (apply LP2P3P8P12P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P3P8P12P13P14mtmp : rk(P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP2P3P8P12P13P14eq HP2P3P8P12P13P14m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P3 :: P12 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P8 :: P12 :: P13 :: P14 :: nil) (P2 :: P8 :: P13 :: P3 :: P12 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P3 :: P12 :: P13 :: P14 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P3 :: P12 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P8P12P13P14mtmp;try rewrite HT2 in HP2P3P8P12P13P14mtmp.
	assert(HT := rule_4 (P2 :: P8 :: P13 :: nil) (P3 :: P12 :: P13 :: P14 :: nil) (P13 :: nil) 4 1 2 HP2P3P8P12P13P14mtmp HP13mtmp HP2P8P13Mtmp Hincl); apply HT.
}
try clear HP2P3P8P12P13P14M1. try clear HP2P3P8P12P13P14M2. try clear HP2P3P8P12P13P14M3. try clear HP2P3P8P12P13P14m4. try clear HP2P3P8P12P13P14m3. try clear HP2P3P8P12P13P14m2. try clear HP2P3P8P12P13P14m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP13P14m2 : rk(P13 :: P14 :: nil) >= 2).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP3P12P13P14eq : rk(P3 :: P12 :: P13 :: P14 :: nil) = 3) by (apply LP3P12P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P13P14mtmp : rk(P3 :: P12 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP3P12P13P14eq HP3P12P13P14m3).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P3 :: P12 :: P14 :: nil) (P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P12 :: P13 :: P14 :: nil) (P3 :: P12 :: P14 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P12 :: P14 :: P13 :: P14 :: nil) ((P3 :: P12 :: P14 :: nil) ++ (P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P12P13P14mtmp;try rewrite HT2 in HP3P12P13P14mtmp.
	assert(HT := rule_4 (P3 :: P12 :: P14 :: nil) (P13 :: P14 :: nil) (P14 :: nil) 3 1 2 HP3P12P13P14mtmp HP14mtmp HP3P12P14Mtmp Hincl); apply HT.
}
try clear HP3P12P13P14M1. try clear HP3P12P13P14M2. try clear HP3P12P13P14M3. try clear HP3P12P13P14m4. try clear HP3P12P13P14m3. try clear HP3P12P13P14m2. try clear HP3P12P13P14m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P3P12P14M3 : rk(P1 :: P3 :: P12 :: P14 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P12 :: P14 :: nil) (P1 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P12 :: P14 :: nil) ((P1 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P3 :: P12 :: P14 :: nil) (nil) 1 2 0 HP1Mtmp HP3P12P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P12P14m2 : rk(P1 :: P3 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P12 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P12P14m3 : rk(P1 :: P3 :: P12 :: P14 :: nil) >= 3).
{
	try assert(HP1P3P12eq : rk(P1 :: P3 :: P12 :: nil) = 3) by (apply LP1P3P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P3P12M1. try clear HP1P3P12M2. try clear HP1P3P12M3. try clear HP1P3P12m4. try clear HP1P3P12m3. try clear HP1P3P12m2. try clear HP1P3P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P13m2 : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P13m3 : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P13m4 : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP2P3P7P8mtmp : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8eq HP2P3P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: P13 :: nil) 4 4 HP2P3P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P7P8M1. try clear HP2P3P7P8M2. try clear HP2P3P7P8M3. try clear HP2P3P7P8m4. try clear HP2P3P7P8m3. try clear HP2P3P7P8m2. try clear HP2P3P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P13m2 : rk(P3 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P13 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P7P13m3 : rk(P3 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P3P7P8P13eq : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P3P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P3P7P8P13mtmp : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8P13eq HP2P3P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P7 :: P8 :: P13 :: nil) (P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P3 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P7P8P13mtmp;try rewrite HT2 in HP2P3P7P8P13mtmp.
	assert(HT := rule_2 (P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P3P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P7P13P14M3 : rk(P3 :: P7 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP3eq : rk(P3 :: nil) = 1) by (apply LP3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP3Mtmp : rk(P3 :: nil) <= 1) by (solve_hyps_max HP3eq HP3M1).
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P13 :: P14 :: nil) (P3 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P13 :: P14 :: nil) ((P3 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: nil) (P7 :: P13 :: P14 :: nil) (nil) 1 2 0 HP3Mtmp HP7P13P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3M1. try clear HP3M2. try clear HP3M3. try clear HP3m4. try clear HP3m3. try clear HP3m2. try clear HP3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P13P14m2 : rk(P3 :: P7 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P13 :: P14 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P7P13P14m3 : rk(P3 :: P7 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP3P7P13mtmp : rk(P3 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP3P7P13eq HP3P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: P13 :: nil) (P3 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: P13 :: nil) (P3 :: P7 :: P13 :: P14 :: nil) 3 3 HP3P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7P13M1. try clear HP3P7P13M2. try clear HP3P7P13M3. try clear HP3P7P13m4. try clear HP3P7P13m3. try clear HP3P7P13m2. try clear HP3P7P13m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P14m2 : rk(P3 :: P14 :: nil) >= 2).
{
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP3P7P13P14eq : rk(P3 :: P7 :: P13 :: P14 :: nil) = 3) by (apply LP3P7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P7P13P14mtmp : rk(P3 :: P7 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP3P7P13P14eq HP3P7P13P14m3).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P3 :: P14 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P13 :: P14 :: nil) (P3 :: P14 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P14 :: P7 :: P13 :: P14 :: nil) ((P3 :: P14 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P7P13P14mtmp;try rewrite HT2 in HP3P7P13P14mtmp.
	assert(HT := rule_2 (P3 :: P14 :: nil) (P7 :: P13 :: P14 :: nil) (P14 :: nil) 3 1 2 HP3P7P13P14mtmp HP14mtmp HP7P13P14Mtmp Hincl);apply HT.
}
try clear HP3P7P13P14M1. try clear HP3P7P13P14M2. try clear HP3P7P13P14M3. try clear HP3P7P13P14m4. try clear HP3P7P13P14m3. try clear HP3P7P13P14m2. try clear HP3P7P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P14m2 : rk(P1 :: P3 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P14m3 : rk(P1 :: P3 :: P14 :: nil) >= 3).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP1P3P12P14eq : rk(P1 :: P3 :: P12 :: P14 :: nil) = 3) by (apply LP1P3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P12P14mtmp : rk(P1 :: P3 :: P12 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P3P12P14eq HP1P3P12P14m3).
	try assert(HP3P14eq : rk(P3 :: P14 :: nil) = 2) by (apply LP3P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P14mtmp : rk(P3 :: P14 :: nil) >= 2) by (solve_hyps_min HP3P14eq HP3P14m2).
	assert(Hincl : incl (P3 :: P14 :: nil) (list_inter (P1 :: P3 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P12 :: P14 :: nil) (P1 :: P3 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P14 :: P3 :: P12 :: P14 :: nil) ((P1 :: P3 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P12P14mtmp;try rewrite HT2 in HP1P3P12P14mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P3 :: P14 :: nil) 3 2 2 HP1P3P12P14mtmp HP3P14mtmp HP3P12P14Mtmp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P13P14m2 : rk(P1 :: P2 :: P3 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P13P14m3 : rk(P1 :: P2 :: P3 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P3P14mtmp : rk(P1 :: P3 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P3P14eq HP1P3P14m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P14 :: nil) (P1 :: P2 :: P3 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P14 :: nil) (P1 :: P2 :: P3 :: P13 :: P14 :: nil) 3 3 HP1P3P14mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P14m2 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P14m3 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P14m4 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P14m2 : rk(P1 :: P2 :: P5 :: P8 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P14m3 : rk(P1 :: P2 :: P5 :: P8 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P14m4 : rk(P1 :: P2 :: P5 :: P8 :: P14 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P14m2 : rk(P1 :: P2 :: P3 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P14M3 : rk(P1 :: P2 :: P3 :: P14 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14Mtmp : rk(P14 :: nil) <= 1) by (solve_hyps_max HP14eq HP14M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P3 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P14 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P14 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P14m3 : rk(P1 :: P2 :: P3 :: P14 :: nil) >= 3).
{
	try assert(HP1P2P5P8P14eq : rk(P1 :: P2 :: P5 :: P8 :: P14 :: nil) = 4) by (apply LP1P2P5P8P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P8P14Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P14 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P14eq HP1P2P5P8P14M4).
	try assert(HP1P2P3P5P8P14eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) = 4) by (apply LP1P2P3P5P8P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P5P8P14mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8P14eq HP1P2P3P5P8P14m4).
	try assert(HP1P2P14eq : rk(P1 :: P2 :: P14 :: nil) = 3) by (apply LP1P2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P14mtmp : rk(P1 :: P2 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P14eq HP1P2P14m3).
	assert(Hincl : incl (P1 :: P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: P14 :: nil) (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P5 :: P8 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P5 :: P8 :: P14 :: nil) ((P1 :: P2 :: P3 :: P14 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8P14mtmp;try rewrite HT2 in HP1P2P3P5P8P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P5 :: P8 :: P14 :: nil) (P1 :: P2 :: P14 :: nil) 4 3 4 HP1P2P3P5P8P14mtmp HP1P2P14mtmp HP1P2P5P8P14Mtmp Hincl);apply HT.
}
try clear HP1P2P5P8P14M1. try clear HP1P2P5P8P14M2. try clear HP1P2P5P8P14M3. try clear HP1P2P5P8P14m4. try clear HP1P2P5P8P14m3. try clear HP1P2P5P8P14m2. try clear HP1P2P5P8P14m1. try clear HP1P2P3P5P8P14M1. try clear HP1P2P3P5P8P14M2. try clear HP1P2P3P5P8P14M3. try clear HP1P2P3P5P8P14m4. try clear HP1P2P3P5P8P14m3. try clear HP1P2P3P5P8P14m2. try clear HP1P2P3P5P8P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P13P14m2 : rk(P1 :: P2 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P13P14m3 : rk(P1 :: P2 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P2P3P14eq : rk(P1 :: P2 :: P3 :: P14 :: nil) = 3) by (apply LP1P2P3P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P14Mtmp : rk(P1 :: P2 :: P3 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P2P3P14eq HP1P2P3P14M3).
	try assert(HP1P2P3P13P14eq : rk(P1 :: P2 :: P3 :: P13 :: P14 :: nil) = 3) by (apply LP1P2P3P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P13P14mtmp : rk(P1 :: P2 :: P3 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P3P13P14eq HP1P2P3P13P14m3).
	try assert(HP1P2P14eq : rk(P1 :: P2 :: P14 :: nil) = 3) by (apply LP1P2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P14mtmp : rk(P1 :: P2 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P14eq HP1P2P14m3).
	assert(Hincl : incl (P1 :: P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P13 :: P14 :: nil) (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P13 :: P14 :: nil) ((P1 :: P2 :: P3 :: P14 :: nil) ++ (P1 :: P2 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P13P14mtmp;try rewrite HT2 in HP1P2P3P13P14mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P13 :: P14 :: nil) (P1 :: P2 :: P14 :: nil) 3 3 3 HP1P2P3P13P14mtmp HP1P2P14mtmp HP1P2P3P14Mtmp Hincl); apply HT.
}
try clear HP1P2P3P13P14M1. try clear HP1P2P3P13P14M2. try clear HP1P2P3P13P14M3. try clear HP1P2P3P13P14m4. try clear HP1P2P3P13P14m3. try clear HP1P2P3P13P14m2. try clear HP1P2P3P13P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P13P14m4 : rk(P1 :: P2 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP1P2P7P13P14eq : rk(P1 :: P2 :: P7 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P7P13P14mtmp : rk(P1 :: P2 :: P7 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P7P13P14eq HP1P2P7P13P14m4).
	try assert(HP13P14eq : rk(P13 :: P14 :: nil) = 2) by (apply LP13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13P14mtmp : rk(P13 :: P14 :: nil) >= 2) by (solve_hyps_min HP13P14eq HP13P14m2).
	assert(Hincl : incl (P13 :: P14 :: nil) (list_inter (P1 :: P2 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P13 :: P14 :: nil) (P1 :: P2 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil) ((P1 :: P2 :: P13 :: P14 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P13P14mtmp;try rewrite HT2 in HP1P2P7P13P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil) (P13 :: P14 :: nil) 4 2 2 HP1P2P7P13P14mtmp HP13P14mtmp HP7P13P14Mtmp Hincl);apply HT.
}
try clear HP1P2P7P13P14M1. try clear HP1P2P7P13P14M2. try clear HP1P2P7P13P14M3. try clear HP1P2P7P13P14m4. try clear HP1P2P7P13P14m3. try clear HP1P2P7P13P14m2. try clear HP1P2P7P13P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P14m2 : rk(P1 :: P14 :: nil) >= 2).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP1P3P12P14eq : rk(P1 :: P3 :: P12 :: P14 :: nil) = 3) by (apply LP1P3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P12P14mtmp : rk(P1 :: P3 :: P12 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P3P12P14eq HP1P3P12P14m3).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P1 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P12 :: P14 :: nil) (P1 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P14 :: P3 :: P12 :: P14 :: nil) ((P1 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P12P14mtmp;try rewrite HT2 in HP1P3P12P14mtmp.
	assert(HT := rule_2 (P1 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P14 :: nil) 3 1 2 HP1P3P12P14mtmp HP14mtmp HP3P12P14Mtmp Hincl);apply HT.
}
try clear HP1P3P12P14M1. try clear HP1P3P12P14M2. try clear HP1P3P12P14M3. try clear HP1P3P12P14m4. try clear HP1P3P12P14m3. try clear HP1P3P12P14m2. try clear HP1P3P12P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P13m2 : rk(P2 :: P13 :: nil) >= 2).
{
	try assert(HP1P14eq : rk(P1 :: P14 :: nil) = 2) by (apply LP1P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P14Mtmp : rk(P1 :: P14 :: nil) <= 2) by (solve_hyps_max HP1P14eq HP1P14M2).
	try assert(HP1P2P13P14eq : rk(P1 :: P2 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P13P14mtmp : rk(P1 :: P2 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P13P14eq HP1P2P13P14m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P13 :: nil) (P1 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P13 :: P14 :: nil) (P2 :: P13 :: P1 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P13 :: P1 :: P14 :: nil) ((P2 :: P13 :: nil) ++ (P1 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P13P14mtmp;try rewrite HT2 in HP1P2P13P14mtmp.
	assert(HT := rule_2 (P2 :: P13 :: nil) (P1 :: P14 :: nil) (nil) 4 0 2 HP1P2P13P14mtmp Hmtmp HP1P14Mtmp Hincl);apply HT.
}


assert(HP2P13M : rk(P2 :: P13 ::  nil) <= 2) by (solve_hyps_max HP2P13eq HP2P13M2).
assert(HP2P13m : rk(P2 :: P13 ::  nil) >= 1) by (solve_hyps_min HP2P13eq HP2P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P5P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P5 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P13m2 : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P13m3 : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P13m4 : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P13 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P13m2 : rk(P1 :: P5 :: P13 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P13 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P13m3 : rk(P1 :: P5 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P5P8P13eq : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P5P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P8P13mtmp : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P13eq HP1P2P5P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P13 :: nil) (P1 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P5 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P13mtmp;try rewrite HT2 in HP1P2P5P8P13mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P5P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


assert(HP1P5P13M : rk(P1 :: P5 :: P13 ::  nil) <= 3) by (solve_hyps_max HP1P5P13eq HP1P5P13M3).
assert(HP1P5P13m : rk(P1 :: P5 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P5P13eq HP1P5P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P2P5P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P2 :: P5 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P13m2 : rk(P1 :: P2 :: P5 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P13m3 : rk(P1 :: P2 :: P5 :: P13 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P13 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P13m4 : rk(P1 :: P2 :: P5 :: P13 :: nil) >= 4).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P5P8P13eq : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P5P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P8P13mtmp : rk(P1 :: P2 :: P5 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P13eq HP1P2P5P8P13m4).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P1 :: P2 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P13 :: nil) (P1 :: P2 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P2 :: P5 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P13mtmp;try rewrite HT2 in HP1P2P5P8P13mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 4 2 2 HP1P2P5P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P5P8P13M1. try clear HP1P2P5P8P13M2. try clear HP1P2P5P8P13M3. try clear HP1P2P5P8P13m4. try clear HP1P2P5P8P13m3. try clear HP1P2P5P8P13m2. try clear HP1P2P5P8P13m1. 

assert(HP1P2P5P13M : rk(P1 :: P2 :: P5 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P5P13m : rk(P1 :: P2 :: P5 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P2P5P13eq HP1P2P5P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P3P5P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P3 :: P5 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P8P13m2 : rk(P1 :: P3 :: P5 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P13m3 : rk(P1 :: P3 :: P5 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P13m4 : rk(P1 :: P3 :: P5 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P13 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P12P14m2 : rk(P1 :: P3 :: P7 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P12 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P12P14m3 : rk(P1 :: P3 :: P7 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P12 :: P14 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P7P12P14m4 : rk(P1 :: P3 :: P7 :: P12 :: P14 :: nil) >= 4).
{
	try assert(HP1P3P7P12eq : rk(P1 :: P3 :: P7 :: P12 :: nil) = 4) by (apply LP1P3P7P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P3P7P12M1. try clear HP1P3P7P12M2. try clear HP1P3P7P12M3. try clear HP1P3P7P12m4. try clear HP1P3P7P12m3. try clear HP1P3P7P12m2. try clear HP1P3P7P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P14m2 : rk(P1 :: P3 :: P7 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P14m3 : rk(P1 :: P3 :: P7 :: P14 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P14 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P7P14m4 : rk(P1 :: P3 :: P7 :: P14 :: nil) >= 4).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP1P3P7P12P14eq : rk(P1 :: P3 :: P7 :: P12 :: P14 :: nil) = 4) by (apply LP1P3P7P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P7P12P14mtmp : rk(P1 :: P3 :: P7 :: P12 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P7P12P14eq HP1P3P7P12P14m4).
	try assert(HP3P14eq : rk(P3 :: P14 :: nil) = 2) by (apply LP3P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P14mtmp : rk(P3 :: P14 :: nil) >= 2) by (solve_hyps_min HP3P14eq HP3P14m2).
	assert(Hincl : incl (P3 :: P14 :: nil) (list_inter (P1 :: P3 :: P7 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P7 :: P12 :: P14 :: nil) (P1 :: P3 :: P7 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P7 :: P14 :: P3 :: P12 :: P14 :: nil) ((P1 :: P3 :: P7 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P7P12P14mtmp;try rewrite HT2 in HP1P3P7P12P14mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P7 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P3 :: P14 :: nil) 4 2 2 HP1P3P7P12P14mtmp HP3P14mtmp HP3P12P14Mtmp Hincl);apply HT.
}
try clear HP3P14M1. try clear HP3P14M2. try clear HP3P14M3. try clear HP3P14m4. try clear HP3P14m3. try clear HP3P14m2. try clear HP3P14m1. try clear HP1P3P7P12P14M1. try clear HP1P3P7P12P14M2. try clear HP1P3P7P12P14M3. try clear HP1P3P7P12P14m4. try clear HP1P3P7P12P14m3. try clear HP1P3P7P12P14m2. try clear HP1P3P7P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P7P13P14m2 : rk(P1 :: P3 :: P7 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P7P13P14m3 : rk(P1 :: P3 :: P7 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P3P7mtmp : rk(P1 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P3P7eq HP1P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil) 3 3 HP1P3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P7M1. try clear HP1P3P7M2. try clear HP1P3P7M3. try clear HP1P3P7m4. try clear HP1P3P7m3. try clear HP1P3P7m2. try clear HP1P3P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P3P7P13P14m4 : rk(P1 :: P3 :: P7 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P3P7P14mtmp : rk(P1 :: P3 :: P7 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P7P14eq HP1P3P7P14m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P7 :: P14 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P7 :: P14 :: nil) (P1 :: P3 :: P7 :: P13 :: P14 :: nil) 4 4 HP1P3P7P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P7P14M1. try clear HP1P3P7P14M2. try clear HP1P3P7P14M3. try clear HP1P3P7P14m4. try clear HP1P3P7P14m3. try clear HP1P3P7P14m2. try clear HP1P3P7P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P13P14m2 : rk(P1 :: P3 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P13 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P13P14m3 : rk(P1 :: P3 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P3P14mtmp : rk(P1 :: P3 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P3P14eq HP1P3P14m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P14 :: nil) (P1 :: P3 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P14 :: nil) (P1 :: P3 :: P13 :: P14 :: nil) 3 3 HP1P3P14mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P13P14m4 : rk(P1 :: P3 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP1P3P7P13P14eq : rk(P1 :: P3 :: P7 :: P13 :: P14 :: nil) = 4) by (apply LP1P3P7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P7P13P14mtmp : rk(P1 :: P3 :: P7 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P7P13P14eq HP1P3P7P13P14m4).
	try assert(HP13P14eq : rk(P13 :: P14 :: nil) = 2) by (apply LP13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13P14mtmp : rk(P13 :: P14 :: nil) >= 2) by (solve_hyps_min HP13P14eq HP13P14m2).
	assert(Hincl : incl (P13 :: P14 :: nil) (list_inter (P1 :: P3 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P7 :: P13 :: P14 :: nil) (P1 :: P3 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil) ((P1 :: P3 :: P13 :: P14 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P7P13P14mtmp;try rewrite HT2 in HP1P3P7P13P14mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil) (P13 :: P14 :: nil) 4 2 2 HP1P3P7P13P14mtmp HP13P14mtmp HP7P13P14Mtmp Hincl);apply HT.
}
try clear HP1P3P7P13P14M1. try clear HP1P3P7P13P14M2. try clear HP1P3P7P13P14M3. try clear HP1P3P7P13P14m4. try clear HP1P3P7P13P14m3. try clear HP1P3P7P13P14m2. try clear HP1P3P7P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P13m2 : rk(P1 :: P3 :: P13 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P13 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P13m3 : rk(P1 :: P3 :: P13 :: nil) >= 3).
{
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14Mtmp : rk(P14 :: nil) <= 1) by (solve_hyps_max HP14eq HP14M1).
	try assert(HP1P3P13P14eq : rk(P1 :: P3 :: P13 :: P14 :: nil) = 4) by (apply LP1P3P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P13P14mtmp : rk(P1 :: P3 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P13P14eq HP1P3P13P14m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P3 :: P13 :: nil) (P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P13 :: P14 :: nil) (P1 :: P3 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P13 :: P14 :: nil) ((P1 :: P3 :: P13 :: nil) ++ (P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P13P14mtmp;try rewrite HT2 in HP1P3P13P14mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P13 :: nil) (P14 :: nil) (nil) 4 0 1 HP1P3P13P14mtmp Hmtmp HP14Mtmp Hincl);apply HT.
}
try clear HP1P3P13P14M1. try clear HP1P3P13P14M2. try clear HP1P3P13P14M3. try clear HP1P3P13P14m4. try clear HP1P3P13P14m3. try clear HP1P3P13P14m2. try clear HP1P3P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P8P13m2 : rk(P1 :: P2 :: P3 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P8P13M3 : rk(P1 :: P2 :: P3 :: P8 :: P13 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P1 :: P2 :: P3 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P8 :: P13 :: nil) (P1 :: P2 :: P3 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P2 :: P8 :: P13 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: nil) 2 2 1 HP1P2P3Mtmp HP2P8P13Mtmp HP2mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P3M1. try clear HP1P2P3M2. try clear HP1P2P3M3. try clear HP1P2P3m4. try clear HP1P2P3m3. try clear HP1P2P3m2. try clear HP1P2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P8P13m3 : rk(P1 :: P2 :: P3 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil) 3 3 HP1P2P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P8P13m2 : rk(P1 :: P3 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P13 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P8P13m3 : rk(P1 :: P3 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P13 :: nil) 3 3 HP1P3P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P3P8P13M3 : rk(P1 :: P3 :: P8 :: P13 :: nil) <= 3).
{
	assert(HP1P2P3P8P13Mtmp : rk(P1 :: P2 :: P3 :: P8 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P2P3P8P13eq HP1P2P3P8P13M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P8 :: P13 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P3 :: P8 :: P13 :: nil) (P1 :: P2 :: P3 :: P8 :: P13 :: nil) 3 3 HP1P2P3P8P13Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P8P13M1. try clear HP1P2P3P8P13M2. try clear HP1P2P3P8P13M3. try clear HP1P2P3P8P13m4. try clear HP1P2P3P8P13m3. try clear HP1P2P3P8P13m2. try clear HP1P2P3P8P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P13m2 : rk(P1 :: P3 :: P5 :: P13 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P13 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P13m3 : rk(P1 :: P3 :: P5 :: P13 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P13 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P13m4 : rk(P1 :: P3 :: P5 :: P13 :: nil) >= 4).
{
	try assert(HP1P3P8P13eq : rk(P1 :: P3 :: P8 :: P13 :: nil) = 3) by (apply LP1P3P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P8P13Mtmp : rk(P1 :: P3 :: P8 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P3P8P13eq HP1P3P8P13M3).
	try assert(HP1P3P5P8P13eq : rk(P1 :: P3 :: P5 :: P8 :: P13 :: nil) = 4) by (apply LP1P3P5P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P5P8P13mtmp : rk(P1 :: P3 :: P5 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8P13eq HP1P3P5P8P13m4).
	try assert(HP1P3P13eq : rk(P1 :: P3 :: P13 :: nil) = 3) by (apply LP1P3P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P13mtmp : rk(P1 :: P3 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P3P13eq HP1P3P13m3).
	assert(Hincl : incl (P1 :: P3 :: P13 :: nil) (list_inter (P1 :: P3 :: P5 :: P13 :: nil) (P1 :: P3 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P8 :: P13 :: nil) (P1 :: P3 :: P5 :: P13 :: P1 :: P3 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P13 :: P1 :: P3 :: P8 :: P13 :: nil) ((P1 :: P3 :: P5 :: P13 :: nil) ++ (P1 :: P3 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P8P13mtmp;try rewrite HT2 in HP1P3P5P8P13mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P5 :: P13 :: nil) (P1 :: P3 :: P8 :: P13 :: nil) (P1 :: P3 :: P13 :: nil) 4 3 3 HP1P3P5P8P13mtmp HP1P3P13mtmp HP1P3P8P13Mtmp Hincl);apply HT.
}
try clear HP1P3P8P13M1. try clear HP1P3P8P13M2. try clear HP1P3P8P13M3. try clear HP1P3P8P13m4. try clear HP1P3P8P13m3. try clear HP1P3P8P13m2. try clear HP1P3P8P13m1. try clear HP1P3P13M1. try clear HP1P3P13M2. try clear HP1P3P13M3. try clear HP1P3P13m4. try clear HP1P3P13m3. try clear HP1P3P13m2. try clear HP1P3P13m1. try clear HP1P3P5P8P13M1. try clear HP1P3P5P8P13M2. try clear HP1P3P5P8P13M3. try clear HP1P3P5P8P13m4. try clear HP1P3P5P8P13m3. try clear HP1P3P5P8P13m2. try clear HP1P3P5P8P13m1. 

assert(HP1P3P5P13M : rk(P1 :: P3 :: P5 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P3P5P13m : rk(P1 :: P3 :: P5 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P3P5P13eq HP1P3P5P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P4P5P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P4 :: P5 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P13m2 : rk(P1 :: P4 :: P5 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P13m3 : rk(P1 :: P4 :: P5 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P13m4 : rk(P1 :: P4 :: P5 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P4P5P8mtmp : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P13 :: nil) 4 4 HP1P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5P8M1. try clear HP1P4P5P8M2. try clear HP1P4P5P8M3. try clear HP1P4P5P8m4. try clear HP1P4P5P8m3. try clear HP1P4P5P8m2. try clear HP1P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P5P12P14m2 : rk(P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P5P12P14m3 : rk(P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P2P3P5P12P14m4 : rk(P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P5P12eq : rk(P1 :: P2 :: P5 :: P12 :: nil) = 4) by (apply LP1P2P5P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P2P5P12M1. try clear HP1P2P5P12M2. try clear HP1P2P5P12M3. try clear HP1P2P5P12m4. try clear HP1P2P5P12m3. try clear HP1P2P5P12m2. try clear HP1P2P5P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P14m2 : rk(P1 :: P2 :: P5 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P14m3 : rk(P1 :: P2 :: P5 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P14m4 : rk(P1 :: P2 :: P5 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P3P12P14eq : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) = 3) by (apply LP1P2P3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P12P14Mtmp : rk(P1 :: P2 :: P3 :: P12 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P2P3P12P14eq HP1P2P3P12P14M3).
	try assert(HP1P2P3P5P12P14eq : rk(P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) = 4) by (apply LP1P2P3P5P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P5P12P14mtmp : rk(P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P12P14eq HP1P2P3P5P12P14m4).
	try assert(HP1P2P14eq : rk(P1 :: P2 :: P14 :: nil) = 3) by (apply LP1P2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P14mtmp : rk(P1 :: P2 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P14eq HP1P2P14m3).
	assert(Hincl : incl (P1 :: P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P12 :: P14 :: nil) (P1 :: P2 :: P5 :: P14 :: P1 :: P2 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P14 :: P1 :: P2 :: P3 :: P12 :: P14 :: nil) ((P1 :: P2 :: P5 :: P14 :: nil) ++ (P1 :: P2 :: P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P12P14mtmp;try rewrite HT2 in HP1P2P3P5P12P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P3 :: P12 :: P14 :: nil) (P1 :: P2 :: P14 :: nil) 4 3 3 HP1P2P3P5P12P14mtmp HP1P2P14mtmp HP1P2P3P12P14Mtmp Hincl);apply HT.
}
try clear HP1P2P3P12P14M1. try clear HP1P2P3P12P14M2. try clear HP1P2P3P12P14M3. try clear HP1P2P3P12P14m4. try clear HP1P2P3P12P14m3. try clear HP1P2P3P12P14m2. try clear HP1P2P3P12P14m1. try clear HP1P2P3P5P12P14M1. try clear HP1P2P3P5P12P14M2. try clear HP1P2P3P5P12P14M3. try clear HP1P2P3P5P12P14m4. try clear HP1P2P3P5P12P14m3. try clear HP1P2P3P5P12P14m2. try clear HP1P2P3P5P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P5P13P14m2 : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P5P13P14m3 : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P4P5P13P14m4 : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P2P5P14mtmp : rk(P1 :: P2 :: P5 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P5P14eq HP1P2P5P14m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) 4 4 HP1P2P5P14mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P13P14m2 : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P13P14m3 : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P5P13P14m4 : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P2P5P14mtmp : rk(P1 :: P2 :: P5 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P5P14eq HP1P2P5P14m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil) 4 4 HP1P2P5P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P14M1. try clear HP1P2P5P14M2. try clear HP1P2P5P14M3. try clear HP1P2P5P14m4. try clear HP1P2P5P14m3. try clear HP1P2P5P14m2. try clear HP1P2P5P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P4P13P14m2 : rk(P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P3P4P13P14m3 : rk(P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P3P14mtmp : rk(P1 :: P3 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P3P14eq HP1P3P14m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P14 :: nil) (P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P14 :: nil) (P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) 3 3 HP1P3P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P14M1. try clear HP1P3P14M2. try clear HP1P3P14M3. try clear HP1P3P14m4. try clear HP1P3P14m3. try clear HP1P3P14m2. try clear HP1P3P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P13P14m2 : rk(P1 :: P2 :: P4 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P13P14m3 : rk(P1 :: P2 :: P4 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P2P3P14eq : rk(P1 :: P2 :: P3 :: P14 :: nil) = 3) by (apply LP1P2P3P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P14Mtmp : rk(P1 :: P2 :: P3 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P2P3P14eq HP1P2P3P14M3).
	try assert(HP1P2P3P4P13P14eq : rk(P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) = 3) by (apply LP1P2P3P4P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P3P4P13P14mtmp : rk(P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P3P4P13P14eq HP1P2P3P4P13P14m3).
	try assert(HP1P2P14eq : rk(P1 :: P2 :: P14 :: nil) = 3) by (apply LP1P2P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P14mtmp : rk(P1 :: P2 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P14eq HP1P2P14m3).
	assert(Hincl : incl (P1 :: P2 :: P14 :: nil) (list_inter (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P4 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P4 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P14 :: P1 :: P2 :: P4 :: P13 :: P14 :: nil) ((P1 :: P2 :: P3 :: P14 :: nil) ++ (P1 :: P2 :: P4 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P13P14mtmp;try rewrite HT2 in HP1P2P3P4P13P14mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P14 :: nil) (P1 :: P2 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P14 :: nil) 3 3 3 HP1P2P3P4P13P14mtmp HP1P2P14mtmp HP1P2P3P14Mtmp Hincl); apply HT.
}
try clear HP1P2P3P14M1. try clear HP1P2P3P14M2. try clear HP1P2P3P14M3. try clear HP1P2P3P14m4. try clear HP1P2P3P14m3. try clear HP1P2P3P14m2. try clear HP1P2P3P14m1. try clear HP1P2P14M1. try clear HP1P2P14M2. try clear HP1P2P14M3. try clear HP1P2P14m4. try clear HP1P2P14m3. try clear HP1P2P14m2. try clear HP1P2P14m1. try clear HP1P2P3P4P13P14M1. try clear HP1P2P3P4P13P14M2. try clear HP1P2P3P4P13P14M3. try clear HP1P2P3P4P13P14m4. try clear HP1P2P3P4P13P14m3. try clear HP1P2P3P4P13P14m2. try clear HP1P2P3P4P13P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P13P14m4 : rk(P1 :: P2 :: P4 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P5P13P14eq : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P5P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P13P14Mtmp : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) <= 4) by (solve_hyps_max HP1P2P5P13P14eq HP1P2P5P13P14M4).
	try assert(HP1P2P4P5P13P14eq : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P4P5P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P4P5P13P14mtmp : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P13P14eq HP1P2P4P5P13P14m4).
	try assert(HP1P2P13P14eq : rk(P1 :: P2 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P13P14mtmp : rk(P1 :: P2 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P13P14eq HP1P2P13P14m4).
	assert(Hincl : incl (P1 :: P2 :: P13 :: P14 :: nil) (list_inter (P1 :: P2 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) (P1 :: P2 :: P4 :: P13 :: P14 :: P1 :: P2 :: P5 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P13 :: P14 :: P1 :: P2 :: P5 :: P13 :: P14 :: nil) ((P1 :: P2 :: P4 :: P13 :: P14 :: nil) ++ (P1 :: P2 :: P5 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P13P14mtmp;try rewrite HT2 in HP1P2P4P5P13P14mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil) (P1 :: P2 :: P13 :: P14 :: nil) 4 4 4 HP1P2P4P5P13P14mtmp HP1P2P13P14mtmp HP1P2P5P13P14Mtmp Hincl);apply HT.
}
try clear HP1P2P13P14M1. try clear HP1P2P13P14M2. try clear HP1P2P13P14M3. try clear HP1P2P13P14m4. try clear HP1P2P13P14m3. try clear HP1P2P13P14m2. try clear HP1P2P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P8P13m2 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P8P13m3 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P8P13m4 : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P13 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7P8M1. try clear HP1P2P7P8M2. try clear HP1P2P7P8M3. try clear HP1P2P7P8m4. try clear HP1P2P7P8m3. try clear HP1P2P7P8m2. try clear HP1P2P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P7P13m2 : rk(P1 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP1P7mtmp : rk(P1 :: P7 :: nil) >= 2) by (solve_hyps_min HP1P7eq HP1P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P7 :: nil) (P1 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P7 :: nil) (P1 :: P7 :: P13 :: nil) 2 2 HP1P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P7P13m3 : rk(P1 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P7P8P13eq : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P7P8P13mtmp : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8P13eq HP1P2P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P8 :: P13 :: nil) (P1 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P8P13mtmp;try rewrite HT2 in HP1P2P7P8P13mtmp.
	assert(HT := rule_2 (P1 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P7P13P14M3 : rk(P1 :: P7 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P7 :: P13 :: P14 :: nil) (P1 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P7 :: P13 :: P14 :: nil) ((P1 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P7 :: P13 :: P14 :: nil) (nil) 1 2 0 HP1Mtmp HP7P13P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P7P13P14m2 : rk(P1 :: P7 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P7mtmp : rk(P1 :: P7 :: nil) >= 2) by (solve_hyps_min HP1P7eq HP1P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P7 :: nil) (P1 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P7 :: nil) (P1 :: P7 :: P13 :: P14 :: nil) 2 2 HP1P7mtmp Hcomp Hincl);apply HT.
}
try clear HP1P7M1. try clear HP1P7M2. try clear HP1P7M3. try clear HP1P7m4. try clear HP1P7m3. try clear HP1P7m2. try clear HP1P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P7P13P14m3 : rk(P1 :: P7 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P7P13mtmp : rk(P1 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P7P13eq HP1P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P7 :: P13 :: nil) (P1 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P7 :: P13 :: nil) (P1 :: P7 :: P13 :: P14 :: nil) 3 3 HP1P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P7P13M1. try clear HP1P7P13M2. try clear HP1P7P13M3. try clear HP1P7P13m4. try clear HP1P7P13m3. try clear HP1P7P13m2. try clear HP1P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6P13P14m2 : rk(P1 :: P5 :: P6 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P13 :: P14 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P6P13P14m3 : rk(P1 :: P5 :: P6 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P5P13eq : rk(P1 :: P5 :: P13 :: nil) = 3) by (apply LP1P5P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P8P13M3 : rk(P1 :: P2 :: P8 :: P13 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P8 :: P13 :: nil) (P1 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P8 :: P13 :: nil) ((P1 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P2 :: P8 :: P13 :: nil) (nil) 1 2 0 HP1Mtmp HP2P8P13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1M1. try clear HP1M2. try clear HP1M3. try clear HP1m4. try clear HP1m3. try clear HP1m2. try clear HP1m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P8P13m2 : rk(P1 :: P2 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P8P13m3 : rk(P1 :: P2 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P8 :: P13 :: nil) 3 3 HP1P2P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P13m2 : rk(P1 :: P13 :: nil) >= 2).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P8P13eq : rk(P1 :: P2 :: P8 :: P13 :: nil) = 3) by (apply LP1P2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P8P13mtmp : rk(P1 :: P2 :: P8 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P2P8P13eq HP1P2P8P13m3).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P8 :: P13 :: nil) (P1 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P8P13mtmp;try rewrite HT2 in HP1P2P8P13mtmp.
	assert(HT := rule_2 (P1 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 3 1 2 HP1P2P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P8P13M1. try clear HP1P2P8P13M2. try clear HP1P2P8P13M3. try clear HP1P2P8P13m4. try clear HP1P2P8P13m3. try clear HP1P2P8P13m2. try clear HP1P2P8P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P6P8P13m2 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P6P8P13m3 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P6P8P13m4 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6P13m2 : rk(P1 :: P5 :: P6 :: P13 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P13 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P13M3 : rk(P1 :: P5 :: P6 :: P13 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13Mtmp : rk(P13 :: nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P13 :: nil) (P1 :: P5 :: P6 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P13 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P13 :: nil) (nil) 2 1 0 HP1P5P6Mtmp HP13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P13m3 : rk(P1 :: P5 :: P6 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P5P6P8P13eq : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P5P6P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P6P8P13mtmp : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P8P13eq HP1P2P5P6P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P5 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P8 :: P13 :: nil) (P1 :: P5 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P5 :: P6 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P8P13mtmp;try rewrite HT2 in HP1P2P5P6P8P13mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P5P6P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P5P6P8P13M1. try clear HP1P2P5P6P8P13M2. try clear HP1P2P5P6P8P13M3. try clear HP1P2P5P6P8P13m4. try clear HP1P2P5P6P8P13m3. try clear HP1P2P5P6P8P13m2. try clear HP1P2P5P6P8P13m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P13P14m2 : rk(P1 :: P13 :: P14 :: nil) >= 2).
{
	try assert(HP1P5P6P13eq : rk(P1 :: P5 :: P6 :: P13 :: nil) = 3) by (apply LP1P5P6P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P6P13Mtmp : rk(P1 :: P5 :: P6 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P5P6P13eq HP1P5P6P13M3).
	try assert(HP1P5P6P13P14eq : rk(P1 :: P5 :: P6 :: P13 :: P14 :: nil) = 3) by (apply LP1P5P6P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P6P13P14mtmp : rk(P1 :: P5 :: P6 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P5P6P13P14eq HP1P5P6P13P14m3).
	try assert(HP1P13eq : rk(P1 :: P13 :: nil) = 2) by (apply LP1P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P13mtmp : rk(P1 :: P13 :: nil) >= 2) by (solve_hyps_min HP1P13eq HP1P13m2).
	assert(Hincl : incl (P1 :: P13 :: nil) (list_inter (P1 :: P5 :: P6 :: P13 :: nil) (P1 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P13 :: P14 :: nil) (P1 :: P5 :: P6 :: P13 :: P1 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P13 :: P1 :: P13 :: P14 :: nil) ((P1 :: P5 :: P6 :: P13 :: nil) ++ (P1 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P13P14mtmp;try rewrite HT2 in HP1P5P6P13P14mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P13 :: nil) (P1 :: P13 :: P14 :: nil) (P1 :: P13 :: nil) 3 2 3 HP1P5P6P13P14mtmp HP1P13mtmp HP1P5P6P13Mtmp Hincl); apply HT.
}
try clear HP1P5P6P13M1. try clear HP1P5P6P13M2. try clear HP1P5P6P13M3. try clear HP1P5P6P13m4. try clear HP1P5P6P13m3. try clear HP1P5P6P13m2. try clear HP1P5P6P13m1. try clear HP1P13M1. try clear HP1P13M2. try clear HP1P13M3. try clear HP1P13m4. try clear HP1P13m3. try clear HP1P13m2. try clear HP1P13m1. try clear HP1P5P6P13P14M1. try clear HP1P5P6P13P14M2. try clear HP1P5P6P13P14M3. try clear HP1P5P6P13P14m4. try clear HP1P5P6P13P14m3. try clear HP1P5P6P13P14m2. try clear HP1P5P6P13P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P13P14m3 : rk(P1 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP1P7P13P14eq : rk(P1 :: P7 :: P13 :: P14 :: nil) = 3) by (apply LP1P7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P7P13P14mtmp : rk(P1 :: P7 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P7P13P14eq HP1P7P13P14m3).
	try assert(HP13P14eq : rk(P13 :: P14 :: nil) = 2) by (apply LP13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13P14mtmp : rk(P13 :: P14 :: nil) >= 2) by (solve_hyps_min HP13P14eq HP13P14m2).
	assert(Hincl : incl (P13 :: P14 :: nil) (list_inter (P1 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P7 :: P13 :: P14 :: nil) (P1 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P13 :: P14 :: P7 :: P13 :: P14 :: nil) ((P1 :: P13 :: P14 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P7P13P14mtmp;try rewrite HT2 in HP1P7P13P14mtmp.
	assert(HT := rule_2 (P1 :: P13 :: P14 :: nil) (P7 :: P13 :: P14 :: nil) (P13 :: P14 :: nil) 3 2 2 HP1P7P13P14mtmp HP13P14mtmp HP7P13P14Mtmp Hincl);apply HT.
}
try clear HP13P14M1. try clear HP13P14M2. try clear HP13P14M3. try clear HP13P14m4. try clear HP13P14m3. try clear HP13P14m2. try clear HP13P14m1. try clear HP1P7P13P14M1. try clear HP1P7P13P14M2. try clear HP1P7P13P14M3. try clear HP1P7P13P14m4. try clear HP1P7P13P14m3. try clear HP1P7P13P14m2. try clear HP1P7P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P13P14m2 : rk(P1 :: P4 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P13 :: P14 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P13P14m3 : rk(P1 :: P4 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P2P5P13P14eq : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P5P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P13P14Mtmp : rk(P1 :: P2 :: P5 :: P13 :: P14 :: nil) <= 4) by (solve_hyps_max HP1P2P5P13P14eq HP1P2P5P13P14M4).
	try assert(HP1P2P4P5P13P14eq : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P4P5P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P4P5P13P14mtmp : rk(P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P13P14eq HP1P2P4P5P13P14m4).
	try assert(HP1P13P14eq : rk(P1 :: P13 :: P14 :: nil) = 3) by (apply LP1P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P13P14mtmp : rk(P1 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P13P14eq HP1P13P14m3).
	assert(Hincl : incl (P1 :: P13 :: P14 :: nil) (list_inter (P1 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P13 :: P14 :: nil) (P1 :: P4 :: P13 :: P14 :: P1 :: P2 :: P5 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P13 :: P14 :: P1 :: P2 :: P5 :: P13 :: P14 :: nil) ((P1 :: P4 :: P13 :: P14 :: nil) ++ (P1 :: P2 :: P5 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P13P14mtmp;try rewrite HT2 in HP1P2P4P5P13P14mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P5 :: P13 :: P14 :: nil) (P1 :: P13 :: P14 :: nil) 4 3 4 HP1P2P4P5P13P14mtmp HP1P13P14mtmp HP1P2P5P13P14Mtmp Hincl);apply HT.
}
try clear HP1P2P5P13P14M1. try clear HP1P2P5P13P14M2. try clear HP1P2P5P13P14M3. try clear HP1P2P5P13P14m4. try clear HP1P2P5P13P14m3. try clear HP1P2P5P13P14m2. try clear HP1P2P5P13P14m1. try clear HP1P2P4P5P13P14M1. try clear HP1P2P4P5P13P14M2. try clear HP1P2P4P5P13P14M3. try clear HP1P2P4P5P13P14m4. try clear HP1P2P4P5P13P14m3. try clear HP1P2P4P5P13P14m2. try clear HP1P2P4P5P13P14m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P4P13P14m4 : rk(P1 :: P4 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP1P2P4P13P14eq : rk(P1 :: P2 :: P4 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P4P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P4P13P14mtmp : rk(P1 :: P2 :: P4 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P4P13P14eq HP1P2P4P13P14m4).
	try assert(HP1P4eq : rk(P1 :: P4 :: nil) = 2) by (apply LP1P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hincl : incl (P1 :: P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P13 :: P14 :: nil) (P1 :: P2 :: P4 :: P1 :: P4 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P1 :: P4 :: P13 :: P14 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P1 :: P4 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P13P14mtmp;try rewrite HT2 in HP1P2P4P13P14mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: nil) (P1 :: P4 :: P13 :: P14 :: nil) (P1 :: P4 :: nil) 4 2 2 HP1P2P4P13P14mtmp HP1P4mtmp HP1P2P4Mtmp Hincl); apply HT.
}
try clear HP1P2P4P13P14M1. try clear HP1P2P4P13P14M2. try clear HP1P2P4P13P14M3. try clear HP1P2P4P13P14m4. try clear HP1P2P4P13P14m3. try clear HP1P2P4P13P14m2. try clear HP1P2P4P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P13m2 : rk(P1 :: P4 :: P13 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P13 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P13m3 : rk(P1 :: P4 :: P13 :: nil) >= 3).
{
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14Mtmp : rk(P14 :: nil) <= 1) by (solve_hyps_max HP14eq HP14M1).
	try assert(HP1P4P13P14eq : rk(P1 :: P4 :: P13 :: P14 :: nil) = 4) by (apply LP1P4P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P4P13P14mtmp : rk(P1 :: P4 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P4P13P14eq HP1P4P13P14m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P4 :: P13 :: nil) (P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P13 :: P14 :: nil) (P1 :: P4 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P13 :: P14 :: nil) ((P1 :: P4 :: P13 :: nil) ++ (P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P13P14mtmp;try rewrite HT2 in HP1P4P13P14mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P13 :: nil) (P14 :: nil) (nil) 4 0 1 HP1P4P13P14mtmp Hmtmp HP14Mtmp Hincl);apply HT.
}
try clear HP1P4P13P14M1. try clear HP1P4P13P14M2. try clear HP1P4P13P14M3. try clear HP1P4P13P14m4. try clear HP1P4P13P14m3. try clear HP1P4P13P14m2. try clear HP1P4P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P8P13m2 : rk(P1 :: P2 :: P4 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P8P13M3 : rk(P1 :: P2 :: P4 :: P8 :: P13 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2mtmp : rk(P2 :: nil) >= 1) by (solve_hyps_min HP2eq HP2m1).
	assert(Hincl : incl (P2 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P8 :: P13 :: nil) (P1 :: P2 :: P4 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P2 :: P8 :: P13 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: nil) 2 2 1 HP1P2P4Mtmp HP2P8P13Mtmp HP2mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P4M1. try clear HP1P2P4M2. try clear HP1P2P4M3. try clear HP1P2P4m4. try clear HP1P2P4m3. try clear HP1P2P4m2. try clear HP1P2P4m1. try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P4P8P13m3 : rk(P1 :: P2 :: P4 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P8mtmp : rk(P1 :: P2 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P2P8eq HP1P2P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P8 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil) 3 3 HP1P2P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P8M1. try clear HP1P2P8M2. try clear HP1P2P8M3. try clear HP1P2P8m4. try clear HP1P2P8m3. try clear HP1P2P8m2. try clear HP1P2P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P8P13m2 : rk(P1 :: P4 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P8 :: P13 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P8P13m3 : rk(P1 :: P4 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P4P8mtmp : rk(P1 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P4P8eq HP1P4P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P8 :: nil) (P1 :: P4 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P8 :: nil) (P1 :: P4 :: P8 :: P13 :: nil) 3 3 HP1P4P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P8M1. try clear HP1P4P8M2. try clear HP1P4P8M3. try clear HP1P4P8m4. try clear HP1P4P8m3. try clear HP1P4P8m2. try clear HP1P4P8m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P4P8P13M3 : rk(P1 :: P4 :: P8 :: P13 :: nil) <= 3).
{
	assert(HP1P2P4P8P13Mtmp : rk(P1 :: P2 :: P4 :: P8 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P2P4P8P13eq HP1P2P4P8P13M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P8 :: P13 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P4 :: P8 :: P13 :: nil) (P1 :: P2 :: P4 :: P8 :: P13 :: nil) 3 3 HP1P2P4P8P13Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P4P8P13M1. try clear HP1P2P4P8P13M2. try clear HP1P2P4P8P13M3. try clear HP1P2P4P8P13m4. try clear HP1P2P4P8P13m3. try clear HP1P2P4P8P13m2. try clear HP1P2P4P8P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P13m2 : rk(P1 :: P4 :: P5 :: P13 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P13 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4M1. try clear HP1P4M2. try clear HP1P4M3. try clear HP1P4m4. try clear HP1P4m3. try clear HP1P4m2. try clear HP1P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P13m3 : rk(P1 :: P4 :: P5 :: P13 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P13 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5M1. try clear HP1P4P5M2. try clear HP1P4P5M3. try clear HP1P4P5m4. try clear HP1P4P5m3. try clear HP1P4P5m2. try clear HP1P4P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P13m4 : rk(P1 :: P4 :: P5 :: P13 :: nil) >= 4).
{
	try assert(HP1P4P8P13eq : rk(P1 :: P4 :: P8 :: P13 :: nil) = 3) by (apply LP1P4P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P4P8P13Mtmp : rk(P1 :: P4 :: P8 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P4P8P13eq HP1P4P8P13M3).
	try assert(HP1P4P5P8P13eq : rk(P1 :: P4 :: P5 :: P8 :: P13 :: nil) = 4) by (apply LP1P4P5P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P4P5P8P13mtmp : rk(P1 :: P4 :: P5 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8P13eq HP1P4P5P8P13m4).
	try assert(HP1P4P13eq : rk(P1 :: P4 :: P13 :: nil) = 3) by (apply LP1P4P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P4P13mtmp : rk(P1 :: P4 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P4P13eq HP1P4P13m3).
	assert(Hincl : incl (P1 :: P4 :: P13 :: nil) (list_inter (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P8 :: P13 :: nil) (P1 :: P4 :: P5 :: P13 :: P1 :: P4 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P13 :: P1 :: P4 :: P8 :: P13 :: nil) ((P1 :: P4 :: P5 :: P13 :: nil) ++ (P1 :: P4 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P8P13mtmp;try rewrite HT2 in HP1P4P5P8P13mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P8 :: P13 :: nil) (P1 :: P4 :: P13 :: nil) 4 3 3 HP1P4P5P8P13mtmp HP1P4P13mtmp HP1P4P8P13Mtmp Hincl);apply HT.
}
try clear HP1P4P8P13M1. try clear HP1P4P8P13M2. try clear HP1P4P8P13M3. try clear HP1P4P8P13m4. try clear HP1P4P8P13m3. try clear HP1P4P8P13m2. try clear HP1P4P8P13m1. try clear HP1P4P13M1. try clear HP1P4P13M2. try clear HP1P4P13M3. try clear HP1P4P13m4. try clear HP1P4P13m3. try clear HP1P4P13m2. try clear HP1P4P13m1. try clear HP1P4P5P8P13M1. try clear HP1P4P5P8P13M2. try clear HP1P4P5P8P13M3. try clear HP1P4P5P8P13m4. try clear HP1P4P5P8P13m3. try clear HP1P4P5P8P13m2. try clear HP1P4P5P8P13m1. 

assert(HP1P4P5P13M : rk(P1 :: P4 :: P5 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P4P5P13m : rk(P1 :: P4 :: P5 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P4P5P13eq HP1P4P5P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P6P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P6 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P8P13m2 : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P13m3 : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P13m4 : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P13 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P13m2 : rk(P1 :: P6 :: P13 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P13 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P13m3 : rk(P1 :: P6 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P6P8P13eq : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P6P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P6P8P13mtmp : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8P13eq HP1P2P6P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P8 :: P13 :: nil) (P1 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P6 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P8P13mtmp;try rewrite HT2 in HP1P2P6P8P13mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P6P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


assert(HP1P6P13M : rk(P1 :: P6 :: P13 ::  nil) <= 3) by (solve_hyps_max HP1P6P13eq HP1P6P13M3).
assert(HP1P6P13m : rk(P1 :: P6 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P6P13eq HP1P6P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P2P6P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P2 :: P6 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P13m2 : rk(P1 :: P2 :: P6 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P13m3 : rk(P1 :: P2 :: P6 :: P13 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P13 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P13m4 : rk(P1 :: P2 :: P6 :: P13 :: nil) >= 4).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P6P8P13eq : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P6P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P6P8P13mtmp : rk(P1 :: P2 :: P6 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8P13eq HP1P2P6P8P13m4).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P1 :: P2 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P8 :: P13 :: nil) (P1 :: P2 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P2 :: P6 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P8P13mtmp;try rewrite HT2 in HP1P2P6P8P13mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P6 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 4 2 2 HP1P2P6P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P6P8P13M1. try clear HP1P2P6P8P13M2. try clear HP1P2P6P8P13M3. try clear HP1P2P6P8P13m4. try clear HP1P2P6P8P13m3. try clear HP1P2P6P8P13m2. try clear HP1P2P6P8P13m1. 

assert(HP1P2P6P13M : rk(P1 :: P2 :: P6 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P6P13m : rk(P1 :: P2 :: P6 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P2P6P13eq HP1P2P6P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP2P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P2 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P7P13m2 : rk(P2 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P13 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7M1. try clear HP2P7M2. try clear HP2P7M3. try clear HP2P7m4. try clear HP2P7m3. try clear HP2P7m2. try clear HP2P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P7P13m3 : rk(P2 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P7P8P13eq : rk(P2 :: P7 :: P8 :: P13 :: nil) = 3) by (apply LP2P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P7P8P13mtmp : rk(P2 :: P7 :: P8 :: P13 :: nil) >= 3) by (solve_hyps_min HP2P7P8P13eq HP2P7P8P13m3).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P2 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P13 :: nil) (P2 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P2 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P8P13mtmp;try rewrite HT2 in HP2P7P8P13mtmp.
	assert(HT := rule_2 (P2 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 3 2 2 HP2P7P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P7P8P13M1. try clear HP2P7P8P13M2. try clear HP2P7P8P13M3. try clear HP2P7P8P13m4. try clear HP2P7P8P13m3. try clear HP2P7P8P13m2. try clear HP2P7P8P13m1. 

assert(HP2P7P13M : rk(P2 :: P7 :: P13 ::  nil) <= 3) by (solve_hyps_max HP2P7P13eq HP2P7P13M3).
assert(HP2P7P13m : rk(P2 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP2P7P13eq HP2P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P2P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P2 :: P7 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P13m2 : rk(P1 :: P2 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P7P13m3 : rk(P1 :: P2 :: P7 :: P13 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7M1. try clear HP1P2P7M2. try clear HP1P2P7M3. try clear HP1P2P7m4. try clear HP1P2P7m3. try clear HP1P2P7m2. try clear HP1P2P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P13m4 : rk(P1 :: P2 :: P7 :: P13 :: nil) >= 4).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P7P8P13eq : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P7P8P13mtmp : rk(P1 :: P2 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8P13eq HP1P2P7P8P13m4).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P1 :: P2 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P8 :: P13 :: nil) (P1 :: P2 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P2 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P8P13mtmp;try rewrite HT2 in HP1P2P7P8P13mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 4 2 2 HP1P2P7P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P7P8P13M1. try clear HP1P2P7P8P13M2. try clear HP1P2P7P8P13M3. try clear HP1P2P7P8P13m4. try clear HP1P2P7P8P13m3. try clear HP1P2P7P8P13m2. try clear HP1P2P7P8P13m1. 

assert(HP1P2P7P13M : rk(P1 :: P2 :: P7 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P2P7P13m : rk(P1 :: P2 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P2P7P13eq HP1P2P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP3P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P3 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P7P13m3 : rk(P3 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P3P7P8P13eq : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P3P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P3P7P8P13mtmp : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8P13eq HP2P3P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P7 :: P8 :: P13 :: nil) (P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P3 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P7P8P13mtmp;try rewrite HT2 in HP2P3P7P8P13mtmp.
	assert(HT := rule_2 (P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P3P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


assert(HP3P7P13M : rk(P3 :: P7 :: P13 ::  nil) <= 3) by (solve_hyps_max HP3P7P13eq HP3P7P13M3).
assert(HP3P7P13m : rk(P3 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP3P7P13eq HP3P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP2P3P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P2 :: P3 :: P7 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P7P13m2 : rk(P2 :: P3 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P13 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P7P13m3 : rk(P2 :: P3 :: P7 :: P13 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P13 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P7M1. try clear HP2P3P7M2. try clear HP2P3P7M3. try clear HP2P3P7m4. try clear HP2P3P7m3. try clear HP2P3P7m2. try clear HP2P3P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P7P13m4 : rk(P2 :: P3 :: P7 :: P13 :: nil) >= 4).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P3P7P8P13eq : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P3P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P3P7P8P13mtmp : rk(P2 :: P3 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8P13eq HP2P3P7P8P13m4).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P2 :: P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P7 :: P8 :: P13 :: nil) (P2 :: P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P2 :: P3 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P7P8P13mtmp;try rewrite HT2 in HP2P3P7P8P13mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 4 2 2 HP2P3P7P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P3P7P8P13M1. try clear HP2P3P7P8P13M2. try clear HP2P3P7P8P13M3. try clear HP2P3P7P8P13m4. try clear HP2P3P7P8P13m3. try clear HP2P3P7P8P13m2. try clear HP2P3P7P8P13m1. 

assert(HP2P3P7P13M : rk(P2 :: P3 :: P7 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P7P13m : rk(P2 :: P3 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP2P3P7P13eq HP2P3P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP4P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P4 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P8P13m2 : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P8P13m3 : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP2P4P7mtmp : rk(P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P4P7eq HP2P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil) 3 3 HP2P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P8P13m4 : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP2P4P7P8mtmp : rk(P2 :: P4 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P7P8eq HP2P4P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: P8 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: P8 :: nil) (P2 :: P4 :: P7 :: P8 :: P13 :: nil) 4 4 HP2P4P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P7P8M1. try clear HP2P4P7P8M2. try clear HP2P4P7P8M3. try clear HP2P4P7P8m4. try clear HP2P4P7P8m3. try clear HP2P4P7P8m2. try clear HP2P4P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P7P13m2 : rk(P4 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP4P7mtmp : rk(P4 :: P7 :: nil) >= 2) by (solve_hyps_min HP4P7eq HP4P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P7 :: nil) (P4 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P7 :: nil) (P4 :: P7 :: P13 :: nil) 2 2 HP4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP4P7M1. try clear HP4P7M2. try clear HP4P7M3. try clear HP4P7m4. try clear HP4P7m3. try clear HP4P7m2. try clear HP4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P7P13m3 : rk(P4 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P4P7P8P13eq : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P4P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P4P7P8P13mtmp : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P4P7P8P13eq HP2P4P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P4 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P7 :: P8 :: P13 :: nil) (P4 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P4 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P7P8P13mtmp;try rewrite HT2 in HP2P4P7P8P13mtmp.
	assert(HT := rule_2 (P4 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P4P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}


assert(HP4P7P13M : rk(P4 :: P7 :: P13 ::  nil) <= 3) by (solve_hyps_max HP4P7P13eq HP4P7P13M3).
assert(HP4P7P13m : rk(P4 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP4P7P13eq HP4P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP2P4P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P2 :: P4 :: P7 :: P13 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P7P13m2 : rk(P2 :: P4 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P13 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P7P13m3 : rk(P2 :: P4 :: P7 :: P13 :: nil) >= 3).
{
	assert(HP2P4P7mtmp : rk(P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P4P7eq HP2P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P13 :: nil) 3 3 HP2P4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P7M1. try clear HP2P4P7M2. try clear HP2P4P7M3. try clear HP2P4P7m4. try clear HP2P4P7m3. try clear HP2P4P7m2. try clear HP2P4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P7P13m4 : rk(P2 :: P4 :: P7 :: P13 :: nil) >= 4).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P4P7P8P13eq : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P4P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P4P7P8P13mtmp : rk(P2 :: P4 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P4P7P8P13eq HP2P4P7P8P13m4).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P2 :: P4 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P7 :: P8 :: P13 :: nil) (P2 :: P4 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P2 :: P4 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P7P8P13mtmp;try rewrite HT2 in HP2P4P7P8P13mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P2 :: P13 :: nil) 4 2 2 HP2P4P7P8P13mtmp HP2P13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P13M1. try clear HP2P13M2. try clear HP2P13M3. try clear HP2P13m4. try clear HP2P13m3. try clear HP2P13m2. try clear HP2P13m1. try clear HP2P4P7P8P13M1. try clear HP2P4P7P8P13M2. try clear HP2P4P7P8P13M3. try clear HP2P4P7P8P13m4. try clear HP2P4P7P8P13m3. try clear HP2P4P7P8P13m2. try clear HP2P4P7P8P13m1. 

assert(HP2P4P7P13M : rk(P2 :: P4 :: P7 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P7P13m : rk(P2 :: P4 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP2P4P7P13eq HP2P4P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP5P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13m2 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13m3 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13m4 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P5P7P8P13m2 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP2P5mtmp : rk(P2 :: P5 :: nil) >= 2) by (solve_hyps_min HP2P5eq HP2P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P5 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P5 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil) 2 2 HP2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P7P8P13m3 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P7P8P13eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) = 3) by (apply LP1P2P5P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P7P8P13mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P2P5P7P8P13eq HP1P2P5P7P8P13m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P1 :: P5 :: P7 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P5 :: P7 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8P13mtmp;try rewrite HT2 in HP1P2P5P7P8P13mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P2P5P7P8P13mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P7P8P13m4 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8Mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P7P8eq HP1P5P7P8M3).
	try assert(HP1P2P5P7P8P13eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P5P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P7P8P13mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8P13eq HP1P2P5P7P8P13m4).
	try assert(HP5P7P8eq : rk(P5 :: P7 :: P8 :: nil) = 3) by (apply LP5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7P8mtmp : rk(P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P7P8eq HP5P7P8m3).
	assert(Hincl : incl (P5 :: P7 :: P8 :: nil) (list_inter (P1 :: P5 :: P7 :: P8 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P1 :: P5 :: P7 :: P8 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) ((P1 :: P5 :: P7 :: P8 :: nil) ++ (P2 :: P5 :: P7 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8P13mtmp;try rewrite HT2 in HP1P2P5P7P8P13mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P8 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P5 :: P7 :: P8 :: nil) 4 3 3 HP1P2P5P7P8P13mtmp HP5P7P8mtmp HP1P5P7P8Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P7P13m2 : rk(P5 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P7 :: nil) (P5 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P7 :: nil) (P5 :: P7 :: P13 :: nil) 2 2 HP5P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P7P13m3 : rk(P5 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P5P7P8P13eq : rk(P2 :: P5 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P5P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P5P7P8P13mtmp : rk(P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P5P7P8P13eq HP2P5P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P5 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P5 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P5 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P5P7P8P13mtmp;try rewrite HT2 in HP2P5P7P8P13mtmp.
	assert(HT := rule_2 (P5 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P5P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P5P7P8P13M1. try clear HP2P5P7P8P13M2. try clear HP2P5P7P8P13M3. try clear HP2P5P7P8P13m4. try clear HP2P5P7P8P13m3. try clear HP2P5P7P8P13m2. try clear HP2P5P7P8P13m1. 

assert(HP5P7P13M : rk(P5 :: P7 :: P13 ::  nil) <= 3) by (solve_hyps_max HP5P7P13eq HP5P7P13M3).
assert(HP5P7P13m : rk(P5 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP5P7P13eq HP5P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P5P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P5 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P7P13m2 : rk(P1 :: P5 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P13M3 : rk(P1 :: P5 :: P7 :: P13 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13Mtmp : rk(P13 :: nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P7 :: nil) (P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P13 :: nil) (P1 :: P5 :: P7 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P13 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P13 :: nil) (nil) 2 1 0 HP1P5P7Mtmp HP13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P7P13m3 : rk(P1 :: P5 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P5P7P8P13eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P5P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P7P8P13mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8P13eq HP1P2P5P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P5 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: nil) (P1 :: P5 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P5 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8P13mtmp;try rewrite HT2 in HP1P2P5P7P8P13mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P5P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P5P7P8P13M1. try clear HP1P2P5P7P8P13M2. try clear HP1P2P5P7P8P13M3. try clear HP1P2P5P7P8P13m4. try clear HP1P2P5P7P8P13m3. try clear HP1P2P5P7P8P13m2. try clear HP1P2P5P7P8P13m1. 

assert(HP1P5P7P13M : rk(P1 :: P5 :: P7 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P5P7P13m : rk(P1 :: P5 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P5P7P13eq HP1P5P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP6P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P6 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P7P8P13m2 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P7P8P13m3 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P7P8P13m4 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P8M1. try clear HP1P2P6P8M2. try clear HP1P2P6P8M3. try clear HP1P2P6P8m4. try clear HP1P2P6P8m3. try clear HP1P2P6P8m2. try clear HP1P2P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P7P8P13m2 : rk(P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P6M1. try clear HP2P6M2. try clear HP2P6M3. try clear HP2P6m4. try clear HP2P6m3. try clear HP2P6m2. try clear HP2P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P13m3 : rk(P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P8P13eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) = 3) by (apply LP1P2P6P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P6P7P8P13mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P8P13eq HP1P2P6P7P8P13m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P13mtmp;try rewrite HT2 in HP1P2P6P7P8P13mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P8P13mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P13m4 : rk(P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 4).
{
	try assert(HP1P6P7P8eq : rk(P1 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7P8Mtmp : rk(P1 :: P6 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P6P7P8eq HP1P6P7P8M3).
	try assert(HP1P2P6P7P8P13eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P6P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P6P7P8P13mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P8P13eq HP1P2P6P7P8P13m4).
	try assert(HP6P7P8eq : rk(P6 :: P7 :: P8 :: nil) = 3) by (apply LP6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7P8mtmp : rk(P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP6P7P8eq HP6P7P8m3).
	assert(Hincl : incl (P6 :: P7 :: P8 :: nil) (list_inter (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) ((P1 :: P6 :: P7 :: P8 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P13mtmp;try rewrite HT2 in HP1P2P6P7P8P13mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P6 :: P7 :: P8 :: nil) 4 3 3 HP1P2P6P7P8P13mtmp HP6P7P8mtmp HP1P6P7P8Mtmp Hincl); apply HT.
}
try clear HP1P6P7P8M1. try clear HP1P6P7P8M2. try clear HP1P6P7P8M3. try clear HP1P6P7P8m4. try clear HP1P6P7P8m3. try clear HP1P6P7P8m2. try clear HP1P6P7P8m1. try clear HP6P7P8M1. try clear HP6P7P8M2. try clear HP6P7P8M3. try clear HP6P7P8m4. try clear HP6P7P8m3. try clear HP6P7P8m2. try clear HP6P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P7P13m2 : rk(P6 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P6 :: P7 :: nil) (P6 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P7 :: nil) (P6 :: P7 :: P13 :: nil) 2 2 HP6P7mtmp Hcomp Hincl);apply HT.
}
try clear HP6P7M1. try clear HP6P7M2. try clear HP6P7M3. try clear HP6P7m4. try clear HP6P7m3. try clear HP6P7m2. try clear HP6P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP6P7P13m3 : rk(P6 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P6P7P8P13eq : rk(P2 :: P6 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP2P6P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P6P7P8P13mtmp : rk(P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P6P7P8P13eq HP2P6P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P6 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P6 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P6 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P8P13mtmp;try rewrite HT2 in HP2P6P7P8P13mtmp.
	assert(HT := rule_2 (P6 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P6P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P6P7P8P13M1. try clear HP2P6P7P8P13M2. try clear HP2P6P7P8P13M3. try clear HP2P6P7P8P13m4. try clear HP2P6P7P8P13m3. try clear HP2P6P7P8P13m2. try clear HP2P6P7P8P13m1. 

assert(HP6P7P13M : rk(P6 :: P7 :: P13 ::  nil) <= 3) by (solve_hyps_max HP6P7P13eq HP6P7P13M3).
assert(HP6P7P13m : rk(P6 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP6P7P13eq HP6P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP1P6P7P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P1 :: P6 :: P7 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P7P13m2 : rk(P1 :: P6 :: P7 :: P13 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P13 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6M1. try clear HP1P6M2. try clear HP1P6M3. try clear HP1P6m4. try clear HP1P6m3. try clear HP1P6m2. try clear HP1P6m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P7P13M3 : rk(P1 :: P6 :: P7 :: P13 :: nil) <= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13Mtmp : rk(P13 :: nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P6 :: P7 :: nil) (P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P13 :: nil) (P1 :: P6 :: P7 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P13 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P6 :: P7 :: nil) (P13 :: nil) (nil) 2 1 0 HP1P6P7Mtmp HP13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P6P7M1. try clear HP1P6P7M2. try clear HP1P6P7M3. try clear HP1P6P7m4. try clear HP1P6P7m3. try clear HP1P6P7m2. try clear HP1P6P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P7P13m3 : rk(P1 :: P6 :: P7 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP1P2P6P7P8P13eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) = 4) by (apply LP1P2P6P7P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P6P7P8P13mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P8P13eq HP1P2P6P7P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P1 :: P6 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P13 :: nil) (P1 :: P6 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P13 :: P2 :: P8 :: P13 :: nil) ((P1 :: P6 :: P7 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P13mtmp;try rewrite HT2 in HP1P2P6P7P8P13mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P7 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP1P2P6P7P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP1P2P6P7P8P13M1. try clear HP1P2P6P7P8P13M2. try clear HP1P2P6P7P8P13M3. try clear HP1P2P6P7P8P13m4. try clear HP1P2P6P7P8P13m3. try clear HP1P2P6P7P8P13m2. try clear HP1P2P6P7P8P13m1. 

assert(HP1P6P7P13M : rk(P1 :: P6 :: P7 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P6P7P13m : rk(P1 :: P6 :: P7 :: P13 ::  nil) >= 1) by (solve_hyps_min HP1P6P7P13eq HP1P6P7P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP8P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P8 :: P13 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P8P12P14m2 : rk(P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P8P12P14m3 : rk(P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P5P8P12P14m4 : rk(P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P8M1. try clear HP1P3P5P8M2. try clear HP1P3P5P8M3. try clear HP1P3P5P8m4. try clear HP1P3P5P8m3. try clear HP1P3P5P8m2. try clear HP1P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13P14m2 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13P14m3 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P7P8P13P14m4 : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P5P7P8P13P14m2 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP2P5mtmp : rk(P2 :: P5 :: nil) >= 2) by (solve_hyps_min HP2P5eq HP2P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P5 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P5 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) 2 2 HP2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P5M1. try clear HP2P5M2. try clear HP2P5M3. try clear HP2P5m4. try clear HP2P5m3. try clear HP2P5m2. try clear HP2P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P7P8P13P14m3 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P2P5P7P8P13P14eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) = 3) by (apply LP1P2P5P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P7P8P13P14mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P2P5P7P8P13P14eq HP1P2P5P7P8P13P14m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) (P1 :: P5 :: P7 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8P13P14mtmp;try rewrite HT2 in HP1P2P5P7P8P13P14mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P2P5P7P8P13P14mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P7P8P13P14m4 : rk(P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8Mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P7P8eq HP1P5P7P8M3).
	try assert(HP1P2P5P7P8P13P14eq : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) = 4) by (apply LP1P2P5P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P7P8P13P14mtmp : rk(P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P8P13P14eq HP1P2P5P7P8P13P14m4).
	try assert(HP5P7P8eq : rk(P5 :: P7 :: P8 :: nil) = 3) by (apply LP5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7P8mtmp : rk(P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P7P8eq HP5P7P8m3).
	assert(Hincl : incl (P5 :: P7 :: P8 :: nil) (list_inter (P1 :: P5 :: P7 :: P8 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) (P1 :: P5 :: P7 :: P8 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) ((P1 :: P5 :: P7 :: P8 :: nil) ++ (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P8P13P14mtmp;try rewrite HT2 in HP1P2P5P7P8P13P14mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P8 :: nil) (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) (P5 :: P7 :: P8 :: nil) 4 3 3 HP1P2P5P7P8P13P14mtmp HP5P7P8mtmp HP1P5P7P8Mtmp Hincl); apply HT.
}
try clear HP1P5P7P8M1. try clear HP1P5P7P8M2. try clear HP1P5P7P8M3. try clear HP1P5P7P8m4. try clear HP1P5P7P8m3. try clear HP1P5P7P8m2. try clear HP1P5P7P8m1. try clear HP5P7P8M1. try clear HP5P7P8M2. try clear HP5P7P8M3. try clear HP5P7P8m4. try clear HP5P7P8m3. try clear HP5P7P8m2. try clear HP5P7P8m1. try clear HP1P2P5P7P8P13P14M1. try clear HP1P2P5P7P8P13P14M2. try clear HP1P2P5P7P8P13P14M3. try clear HP1P2P5P7P8P13P14m4. try clear HP1P2P5P7P8P13P14m3. try clear HP1P2P5P7P8P13P14m2. try clear HP1P2P5P7P8P13P14m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P8P12P14M3 : rk(P3 :: P8 :: P12 :: P14 :: nil) <= 3).
{
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P8 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P8 :: P12 :: P14 :: nil) (P8 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P3 :: P12 :: P14 :: nil) ((P8 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P8 :: nil) (P3 :: P12 :: P14 :: nil) (nil) 1 2 0 HP8Mtmp HP3P12P14Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP8M1. try clear HP8M2. try clear HP8M3. try clear HP8m4. try clear HP8m3. try clear HP8m2. try clear HP8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P8P12P14m2 : rk(P3 :: P8 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP3P8mtmp : rk(P3 :: P8 :: nil) >= 2) by (solve_hyps_min HP3P8eq HP3P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P8 :: nil) (P3 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P8 :: nil) (P3 :: P8 :: P12 :: P14 :: nil) 2 2 HP3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P8M1. try clear HP3P8M2. try clear HP3P8M3. try clear HP3P8m4. try clear HP3P8m3. try clear HP3P8m2. try clear HP3P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P8P12P14m3 : rk(P3 :: P8 :: P12 :: P14 :: nil) >= 3).
{
	try assert(HP3P8P12eq : rk(P3 :: P8 :: P12 :: nil) = 3) by (apply LP3P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP3P8P12M1. try clear HP3P8P12M2. try clear HP3P8P12M3. try clear HP3P8P12m4. try clear HP3P8P12m3. try clear HP3P8P12m2. try clear HP3P8P12m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP8P14m2 : rk(P8 :: P14 :: nil) >= 2).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP3P8P12P14eq : rk(P3 :: P8 :: P12 :: P14 :: nil) = 3) by (apply LP3P8P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P8P12P14mtmp : rk(P3 :: P8 :: P12 :: P14 :: nil) >= 3) by (solve_hyps_min HP3P8P12P14eq HP3P8P12P14m3).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P8 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P8 :: P12 :: P14 :: nil) (P8 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P14 :: P3 :: P12 :: P14 :: nil) ((P8 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P8P12P14mtmp;try rewrite HT2 in HP3P8P12P14mtmp.
	assert(HT := rule_2 (P8 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P14 :: nil) 3 1 2 HP3P8P12P14mtmp HP14mtmp HP3P12P14Mtmp Hincl);apply HT.
}
try clear HP3P8P12P14M1. try clear HP3P8P12P14M2. try clear HP3P8P12P14M3. try clear HP3P8P12P14m4. try clear HP3P8P12P14m3. try clear HP3P8P12P14m2. try clear HP3P8P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P8P14m2 : rk(P5 :: P8 :: P14 :: nil) >= 2).
{
	assert(HP5P8mtmp : rk(P5 :: P8 :: nil) >= 2) by (solve_hyps_min HP5P8eq HP5P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P8 :: nil) (P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P8 :: nil) (P5 :: P8 :: P14 :: nil) 2 2 HP5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP5P8M1. try clear HP5P8M2. try clear HP5P8M3. try clear HP5P8m4. try clear HP5P8m3. try clear HP5P8m2. try clear HP5P8m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P8P14m3 : rk(P5 :: P8 :: P14 :: nil) >= 3).
{
	try assert(HP2P7P8P13P14eq : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) = 3) by (apply LP2P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P7P8P13P14Mtmp : rk(P2 :: P7 :: P8 :: P13 :: P14 :: nil) <= 3) by (solve_hyps_max HP2P7P8P13P14eq HP2P7P8P13P14M3).
	try assert(HP2P5P7P8P13P14eq : rk(P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) = 4) by (apply LP2P5P7P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P5P7P8P13P14mtmp : rk(P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP2P5P7P8P13P14eq HP2P5P7P8P13P14m4).
	try assert(HP8P14eq : rk(P8 :: P14 :: nil) = 2) by (apply LP8P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP8P14mtmp : rk(P8 :: P14 :: nil) >= 2) by (solve_hyps_min HP8P14eq HP8P14m2).
	assert(Hincl : incl (P8 :: P14 :: nil) (list_inter (P5 :: P8 :: P14 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P5 :: P7 :: P8 :: P13 :: P14 :: nil) (P5 :: P8 :: P14 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P8 :: P14 :: P2 :: P7 :: P8 :: P13 :: P14 :: nil) ((P5 :: P8 :: P14 :: nil) ++ (P2 :: P7 :: P8 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P5P7P8P13P14mtmp;try rewrite HT2 in HP2P5P7P8P13P14mtmp.
	assert(HT := rule_2 (P5 :: P8 :: P14 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: nil) (P8 :: P14 :: nil) 4 2 3 HP2P5P7P8P13P14mtmp HP8P14mtmp HP2P7P8P13P14Mtmp Hincl);apply HT.
}
try clear HP2P7P8P13P14M1. try clear HP2P7P8P13P14M2. try clear HP2P7P8P13P14M3. try clear HP2P7P8P13P14m4. try clear HP2P7P8P13P14m3. try clear HP2P7P8P13P14m2. try clear HP2P7P8P13P14m1. try clear HP8P14M1. try clear HP8P14M2. try clear HP8P14M3. try clear HP8P14m4. try clear HP8P14m3. try clear HP8P14m2. try clear HP8P14m1. try clear HP2P5P7P8P13P14M1. try clear HP2P5P7P8P13P14M2. try clear HP2P5P7P8P13P14M3. try clear HP2P5P7P8P13P14m4. try clear HP2P5P7P8P13P14m3. try clear HP2P5P7P8P13P14m2. try clear HP2P5P7P8P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P12P14m2 : rk(P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P12P14m3 : rk(P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP3P5P8mtmp : rk(P3 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P5P8eq HP3P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil) 3 3 HP3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5P8M1. try clear HP3P5P8M2. try clear HP3P5P8M3. try clear HP3P5P8m4. try clear HP3P5P8m3. try clear HP3P5P8m2. try clear HP3P5P8m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P8P12P14M3 : rk(P3 :: P5 :: P8 :: P12 :: P14 :: nil) <= 3).
{
	try assert(HP3P5P8P12eq : rk(P3 :: P5 :: P8 :: P12 :: nil) = 3) by (apply LP3P5P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P8P12Mtmp : rk(P3 :: P5 :: P8 :: P12 :: nil) <= 3) by (solve_hyps_max HP3P5P8P12eq HP3P5P8P12M3).
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP3P12eq : rk(P3 :: P12 :: nil) = 2) by (apply LP3P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P12mtmp : rk(P3 :: P12 :: nil) >= 2) by (solve_hyps_min HP3P12eq HP3P12m2).
	assert(Hincl : incl (P3 :: P12 :: nil) (list_inter (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P8 :: P12 :: P14 :: nil) (P3 :: P5 :: P8 :: P12 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P8 :: P12 :: P3 :: P12 :: P14 :: nil) ((P3 :: P5 :: P8 :: P12 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P12 :: P14 :: nil) (P3 :: P12 :: nil) 3 2 2 HP3P5P8P12Mtmp HP3P12P14Mtmp HP3P12mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P5P8P12M1. try clear HP3P5P8P12M2. try clear HP3P5P8P12M3. try clear HP3P5P8P12m4. try clear HP3P5P8P12m3. try clear HP3P5P8P12m2. try clear HP3P5P8P12m1. try clear HP3P12M1. try clear HP3P12M2. try clear HP3P12M3. try clear HP3P12m4. try clear HP3P12m3. try clear HP3P12m2. try clear HP3P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P8P14m2 : rk(P1 :: P5 :: P8 :: P14 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P14 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P14m3 : rk(P1 :: P5 :: P8 :: P14 :: nil) >= 3).
{
	assert(HP1P5P8mtmp : rk(P1 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P8eq HP1P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P14 :: nil) 3 3 HP1P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P8P14m4 : rk(P1 :: P5 :: P8 :: P14 :: nil) >= 4).
{
	try assert(HP3P5P8P12P14eq : rk(P3 :: P5 :: P8 :: P12 :: P14 :: nil) = 3) by (apply LP3P5P8P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P5P8P12P14Mtmp : rk(P3 :: P5 :: P8 :: P12 :: P14 :: nil) <= 3) by (solve_hyps_max HP3P5P8P12P14eq HP3P5P8P12P14M3).
	try assert(HP1P3P5P8P12P14eq : rk(P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) = 4) by (apply LP1P3P5P8P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P5P8P12P14mtmp : rk(P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8P12P14eq HP1P3P5P8P12P14m4).
	try assert(HP5P8P14eq : rk(P5 :: P8 :: P14 :: nil) = 3) by (apply LP5P8P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP5P8P14mtmp : rk(P5 :: P8 :: P14 :: nil) >= 3) by (solve_hyps_min HP5P8P14eq HP5P8P14m3).
	assert(Hincl : incl (P5 :: P8 :: P14 :: nil) (list_inter (P1 :: P5 :: P8 :: P14 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) (P1 :: P5 :: P8 :: P14 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P8 :: P14 :: P3 :: P5 :: P8 :: P12 :: P14 :: nil) ((P1 :: P5 :: P8 :: P14 :: nil) ++ (P3 :: P5 :: P8 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P8P12P14mtmp;try rewrite HT2 in HP1P3P5P8P12P14mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P8 :: P14 :: nil) (P3 :: P5 :: P8 :: P12 :: P14 :: nil) (P5 :: P8 :: P14 :: nil) 4 3 3 HP1P3P5P8P12P14mtmp HP5P8P14mtmp HP3P5P8P12P14Mtmp Hincl);apply HT.
}
try clear HP3P5P8P12P14M1. try clear HP3P5P8P12P14M2. try clear HP3P5P8P12P14M3. try clear HP3P5P8P12P14m4. try clear HP3P5P8P12P14m3. try clear HP3P5P8P12P14m2. try clear HP3P5P8P12P14m1. try clear HP5P8P14M1. try clear HP5P8P14M2. try clear HP5P8P14M3. try clear HP5P8P14m4. try clear HP5P8P14m3. try clear HP5P8P14m2. try clear HP5P8P14m1. try clear HP1P3P5P8P12P14M1. try clear HP1P3P5P8P12P14M2. try clear HP1P3P5P8P12P14M3. try clear HP1P3P5P8P12P14m4. try clear HP1P3P5P8P12P14m3. try clear HP1P3P5P8P12P14m2. try clear HP1P3P5P8P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P8P13P14m2 : rk(P1 :: P5 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P13P14m3 : rk(P1 :: P5 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P5P8mtmp : rk(P1 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P8eq HP1P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil) 3 3 HP1P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P8M1. try clear HP1P5P8M2. try clear HP1P5P8M3. try clear HP1P5P8m4. try clear HP1P5P8m3. try clear HP1P5P8m2. try clear HP1P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P5P8P13P14m4 : rk(P1 :: P5 :: P8 :: P13 :: P14 :: nil) >= 4).
{
	assert(HP1P5P8P14mtmp : rk(P1 :: P5 :: P8 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P5P8P14eq HP1P5P8P14m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: P14 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: P14 :: nil) (P1 :: P5 :: P8 :: P13 :: P14 :: nil) 4 4 HP1P5P8P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P8P14M1. try clear HP1P5P8P14M2. try clear HP1P5P8P14M3. try clear HP1P5P8P14m4. try clear HP1P5P8P14m3. try clear HP1P5P8P14m2. try clear HP1P5P8P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P7P13P14m2 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P13P14M3 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P13 :: P14 :: nil) (P1 :: P5 :: P7 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P7 :: P13 :: P14 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P7 :: P13 :: P14 :: nil) (P7 :: nil) 2 2 1 HP1P5P7Mtmp HP7P13P14Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP7M1. try clear HP7M2. try clear HP7M3. try clear HP7m4. try clear HP7m3. try clear HP7m2. try clear HP7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P7P13P14m3 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P5P13eq : rk(P1 :: P5 :: P13 :: nil) = 3) by (apply LP1P5P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P13P14m2 : rk(P1 :: P5 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P13 :: P14 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5M1. try clear HP1P5M2. try clear HP1P5M3. try clear HP1P5m4. try clear HP1P5m3. try clear HP1P5m2. try clear HP1P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P5P13P14m3 : rk(P1 :: P5 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP1P5P13eq : rk(P1 :: P5 :: P13 :: nil) = 3) by (apply LP1P5P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
try clear HP1P5P13M1. try clear HP1P5P13M2. try clear HP1P5P13M3. try clear HP1P5P13m4. try clear HP1P5P13m3. try clear HP1P5P13m2. try clear HP1P5P13m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P5P13P14M3 : rk(P1 :: P5 :: P13 :: P14 :: nil) <= 3).
{
	assert(HP1P5P7P13P14Mtmp : rk(P1 :: P5 :: P7 :: P13 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13P14eq HP1P5P7P13P14M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P13 :: P14 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P5 :: P13 :: P14 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: nil) 3 3 HP1P5P7P13P14Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P7P13P14M1. try clear HP1P5P7P13P14M2. try clear HP1P5P7P13P14M3. try clear HP1P5P7P13P14m4. try clear HP1P5P7P13P14m3. try clear HP1P5P7P13P14m2. try clear HP1P5P7P13P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P8P12P14m2 : rk(P1 :: P3 :: P8 :: P12 :: P14 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P8 :: P12 :: P14 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P3P8P12P14m3 : rk(P1 :: P3 :: P8 :: P12 :: P14 :: nil) >= 3).
{
	assert(HP1P3P8mtmp : rk(P1 :: P3 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P3P8eq HP1P3P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P12 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P8 :: nil) (P1 :: P3 :: P8 :: P12 :: P14 :: nil) 3 3 HP1P3P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P8M1. try clear HP1P3P8M2. try clear HP1P3P8M3. try clear HP1P3P8m4. try clear HP1P3P8m3. try clear HP1P3P8m2. try clear HP1P3P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P3P8P12P14m4 : rk(P1 :: P3 :: P8 :: P12 :: P14 :: nil) >= 4).
{
	try assert(HP1P3P8P12eq : rk(P1 :: P3 :: P8 :: P12 :: nil) = 4) by (apply LP1P3P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP1P3P8P12M1. try clear HP1P3P8P12M2. try clear HP1P3P8P12M3. try clear HP1P3P8P12m4. try clear HP1P3P8P12m3. try clear HP1P3P8P12m2. try clear HP1P3P8P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P8P14m2 : rk(P1 :: P8 :: P14 :: nil) >= 2).
{
	assert(HP1P8mtmp : rk(P1 :: P8 :: nil) >= 2) by (solve_hyps_min HP1P8eq HP1P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P8 :: nil) (P1 :: P8 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P8 :: nil) (P1 :: P8 :: P14 :: nil) 2 2 HP1P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P8P14m3 : rk(P1 :: P8 :: P14 :: nil) >= 3).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP1P3P8P12P14eq : rk(P1 :: P3 :: P8 :: P12 :: P14 :: nil) = 4) by (apply LP1P3P8P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P3P8P12P14mtmp : rk(P1 :: P3 :: P8 :: P12 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P3P8P12P14eq HP1P3P8P12P14m4).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P1 :: P8 :: P14 :: nil) (P3 :: P12 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P8 :: P12 :: P14 :: nil) (P1 :: P8 :: P14 :: P3 :: P12 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P8 :: P14 :: P3 :: P12 :: P14 :: nil) ((P1 :: P8 :: P14 :: nil) ++ (P3 :: P12 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P8P12P14mtmp;try rewrite HT2 in HP1P3P8P12P14mtmp.
	assert(HT := rule_2 (P1 :: P8 :: P14 :: nil) (P3 :: P12 :: P14 :: nil) (P14 :: nil) 4 1 2 HP1P3P8P12P14mtmp HP14mtmp HP3P12P14Mtmp Hincl);apply HT.
}
try clear HP1P3P8P12P14M1. try clear HP1P3P8P12P14M2. try clear HP1P3P8P12P14M3. try clear HP1P3P8P12P14m4. try clear HP1P3P8P12P14m3. try clear HP1P3P8P12P14m2. try clear HP1P3P8P12P14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P8P13P14m2 : rk(P1 :: P8 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP1P8mtmp : rk(P1 :: P8 :: nil) >= 2) by (solve_hyps_min HP1P8eq HP1P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P8 :: nil) (P1 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P8 :: nil) (P1 :: P8 :: P13 :: P14 :: nil) 2 2 HP1P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P8M1. try clear HP1P8M2. try clear HP1P8M3. try clear HP1P8m4. try clear HP1P8m3. try clear HP1P8m2. try clear HP1P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P8P13P14m3 : rk(P1 :: P8 :: P13 :: P14 :: nil) >= 3).
{
	assert(HP1P8P14mtmp : rk(P1 :: P8 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P8P14eq HP1P8P14m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P8 :: P14 :: nil) (P1 :: P8 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P8 :: P14 :: nil) (P1 :: P8 :: P13 :: P14 :: nil) 3 3 HP1P8P14mtmp Hcomp Hincl);apply HT.
}
try clear HP1P8P14M1. try clear HP1P8P14M2. try clear HP1P8P14M3. try clear HP1P8P14m4. try clear HP1P8P14m3. try clear HP1P8P14m2. try clear HP1P8P14m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P8P13P14m4 : rk(P1 :: P8 :: P13 :: P14 :: nil) >= 4).
{
	try assert(HP1P5P13P14eq : rk(P1 :: P5 :: P13 :: P14 :: nil) = 3) by (apply LP1P5P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P13P14Mtmp : rk(P1 :: P5 :: P13 :: P14 :: nil) <= 3) by (solve_hyps_max HP1P5P13P14eq HP1P5P13P14M3).
	try assert(HP1P5P8P13P14eq : rk(P1 :: P5 :: P8 :: P13 :: P14 :: nil) = 4) by (apply LP1P5P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P8P13P14mtmp : rk(P1 :: P5 :: P8 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P5P8P13P14eq HP1P5P8P13P14m4).
	try assert(HP1P13P14eq : rk(P1 :: P13 :: P14 :: nil) = 3) by (apply LP1P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P13P14mtmp : rk(P1 :: P13 :: P14 :: nil) >= 3) by (solve_hyps_min HP1P13P14eq HP1P13P14m3).
	assert(Hincl : incl (P1 :: P13 :: P14 :: nil) (list_inter (P1 :: P5 :: P13 :: P14 :: nil) (P1 :: P8 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P8 :: P13 :: P14 :: nil) (P1 :: P5 :: P13 :: P14 :: P1 :: P8 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P13 :: P14 :: P1 :: P8 :: P13 :: P14 :: nil) ((P1 :: P5 :: P13 :: P14 :: nil) ++ (P1 :: P8 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P8P13P14mtmp;try rewrite HT2 in HP1P5P8P13P14mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P13 :: P14 :: nil) (P1 :: P8 :: P13 :: P14 :: nil) (P1 :: P13 :: P14 :: nil) 4 3 3 HP1P5P8P13P14mtmp HP1P13P14mtmp HP1P5P13P14Mtmp Hincl); apply HT.
}
try clear HP1P5P13P14M1. try clear HP1P5P13P14M2. try clear HP1P5P13P14M3. try clear HP1P5P13P14m4. try clear HP1P5P13P14m3. try clear HP1P5P13P14m2. try clear HP1P5P13P14m1. try clear HP1P13P14M1. try clear HP1P13P14M2. try clear HP1P13P14M3. try clear HP1P13P14m4. try clear HP1P13P14m3. try clear HP1P13P14m2. try clear HP1P13P14m1. try clear HP1P5P8P13P14M1. try clear HP1P5P8P13P14M2. try clear HP1P5P8P13P14M3. try clear HP1P5P8P13P14m4. try clear HP1P5P8P13P14m3. try clear HP1P5P8P13P14m2. try clear HP1P5P8P13P14m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP8P13m2 : rk(P8 :: P13 :: nil) >= 2).
{
	try assert(HP1P14eq : rk(P1 :: P14 :: nil) = 2) by (apply LP1P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P14Mtmp : rk(P1 :: P14 :: nil) <= 2) by (solve_hyps_max HP1P14eq HP1P14M2).
	try assert(HP1P8P13P14eq : rk(P1 :: P8 :: P13 :: P14 :: nil) = 4) by (apply LP1P8P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P8P13P14mtmp : rk(P1 :: P8 :: P13 :: P14 :: nil) >= 4) by (solve_hyps_min HP1P8P13P14eq HP1P8P13P14m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P8 :: P13 :: nil) (P1 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P8 :: P13 :: P14 :: nil) (P8 :: P13 :: P1 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P13 :: P1 :: P14 :: nil) ((P8 :: P13 :: nil) ++ (P1 :: P14 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P8P13P14mtmp;try rewrite HT2 in HP1P8P13P14mtmp.
	assert(HT := rule_2 (P8 :: P13 :: nil) (P1 :: P14 :: nil) (nil) 4 0 2 HP1P8P13P14mtmp Hmtmp HP1P14Mtmp Hincl);apply HT.
}
try clear HP1P14M1. try clear HP1P14M2. try clear HP1P14M3. try clear HP1P14m4. try clear HP1P14m3. try clear HP1P14m2. try clear HP1P14m1. try clear HP1P8P13P14M1. try clear HP1P8P13P14M2. try clear HP1P8P13P14M3. try clear HP1P8P13P14m4. try clear HP1P8P13P14m3. try clear HP1P8P13P14m2. try clear HP1P8P13P14m1. 

assert(HP8P13M : rk(P8 :: P13 ::  nil) <= 2) by (solve_hyps_max HP8P13eq HP8P13M2).
assert(HP8P13m : rk(P8 :: P13 ::  nil) >= 1) by (solve_hyps_min HP8P13eq HP8P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP2P8P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P2 :: P8 :: P13 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

assert(HP2P8P13M : rk(P2 :: P8 :: P13 ::  nil) <= 3) by (solve_hyps_max HP2P8P13eq HP2P8P13M3).
assert(HP2P8P13m : rk(P2 :: P8 :: P13 ::  nil) >= 1) by (solve_hyps_min HP2P8P13eq HP2P8P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP10P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P10 :: P13 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P10P13m2 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P10P13m3 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P5P8P10P13m4 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P8P10P13m2 : rk(P2 :: P8 :: P10 :: P13 :: nil) >= 2).
{
	assert(HP2P8mtmp : rk(P2 :: P8 :: nil) >= 2) by (solve_hyps_min HP2P8eq HP2P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P8 :: nil) (P2 :: P8 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P8 :: nil) (P2 :: P8 :: P10 :: P13 :: nil) 2 2 HP2P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P8M1. try clear HP2P8M2. try clear HP2P8M3. try clear HP2P8m4. try clear HP2P8m3. try clear HP2P8m2. try clear HP2P8m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P8P10P13M3 : rk(P2 :: P8 :: P10 :: P13 :: nil) <= 3).
{
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10Mtmp : rk(P10 :: nil) <= 1) by (solve_hyps_max HP10eq HP10M1).
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P10 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P8 :: P10 :: P13 :: nil) (P10 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P10 :: P2 :: P8 :: P13 :: nil) ((P10 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P10 :: nil) (P2 :: P8 :: P13 :: nil) (nil) 1 2 0 HP10Mtmp HP2P8P13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP10M1. try clear HP10M2. try clear HP10M3. try clear HP10m4. try clear HP10m3. try clear HP10m2. try clear HP10m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P8P10P13m3 : rk(P2 :: P8 :: P10 :: P13 :: nil) >= 3).
{
	try assert(HP1P2P5P10eq : rk(P1 :: P2 :: P5 :: P10 :: nil) = 3) by (apply LP1P2P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP1P2P5P10Mtmp : rk(P1 :: P2 :: P5 :: P10 :: nil) <= 3) by (solve_hyps_max HP1P2P5P10eq HP1P2P5P10M3).
	try assert(HP1P2P5P8P10P13eq : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) = 4) by (apply LP1P2P5P8P10P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P2P5P8P10P13mtmp : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P10P13eq HP1P2P5P8P10P13m4).
	try assert(HP2P10eq : rk(P2 :: P10 :: nil) = 2) by (apply LP2P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hincl : incl (P2 :: P10 :: nil) (list_inter (P1 :: P2 :: P5 :: P10 :: nil) (P2 :: P8 :: P10 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P10 :: P13 :: nil) (P1 :: P2 :: P5 :: P10 :: P2 :: P8 :: P10 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P10 :: P2 :: P8 :: P10 :: P13 :: nil) ((P1 :: P2 :: P5 :: P10 :: nil) ++ (P2 :: P8 :: P10 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P10P13mtmp;try rewrite HT2 in HP1P2P5P8P10P13mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P10 :: nil) (P2 :: P8 :: P10 :: P13 :: nil) (P2 :: P10 :: nil) 4 2 3 HP1P2P5P8P10P13mtmp HP2P10mtmp HP1P2P5P10Mtmp Hincl); apply HT.
}
try clear HP1P2P5P10M1. try clear HP1P2P5P10M2. try clear HP1P2P5P10M3. try clear HP1P2P5P10m4. try clear HP1P2P5P10m3. try clear HP1P2P5P10m2. try clear HP1P2P5P10m1. try clear HP2P10M1. try clear HP2P10M2. try clear HP2P10M3. try clear HP2P10m4. try clear HP2P10m3. try clear HP2P10m2. try clear HP2P10m1. try clear HP1P2P5P8P10P13M1. try clear HP1P2P5P8P10P13M2. try clear HP1P2P5P8P10P13M3. try clear HP1P2P5P8P10P13m4. try clear HP1P2P5P8P10P13m3. try clear HP1P2P5P8P10P13m2. try clear HP1P2P5P8P10P13m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP10P13m2 : rk(P10 :: P13 :: nil) >= 2).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P8P10P13eq : rk(P2 :: P8 :: P10 :: P13 :: nil) = 3) by (apply LP2P8P10P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P10P13mtmp : rk(P2 :: P8 :: P10 :: P13 :: nil) >= 3) by (solve_hyps_min HP2P8P10P13eq HP2P8P10P13m3).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P10 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P8 :: P10 :: P13 :: nil) (P2 :: P8 :: P13 :: P10 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P10 :: P13 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P10 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P8P10P13mtmp;try rewrite HT2 in HP2P8P10P13mtmp.
	assert(HT := rule_4 (P2 :: P8 :: P13 :: nil) (P10 :: P13 :: nil) (P13 :: nil) 3 1 2 HP2P8P10P13mtmp HP13mtmp HP2P8P13Mtmp Hincl); apply HT.
}
try clear HP2P8P10P13M1. try clear HP2P8P10P13M2. try clear HP2P8P10P13M3. try clear HP2P8P10P13m4. try clear HP2P8P10P13m3. try clear HP2P8P10P13m2. try clear HP2P8P10P13m1. 

assert(HP10P13M : rk(P10 :: P13 ::  nil) <= 2) by (solve_hyps_max HP10P13eq HP10P13M2).
assert(HP10P13m : rk(P10 :: P13 ::  nil) >= 1) by (solve_hyps_min HP10P13eq HP10P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP4P5P10P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P4 :: P5 :: P10 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P5P8P13m2 : rk(P2 :: P4 :: P5 :: P8 :: P13 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P13m3 : rk(P2 :: P4 :: P5 :: P8 :: P13 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5M1. try clear HP2P4P5M2. try clear HP2P4P5M3. try clear HP2P4P5m4. try clear HP2P4P5m3. try clear HP2P4P5m2. try clear HP2P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P13m4 : rk(P2 :: P4 :: P5 :: P8 :: P13 :: nil) >= 4).
{
	assert(HP2P4P5P8mtmp : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8eq HP2P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P13 :: nil) 4 4 HP2P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5P8M1. try clear HP2P4P5P8M2. try clear HP2P4P5P8M3. try clear HP2P4P5P8m4. try clear HP2P4P5P8m3. try clear HP2P4P5P8m2. try clear HP2P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P13m2 : rk(P4 :: P5 :: P13 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P13 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P5P13m3 : rk(P4 :: P5 :: P13 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P4P5P8P13eq : rk(P2 :: P4 :: P5 :: P8 :: P13 :: nil) = 4) by (apply LP2P4P5P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P4P5P8P13mtmp : rk(P2 :: P4 :: P5 :: P8 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8P13eq HP2P4P5P8P13m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P4 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P8 :: P13 :: nil) (P4 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P13 :: P2 :: P8 :: P13 :: nil) ((P4 :: P5 :: P13 :: nil) ++ (P2 :: P8 :: P13 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P8P13mtmp;try rewrite HT2 in HP2P4P5P8P13mtmp.
	assert(HT := rule_2 (P4 :: P5 :: P13 :: nil) (P2 :: P8 :: P13 :: nil) (P13 :: nil) 4 1 2 HP2P4P5P8P13mtmp HP13mtmp HP2P8P13Mtmp Hincl);apply HT.
}
try clear HP2P8P13M1. try clear HP2P8P13M2. try clear HP2P8P13M3. try clear HP2P8P13m4. try clear HP2P8P13m3. try clear HP2P8P13m2. try clear HP2P8P13m1. try clear HP2P4P5P8P13M1. try clear HP2P4P5P8P13M2. try clear HP2P4P5P8P13M3. try clear HP2P4P5P8P13m4. try clear HP2P4P5P8P13m3. try clear HP2P4P5P8P13m2. try clear HP2P4P5P8P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P10P13m2 : rk(P4 :: P5 :: P10 :: P13 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P13 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5M1. try clear HP4P5M2. try clear HP4P5M3. try clear HP4P5m4. try clear HP4P5m3. try clear HP4P5m2. try clear HP4P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P10P13M3 : rk(P4 :: P5 :: P10 :: P13 :: nil) <= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13Mtmp : rk(P13 :: nil) <= 1) by (solve_hyps_max HP13eq HP13M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: P5 :: P10 :: nil) (P13 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P10 :: P13 :: nil) (P4 :: P5 :: P10 :: P13 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P13 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P13 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P5 :: P10 :: nil) (P13 :: nil) (nil) 2 1 0 HP4P5P10Mtmp HP13Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4P5P10M1. try clear HP4P5P10M2. try clear HP4P5P10M3. try clear HP4P5P10m4. try clear HP4P5P10m3. try clear HP4P5P10m2. try clear HP4P5P10m1. try clear HP13M1. try clear HP13M2. try clear HP13M3. try clear HP13m4. try clear HP13m3. try clear HP13m2. try clear HP13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P5P10P13m3 : rk(P4 :: P5 :: P10 :: P13 :: nil) >= 3).
{
	assert(HP4P5P13mtmp : rk(P4 :: P5 :: P13 :: nil) >= 3) by (solve_hyps_min HP4P5P13eq HP4P5P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P13 :: nil) (P4 :: P5 :: P10 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P13 :: nil) (P4 :: P5 :: P10 :: P13 :: nil) 3 3 HP4P5P13mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5P13M1. try clear HP4P5P13M2. try clear HP4P5P13M3. try clear HP4P5P13m4. try clear HP4P5P13m3. try clear HP4P5P13m2. try clear HP4P5P13m1. 

assert(HP4P5P10P13M : rk(P4 :: P5 :: P10 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP4P5P10P13m : rk(P4 :: P5 :: P10 :: P13 ::  nil) >= 1) by (solve_hyps_min HP4P5P10P13eq HP4P5P10P13m1).
intuition.
Qed.

(* dans la couche 5 *)
Lemma LP3P7P12P13 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P3 :: P7 :: P12 :: P13 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P7P12P13P14m2 : rk(P3 :: P7 :: P12 :: P13 :: P14 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: P13 :: P14 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P7P12P13P14m3 : rk(P3 :: P7 :: P12 :: P13 :: P14 :: nil) >= 3).
{
	try assert(HP3P7P12eq : rk(P3 :: P7 :: P12 :: nil) = 3) by (apply LP3P7P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P7P12P13P14M3 : rk(P3 :: P7 :: P12 :: P13 :: P14 :: nil) <= 3).
{
	try assert(HP3P12P14eq : rk(P3 :: P12 :: P14 :: nil) = 2) by (apply LP3P12P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P12P14Mtmp : rk(P3 :: P12 :: P14 :: nil) <= 2) by (solve_hyps_max HP3P12P14eq HP3P12P14M2).
	try assert(HP7P13P14eq : rk(P7 :: P13 :: P14 :: nil) = 2) by (apply LP7P13P14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP7P13P14Mtmp : rk(P7 :: P13 :: P14 :: nil) <= 2) by (solve_hyps_max HP7P13P14eq HP7P13P14M2).
	try assert(HP14eq : rk(P14 :: nil) = 1) by (apply LP14 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP14mtmp : rk(P14 :: nil) >= 1) by (solve_hyps_min HP14eq HP14m1).
	assert(Hincl : incl (P14 :: nil) (list_inter (P3 :: P12 :: P14 :: nil) (P7 :: P13 :: P14 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P12 :: P13 :: P14 :: nil) (P3 :: P12 :: P14 :: P7 :: P13 :: P14 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P12 :: P14 :: P7 :: P13 :: P14 :: nil) ((P3 :: P12 :: P14 :: nil) ++ (P7 :: P13 :: P14 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P12 :: P14 :: nil) (P7 :: P13 :: P14 :: nil) (P14 :: nil) 2 2 1 HP3P12P14Mtmp HP7P13P14Mtmp HP14mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P12P14M1. try clear HP3P12P14M2. try clear HP3P12P14M3. try clear HP3P12P14m4. try clear HP3P12P14m3. try clear HP3P12P14m2. try clear HP3P12P14m1. try clear HP7P13P14M1. try clear HP7P13P14M2. try clear HP7P13P14M3. try clear HP7P13P14m4. try clear HP7P13P14m3. try clear HP7P13P14m2. try clear HP7P13P14m1. try clear HP14M1. try clear HP14M2. try clear HP14M3. try clear HP14m4. try clear HP14m3. try clear HP14m2. try clear HP14m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P7P12P13m2 : rk(P3 :: P7 :: P12 :: P13 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: P13 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P12 :: P13 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7M1. try clear HP3P7M2. try clear HP3P7M3. try clear HP3P7m4. try clear HP3P7m3. try clear HP3P7m2. try clear HP3P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P7P12P13m3 : rk(P3 :: P7 :: P12 :: P13 :: nil) >= 3).
{
	try assert(HP3P7P12eq : rk(P3 :: P7 :: P12 :: nil) = 3) by (apply LP3P7P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
try clear HP3P7P12M1. try clear HP3P7P12M2. try clear HP3P7P12M3. try clear HP3P7P12m4. try clear HP3P7P12m3. try clear HP3P7P12m2. try clear HP3P7P12m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P7P12P13M3 : rk(P3 :: P7 :: P12 :: P13 :: nil) <= 3).
{
	assert(HP3P7P12P13P14Mtmp : rk(P3 :: P7 :: P12 :: P13 :: P14 :: nil) <= 3) by (solve_hyps_max HP3P7P12P13P14eq HP3P7P12P13P14M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: P12 :: P13 :: nil) (P3 :: P7 :: P12 :: P13 :: P14 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P7 :: P12 :: P13 :: nil) (P3 :: P7 :: P12 :: P13 :: P14 :: nil) 3 3 HP3P7P12P13P14Mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7P12P13P14M1. try clear HP3P7P12P13P14M2. try clear HP3P7P12P13P14M3. try clear HP3P7P12P13P14m4. try clear HP3P7P12P13P14m3. try clear HP3P7P12P13P14m2. try clear HP3P7P12P13P14m1. 

assert(HP3P7P12P13M : rk(P3 :: P7 :: P12 :: P13 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P7P12P13m : rk(P3 :: P7 :: P12 :: P13 ::  nil) >= 1) by (solve_hyps_min HP3P7P12P13eq HP3P7P12P13m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP2P3P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P2 :: P3 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P15m2 : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P15m3 : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P15m4 : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP2P3P5P8mtmp : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8eq HP2P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P15 :: nil) 4 4 HP2P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5P8M1. try clear HP2P3P5P8M2. try clear HP2P3P5P8M3. try clear HP2P3P5P8m4. try clear HP2P3P5P8m3. try clear HP2P3P5P8m2. try clear HP2P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P15m2 : rk(P2 :: P3 :: P15 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P15 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P15m3 : rk(P2 :: P3 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP2P3P5P8P15eq : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP2P3P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P5P8P15mtmp : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8P15eq HP2P3P5P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P2 :: P3 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P8 :: P15 :: nil) (P2 :: P3 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P15 :: P5 :: P8 :: P15 :: nil) ((P2 :: P3 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P8P15mtmp;try rewrite HT2 in HP2P3P5P8P15mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP2P3P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}


assert(HP2P3P15M : rk(P2 :: P3 :: P15 ::  nil) <= 3) by (solve_hyps_max HP2P3P15eq HP2P3P15M3).
assert(HP2P3P15m : rk(P2 :: P3 :: P15 ::  nil) >= 1) by (solve_hyps_min HP2P3P15eq HP2P3P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP4P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P4 :: P15 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P15m2 : rk(P4 :: P15 :: nil) >= 2).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP4P5P8P15eq : rk(P4 :: P5 :: P8 :: P15 :: nil) = 3) by (apply LP4P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P5P8P15mtmp : rk(P4 :: P5 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP4P5P8P15eq HP4P5P8P15m3).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P4 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P15 :: nil) (P4 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P15 :: P5 :: P8 :: P15 :: nil) ((P4 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P8P15mtmp;try rewrite HT2 in HP4P5P8P15mtmp.
	assert(HT := rule_2 (P4 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 3 1 2 HP4P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP4P5P8P15M1. try clear HP4P5P8P15M2. try clear HP4P5P8P15M3. try clear HP4P5P8P15m4. try clear HP4P5P8P15m3. try clear HP4P5P8P15m2. try clear HP4P5P8P15m1. 

assert(HP4P15M : rk(P4 :: P15 ::  nil) <= 2) by (solve_hyps_max HP4P15eq HP4P15M2).
assert(HP4P15m : rk(P4 :: P15 ::  nil) >= 1) by (solve_hyps_min HP4P15eq HP4P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP2P3P5P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P2 :: P3 :: P5 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P12P16m2 : rk(P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P12P16m3 : rk(P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P12P16m4 : rk(P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP1P2P5P12mtmp : rk(P1 :: P2 :: P5 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P5P12eq HP1P2P5P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P12 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P12 :: nil) (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) 4 4 HP1P2P5P12mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P12M1. try clear HP1P2P5P12M2. try clear HP1P2P5P12M3. try clear HP1P2P5P12m4. try clear HP1P2P5P12m3. try clear HP1P2P5P12m2. try clear HP1P2P5P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15P16m2 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15P16m3 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15P16m4 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP1P4P5P8mtmp : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) 4 4 HP1P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP5P6P12P16M3 : rk(P5 :: P6 :: P12 :: P16 :: nil) <= 3).
{
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5Mtmp : rk(P5 :: nil) <= 1) by (solve_hyps_max HP5eq HP5M1).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P12 :: P16 :: nil) (P5 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P12 :: P16 :: nil) ((P5 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: nil) (P6 :: P12 :: P16 :: nil) (nil) 1 2 0 HP5Mtmp HP6P12P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P6P12P16m2 : rk(P5 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P12 :: P16 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P6P12P16m3 : rk(P5 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP5P6P12mtmp : rk(P5 :: P6 :: P12 :: nil) >= 3) by (solve_hyps_min HP5P6P12eq HP5P6P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: P12 :: nil) (P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: P12 :: nil) (P5 :: P6 :: P12 :: P16 :: nil) 3 3 HP5P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP5P6P12M1. try clear HP5P6P12M2. try clear HP5P6P12M3. try clear HP5P6P12m4. try clear HP5P6P12m3. try clear HP5P6P12m2. try clear HP5P6P12m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P16m2 : rk(P5 :: P16 :: nil) >= 2).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP5P6P12P16eq : rk(P5 :: P6 :: P12 :: P16 :: nil) = 3) by (apply LP5P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P6P12P16mtmp : rk(P5 :: P6 :: P12 :: P16 :: nil) >= 3) by (solve_hyps_min HP5P6P12P16eq HP5P6P12P16m3).
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16mtmp : rk(P16 :: nil) >= 1) by (solve_hyps_min HP16eq HP16m1).
	assert(Hincl : incl (P16 :: nil) (list_inter (P5 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P12 :: P16 :: nil) (P5 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P16 :: P6 :: P12 :: P16 :: nil) ((P5 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P6P12P16mtmp;try rewrite HT2 in HP5P6P12P16mtmp.
	assert(HT := rule_2 (P5 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P16 :: nil) 3 1 2 HP5P6P12P16mtmp HP16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP5P6P12P16M1. try clear HP5P6P12P16M2. try clear HP5P6P12P16M3. try clear HP5P6P12P16m4. try clear HP5P6P12P16m3. try clear HP5P6P12P16m2. try clear HP5P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P15P16m2 : rk(P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P15P16m3 : rk(P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP4P5P8mtmp : rk(P4 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P5P8eq HP4P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil) 3 3 HP4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P8P15P16M3 : rk(P4 :: P5 :: P8 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P5 :: P8 :: P15 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P15 :: P16 :: nil) (P5 :: P8 :: P15 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P8 :: P15 :: P4 :: P15 :: P16 :: nil) ((P5 :: P8 :: P15 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P5 :: P8 :: P15 :: nil) (P4 :: P15 :: P16 :: nil) (P15 :: nil) 2 2 1 HP5P8P15Mtmp HP4P15P16Mtmp HP15mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P16m2 : rk(P1 :: P5 :: P16 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P16 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P16m3 : rk(P1 :: P5 :: P16 :: nil) >= 3).
{
	try assert(HP4P5P8P15P16eq : rk(P4 :: P5 :: P8 :: P15 :: P16 :: nil) = 3) by (apply LP4P5P8P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P5P8P15P16Mtmp : rk(P4 :: P5 :: P8 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP4P5P8P15P16eq HP4P5P8P15P16M3).
	try assert(HP1P4P5P8P15P16eq : rk(P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) = 4) by (apply LP1P4P5P8P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P8P15P16mtmp : rk(P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8P15P16eq HP1P4P5P8P15P16m4).
	try assert(HP5P16eq : rk(P5 :: P16 :: nil) = 2) by (apply LP5P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P16mtmp : rk(P5 :: P16 :: nil) >= 2) by (solve_hyps_min HP5P16eq HP5P16m2).
	assert(Hincl : incl (P5 :: P16 :: nil) (list_inter (P1 :: P5 :: P16 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) (P1 :: P5 :: P16 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P16 :: P4 :: P5 :: P8 :: P15 :: P16 :: nil) ((P1 :: P5 :: P16 :: nil) ++ (P4 :: P5 :: P8 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P8P15P16mtmp;try rewrite HT2 in HP1P4P5P8P15P16mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P16 :: nil) (P4 :: P5 :: P8 :: P15 :: P16 :: nil) (P5 :: P16 :: nil) 4 2 3 HP1P4P5P8P15P16mtmp HP5P16mtmp HP4P5P8P15P16Mtmp Hincl);apply HT.
}
try clear HP4P5P8P15P16M1. try clear HP4P5P8P15P16M2. try clear HP4P5P8P15P16M3. try clear HP4P5P8P15P16m4. try clear HP4P5P8P15P16m3. try clear HP4P5P8P15P16m2. try clear HP4P5P8P15P16m1. try clear HP5P16M1. try clear HP5P16M2. try clear HP5P16M3. try clear HP5P16m4. try clear HP5P16m3. try clear HP5P16m2. try clear HP5P16m1. try clear HP1P4P5P8P15P16M1. try clear HP1P4P5P8P15P16M2. try clear HP1P4P5P8P15P16M3. try clear HP1P4P5P8P15P16m4. try clear HP1P4P5P8P15P16m3. try clear HP1P4P5P8P15P16m2. try clear HP1P4P5P8P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P6P12P16m2 : rk(P1 :: P5 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P12P16M3 : rk(P1 :: P5 :: P6 :: P12 :: P16 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P12 :: P16 :: nil) (P1 :: P5 :: P6 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P6 :: P12 :: P16 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: nil) 2 2 1 HP1P5P6Mtmp HP6P12P16Mtmp HP6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P6P12P16m3 : rk(P1 :: P5 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP1P5P12mtmp : rk(P1 :: P5 :: P12 :: nil) >= 3) by (solve_hyps_min HP1P5P12eq HP1P5P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P12 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P12 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil) 3 3 HP1P5P12mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P12M1. try clear HP1P5P12M2. try clear HP1P5P12M3. try clear HP1P5P12m4. try clear HP1P5P12m3. try clear HP1P5P12m2. try clear HP1P5P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P16m2 : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P16m3 : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P16m4 : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 4).
{
	try assert(HP1P5P6P12P16eq : rk(P1 :: P5 :: P6 :: P12 :: P16 :: nil) = 3) by (apply LP1P5P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P6P12P16Mtmp : rk(P1 :: P5 :: P6 :: P12 :: P16 :: nil) <= 3) by (solve_hyps_max HP1P5P6P12P16eq HP1P5P6P12P16M3).
	try assert(HP1P2P5P6P12P16eq : rk(P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) = 4) by (apply LP1P2P5P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P5P6P12P16mtmp : rk(P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P12P16eq HP1P2P5P6P12P16m4).
	try assert(HP1P5P16eq : rk(P1 :: P5 :: P16 :: nil) = 3) by (apply LP1P5P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P16mtmp : rk(P1 :: P5 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P5P16eq HP1P5P16m3).
	assert(Hincl : incl (P1 :: P5 :: P16 :: nil) (list_inter (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P12 :: P16 :: nil) (P1 :: P2 :: P5 :: P16 :: P1 :: P5 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P16 :: P1 :: P5 :: P6 :: P12 :: P16 :: nil) ((P1 :: P2 :: P5 :: P16 :: nil) ++ (P1 :: P5 :: P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P12P16mtmp;try rewrite HT2 in HP1P2P5P6P12P16mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P5 :: P6 :: P12 :: P16 :: nil) (P1 :: P5 :: P16 :: nil) 4 3 3 HP1P2P5P6P12P16mtmp HP1P5P16mtmp HP1P5P6P12P16Mtmp Hincl);apply HT.
}
try clear HP1P5P6P12P16M1. try clear HP1P5P6P12P16M2. try clear HP1P5P6P12P16M3. try clear HP1P5P6P12P16m4. try clear HP1P5P6P12P16m3. try clear HP1P5P6P12P16m2. try clear HP1P5P6P12P16m1. try clear HP1P2P5P6P12P16M1. try clear HP1P2P5P6P12P16M2. try clear HP1P2P5P6P12P16M3. try clear HP1P2P5P6P12P16m4. try clear HP1P2P5P6P12P16m3. try clear HP1P2P5P6P12P16m2. try clear HP1P2P5P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P15P16m2 : rk(P1 :: P2 :: P5 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P15P16m3 : rk(P1 :: P2 :: P5 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P5P15P16m4 : rk(P1 :: P2 :: P5 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP1P2P5P16mtmp : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P5P16eq HP1P2P5P16m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P2 :: P5 :: P15 :: P16 :: nil) 4 4 HP1P2P5P16mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15m2 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15m3 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P8P15m4 : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P4P5P8mtmp : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P8 :: P15 :: nil) 4 4 HP1P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P15m2 : rk(P1 :: P4 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P15m3 : rk(P1 :: P4 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P4P5P8P15eq : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP1P4P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P8P15mtmp : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8P15eq HP1P4P5P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P1 :: P4 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P8 :: P15 :: nil) (P1 :: P4 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P4 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P8P15mtmp;try rewrite HT2 in HP1P4P5P8P15mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP1P4P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P4P15P16M3 : rk(P1 :: P4 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P15 :: P16 :: nil) (P1 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P15 :: P16 :: nil) ((P1 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P4 :: P15 :: P16 :: nil) (nil) 1 2 0 HP1Mtmp HP4P15P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P15P16m2 : rk(P1 :: P4 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P15 :: P16 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P4P15P16m3 : rk(P1 :: P4 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P4P15mtmp : rk(P1 :: P4 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P4P15eq HP1P4P15m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P15 :: nil) (P1 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P15 :: nil) (P1 :: P4 :: P15 :: P16 :: nil) 3 3 HP1P4P15mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P15M1. try clear HP1P4P15M2. try clear HP1P4P15M3. try clear HP1P4P15m4. try clear HP1P4P15m3. try clear HP1P4P15m2. try clear HP1P4P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P6P8P12P15P16m2 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P6P8P12P15P16m3 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P6P8P12P15P16m4 : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P8M1. try clear HP1P3P5P8M2. try clear HP1P3P5P8M3. try clear HP1P3P5P8m4. try clear HP1P3P5P8m3. try clear HP1P3P5P8m2. try clear HP1P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P6P8P12P15P16m2 : rk(P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P8P12P15P16m3 : rk(P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P3P5P6P8P12P15P16eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) = 3) by (apply LP1P3P5P6P8P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P3P5P6P8P12P15P16mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P3P5P6P8P12P15P16eq HP1P3P5P6P8P12P15P16m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8P12P15P16mtmp;try rewrite HT2 in HP1P3P5P6P8P12P15P16mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P3P5P6P8P12P15P16mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P6P8P12P15P16m4 : rk(P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP1P5P6P8eq : rk(P1 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P8Mtmp : rk(P1 :: P5 :: P6 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P6P8eq HP1P5P6P8M3).
	try assert(HP1P3P5P6P8P12P15P16eq : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP1P3P5P6P8P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P3P5P6P8P12P15P16mtmp : rk(P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P3P5P6P8P12P15P16eq HP1P3P5P6P8P12P15P16m4).
	try assert(HP5P6P8eq : rk(P5 :: P6 :: P8 :: nil) = 3) by (apply LP5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (list_inter (P1 :: P5 :: P6 :: P8 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P1 :: P5 :: P6 :: P8 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P8 :: P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) ((P1 :: P5 :: P6 :: P8 :: nil) ++ (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P6P8P12P15P16mtmp;try rewrite HT2 in HP1P3P5P6P8P12P15P16mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P8 :: nil) (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P5 :: P6 :: P8 :: nil) 4 3 3 HP1P3P5P6P8P12P15P16mtmp HP5P6P8mtmp HP1P5P6P8Mtmp Hincl); apply HT.
}
try clear HP1P3P5P6P8P12P15P16M1. try clear HP1P3P5P6P8P12P15P16M2. try clear HP1P3P5P6P8P12P15P16M3. try clear HP1P3P5P6P8P12P15P16m4. try clear HP1P3P5P6P8P12P15P16m3. try clear HP1P3P5P6P8P12P15P16m2. try clear HP1P3P5P6P8P12P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P6P8P12P15P16m2 : rk(P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P6P8P12P15P16m3 : rk(P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) 3 3 HP5P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP5P6P8P12P15P16m4 : rk(P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP3P5P8P12eq : rk(P3 :: P5 :: P8 :: P12 :: nil) = 3) by (apply LP3P5P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P8P12Mtmp : rk(P3 :: P5 :: P8 :: P12 :: nil) <= 3) by (solve_hyps_max HP3P5P8P12eq HP3P5P8P12M3).
	try assert(HP3P5P6P8P12P15P16eq : rk(P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP3P5P6P8P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP3P5P6P8P12P15P16mtmp : rk(P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP3P5P6P8P12P15P16eq HP3P5P6P8P12P15P16m4).
	try assert(HP5P8P12eq : rk(P5 :: P8 :: P12 :: nil) = 3) by (apply LP5P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP5P8P12mtmp : rk(P5 :: P8 :: P12 :: nil) >= 3) by (solve_hyps_min HP5P8P12eq HP5P8P12m3).
	assert(Hincl : incl (P5 :: P8 :: P12 :: nil) (list_inter (P3 :: P5 :: P8 :: P12 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P3 :: P5 :: P8 :: P12 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P8 :: P12 :: P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) ((P3 :: P5 :: P8 :: P12 :: nil) ++ (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P6P8P12P15P16mtmp;try rewrite HT2 in HP3P5P6P8P12P15P16mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P8 :: P12 :: nil) (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P5 :: P8 :: P12 :: nil) 4 3 3 HP3P5P6P8P12P15P16mtmp HP5P8P12mtmp HP3P5P8P12Mtmp Hincl); apply HT.
}
try clear HP3P5P8P12M1. try clear HP3P5P8P12M2. try clear HP3P5P8P12M3. try clear HP3P5P8P12m4. try clear HP3P5P8P12m3. try clear HP3P5P8P12m2. try clear HP3P5P8P12m1. try clear HP5P8P12M1. try clear HP5P8P12M2. try clear HP5P8P12M3. try clear HP5P8P12m4. try clear HP5P8P12m3. try clear HP5P8P12m2. try clear HP5P8P12m1. try clear HP3P5P6P8P12P15P16M1. try clear HP3P5P6P8P12P15P16M2. try clear HP3P5P6P8P12P15P16M3. try clear HP3P5P6P8P12P15P16m4. try clear HP3P5P6P8P12P15P16m3. try clear HP3P5P6P8P12P15P16m2. try clear HP3P5P6P8P12P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P12P15P16m2 : rk(P6 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP6P12mtmp : rk(P6 :: P12 :: nil) >= 2) by (solve_hyps_min HP6P12eq HP6P12m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P6 :: P12 :: nil) (P6 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P12 :: nil) (P6 :: P12 :: P15 :: P16 :: nil) 2 2 HP6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP6P12M1. try clear HP6P12M2. try clear HP6P12M3. try clear HP6P12m4. try clear HP6P12m3. try clear HP6P12m2. try clear HP6P12m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP6P12P15P16M3 : rk(P6 :: P12 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15Mtmp : rk(P15 :: nil) <= 1) by (solve_hyps_max HP15eq HP15M1).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P15 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P12 :: P15 :: P16 :: nil) (P15 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P15 :: P6 :: P12 :: P16 :: nil) ((P15 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P15 :: nil) (P6 :: P12 :: P16 :: nil) (nil) 1 2 0 HP15Mtmp HP6P12P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP6P12P15P16m3 : rk(P6 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP5P6P8P12P15P16eq : rk(P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP5P6P8P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P6P8P12P15P16mtmp : rk(P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP5P6P8P12P15P16eq HP5P6P8P12P15P16m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P5 :: P8 :: P15 :: nil) (P6 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P8 :: P12 :: P15 :: P16 :: nil) (P5 :: P8 :: P15 :: P6 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P8 :: P15 :: P6 :: P12 :: P15 :: P16 :: nil) ((P5 :: P8 :: P15 :: nil) ++ (P6 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P6P8P12P15P16mtmp;try rewrite HT2 in HP5P6P8P12P15P16mtmp.
	assert(HT := rule_4 (P5 :: P8 :: P15 :: nil) (P6 :: P12 :: P15 :: P16 :: nil) (P15 :: nil) 4 1 2 HP5P6P8P12P15P16mtmp HP15mtmp HP5P8P15Mtmp Hincl); apply HT.
}
try clear HP5P6P8P12P15P16M1. try clear HP5P6P8P12P15P16M2. try clear HP5P6P8P12P15P16M3. try clear HP5P6P8P12P15P16m4. try clear HP5P6P8P12P15P16m3. try clear HP5P6P8P12P15P16m2. try clear HP5P6P8P12P15P16m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP15P16m2 : rk(P15 :: P16 :: nil) >= 2).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP6P12P15P16eq : rk(P6 :: P12 :: P15 :: P16 :: nil) = 3) by (apply LP6P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P15P16mtmp : rk(P6 :: P12 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP6P12P15P16eq HP6P12P15P16m3).
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16mtmp : rk(P16 :: nil) >= 1) by (solve_hyps_min HP16eq HP16m1).
	assert(Hincl : incl (P16 :: nil) (list_inter (P6 :: P12 :: P16 :: nil) (P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P12 :: P15 :: P16 :: nil) (P6 :: P12 :: P16 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P12 :: P16 :: P15 :: P16 :: nil) ((P6 :: P12 :: P16 :: nil) ++ (P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP6P12P15P16mtmp;try rewrite HT2 in HP6P12P15P16mtmp.
	assert(HT := rule_4 (P6 :: P12 :: P16 :: nil) (P15 :: P16 :: nil) (P16 :: nil) 3 1 2 HP6P12P15P16mtmp HP16mtmp HP6P12P16Mtmp Hincl); apply HT.
}
try clear HP6P12P15P16M1. try clear HP6P12P15P16M2. try clear HP6P12P15P16M3. try clear HP6P12P15P16m4. try clear HP6P12P15P16m3. try clear HP6P12P15P16m2. try clear HP6P12P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P15m2 : rk(P1 :: P2 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P15m3 : rk(P1 :: P2 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P15m4 : rk(P1 :: P2 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P15 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P15m2 : rk(P1 :: P2 :: P15 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P15 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P15m3 : rk(P1 :: P2 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P2P5P8P15eq : rk(P1 :: P2 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP1P2P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P5P8P15mtmp : rk(P1 :: P2 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P15eq HP1P2P5P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P1 :: P2 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P15 :: nil) (P1 :: P2 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P2 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P15mtmp;try rewrite HT2 in HP1P2P5P8P15mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP1P2P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP1P2P5P8P15M1. try clear HP1P2P5P8P15M2. try clear HP1P2P5P8P15M3. try clear HP1P2P5P8P15m4. try clear HP1P2P5P8P15m3. try clear HP1P2P5P8P15m2. try clear HP1P2P5P8P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P15P16m2 : rk(P1 :: P2 :: P3 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P15P16m3 : rk(P1 :: P2 :: P3 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P15mtmp : rk(P1 :: P2 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P2P15eq HP1P2P15m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P3 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P3 :: P15 :: P16 :: nil) 3 3 HP1P2P15mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P8P15M3 : rk(P1 :: P5 :: P8 :: P15 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P8 :: P15 :: nil) (P1 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P8 :: P15 :: nil) ((P1 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P5 :: P8 :: P15 :: nil) (nil) 1 2 0 HP1Mtmp HP5P8P15Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P15m2 : rk(P1 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P8 :: P15 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P8P15m3 : rk(P1 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P5P8mtmp : rk(P1 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P8eq HP1P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P8 :: P15 :: nil) 3 3 HP1P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P15m2 : rk(P1 :: P15 :: nil) >= 2).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P5P8P15eq : rk(P1 :: P5 :: P8 :: P15 :: nil) = 3) by (apply LP1P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P8P15mtmp : rk(P1 :: P5 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P5P8P15eq HP1P5P8P15m3).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P1 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P8 :: P15 :: nil) (P1 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P8P15mtmp;try rewrite HT2 in HP1P5P8P15mtmp.
	assert(HT := rule_2 (P1 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 3 1 2 HP1P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP1P5P8P15M1. try clear HP1P5P8P15M2. try clear HP1P5P8P15M3. try clear HP1P5P8P15m4. try clear HP1P5P8P15m3. try clear HP1P5P8P15m2. try clear HP1P5P8P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P15m2 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P15m3 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P15m4 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P15m2 : rk(P1 :: P2 :: P3 :: P15 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P15 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P3P15M3 : rk(P1 :: P2 :: P3 :: P15 :: nil) <= 3).
{
	try assert(HP1P2P3eq : rk(P1 :: P2 :: P3 :: nil) = 2) by (apply LP1P2P3 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P3Mtmp : rk(P1 :: P2 :: P3 :: nil) <= 2) by (solve_hyps_max HP1P2P3eq HP1P2P3M2).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15Mtmp : rk(P15 :: nil) <= 1) by (solve_hyps_max HP15eq HP15M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P2 :: P3 :: nil) (P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P15 :: nil) (P1 :: P2 :: P3 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P15 :: nil) ((P1 :: P2 :: P3 :: nil) ++ (P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P3 :: nil) (P15 :: nil) (nil) 2 1 0 HP1P2P3Mtmp HP15Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P3M1. try clear HP1P2P3M2. try clear HP1P2P3M3. try clear HP1P2P3m4. try clear HP1P2P3m3. try clear HP1P2P3m2. try clear HP1P2P3m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P15m3 : rk(P1 :: P2 :: P3 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P2P3P5P8P15eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP1P2P3P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P5P8P15mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8P15eq HP1P2P3P5P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P1 :: P2 :: P3 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: P15 :: nil) (P1 :: P2 :: P3 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P2 :: P3 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8P15mtmp;try rewrite HT2 in HP1P2P3P5P8P15mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP1P2P3P5P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP1P2P3P5P8P15M1. try clear HP1P2P3P5P8P15M2. try clear HP1P2P3P5P8P15M3. try clear HP1P2P3P5P8P15m4. try clear HP1P2P3P5P8P15m3. try clear HP1P2P3P5P8P15m2. try clear HP1P2P3P5P8P15m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P15P16m2 : rk(P1 :: P15 :: P16 :: nil) >= 2).
{
	try assert(HP1P2P3P15eq : rk(P1 :: P2 :: P3 :: P15 :: nil) = 3) by (apply LP1P2P3P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P15Mtmp : rk(P1 :: P2 :: P3 :: P15 :: nil) <= 3) by (solve_hyps_max HP1P2P3P15eq HP1P2P3P15M3).
	try assert(HP1P2P3P15P16eq : rk(P1 :: P2 :: P3 :: P15 :: P16 :: nil) = 3) by (apply LP1P2P3P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P15P16mtmp : rk(P1 :: P2 :: P3 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P2P3P15P16eq HP1P2P3P15P16m3).
	try assert(HP1P15eq : rk(P1 :: P15 :: nil) = 2) by (apply LP1P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P15mtmp : rk(P1 :: P15 :: nil) >= 2) by (solve_hyps_min HP1P15eq HP1P15m2).
	assert(Hincl : incl (P1 :: P15 :: nil) (list_inter (P1 :: P2 :: P3 :: P15 :: nil) (P1 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P15 :: P16 :: nil) (P1 :: P2 :: P3 :: P15 :: P1 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P15 :: P1 :: P15 :: P16 :: nil) ((P1 :: P2 :: P3 :: P15 :: nil) ++ (P1 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P15P16mtmp;try rewrite HT2 in HP1P2P3P15P16mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P15 :: nil) (P1 :: P15 :: P16 :: nil) (P1 :: P15 :: nil) 3 2 3 HP1P2P3P15P16mtmp HP1P15mtmp HP1P2P3P15Mtmp Hincl); apply HT.
}
try clear HP1P2P3P15M1. try clear HP1P2P3P15M2. try clear HP1P2P3P15M3. try clear HP1P2P3P15m4. try clear HP1P2P3P15m3. try clear HP1P2P3P15m2. try clear HP1P2P3P15m1. try clear HP1P15M1. try clear HP1P15M2. try clear HP1P15M3. try clear HP1P15m4. try clear HP1P15m3. try clear HP1P15m2. try clear HP1P15m1. try clear HP1P2P3P15P16M1. try clear HP1P2P3P15P16M2. try clear HP1P2P3P15P16M3. try clear HP1P2P3P15P16m4. try clear HP1P2P3P15P16m3. try clear HP1P2P3P15P16m2. try clear HP1P2P3P15P16m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P15P16m3 : rk(P1 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP1P4P15P16eq : rk(P1 :: P4 :: P15 :: P16 :: nil) = 3) by (apply LP1P4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P15P16mtmp : rk(P1 :: P4 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P4P15P16eq HP1P4P15P16m3).
	try assert(HP15P16eq : rk(P15 :: P16 :: nil) = 2) by (apply LP15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15P16mtmp : rk(P15 :: P16 :: nil) >= 2) by (solve_hyps_min HP15P16eq HP15P16m2).
	assert(Hincl : incl (P15 :: P16 :: nil) (list_inter (P1 :: P15 :: P16 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P15 :: P16 :: nil) (P1 :: P15 :: P16 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P15 :: P16 :: P4 :: P15 :: P16 :: nil) ((P1 :: P15 :: P16 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P15P16mtmp;try rewrite HT2 in HP1P4P15P16mtmp.
	assert(HT := rule_2 (P1 :: P15 :: P16 :: nil) (P4 :: P15 :: P16 :: nil) (P15 :: P16 :: nil) 3 2 2 HP1P4P15P16mtmp HP15P16mtmp HP4P15P16Mtmp Hincl);apply HT.
}
try clear HP15P16M1. try clear HP15P16M2. try clear HP15P16M3. try clear HP15P16m4. try clear HP15P16m3. try clear HP15P16m2. try clear HP15P16m1. try clear HP1P4P15P16M1. try clear HP1P4P15P16M2. try clear HP1P4P15P16M3. try clear HP1P4P15P16m4. try clear HP1P4P15P16m3. try clear HP1P4P15P16m2. try clear HP1P4P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P15P16m2 : rk(P1 :: P2 :: P4 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P2P4P15P16M3 : rk(P1 :: P2 :: P4 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP1P2P4eq : rk(P1 :: P2 :: P4 :: nil) = 2) by (apply LP1P2P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P2P4Mtmp : rk(P1 :: P2 :: P4 :: nil) <= 2) by (solve_hyps_max HP1P2P4eq HP1P2P4M2).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P1 :: P2 :: P4 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P15 :: P16 :: nil) (P1 :: P2 :: P4 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P4 :: P15 :: P16 :: nil) ((P1 :: P2 :: P4 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P2 :: P4 :: nil) (P4 :: P15 :: P16 :: nil) (P4 :: nil) 2 2 1 HP1P2P4Mtmp HP4P15P16Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P2P4M1. try clear HP1P2P4M2. try clear HP1P2P4M3. try clear HP1P2P4m4. try clear HP1P2P4m3. try clear HP1P2P4m2. try clear HP1P2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P4P15P16m3 : rk(P1 :: P2 :: P4 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P15mtmp : rk(P1 :: P2 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P2P15eq HP1P2P15m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil) 3 3 HP1P2P15mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P15P16m2 : rk(P1 :: P2 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P15P16m3 : rk(P1 :: P2 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P15mtmp : rk(P1 :: P2 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P2P15eq HP1P2P15m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P15 :: nil) (P1 :: P2 :: P15 :: P16 :: nil) 3 3 HP1P2P15mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P15M1. try clear HP1P2P15M2. try clear HP1P2P15M3. try clear HP1P2P15m4. try clear HP1P2P15m3. try clear HP1P2P15m2. try clear HP1P2P15m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P15P16M3 : rk(P1 :: P2 :: P15 :: P16 :: nil) <= 3).
{
	assert(HP1P2P4P15P16Mtmp : rk(P1 :: P2 :: P4 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP1P2P4P15P16eq HP1P2P4P15P16M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P2 :: P4 :: P15 :: P16 :: nil) 3 3 HP1P2P4P15P16Mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P4P15P16M1. try clear HP1P2P4P15P16M2. try clear HP1P2P4P15P16M3. try clear HP1P2P4P15P16m4. try clear HP1P2P4P15P16m3. try clear HP1P2P4P15P16m2. try clear HP1P2P4P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P15P16m2 : rk(P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P15P16m3 : rk(P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P5P15P16m4 : rk(P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP1P2P5P16mtmp : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P5P16eq HP1P2P5P16m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P16 :: nil) (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) 4 4 HP1P2P5P16mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P16m2 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P16m3 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P16m4 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P16m2 : rk(P1 :: P2 :: P5 :: P8 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P16m3 : rk(P1 :: P2 :: P5 :: P8 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P16m4 : rk(P1 :: P2 :: P5 :: P8 :: P16 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P16m2 : rk(P1 :: P2 :: P3 :: P5 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P16m3 : rk(P1 :: P2 :: P3 :: P5 :: P16 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P16m4 : rk(P1 :: P2 :: P3 :: P5 :: P16 :: nil) >= 4).
{
	try assert(HP1P2P5P8P16eq : rk(P1 :: P2 :: P5 :: P8 :: P16 :: nil) = 4) by (apply LP1P2P5P8P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P5P8P16Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P16 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P16eq HP1P2P5P8P16M4).
	try assert(HP1P2P3P5P8P16eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) = 4) by (apply LP1P2P3P5P8P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P5P8P16mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8P16eq HP1P2P3P5P8P16m4).
	try assert(HP1P2P5P16eq : rk(P1 :: P2 :: P5 :: P16 :: nil) = 4) by (apply LP1P2P5P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P5P16mtmp : rk(P1 :: P2 :: P5 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P5P16eq HP1P2P5P16m4).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P16 :: nil) (list_inter (P1 :: P2 :: P3 :: P5 :: P16 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: P16 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: P1 :: P2 :: P5 :: P8 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: P16 :: P1 :: P2 :: P5 :: P8 :: P16 :: nil) ((P1 :: P2 :: P3 :: P5 :: P16 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8P16mtmp;try rewrite HT2 in HP1P2P3P5P8P16mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P5 :: P16 :: nil) (P1 :: P2 :: P5 :: P8 :: P16 :: nil) (P1 :: P2 :: P5 :: P16 :: nil) 4 4 4 HP1P2P3P5P8P16mtmp HP1P2P5P16mtmp HP1P2P5P8P16Mtmp Hincl);apply HT.
}
try clear HP1P2P5P8P16M1. try clear HP1P2P5P8P16M2. try clear HP1P2P5P8P16M3. try clear HP1P2P5P8P16m4. try clear HP1P2P5P8P16m3. try clear HP1P2P5P8P16m2. try clear HP1P2P5P8P16m1. try clear HP1P2P5P16M1. try clear HP1P2P5P16M2. try clear HP1P2P5P16M3. try clear HP1P2P5P16m4. try clear HP1P2P5P16m3. try clear HP1P2P5P16m2. try clear HP1P2P5P16m1. try clear HP1P2P3P5P8P16M1. try clear HP1P2P3P5P8P16M2. try clear HP1P2P3P5P8P16M3. try clear HP1P2P3P5P8P16m4. try clear HP1P2P3P5P8P16m3. try clear HP1P2P3P5P8P16m2. try clear HP1P2P3P5P8P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P15P16m2 : rk(P1 :: P5 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P15 :: P16 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P15P16m3 : rk(P1 :: P5 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP1P2P3P5P16eq : rk(P1 :: P2 :: P3 :: P5 :: P16 :: nil) = 4) by (apply LP1P2P3P5P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P5P16Mtmp : rk(P1 :: P2 :: P3 :: P5 :: P16 :: nil) <= 4) by (solve_hyps_max HP1P2P3P5P16eq HP1P2P3P5P16M4).
	try assert(HP1P2P3P5P15P16eq : rk(P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) = 4) by (apply LP1P2P3P5P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P3P5P15P16mtmp : rk(P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P15P16eq HP1P2P3P5P15P16m4).
	try assert(HP1P5P16eq : rk(P1 :: P5 :: P16 :: nil) = 3) by (apply LP1P5P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P16mtmp : rk(P1 :: P5 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P5P16eq HP1P5P16m3).
	assert(Hincl : incl (P1 :: P5 :: P16 :: nil) (list_inter (P1 :: P2 :: P3 :: P5 :: P16 :: nil) (P1 :: P5 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P15 :: P16 :: nil) (P1 :: P2 :: P3 :: P5 :: P16 :: P1 :: P5 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: P16 :: P1 :: P5 :: P15 :: P16 :: nil) ((P1 :: P2 :: P3 :: P5 :: P16 :: nil) ++ (P1 :: P5 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P15P16mtmp;try rewrite HT2 in HP1P2P3P5P15P16mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P5 :: P16 :: nil) (P1 :: P5 :: P15 :: P16 :: nil) (P1 :: P5 :: P16 :: nil) 4 3 4 HP1P2P3P5P15P16mtmp HP1P5P16mtmp HP1P2P3P5P16Mtmp Hincl); apply HT.
}
try clear HP1P2P3P5P16M1. try clear HP1P2P3P5P16M2. try clear HP1P2P3P5P16M3. try clear HP1P2P3P5P16m4. try clear HP1P2P3P5P16m3. try clear HP1P2P3P5P16m2. try clear HP1P2P3P5P16m1. try clear HP1P5P16M1. try clear HP1P5P16M2. try clear HP1P5P16M3. try clear HP1P5P16m4. try clear HP1P5P16m3. try clear HP1P5P16m2. try clear HP1P5P16m1. try clear HP1P2P3P5P15P16M1. try clear HP1P2P3P5P15P16M2. try clear HP1P2P3P5P15P16M3. try clear HP1P2P3P5P15P16m4. try clear HP1P2P3P5P15P16m3. try clear HP1P2P3P5P15P16m2. try clear HP1P2P3P5P15P16m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P5P15P16m4 : rk(P1 :: P5 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP1P2P15P16eq : rk(P1 :: P2 :: P15 :: P16 :: nil) = 3) by (apply LP1P2P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P15P16Mtmp : rk(P1 :: P2 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP1P2P15P16eq HP1P2P15P16M3).
	try assert(HP1P2P5P15P16eq : rk(P1 :: P2 :: P5 :: P15 :: P16 :: nil) = 4) by (apply LP1P2P5P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P5P15P16mtmp : rk(P1 :: P2 :: P5 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P5P15P16eq HP1P2P5P15P16m4).
	try assert(HP1P15P16eq : rk(P1 :: P15 :: P16 :: nil) = 3) by (apply LP1P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P15P16mtmp : rk(P1 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P15P16eq HP1P15P16m3).
	assert(Hincl : incl (P1 :: P15 :: P16 :: nil) (list_inter (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P5 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P15 :: P16 :: nil) (P1 :: P2 :: P15 :: P16 :: P1 :: P5 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P15 :: P16 :: P1 :: P5 :: P15 :: P16 :: nil) ((P1 :: P2 :: P15 :: P16 :: nil) ++ (P1 :: P5 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P15P16mtmp;try rewrite HT2 in HP1P2P5P15P16mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P5 :: P15 :: P16 :: nil) (P1 :: P15 :: P16 :: nil) 4 3 3 HP1P2P5P15P16mtmp HP1P15P16mtmp HP1P2P15P16Mtmp Hincl); apply HT.
}
try clear HP1P2P5P15P16M1. try clear HP1P2P5P15P16M2. try clear HP1P2P5P15P16M3. try clear HP1P2P5P15P16m4. try clear HP1P2P5P15P16m3. try clear HP1P2P5P15P16m2. try clear HP1P2P5P15P16m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P12P16M3 : rk(P1 :: P6 :: P12 :: P16 :: nil) <= 3).
{
	try assert(HP1eq : rk(P1 :: nil) = 1) by (apply LP1 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1Mtmp : rk(P1 :: nil) <= 1) by (solve_hyps_max HP1eq HP1M1).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P12 :: P16 :: nil) (P1 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P12 :: P16 :: nil) ((P1 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: nil) (P6 :: P12 :: P16 :: nil) (nil) 1 2 0 HP1Mtmp HP6P12P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1M1. try clear HP1M2. try clear HP1M3. try clear HP1m4. try clear HP1m3. try clear HP1m2. try clear HP1m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P12P16m2 : rk(P1 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P12 :: P16 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P12P16m3 : rk(P1 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP1P6P12mtmp : rk(P1 :: P6 :: P12 :: nil) >= 3) by (solve_hyps_min HP1P6P12eq HP1P6P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P12 :: nil) (P1 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: P12 :: nil) (P1 :: P6 :: P12 :: P16 :: nil) 3 3 HP1P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6P12M1. try clear HP1P6P12M2. try clear HP1P6P12M3. try clear HP1P6P12m4. try clear HP1P6P12m3. try clear HP1P6P12m2. try clear HP1P6P12m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P16m2 : rk(P1 :: P16 :: nil) >= 2).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP1P6P12P16eq : rk(P1 :: P6 :: P12 :: P16 :: nil) = 3) by (apply LP1P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P6P12P16mtmp : rk(P1 :: P6 :: P12 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P6P12P16eq HP1P6P12P16m3).
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16mtmp : rk(P16 :: nil) >= 1) by (solve_hyps_min HP16eq HP16m1).
	assert(Hincl : incl (P16 :: nil) (list_inter (P1 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P12 :: P16 :: nil) (P1 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P16 :: P6 :: P12 :: P16 :: nil) ((P1 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P12P16mtmp;try rewrite HT2 in HP1P6P12P16mtmp.
	assert(HT := rule_2 (P1 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P16 :: nil) 3 1 2 HP1P6P12P16mtmp HP16mtmp HP6P12P16Mtmp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P15m2 : rk(P5 :: P15 :: nil) >= 2).
{
	try assert(HP1P16eq : rk(P1 :: P16 :: nil) = 2) by (apply LP1P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P16Mtmp : rk(P1 :: P16 :: nil) <= 2) by (solve_hyps_max HP1P16eq HP1P16M2).
	try assert(HP1P5P15P16eq : rk(P1 :: P5 :: P15 :: P16 :: nil) = 4) by (apply LP1P5P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P15P16mtmp : rk(P1 :: P5 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P5P15P16eq HP1P5P15P16m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P5 :: P15 :: nil) (P1 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P15 :: P16 :: nil) (P5 :: P15 :: P1 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P15 :: P1 :: P16 :: nil) ((P5 :: P15 :: nil) ++ (P1 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P15P16mtmp;try rewrite HT2 in HP1P5P15P16mtmp.
	assert(HT := rule_2 (P5 :: P15 :: nil) (P1 :: P16 :: nil) (nil) 4 0 2 HP1P5P15P16mtmp Hmtmp HP1P16Mtmp Hincl);apply HT.
}
try clear HP1P16M1. try clear HP1P16M2. try clear HP1P16M3. try clear HP1P16m4. try clear HP1P16m3. try clear HP1P16m2. try clear HP1P16m1. try clear HP1P5P15P16M1. try clear HP1P5P15P16M2. try clear HP1P5P15P16M3. try clear HP1P5P15P16m4. try clear HP1P5P15P16m3. try clear HP1P5P15P16m2. try clear HP1P5P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P5P15m2 : rk(P2 :: P3 :: P5 :: P15 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P15 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P5P15m3 : rk(P2 :: P3 :: P5 :: P15 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P15 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5M1. try clear HP2P3P5M2. try clear HP2P3P5M3. try clear HP2P3P5m4. try clear HP2P3P5m3. try clear HP2P3P5m2. try clear HP2P3P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P15m4 : rk(P2 :: P3 :: P5 :: P15 :: nil) >= 4).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP2P3P5P8P15eq : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP2P3P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P5P8P15mtmp : rk(P2 :: P3 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8P15eq HP2P3P5P8P15m4).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P2 :: P3 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P8 :: P15 :: nil) (P2 :: P3 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil) ((P2 :: P3 :: P5 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P8P15mtmp;try rewrite HT2 in HP2P3P5P8P15mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 4 2 2 HP2P3P5P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP2P3P5P8P15M1. try clear HP2P3P5P8P15M2. try clear HP2P3P5P8P15M3. try clear HP2P3P5P8P15m4. try clear HP2P3P5P8P15m3. try clear HP2P3P5P8P15m2. try clear HP2P3P5P8P15m1. 

assert(HP2P3P5P15M : rk(P2 :: P3 :: P5 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P5P15m : rk(P2 :: P3 :: P5 :: P15 ::  nil) >= 1) by (solve_hyps_min HP2P3P5P15eq HP2P3P5P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP1P4P5P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P1 :: P4 :: P5 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P15m2 : rk(P1 :: P4 :: P5 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P15m3 : rk(P1 :: P4 :: P5 :: P15 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P15 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P15m4 : rk(P1 :: P4 :: P5 :: P15 :: nil) >= 4).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P4P5P8P15eq : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP1P4P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P8P15mtmp : rk(P1 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8P15eq HP1P4P5P8P15m4).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P1 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P8 :: P15 :: nil) (P1 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P4 :: P5 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P8P15mtmp;try rewrite HT2 in HP1P4P5P8P15mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 4 2 2 HP1P4P5P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP1P4P5P8P15M1. try clear HP1P4P5P8P15M2. try clear HP1P4P5P8P15M3. try clear HP1P4P5P8P15m4. try clear HP1P4P5P8P15m3. try clear HP1P4P5P8P15m2. try clear HP1P4P5P8P15m1. 

assert(HP1P4P5P15M : rk(P1 :: P4 :: P5 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P4P5P15m : rk(P1 :: P4 :: P5 :: P15 ::  nil) >= 1) by (solve_hyps_min HP1P4P5P15eq HP1P4P5P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP2P4P5P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P2 :: P4 :: P5 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P15m2 : rk(P2 :: P4 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P15m3 : rk(P2 :: P4 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P15m4 : rk(P2 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP2P4P5P8mtmp : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8eq HP2P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P15 :: nil) 4 4 HP2P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5P8M1. try clear HP2P4P5P8M2. try clear HP2P4P5P8M3. try clear HP2P4P5P8m4. try clear HP2P4P5P8m3. try clear HP2P4P5P8m2. try clear HP2P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P15m2 : rk(P2 :: P4 :: P5 :: P15 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P15 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P15m3 : rk(P2 :: P4 :: P5 :: P15 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P15 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5M1. try clear HP2P4P5M2. try clear HP2P4P5M3. try clear HP2P4P5m4. try clear HP2P4P5m3. try clear HP2P4P5m2. try clear HP2P4P5m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P15m4 : rk(P2 :: P4 :: P5 :: P15 :: nil) >= 4).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP2P4P5P8P15eq : rk(P2 :: P4 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP2P4P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P5P8P15mtmp : rk(P2 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8P15eq HP2P4P5P8P15m4).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P2 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P8 :: P15 :: nil) (P2 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil) ((P2 :: P4 :: P5 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P8P15mtmp;try rewrite HT2 in HP2P4P5P8P15mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 4 2 2 HP2P4P5P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP2P4P5P8P15M1. try clear HP2P4P5P8P15M2. try clear HP2P4P5P8P15M3. try clear HP2P4P5P8P15m4. try clear HP2P4P5P8P15m3. try clear HP2P4P5P8P15m2. try clear HP2P4P5P8P15m1. 

assert(HP2P4P5P15M : rk(P2 :: P4 :: P5 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P5P15m : rk(P2 :: P4 :: P5 :: P15 ::  nil) >= 1) by (solve_hyps_min HP2P4P5P15eq HP2P4P5P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP3P4P5P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P3 :: P4 :: P5 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P15m2 : rk(P3 :: P4 :: P5 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P15m3 : rk(P3 :: P4 :: P5 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P15m4 : rk(P3 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P15 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P15m2 : rk(P3 :: P4 :: P5 :: P15 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P15 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P15m3 : rk(P3 :: P4 :: P5 :: P15 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P15 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P15m4 : rk(P3 :: P4 :: P5 :: P15 :: nil) >= 4).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP3P4P5P8P15eq : rk(P3 :: P4 :: P5 :: P8 :: P15 :: nil) = 4) by (apply LP3P4P5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP3P4P5P8P15mtmp : rk(P3 :: P4 :: P5 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P15eq HP3P4P5P8P15m4).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P3 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P15 :: nil) (P3 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P15 :: P5 :: P8 :: P15 :: nil) ((P3 :: P4 :: P5 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P15mtmp;try rewrite HT2 in HP3P4P5P8P15mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P5 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 4 2 2 HP3P4P5P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP3P4P5P8P15M1. try clear HP3P4P5P8P15M2. try clear HP3P4P5P8P15M3. try clear HP3P4P5P8P15m4. try clear HP3P4P5P8P15m3. try clear HP3P4P5P8P15m2. try clear HP3P4P5P8P15m1. 

assert(HP3P4P5P15M : rk(P3 :: P4 :: P5 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP3P4P5P15m : rk(P3 :: P4 :: P5 :: P15 ::  nil) >= 1) by (solve_hyps_min HP3P4P5P15eq HP3P4P5P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP2P3P6P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P2 :: P3 :: P6 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P12P16m2 : rk(P2 :: P3 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P12P16m3 : rk(P2 :: P3 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P12P16m4 : rk(P2 :: P3 :: P6 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP2P3P6P12mtmp : rk(P2 :: P3 :: P6 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P3P6P12eq HP2P3P6P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P12 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: P12 :: nil) (P2 :: P3 :: P6 :: P12 :: P16 :: nil) 4 4 HP2P3P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6P12M1. try clear HP2P3P6P12M2. try clear HP2P3P6P12M3. try clear HP2P3P6P12m4. try clear HP2P3P6P12m3. try clear HP2P3P6P12m2. try clear HP2P3P6P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P6P8P15m2 : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P6P8P15m3 : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P6P8P15m4 : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P4P5P8mtmp : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) 4 4 HP1P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P5P6P8P15m2 : rk(P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P6P8P15m3 : rk(P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P4P5P6P8P15eq : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) = 3) by (apply LP1P4P5P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P6P8P15mtmp : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P4P5P6P8P15eq HP1P4P5P6P8P15m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P4 :: P5 :: P6 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P8P15mtmp;try rewrite HT2 in HP1P4P5P6P8P15mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P4P5P6P8P15mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P6P8P15m4 : rk(P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 4).
{
	try assert(HP1P5P6P8eq : rk(P1 :: P5 :: P6 :: P8 :: nil) = 3) by (apply LP1P5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6P8Mtmp : rk(P1 :: P5 :: P6 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P6P8eq HP1P5P6P8M3).
	try assert(HP1P4P5P6P8P15eq : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) = 4) by (apply LP1P4P5P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P6P8P15mtmp : rk(P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P4P5P6P8P15eq HP1P4P5P6P8P15m4).
	try assert(HP5P6P8eq : rk(P5 :: P6 :: P8 :: nil) = 3) by (apply LP5P6P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (list_inter (P1 :: P5 :: P6 :: P8 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P8 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P8 :: P4 :: P5 :: P6 :: P8 :: P15 :: nil) ((P1 :: P5 :: P6 :: P8 :: nil) ++ (P4 :: P5 :: P6 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P8P15mtmp;try rewrite HT2 in HP1P4P5P6P8P15mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P8 :: nil) (P4 :: P5 :: P6 :: P8 :: P15 :: nil) (P5 :: P6 :: P8 :: nil) 4 3 3 HP1P4P5P6P8P15mtmp HP5P6P8mtmp HP1P5P6P8Mtmp Hincl); apply HT.
}
try clear HP1P5P6P8M1. try clear HP1P5P6P8M2. try clear HP1P5P6P8M3. try clear HP1P5P6P8m4. try clear HP1P5P6P8m3. try clear HP1P5P6P8m2. try clear HP1P5P6P8m1. try clear HP1P4P5P6P8P15M1. try clear HP1P4P5P6P8P15M2. try clear HP1P4P5P6P8P15M3. try clear HP1P4P5P6P8P15m4. try clear HP1P4P5P6P8P15m3. try clear HP1P4P5P6P8P15m2. try clear HP1P4P5P6P8P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P15m2 : rk(P4 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P15 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P6P15m3 : rk(P4 :: P6 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP4P5P6P8P15eq : rk(P4 :: P5 :: P6 :: P8 :: P15 :: nil) = 4) by (apply LP4P5P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P5P6P8P15mtmp : rk(P4 :: P5 :: P6 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP4P5P6P8P15eq HP4P5P6P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P4 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P6 :: P8 :: P15 :: nil) (P4 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil) ((P4 :: P6 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P6P8P15mtmp;try rewrite HT2 in HP4P5P6P8P15mtmp.
	assert(HT := rule_2 (P4 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP4P5P6P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP4P5P6P8P15M1. try clear HP4P5P6P8P15M2. try clear HP4P5P6P8P15M3. try clear HP4P5P6P8P15m4. try clear HP4P5P6P8P15m3. try clear HP4P5P6P8P15m2. try clear HP4P5P6P8P15m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P6P15P16M3 : rk(P4 :: P6 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P15 :: P16 :: nil) (P6 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P4 :: P15 :: P16 :: nil) ((P6 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P6 :: nil) (P4 :: P15 :: P16 :: nil) (nil) 1 2 0 HP6Mtmp HP4P15P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P15P16m2 : rk(P4 :: P6 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P15 :: P16 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P6P15P16m3 : rk(P4 :: P6 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP4P6P15mtmp : rk(P4 :: P6 :: P15 :: nil) >= 3) by (solve_hyps_min HP4P6P15eq HP4P6P15m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P15 :: nil) (P4 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P15 :: nil) (P4 :: P6 :: P15 :: P16 :: nil) 3 3 HP4P6P15mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P15M1. try clear HP4P6P15M2. try clear HP4P6P15M3. try clear HP4P6P15m4. try clear HP4P6P15m3. try clear HP4P6P15m2. try clear HP4P6P15m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP6P16m2 : rk(P6 :: P16 :: nil) >= 2).
{
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP4P6P15P16eq : rk(P4 :: P6 :: P15 :: P16 :: nil) = 3) by (apply LP4P6P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P6P15P16mtmp : rk(P4 :: P6 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP4P6P15P16eq HP4P6P15P16m3).
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16mtmp : rk(P16 :: nil) >= 1) by (solve_hyps_min HP16eq HP16m1).
	assert(Hincl : incl (P16 :: nil) (list_inter (P6 :: P16 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P15 :: P16 :: nil) (P6 :: P16 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P16 :: P4 :: P15 :: P16 :: nil) ((P6 :: P16 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P15P16mtmp;try rewrite HT2 in HP4P6P15P16mtmp.
	assert(HT := rule_2 (P6 :: P16 :: nil) (P4 :: P15 :: P16 :: nil) (P16 :: nil) 3 1 2 HP4P6P15P16mtmp HP16mtmp HP4P15P16Mtmp Hincl);apply HT.
}
try clear HP4P6P15P16M1. try clear HP4P6P15P16M2. try clear HP4P6P15P16M3. try clear HP4P6P15P16m4. try clear HP4P6P15P16m3. try clear HP4P6P15P16m2. try clear HP4P6P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P16m2 : rk(P2 :: P3 :: P6 :: P16 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P16 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P16m3 : rk(P2 :: P3 :: P6 :: P16 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P16 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P16m4 : rk(P2 :: P3 :: P6 :: P16 :: nil) >= 4).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP2P3P6P12P16eq : rk(P2 :: P3 :: P6 :: P12 :: P16 :: nil) = 4) by (apply LP2P3P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P6P12P16mtmp : rk(P2 :: P3 :: P6 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P3P6P12P16eq HP2P3P6P12P16m4).
	try assert(HP6P16eq : rk(P6 :: P16 :: nil) = 2) by (apply LP6P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P16mtmp : rk(P6 :: P16 :: nil) >= 2) by (solve_hyps_min HP6P16eq HP6P16m2).
	assert(Hincl : incl (P6 :: P16 :: nil) (list_inter (P2 :: P3 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P12 :: P16 :: nil) (P2 :: P3 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil) ((P2 :: P3 :: P6 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P6P12P16mtmp;try rewrite HT2 in HP2P3P6P12P16mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: P16 :: nil) 4 2 2 HP2P3P6P12P16mtmp HP6P16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP2P3P6P12P16M1. try clear HP2P3P6P12P16M2. try clear HP2P3P6P12P16M3. try clear HP2P3P6P12P16m4. try clear HP2P3P6P12P16m3. try clear HP2P3P6P12P16m2. try clear HP2P3P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P15P16m2 : rk(P2 :: P3 :: P6 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P15P16m3 : rk(P2 :: P3 :: P6 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P3P6P15P16m4 : rk(P2 :: P3 :: P6 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP2P3P6P16mtmp : rk(P2 :: P3 :: P6 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P3P6P16eq HP2P3P6P16m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P16 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: P16 :: nil) (P2 :: P3 :: P6 :: P15 :: P16 :: nil) 4 4 HP2P3P6P16mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6P16M1. try clear HP2P3P6P16M2. try clear HP2P3P6P16M3. try clear HP2P3P6P16m4. try clear HP2P3P6P16m3. try clear HP2P3P6P16m2. try clear HP2P3P6P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P4P15P16m2 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P15P16M3 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P15 :: P16 :: nil) (P2 :: P3 :: P4 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P4 :: P15 :: P16 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P4 :: P15 :: P16 :: nil) (P4 :: nil) 2 2 1 HP2P3P4Mtmp HP4P15P16Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P4M1. try clear HP2P3P4M2. try clear HP2P3P4M3. try clear HP2P3P4m4. try clear HP2P3P4m3. try clear HP2P3P4m2. try clear HP2P3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P15P16m3 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP2P3P15eq : rk(P2 :: P3 :: P15 :: nil) = 3) by (apply LP2P3P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P15P16m2 : rk(P2 :: P3 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P15 :: P16 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P15P16m3 : rk(P2 :: P3 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP2P3P15eq : rk(P2 :: P3 :: P15 :: nil) = 3) by (apply LP2P3P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P3P15P16M3 : rk(P2 :: P3 :: P15 :: P16 :: nil) <= 3).
{
	assert(HP2P3P4P15P16Mtmp : rk(P2 :: P3 :: P4 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP2P3P4P15P16eq HP2P3P4P15P16M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P15 :: P16 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P3 :: P15 :: P16 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: nil) 3 3 HP2P3P4P15P16Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P4P15P16M1. try clear HP2P3P4P15P16M2. try clear HP2P3P4P15P16M3. try clear HP2P3P4P15P16m4. try clear HP2P3P4P15P16m3. try clear HP2P3P4P15P16m2. try clear HP2P3P4P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P3P6P15m2 : rk(P2 :: P3 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P15 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P15m3 : rk(P2 :: P3 :: P6 :: P15 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P15 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P15m4 : rk(P2 :: P3 :: P6 :: P15 :: nil) >= 4).
{
	try assert(HP2P3P15P16eq : rk(P2 :: P3 :: P15 :: P16 :: nil) = 3) by (apply LP2P3P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P15P16Mtmp : rk(P2 :: P3 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP2P3P15P16eq HP2P3P15P16M3).
	try assert(HP2P3P6P15P16eq : rk(P2 :: P3 :: P6 :: P15 :: P16 :: nil) = 4) by (apply LP2P3P6P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P6P15P16mtmp : rk(P2 :: P3 :: P6 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P3P6P15P16eq HP2P3P6P15P16m4).
	try assert(HP2P3P15eq : rk(P2 :: P3 :: P15 :: nil) = 3) by (apply LP2P3P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P3P15mtmp : rk(P2 :: P3 :: P15 :: nil) >= 3) by (solve_hyps_min HP2P3P15eq HP2P3P15m3).
	assert(Hincl : incl (P2 :: P3 :: P15 :: nil) (list_inter (P2 :: P3 :: P6 :: P15 :: nil) (P2 :: P3 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P6 :: P15 :: P16 :: nil) (P2 :: P3 :: P6 :: P15 :: P2 :: P3 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P6 :: P15 :: P2 :: P3 :: P15 :: P16 :: nil) ((P2 :: P3 :: P6 :: P15 :: nil) ++ (P2 :: P3 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P6P15P16mtmp;try rewrite HT2 in HP2P3P6P15P16mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P6 :: P15 :: nil) (P2 :: P3 :: P15 :: P16 :: nil) (P2 :: P3 :: P15 :: nil) 4 3 3 HP2P3P6P15P16mtmp HP2P3P15mtmp HP2P3P15P16Mtmp Hincl);apply HT.
}
try clear HP2P3P15P16M1. try clear HP2P3P15P16M2. try clear HP2P3P15P16M3. try clear HP2P3P15P16m4. try clear HP2P3P15P16m3. try clear HP2P3P15P16m2. try clear HP2P3P15P16m1. try clear HP2P3P15M1. try clear HP2P3P15M2. try clear HP2P3P15M3. try clear HP2P3P15m4. try clear HP2P3P15m3. try clear HP2P3P15m2. try clear HP2P3P15m1. try clear HP2P3P6P15P16M1. try clear HP2P3P6P15P16M2. try clear HP2P3P6P15P16M3. try clear HP2P3P6P15P16m4. try clear HP2P3P6P15P16m3. try clear HP2P3P6P15P16m2. try clear HP2P3P6P15P16m1. 

assert(HP2P3P6P15M : rk(P2 :: P3 :: P6 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P3P6P15m : rk(P2 :: P3 :: P6 :: P15 ::  nil) >= 1) by (solve_hyps_min HP2P3P6P15eq HP2P3P6P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP1P4P6P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P1 :: P4 :: P6 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P6P8P15m2 : rk(P1 :: P4 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P6P8P15m3 : rk(P1 :: P4 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P4P6mtmp : rk(P1 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P4P6eq HP1P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil) 3 3 HP1P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P6P8P15m4 : rk(P1 :: P4 :: P6 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P4P6P8mtmp : rk(P1 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P6P8eq HP1P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P6 :: P8 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P6 :: P8 :: nil) (P1 :: P4 :: P6 :: P8 :: P15 :: nil) 4 4 HP1P4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P6P8M1. try clear HP1P4P6P8M2. try clear HP1P4P6P8M3. try clear HP1P4P6P8m4. try clear HP1P4P6P8m3. try clear HP1P4P6P8m2. try clear HP1P4P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P12P16m2 : rk(P1 :: P2 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P12P16m3 : rk(P1 :: P2 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P12P16m4 : rk(P1 :: P2 :: P6 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP1P2P6P12mtmp : rk(P1 :: P2 :: P6 :: P12 :: nil) >= 4) by (solve_hyps_min HP1P2P6P12eq HP1P2P6P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P12 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P12 :: nil) (P1 :: P2 :: P6 :: P12 :: P16 :: nil) 4 4 HP1P2P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P12M1. try clear HP1P2P6P12M2. try clear HP1P2P6P12M3. try clear HP1P2P6P12m4. try clear HP1P2P6P12m3. try clear HP1P2P6P12m2. try clear HP1P2P6P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P16m2 : rk(P1 :: P2 :: P6 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P16m3 : rk(P1 :: P2 :: P6 :: P16 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P16 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P16m4 : rk(P1 :: P2 :: P6 :: P16 :: nil) >= 4).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP1P2P6P12P16eq : rk(P1 :: P2 :: P6 :: P12 :: P16 :: nil) = 4) by (apply LP1P2P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P6P12P16mtmp : rk(P1 :: P2 :: P6 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P6P12P16eq HP1P2P6P12P16m4).
	try assert(HP6P16eq : rk(P6 :: P16 :: nil) = 2) by (apply LP6P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P16mtmp : rk(P6 :: P16 :: nil) >= 2) by (solve_hyps_min HP6P16eq HP6P16m2).
	assert(Hincl : incl (P6 :: P16 :: nil) (list_inter (P1 :: P2 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P12 :: P16 :: nil) (P1 :: P2 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil) ((P1 :: P2 :: P6 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P12P16mtmp;try rewrite HT2 in HP1P2P6P12P16mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: P16 :: nil) 4 2 2 HP1P2P6P12P16mtmp HP6P16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP1P2P6P12P16M1. try clear HP1P2P6P12P16M2. try clear HP1P2P6P12P16M3. try clear HP1P2P6P12P16m4. try clear HP1P2P6P12P16m3. try clear HP1P2P6P12P16m2. try clear HP1P2P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P2P6P15P16m2 : rk(P1 :: P2 :: P6 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P15P16m3 : rk(P1 :: P2 :: P6 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P6P15P16m4 : rk(P1 :: P2 :: P6 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP1P2P6P16mtmp : rk(P1 :: P2 :: P6 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P6P16eq HP1P2P6P16m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P16 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P16 :: nil) (P1 :: P2 :: P6 :: P15 :: P16 :: nil) 4 4 HP1P2P6P16mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P16M1. try clear HP1P2P6P16M2. try clear HP1P2P6P16M3. try clear HP1P2P6P16m4. try clear HP1P2P6P16m3. try clear HP1P2P6P16m2. try clear HP1P2P6P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P16m2 : rk(P1 :: P6 :: P16 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P16 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P16m3 : rk(P1 :: P6 :: P16 :: nil) >= 3).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP1P6P12P16eq : rk(P1 :: P6 :: P12 :: P16 :: nil) = 3) by (apply LP1P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P6P12P16mtmp : rk(P1 :: P6 :: P12 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P6P12P16eq HP1P6P12P16m3).
	try assert(HP6P16eq : rk(P6 :: P16 :: nil) = 2) by (apply LP6P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P16mtmp : rk(P6 :: P16 :: nil) >= 2) by (solve_hyps_min HP6P16eq HP6P16m2).
	assert(Hincl : incl (P6 :: P16 :: nil) (list_inter (P1 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P12 :: P16 :: nil) (P1 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil) ((P1 :: P6 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P12P16mtmp;try rewrite HT2 in HP1P6P12P16mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: P16 :: nil) 3 2 2 HP1P6P12P16mtmp HP6P16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP1P6P12P16M1. try clear HP1P6P12P16M2. try clear HP1P6P12P16M3. try clear HP1P6P12P16m4. try clear HP1P6P12P16m3. try clear HP1P6P12P16m2. try clear HP1P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P15P16m2 : rk(P1 :: P6 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P15 :: P16 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P6P15P16m3 : rk(P1 :: P6 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP1P6P16mtmp : rk(P1 :: P6 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P6P16eq HP1P6P16m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P16 :: nil) (P1 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: P16 :: nil) (P1 :: P6 :: P15 :: P16 :: nil) 3 3 HP1P6P16mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6P16M1. try clear HP1P6P16M2. try clear HP1P6P16M3. try clear HP1P6P16m4. try clear HP1P6P16m3. try clear HP1P6P16m2. try clear HP1P6P16m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P6P15P16m4 : rk(P1 :: P6 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP1P2P15P16eq : rk(P1 :: P2 :: P15 :: P16 :: nil) = 3) by (apply LP1P2P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P15P16Mtmp : rk(P1 :: P2 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP1P2P15P16eq HP1P2P15P16M3).
	try assert(HP1P2P6P15P16eq : rk(P1 :: P2 :: P6 :: P15 :: P16 :: nil) = 4) by (apply LP1P2P6P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P2P6P15P16mtmp : rk(P1 :: P2 :: P6 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P2P6P15P16eq HP1P2P6P15P16m4).
	try assert(HP1P15P16eq : rk(P1 :: P15 :: P16 :: nil) = 3) by (apply LP1P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P15P16mtmp : rk(P1 :: P15 :: P16 :: nil) >= 3) by (solve_hyps_min HP1P15P16eq HP1P15P16m3).
	assert(Hincl : incl (P1 :: P15 :: P16 :: nil) (list_inter (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P6 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P15 :: P16 :: nil) (P1 :: P2 :: P15 :: P16 :: P1 :: P6 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P15 :: P16 :: P1 :: P6 :: P15 :: P16 :: nil) ((P1 :: P2 :: P15 :: P16 :: nil) ++ (P1 :: P6 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P15P16mtmp;try rewrite HT2 in HP1P2P6P15P16mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P15 :: P16 :: nil) (P1 :: P6 :: P15 :: P16 :: nil) (P1 :: P15 :: P16 :: nil) 4 3 3 HP1P2P6P15P16mtmp HP1P15P16mtmp HP1P2P15P16Mtmp Hincl); apply HT.
}
try clear HP1P2P15P16M1. try clear HP1P2P15P16M2. try clear HP1P2P15P16M3. try clear HP1P2P15P16m4. try clear HP1P2P15P16m3. try clear HP1P2P15P16m2. try clear HP1P2P15P16m1. try clear HP1P15P16M1. try clear HP1P15P16M2. try clear HP1P15P16M3. try clear HP1P15P16m4. try clear HP1P15P16m3. try clear HP1P15P16m2. try clear HP1P15P16m1. try clear HP1P2P6P15P16M1. try clear HP1P2P6P15P16M2. try clear HP1P2P6P15P16M3. try clear HP1P2P6P15P16m4. try clear HP1P2P6P15P16m3. try clear HP1P2P6P15P16m2. try clear HP1P2P6P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P15m2 : rk(P1 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P15 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P15m3 : rk(P1 :: P6 :: P15 :: nil) >= 3).
{
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16Mtmp : rk(P16 :: nil) <= 1) by (solve_hyps_max HP16eq HP16M1).
	try assert(HP1P6P15P16eq : rk(P1 :: P6 :: P15 :: P16 :: nil) = 4) by (apply LP1P6P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P6P15P16mtmp : rk(P1 :: P6 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP1P6P15P16eq HP1P6P15P16m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P6 :: P15 :: nil) (P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P15 :: P16 :: nil) (P1 :: P6 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P15 :: P16 :: nil) ((P1 :: P6 :: P15 :: nil) ++ (P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P6P15P16mtmp;try rewrite HT2 in HP1P6P15P16mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P15 :: nil) (P16 :: nil) (nil) 4 0 1 HP1P6P15P16mtmp Hmtmp HP16Mtmp Hincl);apply HT.
}
try clear HP1P6P15P16M1. try clear HP1P6P15P16M2. try clear HP1P6P15P16M3. try clear HP1P6P15P16m4. try clear HP1P6P15P16m3. try clear HP1P6P15P16m2. try clear HP1P6P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6P8P15m2 : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P8P15M3 : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P5 :: P8 :: P15 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: nil) 2 2 1 HP1P5P6Mtmp HP5P8P15Mtmp HP5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6P8P15m3 : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P5P8mtmp : rk(P1 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P5P8eq HP1P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P8 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil) 3 3 HP1P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P8M1. try clear HP1P5P8M2. try clear HP1P5P8M3. try clear HP1P5P8m4. try clear HP1P5P8m3. try clear HP1P5P8m2. try clear HP1P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P6P8P15m2 : rk(P1 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P8 :: P15 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6M1. try clear HP1P6M2. try clear HP1P6M3. try clear HP1P6m4. try clear HP1P6m3. try clear HP1P6m2. try clear HP1P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P8P15m3 : rk(P1 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P6P8mtmp : rk(P1 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP1P6P8eq HP1P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P8 :: nil) (P1 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: P8 :: nil) (P1 :: P6 :: P8 :: P15 :: nil) 3 3 HP1P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6P8M1. try clear HP1P6P8M2. try clear HP1P6P8M3. try clear HP1P6P8m4. try clear HP1P6P8m3. try clear HP1P6P8m2. try clear HP1P6P8m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P6P8P15M3 : rk(P1 :: P6 :: P8 :: P15 :: nil) <= 3).
{
	assert(HP1P5P6P8P15Mtmp : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) <= 3) by (solve_hyps_max HP1P5P6P8P15eq HP1P5P6P8P15M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P1 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P8 :: P15 :: nil) 3 3 HP1P5P6P8P15Mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P6P15m2 : rk(P1 :: P4 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P6P15m3 : rk(P1 :: P4 :: P6 :: P15 :: nil) >= 3).
{
	assert(HP1P4P6mtmp : rk(P1 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P4P6eq HP1P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P15 :: nil) 3 3 HP1P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P6M1. try clear HP1P4P6M2. try clear HP1P4P6M3. try clear HP1P4P6m4. try clear HP1P4P6m3. try clear HP1P4P6m2. try clear HP1P4P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P6P15m4 : rk(P1 :: P4 :: P6 :: P15 :: nil) >= 4).
{
	try assert(HP1P6P8P15eq : rk(P1 :: P6 :: P8 :: P15 :: nil) = 3) by (apply LP1P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P6P8P15Mtmp : rk(P1 :: P6 :: P8 :: P15 :: nil) <= 3) by (solve_hyps_max HP1P6P8P15eq HP1P6P8P15M3).
	try assert(HP1P4P6P8P15eq : rk(P1 :: P4 :: P6 :: P8 :: P15 :: nil) = 4) by (apply LP1P4P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P6P8P15mtmp : rk(P1 :: P4 :: P6 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P4P6P8P15eq HP1P4P6P8P15m4).
	try assert(HP1P6P15eq : rk(P1 :: P6 :: P15 :: nil) = 3) by (apply LP1P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P6P15mtmp : rk(P1 :: P6 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P6P15eq HP1P6P15m3).
	assert(Hincl : incl (P1 :: P6 :: P15 :: nil) (list_inter (P1 :: P4 :: P6 :: P15 :: nil) (P1 :: P6 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P6 :: P8 :: P15 :: nil) (P1 :: P4 :: P6 :: P15 :: P1 :: P6 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P6 :: P15 :: P1 :: P6 :: P8 :: P15 :: nil) ((P1 :: P4 :: P6 :: P15 :: nil) ++ (P1 :: P6 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P6P8P15mtmp;try rewrite HT2 in HP1P4P6P8P15mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P6 :: P15 :: nil) (P1 :: P6 :: P8 :: P15 :: nil) (P1 :: P6 :: P15 :: nil) 4 3 3 HP1P4P6P8P15mtmp HP1P6P15mtmp HP1P6P8P15Mtmp Hincl);apply HT.
}
try clear HP1P6P8P15M1. try clear HP1P6P8P15M2. try clear HP1P6P8P15M3. try clear HP1P6P8P15m4. try clear HP1P6P8P15m3. try clear HP1P6P8P15m2. try clear HP1P6P8P15m1. try clear HP1P6P15M1. try clear HP1P6P15M2. try clear HP1P6P15M3. try clear HP1P6P15m4. try clear HP1P6P15m3. try clear HP1P6P15m2. try clear HP1P6P15m1. try clear HP1P4P6P8P15M1. try clear HP1P4P6P8P15M2. try clear HP1P4P6P8P15M3. try clear HP1P4P6P8P15m4. try clear HP1P4P6P8P15m3. try clear HP1P4P6P8P15m2. try clear HP1P4P6P8P15m1. 

assert(HP1P4P6P15M : rk(P1 :: P4 :: P6 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P4P6P15m : rk(P1 :: P4 :: P6 :: P15 ::  nil) >= 1) by (solve_hyps_min HP1P4P6P15eq HP1P4P6P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP2P4P6P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P2 :: P4 :: P6 :: P15 ::  nil) = 4.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P12P16m2 : rk(P2 :: P4 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P12P16m3 : rk(P2 :: P4 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P12P16m4 : rk(P2 :: P4 :: P6 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP2P4P6P12mtmp : rk(P2 :: P4 :: P6 :: P12 :: nil) >= 4) by (solve_hyps_min HP2P4P6P12eq HP2P4P6P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P12 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P12 :: nil) (P2 :: P4 :: P6 :: P12 :: P16 :: nil) 4 4 HP2P4P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6P12M1. try clear HP2P4P6P12M2. try clear HP2P4P6P12M3. try clear HP2P4P6P12m4. try clear HP2P4P6P12m3. try clear HP2P4P6P12m2. try clear HP2P4P6P12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P16m2 : rk(P2 :: P4 :: P6 :: P16 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P16 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P16m3 : rk(P2 :: P4 :: P6 :: P16 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P16 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P16m4 : rk(P2 :: P4 :: P6 :: P16 :: nil) >= 4).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP2P4P6P12P16eq : rk(P2 :: P4 :: P6 :: P12 :: P16 :: nil) = 4) by (apply LP2P4P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P6P12P16mtmp : rk(P2 :: P4 :: P6 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P4P6P12P16eq HP2P4P6P12P16m4).
	try assert(HP6P16eq : rk(P6 :: P16 :: nil) = 2) by (apply LP6P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P16mtmp : rk(P6 :: P16 :: nil) >= 2) by (solve_hyps_min HP6P16eq HP6P16m2).
	assert(Hincl : incl (P6 :: P16 :: nil) (list_inter (P2 :: P4 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P12 :: P16 :: nil) (P2 :: P4 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P6 :: P16 :: P6 :: P12 :: P16 :: nil) ((P2 :: P4 :: P6 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P12P16mtmp;try rewrite HT2 in HP2P4P6P12P16mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P6 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: P16 :: nil) 4 2 2 HP2P4P6P12P16mtmp HP6P16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP6P16M1. try clear HP6P16M2. try clear HP6P16M3. try clear HP6P16m4. try clear HP6P16m3. try clear HP6P16m2. try clear HP6P16m1. try clear HP2P4P6P12P16M1. try clear HP2P4P6P12P16M2. try clear HP2P4P6P12P16M3. try clear HP2P4P6P12P16m4. try clear HP2P4P6P12P16m3. try clear HP2P4P6P12P16m2. try clear HP2P4P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P15P16m2 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P15P16m3 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P4P6P15P16m4 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP2P4P6P16mtmp : rk(P2 :: P4 :: P6 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P4P6P16eq HP2P4P6P16m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P16 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P16 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: nil) 4 4 HP2P4P6P16mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6P16M1. try clear HP2P4P6P16M2. try clear HP2P4P6P16M3. try clear HP2P4P6P16m4. try clear HP2P4P6P16m3. try clear HP2P4P6P16m2. try clear HP2P4P6P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P15m2 : rk(P2 :: P4 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P15m3 : rk(P2 :: P4 :: P6 :: P15 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P15m4 : rk(P2 :: P4 :: P6 :: P15 :: nil) >= 4).
{
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP2P4P6P15P16eq : rk(P2 :: P4 :: P6 :: P15 :: P16 :: nil) = 4) by (apply LP2P4P6P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P6P15P16mtmp : rk(P2 :: P4 :: P6 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P4P6P15P16eq HP2P4P6P15P16m4).
	try assert(HP4P15eq : rk(P4 :: P15 :: nil) = 2) by (apply LP4P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15mtmp : rk(P4 :: P15 :: nil) >= 2) by (solve_hyps_min HP4P15eq HP4P15m2).
	assert(Hincl : incl (P4 :: P15 :: nil) (list_inter (P2 :: P4 :: P6 :: P15 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P15 :: P16 :: nil) (P2 :: P4 :: P6 :: P15 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P6 :: P15 :: P4 :: P15 :: P16 :: nil) ((P2 :: P4 :: P6 :: P15 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P15P16mtmp;try rewrite HT2 in HP2P4P6P15P16mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P6 :: P15 :: nil) (P4 :: P15 :: P16 :: nil) (P4 :: P15 :: nil) 4 2 2 HP2P4P6P15P16mtmp HP4P15mtmp HP4P15P16Mtmp Hincl);apply HT.
}
try clear HP4P15M1. try clear HP4P15M2. try clear HP4P15M3. try clear HP4P15m4. try clear HP4P15m3. try clear HP4P15m2. try clear HP4P15m1. try clear HP2P4P6P15P16M1. try clear HP2P4P6P15P16M2. try clear HP2P4P6P15P16M3. try clear HP2P4P6P15P16m4. try clear HP2P4P6P15P16m3. try clear HP2P4P6P15P16m2. try clear HP2P4P6P15P16m1. 

assert(HP2P4P6P15M : rk(P2 :: P4 :: P6 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP2P4P6P15m : rk(P2 :: P4 :: P6 :: P15 ::  nil) >= 1) by (solve_hyps_min HP2P4P6P15eq HP2P4P6P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP5P6P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P5 :: P6 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP5P6P8P15M3 : rk(P5 :: P6 :: P8 :: P15 :: nil) <= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P8 :: P15 :: nil) (P6 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P5 :: P8 :: P15 :: nil) ((P6 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P6 :: nil) (P5 :: P8 :: P15 :: nil) (nil) 1 2 0 HP6Mtmp HP5P8P15Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P8P15m2 : rk(P5 :: P6 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P8 :: P15 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P8P15m3 : rk(P5 :: P6 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP5P6P8mtmp : rk(P5 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P6P8eq HP5P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: P8 :: nil) (P5 :: P6 :: P8 :: P15 :: nil) 3 3 HP5P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP5P6P8M1. try clear HP5P6P8M2. try clear HP5P6P8M3. try clear HP5P6P8m4. try clear HP5P6P8m3. try clear HP5P6P8m2. try clear HP5P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP5P6P15m2 : rk(P5 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P15 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}
try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P6P15m3 : rk(P5 :: P6 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP5P6P8P15eq : rk(P5 :: P6 :: P8 :: P15 :: nil) = 3) by (apply LP5P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P6P8P15mtmp : rk(P5 :: P6 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP5P6P8P15eq HP5P6P8P15m3).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P5 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P5 :: P6 :: P8 :: P15 :: nil) (P5 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil) ((P5 :: P6 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP5P6P8P15mtmp;try rewrite HT2 in HP5P6P8P15mtmp.
	assert(HT := rule_2 (P5 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 3 2 2 HP5P6P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP5P6P8P15M1. try clear HP5P6P8P15M2. try clear HP5P6P8P15M3. try clear HP5P6P8P15m4. try clear HP5P6P8P15m3. try clear HP5P6P8P15m2. try clear HP5P6P8P15m1. 

assert(HP5P6P15M : rk(P5 :: P6 :: P15 ::  nil) <= 3) by (solve_hyps_max HP5P6P15eq HP5P6P15M3).
assert(HP5P6P15m : rk(P5 :: P6 :: P15 ::  nil) >= 1) by (solve_hyps_min HP5P6P15eq HP5P6P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP1P5P6P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P5P6P15m2 : rk(P1 :: P5 :: P6 :: P15 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P15 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5M1. try clear HP1P5M2. try clear HP1P5M3. try clear HP1P5m4. try clear HP1P5m3. try clear HP1P5m2. try clear HP1P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P15M3 : rk(P1 :: P5 :: P6 :: P15 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15Mtmp : rk(P15 :: nil) <= 1) by (solve_hyps_max HP15eq HP15M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P15 :: nil) (P1 :: P5 :: P6 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P15 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P15 :: nil) (nil) 2 1 0 HP1P5P6Mtmp HP15Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P15m3 : rk(P1 :: P5 :: P6 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP1P5P6P8P15eq : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) = 3) by (apply LP1P5P6P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P6P8P15mtmp : rk(P1 :: P5 :: P6 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P5P6P8P15eq HP1P5P6P8P15m3).
	try assert(HP5P15eq : rk(P5 :: P15 :: nil) = 2) by (apply LP5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P15mtmp : rk(P5 :: P15 :: nil) >= 2) by (solve_hyps_min HP5P15eq HP5P15m2).
	assert(Hincl : incl (P5 :: P15 :: nil) (list_inter (P1 :: P5 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P8 :: P15 :: nil) (P1 :: P5 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P15 :: P5 :: P8 :: P15 :: nil) ((P1 :: P5 :: P6 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P5P6P8P15mtmp;try rewrite HT2 in HP1P5P6P8P15mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P6 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: P15 :: nil) 3 2 2 HP1P5P6P8P15mtmp HP5P15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP5P15M1. try clear HP5P15M2. try clear HP5P15M3. try clear HP5P15m4. try clear HP5P15m3. try clear HP5P15m2. try clear HP5P15m1. try clear HP1P5P6P8P15M1. try clear HP1P5P6P8P15M2. try clear HP1P5P6P8P15M3. try clear HP1P5P6P8P15m4. try clear HP1P5P6P8P15m3. try clear HP1P5P6P8P15m2. try clear HP1P5P6P8P15m1. 

assert(HP1P5P6P15M : rk(P1 :: P5 :: P6 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP1P5P6P15m : rk(P1 :: P5 :: P6 :: P15 ::  nil) >= 1) by (solve_hyps_min HP1P5P6P15eq HP1P5P6P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP4P7P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P4 :: P7 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P7P8P15m2 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4M1. try clear HP1P4M2. try clear HP1P4M3. try clear HP1P4m4. try clear HP1P4m3. try clear HP1P4m2. try clear HP1P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P7P8P15m3 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5M1. try clear HP1P4P5M2. try clear HP1P4P5M3. try clear HP1P4P5m4. try clear HP1P4P5m3. try clear HP1P4P5m2. try clear HP1P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP1P4P5P7P8P15m4 : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 4).
{
	assert(HP1P4P5P8mtmp : rk(P1 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P4P5P8eq HP1P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P8 :: nil) (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) 4 4 HP1P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5P8M1. try clear HP1P4P5P8M2. try clear HP1P4P5P8M3. try clear HP1P4P5P8m4. try clear HP1P4P5P8m3. try clear HP1P4P5P8m2. try clear HP1P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P5P7P8P15m2 : rk(P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P8P15m3 : rk(P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P8P15eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) = 3) by (apply LP1P4P5P7P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P7P8P15mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 3) by (solve_hyps_min HP1P4P5P7P8P15eq HP1P4P5P7P8P15m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P4 :: P5 :: P7 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8P15mtmp;try rewrite HT2 in HP1P4P5P7P8P15mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P4P5P7P8P15mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P8P15m4 : rk(P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 4).
{
	try assert(HP1P5P7P8eq : rk(P1 :: P5 :: P7 :: P8 :: nil) = 3) by (apply LP1P5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7P8Mtmp : rk(P1 :: P5 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P5P7P8eq HP1P5P7P8M3).
	try assert(HP1P4P5P7P8P15eq : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) = 4) by (apply LP1P4P5P7P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P4P5P7P8P15mtmp : rk(P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P8P15eq HP1P4P5P7P8P15m4).
	try assert(HP5P7P8eq : rk(P5 :: P7 :: P8 :: nil) = 3) by (apply LP5P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7P8mtmp : rk(P5 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP5P7P8eq HP5P7P8m3).
	assert(Hincl : incl (P5 :: P7 :: P8 :: nil) (list_inter (P1 :: P5 :: P7 :: P8 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) (P1 :: P5 :: P7 :: P8 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P8 :: P4 :: P5 :: P7 :: P8 :: P15 :: nil) ((P1 :: P5 :: P7 :: P8 :: nil) ++ (P4 :: P5 :: P7 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P8P15mtmp;try rewrite HT2 in HP1P4P5P7P8P15mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P8 :: nil) (P4 :: P5 :: P7 :: P8 :: P15 :: nil) (P5 :: P7 :: P8 :: nil) 4 3 3 HP1P4P5P7P8P15mtmp HP5P7P8mtmp HP1P5P7P8Mtmp Hincl); apply HT.
}
try clear HP1P5P7P8M1. try clear HP1P5P7P8M2. try clear HP1P5P7P8M3. try clear HP1P5P7P8m4. try clear HP1P5P7P8m3. try clear HP1P5P7P8m2. try clear HP1P5P7P8m1. try clear HP5P7P8M1. try clear HP5P7P8M2. try clear HP5P7P8M3. try clear HP5P7P8m4. try clear HP5P7P8m3. try clear HP5P7P8m2. try clear HP5P7P8m1. try clear HP1P4P5P7P8P15M1. try clear HP1P4P5P7P8P15M2. try clear HP1P4P5P7P8P15M3. try clear HP1P4P5P7P8P15m4. try clear HP1P4P5P7P8P15m3. try clear HP1P4P5P7P8P15m2. try clear HP1P4P5P7P8P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P7P15m2 : rk(P4 :: P7 :: P15 :: nil) >= 2).
{
	assert(HP4P7mtmp : rk(P4 :: P7 :: nil) >= 2) by (solve_hyps_min HP4P7eq HP4P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P7 :: nil) (P4 :: P7 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P7 :: nil) (P4 :: P7 :: P15 :: nil) 2 2 HP4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP4P7M1. try clear HP4P7M2. try clear HP4P7M3. try clear HP4P7m4. try clear HP4P7m3. try clear HP4P7m2. try clear HP4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P7P15m3 : rk(P4 :: P7 :: P15 :: nil) >= 3).
{
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP4P5P7P8P15eq : rk(P4 :: P5 :: P7 :: P8 :: P15 :: nil) = 4) by (apply LP4P5P7P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P5P7P8P15mtmp : rk(P4 :: P5 :: P7 :: P8 :: P15 :: nil) >= 4) by (solve_hyps_min HP4P5P7P8P15eq HP4P5P7P8P15m4).
	try assert(HP15eq : rk(P15 :: nil) = 1) by (apply LP15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP15mtmp : rk(P15 :: nil) >= 1) by (solve_hyps_min HP15eq HP15m1).
	assert(Hincl : incl (P15 :: nil) (list_inter (P4 :: P7 :: P15 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P7 :: P8 :: P15 :: nil) (P4 :: P7 :: P15 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P7 :: P15 :: P5 :: P8 :: P15 :: nil) ((P4 :: P7 :: P15 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P7P8P15mtmp;try rewrite HT2 in HP4P5P7P8P15mtmp.
	assert(HT := rule_2 (P4 :: P7 :: P15 :: nil) (P5 :: P8 :: P15 :: nil) (P15 :: nil) 4 1 2 HP4P5P7P8P15mtmp HP15mtmp HP5P8P15Mtmp Hincl);apply HT.
}
try clear HP15M1. try clear HP15M2. try clear HP15M3. try clear HP15m4. try clear HP15m3. try clear HP15m2. try clear HP15m1. try clear HP4P5P7P8P15M1. try clear HP4P5P7P8P15M2. try clear HP4P5P7P8P15M3. try clear HP4P5P7P8P15m4. try clear HP4P5P7P8P15m3. try clear HP4P5P7P8P15m2. try clear HP4P5P7P8P15m1. 

assert(HP4P7P15M : rk(P4 :: P7 :: P15 ::  nil) <= 3) by (solve_hyps_max HP4P7P15eq HP4P7P15M3).
assert(HP4P7P15m : rk(P4 :: P7 :: P15 ::  nil) >= 1) by (solve_hyps_min HP4P7P15eq HP4P7P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP4P8P10P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P4 :: P8 :: P10 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P5P8P10P15m2 : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5M1. try clear HP4P5M2. try clear HP4P5M3. try clear HP4P5m4. try clear HP4P5m3. try clear HP4P5m2. try clear HP4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P5P8P10P15m3 : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) >= 3).
{
	assert(HP4P5P8mtmp : rk(P4 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P5P8eq HP4P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil) 3 3 HP4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5P8M1. try clear HP4P5P8M2. try clear HP4P5P8M3. try clear HP4P5P8m4. try clear HP4P5P8m3. try clear HP4P5P8m2. try clear HP4P5P8m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P8P10P15M3 : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) <= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP5P8P15eq : rk(P5 :: P8 :: P15 :: nil) = 2) by (apply LP5P8P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P8P15Mtmp : rk(P5 :: P8 :: P15 :: nil) <= 2) by (solve_hyps_max HP5P8P15eq HP5P8P15M2).
	try assert(HP5eq : rk(P5 :: nil) = 1) by (apply LP5 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5mtmp : rk(P5 :: nil) >= 1) by (solve_hyps_min HP5eq HP5m1).
	assert(Hincl : incl (P5 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P5 :: P8 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P10 :: P15 :: nil) (P4 :: P5 :: P10 :: P5 :: P8 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P5 :: P8 :: P15 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P5 :: P8 :: P15 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P5 :: P10 :: nil) (P5 :: P8 :: P15 :: nil) (P5 :: nil) 2 2 1 HP4P5P10Mtmp HP5P8P15Mtmp HP5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP5P8P15M1. try clear HP5P8P15M2. try clear HP5P8P15M3. try clear HP5P8P15m4. try clear HP5P8P15m3. try clear HP5P8P15m2. try clear HP5P8P15m1. try clear HP5M1. try clear HP5M2. try clear HP5M3. try clear HP5m4. try clear HP5m3. try clear HP5m2. try clear HP5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P8P10P15m2 : rk(P4 :: P8 :: P10 :: P15 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P10 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P10 :: P15 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P10P15m3 : rk(P4 :: P8 :: P10 :: P15 :: nil) >= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4P5P8P10P15eq : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) = 3) by (apply LP4P5P8P10P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P5P8P10P15mtmp : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) >= 3) by (solve_hyps_min HP4P5P8P10P15eq HP4P5P8P10P15m3).
	try assert(HP4P10eq : rk(P4 :: P10 :: nil) = 2) by (apply LP4P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P10mtmp : rk(P4 :: P10 :: nil) >= 2) by (solve_hyps_min HP4P10eq HP4P10m2).
	assert(Hincl : incl (P4 :: P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P4 :: P8 :: P10 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P10 :: P15 :: nil) (P4 :: P5 :: P10 :: P4 :: P8 :: P10 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P4 :: P8 :: P10 :: P15 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P4 :: P8 :: P10 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P8P10P15mtmp;try rewrite HT2 in HP4P5P8P10P15mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P4 :: P8 :: P10 :: P15 :: nil) (P4 :: P10 :: nil) 3 2 2 HP4P5P8P10P15mtmp HP4P10mtmp HP4P5P10Mtmp Hincl); apply HT.
}
try clear HP4P5P10M1. try clear HP4P5P10M2. try clear HP4P5P10M3. try clear HP4P5P10m4. try clear HP4P5P10m3. try clear HP4P5P10m2. try clear HP4P5P10m1. try clear HP4P10M1. try clear HP4P10M2. try clear HP4P10M3. try clear HP4P10m4. try clear HP4P10m3. try clear HP4P10m2. try clear HP4P10m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P8P10P15M3 : rk(P4 :: P8 :: P10 :: P15 :: nil) <= 3).
{
	assert(HP4P5P8P10P15Mtmp : rk(P4 :: P5 :: P8 :: P10 :: P15 :: nil) <= 3) by (solve_hyps_max HP4P5P8P10P15eq HP4P5P8P10P15M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: P10 :: P15 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P4 :: P8 :: P10 :: P15 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: nil) 3 3 HP4P5P8P10P15Mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5P8P10P15M1. try clear HP4P5P8P10P15M2. try clear HP4P5P8P10P15M3. try clear HP4P5P8P10P15m4. try clear HP4P5P8P10P15m3. try clear HP4P5P8P10P15m2. try clear HP4P5P8P10P15m1. 

assert(HP4P8P10P15M : rk(P4 :: P8 :: P10 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP4P8P10P15m : rk(P4 :: P8 :: P10 :: P15 ::  nil) >= 1) by (solve_hyps_min HP4P8P10P15eq HP4P8P10P15m1).
intuition.
Qed.

(* dans la couche 6 *)
Lemma LP4P11P12P15 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P4 :: P11 :: P12 :: P15 ::  nil) = 3.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P6P11P12P16m2 : rk(P4 :: P6 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P6P11P12P16M3 : rk(P4 :: P6 :: P11 :: P12 :: P16 :: nil) <= 3).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6mtmp : rk(P6 :: nil) >= 1) by (solve_hyps_min HP6eq HP6m1).
	assert(Hincl : incl (P6 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P11 :: P12 :: P16 :: nil) (P4 :: P6 :: P11 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P6 :: P12 :: P16 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P6 :: P11 :: nil) (P6 :: P12 :: P16 :: nil) (P6 :: nil) 2 2 1 HP4P6P11Mtmp HP6P12P16Mtmp HP6mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P11P12P16m3 : rk(P4 :: P6 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP4P6P12mtmp : rk(P4 :: P6 :: P12 :: nil) >= 3) by (solve_hyps_min HP4P6P12eq HP4P6P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P12 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P12 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil) 3 3 HP4P6P12mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P16m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P16m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P16m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P6P8P9P11P12P16m2 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P16m3 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P11P12P16m4 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P11P12P16eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) = 4) by (apply LP2P4P6P8P9P11P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P6P8P9P11P12P16mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P11P12P16eq HP2P4P6P8P9P11P12P16m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P11P12P16mtmp;try rewrite HT2 in HP2P4P6P8P9P11P12P16mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P11P12P16mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P4P6P8P9P11P12P16M1. try clear HP2P4P6P8P9P11P12P16M2. try clear HP2P4P6P8P9P11P12P16M3. try clear HP2P4P6P8P9P11P12P16m4. try clear HP2P4P6P8P9P11P12P16m3. try clear HP2P4P6P8P9P11P12P16m2. try clear HP2P4P6P8P9P11P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P16m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P16m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P16m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P8P9P11P12P16m2 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P16m3 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P11P12P16eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) = 4) by (apply LP3P4P5P8P9P11P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP3P4P5P8P9P11P12P16mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P11P12P16eq HP3P4P5P8P9P11P12P16m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P11P12P16mtmp;try rewrite HT2 in HP3P4P5P8P9P11P12P16mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P9 :: nil) 4 1 2 HP3P4P5P8P9P11P12P16mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P4P5P8P9P11P12P16M1. try clear HP3P4P5P8P9P11P12P16M2. try clear HP3P4P5P8P9P11P12P16M3. try clear HP3P4P5P8P9P11P12P16m4. try clear HP3P4P5P8P9P11P12P16m3. try clear HP3P4P5P8P9P11P12P16m2. try clear HP3P4P5P8P9P11P12P16m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P16m4 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6P8P9P11P12P16eq : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) = 4) by (apply LP4P6P8P9P11P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P6P8P9P11P12P16mtmp : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P11P12P16eq HP4P6P8P9P11P12P16m4).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P11P12P16mtmp;try rewrite HT2 in HP4P6P8P9P11P12P16mtmp.
	assert(HT := rule_4 (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P4 :: P11 :: nil) 4 2 2 HP4P6P8P9P11P12P16mtmp HP4P11mtmp HP4P6P11Mtmp Hincl); apply HT.
}
try clear HP4P6P8P9P11P12P16M1. try clear HP4P6P8P9P11P12P16M2. try clear HP4P6P8P9P11P12P16M3. try clear HP4P6P8P9P11P12P16m4. try clear HP4P6P8P9P11P12P16m3. try clear HP4P6P8P9P11P12P16m2. try clear HP4P6P8P9P11P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P11P12P16m2 : rk(P4 :: P11 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P16 :: nil) 2 2 HP4P11mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P11P12P16m3 : rk(P4 :: P11 :: P12 :: P16 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP4P8P9P11P12P16eq : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) = 4) by (apply LP4P8P9P11P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P8P9P11P12P16mtmp : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) >= 4) by (solve_hyps_min HP4P8P9P11P12P16eq HP4P8P9P11P12P16m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P8 :: P9 :: P11 :: P12 :: P16 :: nil) (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P16 :: nil) ((P8 :: P9 :: P12 :: nil) ++ (P4 :: P11 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P8P9P11P12P16mtmp;try rewrite HT2 in HP4P8P9P11P12P16mtmp.
	assert(HT := rule_4 (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P16 :: nil) (P12 :: nil) 4 1 2 HP4P8P9P11P12P16mtmp HP12mtmp HP8P9P12Mtmp Hincl); apply HT.
}
try clear HP4P8P9P11P12P16M1. try clear HP4P8P9P11P12P16M2. try clear HP4P8P9P11P12P16M3. try clear HP4P8P9P11P12P16m4. try clear HP4P8P9P11P12P16m3. try clear HP4P8P9P11P12P16m2. try clear HP4P8P9P11P12P16m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P11P12P16M3 : rk(P4 :: P11 :: P12 :: P16 :: nil) <= 3).
{
	assert(HP4P6P11P12P16Mtmp : rk(P4 :: P6 :: P11 :: P12 :: P16 :: nil) <= 3) by (solve_hyps_max HP4P6P11P12P16eq HP4P6P11P12P16M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: P12 :: P16 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P4 :: P11 :: P12 :: P16 :: nil) (P4 :: P6 :: P11 :: P12 :: P16 :: nil) 3 3 HP4P6P11P12P16Mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P11P12P16M1. try clear HP4P6P11P12P16M2. try clear HP4P6P11P12P16M3. try clear HP4P6P11P12P16m4. try clear HP4P6P11P12P16m3. try clear HP4P6P11P12P16m2. try clear HP4P6P11P12P16m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P6P12P16M3 : rk(P4 :: P6 :: P12 :: P16 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P12 :: P16 :: nil) (P4 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P12 :: P16 :: nil) ((P4 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P6 :: P12 :: P16 :: nil) (nil) 1 2 0 HP4Mtmp HP6P12P16Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P6P12P16m2 : rk(P4 :: P6 :: P12 :: P16 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P12 :: P16 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P12P16m3 : rk(P4 :: P6 :: P12 :: P16 :: nil) >= 3).
{
	assert(HP4P6P12mtmp : rk(P4 :: P6 :: P12 :: nil) >= 3) by (solve_hyps_min HP4P6P12eq HP4P6P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P12 :: nil) (P4 :: P6 :: P12 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P12 :: nil) (P4 :: P6 :: P12 :: P16 :: nil) 3 3 HP4P6P12mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P12M1. try clear HP4P6P12M2. try clear HP4P6P12M3. try clear HP4P6P12m4. try clear HP4P6P12m3. try clear HP4P6P12m2. try clear HP4P6P12m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P16m2 : rk(P4 :: P16 :: nil) >= 2).
{
	try assert(HP6P12P16eq : rk(P6 :: P12 :: P16 :: nil) = 2) by (apply LP6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP6P12P16Mtmp : rk(P6 :: P12 :: P16 :: nil) <= 2) by (solve_hyps_max HP6P12P16eq HP6P12P16M2).
	try assert(HP4P6P12P16eq : rk(P4 :: P6 :: P12 :: P16 :: nil) = 3) by (apply LP4P6P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P6P12P16mtmp : rk(P4 :: P6 :: P12 :: P16 :: nil) >= 3) by (solve_hyps_min HP4P6P12P16eq HP4P6P12P16m3).
	try assert(HP16eq : rk(P16 :: nil) = 1) by (apply LP16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP16mtmp : rk(P16 :: nil) >= 1) by (solve_hyps_min HP16eq HP16m1).
	assert(Hincl : incl (P16 :: nil) (list_inter (P4 :: P16 :: nil) (P6 :: P12 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P12 :: P16 :: nil) (P4 :: P16 :: P6 :: P12 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P16 :: P6 :: P12 :: P16 :: nil) ((P4 :: P16 :: nil) ++ (P6 :: P12 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P12P16mtmp;try rewrite HT2 in HP4P6P12P16mtmp.
	assert(HT := rule_2 (P4 :: P16 :: nil) (P6 :: P12 :: P16 :: nil) (P16 :: nil) 3 1 2 HP4P6P12P16mtmp HP16mtmp HP6P12P16Mtmp Hincl);apply HT.
}
try clear HP6P12P16M1. try clear HP6P12P16M2. try clear HP6P12P16M3. try clear HP6P12P16m4. try clear HP6P12P16m3. try clear HP6P12P16m2. try clear HP6P12P16m1. try clear HP16M1. try clear HP16M2. try clear HP16M3. try clear HP16m4. try clear HP16m3. try clear HP16m2. try clear HP16m1. try clear HP4P6P12P16M1. try clear HP4P6P12P16M2. try clear HP4P6P12P16M3. try clear HP4P6P12P16m4. try clear HP4P6P12P16m3. try clear HP4P6P12P16m2. try clear HP4P6P12P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P15P16m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P15P16m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P15P16m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P6P8P9P11P12P15P16m2 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P15P16m3 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P11P12P15P16m4 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P11P12P15P16eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP2P4P6P8P9P11P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P6P8P9P11P12P15P16mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P11P12P15P16eq HP2P4P6P8P9P11P12P15P16m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P11P12P15P16mtmp;try rewrite HT2 in HP2P4P6P8P9P11P12P15P16mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P11P12P15P16mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P4P6P8P9P11P12P15P16M1. try clear HP2P4P6P8P9P11P12P15P16M2. try clear HP2P4P6P8P9P11P12P15P16M3. try clear HP2P4P6P8P9P11P12P15P16m4. try clear HP2P4P6P8P9P11P12P15P16m3. try clear HP2P4P6P8P9P11P12P15P16m2. try clear HP2P4P6P8P9P11P12P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15P16m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15P16m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15P16m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P8P9P11P12P15P16m2 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15P16m3 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P11P12P15P16eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP3P4P5P8P9P11P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP3P4P5P8P9P11P12P15P16mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P11P12P15P16eq HP3P4P5P8P9P11P12P15P16m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P11P12P15P16mtmp;try rewrite HT2 in HP3P4P5P8P9P11P12P15P16mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P9 :: nil) 4 1 2 HP3P4P5P8P9P11P12P15P16mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P4P5P8P9P11P12P15P16M1. try clear HP3P4P5P8P9P11P12P15P16M2. try clear HP3P4P5P8P9P11P12P15P16M3. try clear HP3P4P5P8P9P11P12P15P16m4. try clear HP3P4P5P8P9P11P12P15P16m3. try clear HP3P4P5P8P9P11P12P15P16m2. try clear HP3P4P5P8P9P11P12P15P16m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15P16m4 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6P8P9P11P12P15P16eq : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP4P6P8P9P11P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P6P8P9P11P12P15P16mtmp : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P11P12P15P16eq HP4P6P8P9P11P12P15P16m4).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P11P12P15P16mtmp;try rewrite HT2 in HP4P6P8P9P11P12P15P16mtmp.
	assert(HT := rule_4 (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P4 :: P11 :: nil) 4 2 2 HP4P6P8P9P11P12P15P16mtmp HP4P11mtmp HP4P6P11Mtmp Hincl); apply HT.
}
try clear HP4P6P8P9P11P12P15P16M1. try clear HP4P6P8P9P11P12P15P16M2. try clear HP4P6P8P9P11P12P15P16M3. try clear HP4P6P8P9P11P12P15P16m4. try clear HP4P6P8P9P11P12P15P16m3. try clear HP4P6P8P9P11P12P15P16m2. try clear HP4P6P8P9P11P12P15P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P11P12P15P16m2 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: nil) >= 2).
{
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil) 2 2 HP4P11mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P11P12P15P16m3 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP4P8P9P11P12P15P16eq : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) = 4) by (apply LP4P8P9P11P12P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P8P9P11P12P15P16mtmp : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) >= 4) by (solve_hyps_min HP4P8P9P11P12P15P16eq HP4P8P9P11P12P15P16m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: nil) (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: P16 :: nil) ((P8 :: P9 :: P12 :: nil) ++ (P4 :: P11 :: P12 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P8P9P11P12P15P16mtmp;try rewrite HT2 in HP4P8P9P11P12P15P16mtmp.
	assert(HT := rule_4 (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil) (P12 :: nil) 4 1 2 HP4P8P9P11P12P15P16mtmp HP12mtmp HP8P9P12Mtmp Hincl); apply HT.
}
try clear HP4P8P9P11P12P15P16M1. try clear HP4P8P9P11P12P15P16M2. try clear HP4P8P9P11P12P15P16M3. try clear HP4P8P9P11P12P15P16m4. try clear HP4P8P9P11P12P15P16m3. try clear HP4P8P9P11P12P15P16m2. try clear HP4P8P9P11P12P15P16m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P11P12P15P16M3 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: nil) <= 3).
{
	try assert(HP4P11P12P16eq : rk(P4 :: P11 :: P12 :: P16 :: nil) = 3) by (apply LP4P11P12P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P11P12P16Mtmp : rk(P4 :: P11 :: P12 :: P16 :: nil) <= 3) by (solve_hyps_max HP4P11P12P16eq HP4P11P12P16M3).
	try assert(HP4P15P16eq : rk(P4 :: P15 :: P16 :: nil) = 2) by (apply LP4P15P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15P16Mtmp : rk(P4 :: P15 :: P16 :: nil) <= 2) by (solve_hyps_max HP4P15P16eq HP4P15P16M2).
	try assert(HP4P16eq : rk(P4 :: P16 :: nil) = 2) by (apply LP4P16 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P16mtmp : rk(P4 :: P16 :: nil) >= 2) by (solve_hyps_min HP4P16eq HP4P16m2).
	assert(Hincl : incl (P4 :: P16 :: nil) (list_inter (P4 :: P11 :: P12 :: P16 :: nil) (P4 :: P15 :: P16 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P11 :: P12 :: P15 :: P16 :: nil) (P4 :: P11 :: P12 :: P16 :: P4 :: P15 :: P16 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P11 :: P12 :: P16 :: P4 :: P15 :: P16 :: nil) ((P4 :: P11 :: P12 :: P16 :: nil) ++ (P4 :: P15 :: P16 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P11 :: P12 :: P16 :: nil) (P4 :: P15 :: P16 :: nil) (P4 :: P16 :: nil) 3 2 2 HP4P11P12P16Mtmp HP4P15P16Mtmp HP4P16mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4P11P12P16M1. try clear HP4P11P12P16M2. try clear HP4P11P12P16M3. try clear HP4P11P12P16m4. try clear HP4P11P12P16m3. try clear HP4P11P12P16m2. try clear HP4P11P12P16m1. try clear HP4P15P16M1. try clear HP4P15P16M2. try clear HP4P15P16M3. try clear HP4P15P16m4. try clear HP4P15P16m3. try clear HP4P15P16m2. try clear HP4P15P16m1. try clear HP4P16M1. try clear HP4P16M2. try clear HP4P16M3. try clear HP4P16m4. try clear HP4P16m3. try clear HP4P16m2. try clear HP4P16m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P15m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP2P4P6P8P9P11P12P15m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6M1. try clear HP2P4P6M2. try clear HP2P4P6M3. try clear HP2P4P6m4. try clear HP2P4P6m3. try clear HP2P4P6m2. try clear HP2P4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P15m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6P8M1. try clear HP2P4P6P8M2. try clear HP2P4P6P8M3. try clear HP2P4P6P8m4. try clear HP2P4P6P8m3. try clear HP2P4P6P8m2. try clear HP2P4P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P6P8P9P11P12P15m2 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6M1. try clear HP4P6M2. try clear HP4P6M3. try clear HP4P6m4. try clear HP4P6m3. try clear HP4P6m2. try clear HP4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P15m3 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P8M1. try clear HP4P6P8M2. try clear HP4P6P8M3. try clear HP4P6P8m4. try clear HP4P6P8m3. try clear HP4P6P8m2. try clear HP4P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P11P12P15m4 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P11P12P15eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) = 4) by (apply LP2P4P6P8P9P11P12P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP2P4P6P8P9P11P12P15mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P11P12P15eq HP2P4P6P8P9P11P12P15m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P11P12P15mtmp;try rewrite HT2 in HP2P4P6P8P9P11P12P15mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P11P12P15mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P9M1. try clear HP2P6P9M2. try clear HP2P6P9M3. try clear HP2P6P9m4. try clear HP2P6P9m3. try clear HP2P6P9m2. try clear HP2P6P9m1. try clear HP6P9M1. try clear HP6P9M2. try clear HP6P9M3. try clear HP6P9m4. try clear HP6P9m3. try clear HP6P9m2. try clear HP6P9m1. try clear HP2P4P6P8P9P11P12P15M1. try clear HP2P4P6P8P9P11P12P15M2. try clear HP2P4P6P8P9P11P12P15M3. try clear HP2P4P6P8P9P11P12P15m4. try clear HP2P4P6P8P9P11P12P15m3. try clear HP2P4P6P8P9P11P12P15m2. try clear HP2P4P6P8P9P11P12P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5M1. try clear HP3P4P5M2. try clear HP3P4P5M3. try clear HP3P4P5m4. try clear HP3P4P5m3. try clear HP3P4P5m2. try clear HP3P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP3P4P5P8P9P11P12P15m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5P8M1. try clear HP3P4P5P8M2. try clear HP3P4P5P8M3. try clear HP3P4P5P8m4. try clear HP3P4P5P8m3. try clear HP3P4P5P8m2. try clear HP3P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 0 *)
assert(HP4P8P9P11P12P15m2 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P8M1. try clear HP4P8M2. try clear HP4P8M3. try clear HP4P8m4. try clear HP4P8m3. try clear HP4P8m2. try clear HP4P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15m3 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P11P12P15eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) = 4) by (apply LP3P4P5P8P9P11P12P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP3P4P5P8P9P11P12P15mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P11P12P15eq HP3P4P5P8P9P11P12P15m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P11P12P15mtmp;try rewrite HT2 in HP3P4P5P8P9P11P12P15mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P9 :: nil) 4 1 2 HP3P4P5P8P9P11P12P15mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P9M1. try clear HP3P5P9M2. try clear HP3P5P9M3. try clear HP3P5P9m4. try clear HP3P5P9m3. try clear HP3P5P9m2. try clear HP3P5P9m1. try clear HP9M1. try clear HP9M2. try clear HP9M3. try clear HP9m4. try clear HP9m3. try clear HP9m2. try clear HP9m1. try clear HP3P4P5P8P9P11P12P15M1. try clear HP3P4P5P8P9P11P12P15M2. try clear HP3P4P5P8P9P11P12P15M3. try clear HP3P4P5P8P9P11P12P15m4. try clear HP3P4P5P8P9P11P12P15m3. try clear HP3P4P5P8P9P11P12P15m2. try clear HP3P4P5P8P9P11P12P15m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15m4 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6P8P9P11P12P15eq : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) = 4) by (apply LP4P6P8P9P11P12P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P6P8P9P11P12P15mtmp : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P11P12P15eq HP4P6P8P9P11P12P15m4).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P11P12P15mtmp;try rewrite HT2 in HP4P6P8P9P11P12P15mtmp.
	assert(HT := rule_4 (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P4 :: P11 :: nil) 4 2 2 HP4P6P8P9P11P12P15mtmp HP4P11mtmp HP4P6P11Mtmp Hincl); apply HT.
}
try clear HP4P6P11M1. try clear HP4P6P11M2. try clear HP4P6P11M3. try clear HP4P6P11m4. try clear HP4P6P11m3. try clear HP4P6P11m2. try clear HP4P6P11m1. try clear HP4P6P8P9P11P12P15M1. try clear HP4P6P8P9P11P12P15M2. try clear HP4P6P8P9P11P12P15M3. try clear HP4P6P8P9P11P12P15m4. try clear HP4P6P8P9P11P12P15m3. try clear HP4P6P8P9P11P12P15m2. try clear HP4P6P8P9P11P12P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P11P12P15m2 : rk(P4 :: P11 :: P12 :: P15 :: nil) >= 2).
{
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: nil) 2 2 HP4P11mtmp Hcomp Hincl);apply HT.
}
try clear HP4P11M1. try clear HP4P11M2. try clear HP4P11M3. try clear HP4P11m4. try clear HP4P11m3. try clear HP4P11m2. try clear HP4P11m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P11P12P15m3 : rk(P4 :: P11 :: P12 :: P15 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP4P8P9P11P12P15eq : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) = 4) by (apply LP4P8P9P11P12P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P8P9P11P12P15mtmp : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) >= 4) by (solve_hyps_min HP4P8P9P11P12P15eq HP4P8P9P11P12P15m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: nil) (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: nil) ((P8 :: P9 :: P12 :: nil) ++ (P4 :: P11 :: P12 :: P15 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P8P9P11P12P15mtmp;try rewrite HT2 in HP4P8P9P11P12P15mtmp.
	assert(HT := rule_4 (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: nil) (P12 :: nil) 4 1 2 HP4P8P9P11P12P15mtmp HP12mtmp HP8P9P12Mtmp Hincl); apply HT.
}
try clear HP8P9P12M1. try clear HP8P9P12M2. try clear HP8P9P12M3. try clear HP8P9P12m4. try clear HP8P9P12m3. try clear HP8P9P12m2. try clear HP8P9P12m1. try clear HP12M1. try clear HP12M2. try clear HP12M3. try clear HP12m4. try clear HP12m3. try clear HP12m2. try clear HP12m1. try clear HP4P8P9P11P12P15M1. try clear HP4P8P9P11P12P15M2. try clear HP4P8P9P11P12P15M3. try clear HP4P8P9P11P12P15m4. try clear HP4P8P9P11P12P15m3. try clear HP4P8P9P11P12P15m2. try clear HP4P8P9P11P12P15m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP4P11P12P15M3 : rk(P4 :: P11 :: P12 :: P15 :: nil) <= 3).
{
	assert(HP4P11P12P15P16Mtmp : rk(P4 :: P11 :: P12 :: P15 :: P16 :: nil) <= 3) by (solve_hyps_max HP4P11P12P15P16eq HP4P11P12P15P16M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: P12 :: P15 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P4 :: P11 :: P12 :: P15 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: nil) 3 3 HP4P11P12P15P16Mtmp Hcomp Hincl);apply HT.
}
try clear HP4P11P12P15P16M1. try clear HP4P11P12P15P16M2. try clear HP4P11P12P15P16M3. try clear HP4P11P12P15P16m4. try clear HP4P11P12P15P16m3. try clear HP4P11P12P15P16m2. try clear HP4P11P12P15P16m1. 

assert(HP4P11P12P15M : rk(P4 :: P11 :: P12 :: P15 ::  nil) <= 4) by (apply rk_upper_dim).
assert(HP4P11P12P15m : rk(P4 :: P11 :: P12 :: P15 ::  nil) >= 1) by (solve_hyps_min HP4P11P12P15eq HP4P11P12P15m1).
intuition.
Qed.

(* dans la couche 7 *)
Lemma LP9P10P11 : forall P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 P17 ,
rk(P2 :: P3 ::  nil) = 2 -> rk(P2 :: P4 ::  nil) = 2 -> rk(P3 :: P4 ::  nil) = 2 ->
rk(P1 :: P2 :: P3 :: P4 ::  nil) = 2 -> rk(P1 :: P2 :: P5 ::  nil) = 3 -> rk(P1 :: P3 :: P6 ::  nil) = 3 ->
rk(P5 :: P6 ::  nil) = 2 -> rk(P1 :: P4 :: P7 ::  nil) = 3 -> rk(P5 :: P7 ::  nil) = 2 ->
rk(P6 :: P7 ::  nil) = 2 -> rk(P1 :: P5 :: P6 :: P7 ::  nil) = 2 -> rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P7 :: P8 ::  nil) = 4 ->
rk(P3 :: P5 :: P9 ::  nil) = 2 -> rk(P2 :: P6 :: P9 ::  nil) = 2 -> rk(P4 :: P5 :: P10 ::  nil) = 2 ->
rk(P2 :: P7 :: P10 ::  nil) = 2 -> rk(P4 :: P6 :: P11 ::  nil) = 2 -> rk(P3 :: P7 :: P11 ::  nil) = 2 ->
rk(P8 :: P12 ::  nil) = 2 -> rk(P9 :: P12 ::  nil) = 2 -> rk(P8 :: P9 :: P12 ::  nil) = 2 ->
rk(P2 :: P8 :: P13 ::  nil) = 2 -> rk(P2 :: P7 :: P8 :: P13 ::  nil) = 3 -> rk(P3 :: P12 :: P14 ::  nil) = 2 ->
rk(P7 :: P13 :: P14 ::  nil) = 2 -> rk(P5 :: P8 :: P15 ::  nil) = 2 -> rk(P4 :: P5 :: P8 :: P15 ::  nil) = 3 ->
rk(P6 :: P12 :: P16 ::  nil) = 2 -> rk(P4 :: P15 :: P16 ::  nil) = 2 -> rk(P7 :: P13 :: P14 :: P17 ::  nil) = 2 ->
rk(P4 :: P15 :: P16 :: P17 ::  nil) = 2 -> rk(P9 :: P10 :: P11 ::  nil) = 2.
Proof.

intros P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 P16 P17 
HP2P3eq HP2P4eq HP3P4eq HP1P2P3P4eq HP1P2P5eq HP1P3P6eq HP5P6eq HP1P4P7eq HP5P7eq HP6P7eq
HP1P5P6P7eq HP1P2P3P4P5P6P7P8eq HP3P5P9eq HP2P6P9eq HP4P5P10eq HP2P7P10eq HP4P6P11eq HP3P7P11eq HP8P12eq HP9P12eq
HP8P9P12eq HP2P8P13eq HP2P7P8P13eq HP3P12P14eq HP7P13P14eq HP5P8P15eq HP4P5P8P15eq HP6P12P16eq HP4P15P16eq HP7P13P14P17eq
HP4P15P16P17eq .

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P10P13P14P17m2 : rk(P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P10P13P14P17M3 : rk(P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P2 :: P7 :: P10 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P2 :: P7 :: P10 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P7 :: P10 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P7 :: P10 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: nil) 2 2 1 HP2P7P10Mtmp HP7P13P14P17Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P10P13P14P17m3 : rk(P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P7P13mtmp : rk(P2 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP2P7P13eq HP2P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P13 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P13 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P13mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P10P13P14P17m2 : rk(P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P10P13P14P17m3 : rk(P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P7P8mtmp : rk(P2 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P7P8eq HP2P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P8P10P13P14P17M3 : rk(P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P7P10P13P14P17eq : rk(P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP2P7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P10P13P14P17Mtmp : rk(P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P7P10P13P14P17eq HP2P7P10P13P14P17M3).
	try assert(HP2P13eq : rk(P2 :: P13 :: nil) = 2) by (apply LP2P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P13mtmp : rk(P2 :: P13 :: nil) >= 2) by (solve_hyps_min HP2P13eq HP2P13m2).
	assert(Hincl : incl (P2 :: P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) (P2 :: P8 :: P13 :: P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P8 :: P13 :: nil) (P2 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P2 :: P13 :: nil) 2 3 2 HP2P8P13Mtmp HP2P7P10P13P14P17Mtmp HP2P13mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P7P10P13P14P17M1. try clear HP2P7P10P13P14P17M2. try clear HP2P7P10P13P14P17M3. try clear HP2P7P10P13P14P17m4. try clear HP2P7P10P13P14P17m3. try clear HP2P7P10P13P14P17m2. try clear HP2P7P10P13P14P17m1. try clear HP2P13M1. try clear HP2P13M2. try clear HP2P13M3. try clear HP2P13m4. try clear HP2P13m3. try clear HP2P13m2. try clear HP2P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P10P17m2 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P10P17m3 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P10P17m4 : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P8P10P17m2 : rk(P2 :: P8 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P8mtmp : rk(P2 :: P8 :: nil) >= 2) by (solve_hyps_min HP2P8eq HP2P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P8 :: nil) (P2 :: P8 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P8 :: nil) (P2 :: P8 :: P10 :: P17 :: nil) 2 2 HP2P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P8P10P17m3 : rk(P2 :: P8 :: P10 :: P17 :: nil) >= 3).
{
	try assert(HP1P2P5P10eq : rk(P1 :: P2 :: P5 :: P10 :: nil) = 3) by (apply LP1P2P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP1P2P5P10Mtmp : rk(P1 :: P2 :: P5 :: P10 :: nil) <= 3) by (solve_hyps_max HP1P2P5P10eq HP1P2P5P10M3).
	try assert(HP1P2P5P8P10P17eq : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) = 4) by (apply LP1P2P5P8P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P10P17mtmp : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P10P17eq HP1P2P5P8P10P17m4).
	try assert(HP2P10eq : rk(P2 :: P10 :: nil) = 2) by (apply LP2P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hincl : incl (P2 :: P10 :: nil) (list_inter (P1 :: P2 :: P5 :: P10 :: nil) (P2 :: P8 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) (P1 :: P2 :: P5 :: P10 :: P2 :: P8 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P10 :: P2 :: P8 :: P10 :: P17 :: nil) ((P1 :: P2 :: P5 :: P10 :: nil) ++ (P2 :: P8 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P10P17mtmp;try rewrite HT2 in HP1P2P5P8P10P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P10 :: nil) (P2 :: P8 :: P10 :: P17 :: nil) (P2 :: P10 :: nil) 4 2 3 HP1P2P5P8P10P17mtmp HP2P10mtmp HP1P2P5P10Mtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP2P8P10P17M3 : rk(P2 :: P8 :: P10 :: P17 :: nil) <= 3).
{
	assert(HP2P7P8P10P13P14P17Mtmp : rk(P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P7P8P10P13P14P17eq HP2P7P8P10P13P14P17M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P8 :: P10 :: P17 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P2 :: P8 :: P10 :: P17 :: nil) (P2 :: P7 :: P8 :: P10 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P8P10P13P14P17Mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7P8P10P13P14P17M1. try clear HP2P7P8P10P13P14P17M2. try clear HP2P7P8P10P13P14P17M3. try clear HP2P7P8P10P13P14P17m4. try clear HP2P7P8P10P13P14P17m3. try clear HP2P7P8P10P13P14P17m2. try clear HP2P7P8P10P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P10P15P16P17m2 : rk(P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P10P15P16P17m3 : rk(P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP4P5P8mtmp : rk(P4 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P5P8eq HP4P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 3 3 HP4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P8P10P15P16P17m2 : rk(P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P10P15P16P17m3 : rk(P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4P5P8P10P15P16P17eq : rk(P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP4P5P8P10P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P8P10P15P16P17mtmp : rk(P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P5P8P10P15P16P17eq HP4P5P8P10P15P16P17m3).
	try assert(HP4P10eq : rk(P4 :: P10 :: nil) = 2) by (apply LP4P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P10mtmp : rk(P4 :: P10 :: nil) >= 2) by (solve_hyps_min HP4P10eq HP4P10m2).
	assert(Hincl : incl (P4 :: P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P4 :: P5 :: P10 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P8P10P15P16P17mtmp;try rewrite HT2 in HP4P5P8P10P15P16P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P4 :: P10 :: nil) 3 2 2 HP4P5P8P10P15P16P17mtmp HP4P10mtmp HP4P5P10Mtmp Hincl); apply HT.
}
try clear HP4P5P8P10P15P16P17M1. try clear HP4P5P8P10P15P16P17M2. try clear HP4P5P8P10P15P16P17M3. try clear HP4P5P8P10P15P16P17m4. try clear HP4P5P8P10P15P16P17m3. try clear HP4P5P8P10P15P16P17m2. try clear HP4P5P8P10P15P16P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P8P10P15P16P17M3 : rk(P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) <= 3).
{
	try assert(HP4P8P10P15eq : rk(P4 :: P8 :: P10 :: P15 :: nil) = 3) by (apply LP4P8P10P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P8P10P15Mtmp : rk(P4 :: P8 :: P10 :: P15 :: nil) <= 3) by (solve_hyps_max HP4P8P10P15eq HP4P8P10P15M3).
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP4P15eq : rk(P4 :: P15 :: nil) = 2) by (apply LP4P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15mtmp : rk(P4 :: P15 :: nil) >= 2) by (solve_hyps_min HP4P15eq HP4P15m2).
	assert(Hincl : incl (P4 :: P15 :: nil) (list_inter (P4 :: P8 :: P10 :: P15 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P4 :: P8 :: P10 :: P15 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P8 :: P10 :: P15 :: P4 :: P15 :: P16 :: P17 :: nil) ((P4 :: P8 :: P10 :: P15 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P8 :: P10 :: P15 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: P15 :: nil) 3 2 2 HP4P8P10P15Mtmp HP4P15P16P17Mtmp HP4P15mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4P8P10P15M1. try clear HP4P8P10P15M2. try clear HP4P8P10P15M3. try clear HP4P8P10P15m4. try clear HP4P8P10P15m3. try clear HP4P8P10P15m2. try clear HP4P8P10P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P10P15P16P17m2 : rk(P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P10P15P16P17m3 : rk(P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P8P10P15P16P17m4 : rk(P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	assert(HP2P4P5P8mtmp : rk(P2 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8eq HP2P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: P8 :: nil) (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 4 4 HP2P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5P8M1. try clear HP2P4P5P8M2. try clear HP2P4P5P8M3. try clear HP2P4P5P8m4. try clear HP2P4P5P8m3. try clear HP2P4P5P8m2. try clear HP2P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P8P10P15P16P17m2 : rk(P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P8P10P15P16P17m3 : rk(P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P4P8mtmp : rk(P2 :: P4 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P4P8eq HP2P4P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P8 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P4P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P8M1. try clear HP2P4P8M2. try clear HP2P4P8M3. try clear HP2P4P8m4. try clear HP2P4P8m3. try clear HP2P4P8m2. try clear HP2P4P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P8P10P15P16P17m4 : rk(P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP2P4P5P8P10P15P16P17eq : rk(P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P4P5P8P10P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P8P10P15P16P17mtmp : rk(P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P8P10P15P16P17eq HP2P4P5P8P10P15P16P17m4).
	try assert(HP4P10eq : rk(P4 :: P10 :: nil) = 2) by (apply LP4P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P10mtmp : rk(P4 :: P10 :: nil) >= 2) by (solve_hyps_min HP4P10eq HP4P10m2).
	assert(Hincl : incl (P4 :: P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P4 :: P5 :: P10 :: P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P8P10P15P16P17mtmp;try rewrite HT2 in HP2P4P5P8P10P15P16P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P4 :: P10 :: nil) 4 2 2 HP2P4P5P8P10P15P16P17mtmp HP4P10mtmp HP4P5P10Mtmp Hincl); apply HT.
}
try clear HP4P10M1. try clear HP4P10M2. try clear HP4P10M3. try clear HP4P10m4. try clear HP4P10m3. try clear HP4P10m2. try clear HP4P10m1. try clear HP2P4P5P8P10P15P16P17M1. try clear HP2P4P5P8P10P15P16P17M2. try clear HP2P4P5P8P10P15P16P17M3. try clear HP2P4P5P8P10P15P16P17m4. try clear HP2P4P5P8P10P15P16P17m3. try clear HP2P4P5P8P10P15P16P17m2. try clear HP2P4P5P8P10P15P16P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP8P10P17m2 : rk(P8 :: P10 :: P17 :: nil) >= 2).
{
	try assert(HP1P2P5P10eq : rk(P1 :: P2 :: P5 :: P10 :: nil) = 3) by (apply LP1P2P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP1P2P5P10Mtmp : rk(P1 :: P2 :: P5 :: P10 :: nil) <= 3) by (solve_hyps_max HP1P2P5P10eq HP1P2P5P10M3).
	try assert(HP1P2P5P8P10P17eq : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) = 4) by (apply LP1P2P5P8P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P10P17mtmp : rk(P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P10P17eq HP1P2P5P8P10P17m4).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P1 :: P2 :: P5 :: P10 :: nil) (P8 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P10 :: P17 :: nil) (P1 :: P2 :: P5 :: P10 :: P8 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P10 :: P8 :: P10 :: P17 :: nil) ((P1 :: P2 :: P5 :: P10 :: nil) ++ (P8 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P10P17mtmp;try rewrite HT2 in HP1P2P5P8P10P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P10 :: nil) (P8 :: P10 :: P17 :: nil) (P10 :: nil) 4 1 3 HP1P2P5P8P10P17mtmp HP10mtmp HP1P2P5P10Mtmp Hincl); apply HT.
}
try clear HP1P2P5P10M1. try clear HP1P2P5P10M2. try clear HP1P2P5P10M3. try clear HP1P2P5P10m4. try clear HP1P2P5P10m3. try clear HP1P2P5P10m2. try clear HP1P2P5P10m1. try clear HP1P2P5P8P10P17M1. try clear HP1P2P5P8P10P17M2. try clear HP1P2P5P8P10P17M3. try clear HP1P2P5P8P10P17m4. try clear HP1P2P5P8P10P17m3. try clear HP1P2P5P8P10P17m2. try clear HP1P2P5P8P10P17m1. 

(* Application de la règle 3 code (6 dans la thèse) *)
assert(HP8P10P17M2 : rk(P8 :: P10 :: P17 :: nil) <= 2).
{
	try assert(HP2P8P10P17eq : rk(P2 :: P8 :: P10 :: P17 :: nil) = 3) by (apply LP2P8P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P8P10P17Mtmp : rk(P2 :: P8 :: P10 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P8P10P17eq HP2P8P10P17M3).
	try assert(HP4P8P10P15P16P17eq : rk(P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP4P8P10P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P8P10P15P16P17Mtmp : rk(P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) <= 3) by (solve_hyps_max HP4P8P10P15P16P17eq HP4P8P10P15P16P17M3).
	try assert(HP2P4P8P10P15P16P17eq : rk(P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P4P8P10P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P8P10P15P16P17mtmp : rk(P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P8P10P15P16P17eq HP2P4P8P10P15P16P17m4).
	assert(Hincl : incl (P8 :: P10 :: P17 :: nil) (list_inter (P2 :: P8 :: P10 :: P17 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P2 :: P8 :: P10 :: P17 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P10 :: P17 :: P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) ((P2 :: P8 :: P10 :: P17 :: nil) ++ (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P8P10P15P16P17mtmp;try rewrite HT2 in HP2P4P8P10P15P16P17mtmp.
	assert(HT := rule_3 (P2 :: P8 :: P10 :: P17 :: nil) (P4 :: P8 :: P10 :: P15 :: P16 :: P17 :: nil) (P8 :: P10 :: P17 :: nil) 3 3 4 HP2P8P10P17Mtmp HP4P8P10P15P16P17Mtmp HP2P4P8P10P15P16P17mtmp Hincl);apply HT.
}
try clear HP2P8P10P17M1. try clear HP2P8P10P17M2. try clear HP2P8P10P17M3. try clear HP2P8P10P17m4. try clear HP2P8P10P17m3. try clear HP2P8P10P17m2. try clear HP2P8P10P17m1. try clear HP4P8P10P15P16P17M1. try clear HP4P8P10P15P16P17M2. try clear HP4P8P10P15P16P17M3. try clear HP4P8P10P15P16P17m4. try clear HP4P8P10P15P16P17m3. try clear HP4P8P10P15P16P17m2. try clear HP4P8P10P15P16P17m1. try clear HP2P4P8P10P15P16P17M1. try clear HP2P4P8P10P15P16P17M2. try clear HP2P4P8P10P15P16P17M3. try clear HP2P4P8P10P15P16P17m4. try clear HP2P4P8P10P15P16P17m3. try clear HP2P4P8P10P15P16P17m2. try clear HP2P4P8P10P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P11P13P14P17m2 : rk(P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P7P11P13P14P17M3 : rk(P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP3P7P11eq : rk(P3 :: P7 :: P11 :: nil) = 2) by (apply LP3P7P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P7P11Mtmp : rk(P3 :: P7 :: P11 :: nil) <= 2) by (solve_hyps_max HP3P7P11eq HP3P7P11M2).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P3 :: P7 :: P11 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) (P3 :: P7 :: P11 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P11 :: P7 :: P13 :: P14 :: P17 :: nil) ((P3 :: P7 :: P11 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P7 :: P11 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: nil) 2 2 1 HP3P7P11Mtmp HP7P13P14P17Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P7P11M1. try clear HP3P7P11M2. try clear HP3P7P11M3. try clear HP3P7P11m4. try clear HP3P7P11m3. try clear HP3P7P11m2. try clear HP3P7P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P11P13P14P17m3 : rk(P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP3P7P13mtmp : rk(P3 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP3P7P13eq HP3P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: P13 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: P13 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) 3 3 HP3P7P13mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P11P12P13P14P17m2 : rk(P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP3P7mtmp : rk(P3 :: P7 :: nil) >= 2) by (solve_hyps_min HP3P7eq HP3P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) 2 2 HP3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7M1. try clear HP3P7M2. try clear HP3P7M3. try clear HP3P7m4. try clear HP3P7m3. try clear HP3P7m2. try clear HP3P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P7P11P12P13P14P17m3 : rk(P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP3P7P12mtmp : rk(P3 :: P7 :: P12 :: nil) >= 3) by (solve_hyps_min HP3P7P12eq HP3P7P12m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P7 :: P12 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P7 :: P12 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) 3 3 HP3P7P12mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7P12M1. try clear HP3P7P12M2. try clear HP3P7P12M3. try clear HP3P7P12m4. try clear HP3P7P12m3. try clear HP3P7P12m2. try clear HP3P7P12m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P7P11P12P13P14P17M3 : rk(P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP3P7P12P13eq : rk(P3 :: P7 :: P12 :: P13 :: nil) = 3) by (apply LP3P7P12P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P7P12P13Mtmp : rk(P3 :: P7 :: P12 :: P13 :: nil) <= 3) by (solve_hyps_max HP3P7P12P13eq HP3P7P12P13M3).
	try assert(HP3P7P11P13P14P17eq : rk(P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP3P7P11P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P7P11P13P14P17Mtmp : rk(P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP3P7P11P13P14P17eq HP3P7P11P13P14P17M3).
	try assert(HP3P7P13eq : rk(P3 :: P7 :: P13 :: nil) = 3) by (apply LP3P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP3P7P13mtmp : rk(P3 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP3P7P13eq HP3P7P13m3).
	assert(Hincl : incl (P3 :: P7 :: P13 :: nil) (list_inter (P3 :: P7 :: P12 :: P13 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) (P3 :: P7 :: P12 :: P13 :: P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P7 :: P12 :: P13 :: P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) ((P3 :: P7 :: P12 :: P13 :: nil) ++ (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P7 :: P12 :: P13 :: nil) (P3 :: P7 :: P11 :: P13 :: P14 :: P17 :: nil) (P3 :: P7 :: P13 :: nil) 3 3 3 HP3P7P12P13Mtmp HP3P7P11P13P14P17Mtmp HP3P7P13mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP3P7P12P13M1. try clear HP3P7P12P13M2. try clear HP3P7P12P13M3. try clear HP3P7P12P13m4. try clear HP3P7P12P13m3. try clear HP3P7P12P13m2. try clear HP3P7P12P13m1. try clear HP3P7P11P13P14P17M1. try clear HP3P7P11P13P14P17M2. try clear HP3P7P11P13P14P17M3. try clear HP3P7P11P13P14P17m4. try clear HP3P7P11P13P14P17m3. try clear HP3P7P11P13P14P17m2. try clear HP3P7P11P13P14P17m1. try clear HP3P7P13M1. try clear HP3P7P13M2. try clear HP3P7P13M3. try clear HP3P7P13m4. try clear HP3P7P13m3. try clear HP3P7P13m2. try clear HP3P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P11P12P17m2 : rk(P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P11P12P17m3 : rk(P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P11P12P17m4 : rk(P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P11P12P17m2 : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P8P11P12P17m3 : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP3P5P8mtmp : rk(P3 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP3P5P8eq HP3P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: P8 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) 3 3 HP3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5P8M1. try clear HP3P5P8M2. try clear HP3P5P8M3. try clear HP3P5P8m4. try clear HP3P5P8m3. try clear HP3P5P8m2. try clear HP3P5P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P8P11P12P17m4 : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	try assert(HP1P3P5P11eq : rk(P1 :: P3 :: P5 :: P11 :: nil) = 3) by (apply LP1P3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP1P3P5P11Mtmp : rk(P1 :: P3 :: P5 :: P11 :: nil) <= 3) by (solve_hyps_max HP1P3P5P11eq HP1P3P5P11M3).
	try assert(HP1P3P5P8P11P12P17eq : rk(P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP1P3P5P8P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P8P11P12P17mtmp : rk(P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8P11P12P17eq HP1P3P5P8P11P12P17m4).
	try assert(HP3P5P11eq : rk(P3 :: P5 :: P11 :: nil) = 3) by (apply LP3P5P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP3P5P11mtmp : rk(P3 :: P5 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P5P11eq HP3P5P11m3).
	assert(Hincl : incl (P3 :: P5 :: P11 :: nil) (list_inter (P1 :: P3 :: P5 :: P11 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) (P1 :: P3 :: P5 :: P11 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P11 :: P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) ((P1 :: P3 :: P5 :: P11 :: nil) ++ (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P8P11P12P17mtmp;try rewrite HT2 in HP1P3P5P8P11P12P17mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P5 :: P11 :: nil) (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) (P3 :: P5 :: P11 :: nil) 4 3 3 HP1P3P5P8P11P12P17mtmp HP3P5P11mtmp HP1P3P5P11Mtmp Hincl); apply HT.
}
try clear HP1P3P5P11M1. try clear HP1P3P5P11M2. try clear HP1P3P5P11M3. try clear HP1P3P5P11m4. try clear HP1P3P5P11m3. try clear HP1P3P5P11m2. try clear HP1P3P5P11m1. try clear HP3P5P11M1. try clear HP3P5P11M2. try clear HP3P5P11M3. try clear HP3P5P11m4. try clear HP3P5P11m3. try clear HP3P5P11m2. try clear HP3P5P11m1. try clear HP1P3P5P8P11P12P17M1. try clear HP1P3P5P8P11P12P17M2. try clear HP1P3P5P8P11P12P17M3. try clear HP1P3P5P8P11P12P17m4. try clear HP1P3P5P8P11P12P17m3. try clear HP1P3P5P8P11P12P17m2. try clear HP1P3P5P8P11P12P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P11P12P17m2 : rk(P3 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP3P11mtmp : rk(P3 :: P11 :: nil) >= 2) by (solve_hyps_min HP3P11eq HP3P11m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P11 :: nil) (P3 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P11 :: nil) (P3 :: P11 :: P12 :: P17 :: nil) 2 2 HP3P11mtmp Hcomp Hincl);apply HT.
}
try clear HP3P11M1. try clear HP3P11M2. try clear HP3P11M3. try clear HP3P11m4. try clear HP3P11m3. try clear HP3P11m2. try clear HP3P11m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P11P12P17m3 : rk(P3 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	try assert(HP3P5P8P12eq : rk(P3 :: P5 :: P8 :: P12 :: nil) = 3) by (apply LP3P5P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P8P12Mtmp : rk(P3 :: P5 :: P8 :: P12 :: nil) <= 3) by (solve_hyps_max HP3P5P8P12eq HP3P5P8P12M3).
	try assert(HP3P5P8P11P12P17eq : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP3P5P8P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P8P11P12P17mtmp : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P5P8P11P12P17eq HP3P5P8P11P12P17m4).
	try assert(HP3P12eq : rk(P3 :: P12 :: nil) = 2) by (apply LP3P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P12mtmp : rk(P3 :: P12 :: nil) >= 2) by (solve_hyps_min HP3P12eq HP3P12m2).
	assert(Hincl : incl (P3 :: P12 :: nil) (list_inter (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) (P3 :: P5 :: P8 :: P12 :: P3 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P8 :: P12 :: P3 :: P11 :: P12 :: P17 :: nil) ((P3 :: P5 :: P8 :: P12 :: nil) ++ (P3 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P8P11P12P17mtmp;try rewrite HT2 in HP3P5P8P11P12P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P8 :: P12 :: nil) (P3 :: P11 :: P12 :: P17 :: nil) (P3 :: P12 :: nil) 4 2 3 HP3P5P8P11P12P17mtmp HP3P12mtmp HP3P5P8P12Mtmp Hincl); apply HT.
}
try clear HP3P12M1. try clear HP3P12M2. try clear HP3P12M3. try clear HP3P12m4. try clear HP3P12m3. try clear HP3P12m2. try clear HP3P12m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP3P11P12P17M3 : rk(P3 :: P11 :: P12 :: P17 :: nil) <= 3).
{
	assert(HP3P7P11P12P13P14P17Mtmp : rk(P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP3P7P11P12P13P14P17eq HP3P7P11P12P13P14P17M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P11 :: P12 :: P17 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P3 :: P11 :: P12 :: P17 :: nil) (P3 :: P7 :: P11 :: P12 :: P13 :: P14 :: P17 :: nil) 3 3 HP3P7P11P12P13P14P17Mtmp Hcomp Hincl);apply HT.
}
try clear HP3P7P11P12P13P14P17M1. try clear HP3P7P11P12P13P14P17M2. try clear HP3P7P11P12P13P14P17M3. try clear HP3P7P11P12P13P14P17m4. try clear HP3P7P11P12P13P14P17m3. try clear HP3P7P11P12P13P14P17m2. try clear HP3P7P11P12P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P15P16P17m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P15P16P17m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P15P16P17m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P15P16P17m2 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P15P16P17m3 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P11P12P15P16P17m4 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P11P12P15P16P17eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P4P6P8P9P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P6P8P9P11P12P15P16P17mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P11P12P15P16P17eq HP2P4P6P8P9P11P12P15P16P17m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P11P12P15P16P17mtmp;try rewrite HT2 in HP2P4P6P8P9P11P12P15P16P17mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P11P12P15P16P17mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P4P6P8P9P11P12P15P16P17M1. try clear HP2P4P6P8P9P11P12P15P16P17M2. try clear HP2P4P6P8P9P11P12P15P16P17M3. try clear HP2P4P6P8P9P11P12P15P16P17m4. try clear HP2P4P6P8P9P11P12P15P16P17m3. try clear HP2P4P6P8P9P11P12P15P16P17m2. try clear HP2P4P6P8P9P11P12P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P11P12P15P16P17m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P11P12P15P16P17m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P11P12P15P16P17m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P8P9P11P12P15P16P17m2 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P8mtmp : rk(P4 :: P8 :: nil) >= 2) by (solve_hyps_min HP4P8eq HP4P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P8 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P8M1. try clear HP4P8M2. try clear HP4P8M3. try clear HP4P8m4. try clear HP4P8m3. try clear HP4P8m2. try clear HP4P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15P16P17m3 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P11P12P15P16P17eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP3P4P5P8P9P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P8P9P11P12P15P16P17mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P11P12P15P16P17eq HP3P4P5P8P9P11P12P15P16P17m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P11P12P15P16P17mtmp;try rewrite HT2 in HP3P4P5P8P9P11P12P15P16P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P9 :: nil) 4 1 2 HP3P4P5P8P9P11P12P15P16P17mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P4P5P8P9P11P12P15P16P17M1. try clear HP3P4P5P8P9P11P12P15P16P17M2. try clear HP3P4P5P8P9P11P12P15P16P17M3. try clear HP3P4P5P8P9P11P12P15P16P17m4. try clear HP3P4P5P8P9P11P12P15P16P17m3. try clear HP3P4P5P8P9P11P12P15P16P17m2. try clear HP3P4P5P8P9P11P12P15P16P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P8P9P11P12P15P16P17m4 : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6P8P9P11P12P15P16P17eq : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP4P6P8P9P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P6P8P9P11P12P15P16P17mtmp : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P11P12P15P16P17eq HP4P6P8P9P11P12P15P16P17m4).
	try assert(HP4P11eq : rk(P4 :: P11 :: nil) = 2) by (apply LP4P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hincl : incl (P4 :: P11 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P11P12P15P16P17mtmp;try rewrite HT2 in HP4P6P8P9P11P12P15P16P17mtmp.
	assert(HT := rule_4 (P4 :: P6 :: P11 :: nil) (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P4 :: P11 :: nil) 4 2 2 HP4P6P8P9P11P12P15P16P17mtmp HP4P11mtmp HP4P6P11Mtmp Hincl); apply HT.
}
try clear HP4P6P8P9P11P12P15P16P17M1. try clear HP4P6P8P9P11P12P15P16P17M2. try clear HP4P6P8P9P11P12P15P16P17M3. try clear HP4P6P8P9P11P12P15P16P17m4. try clear HP4P6P8P9P11P12P15P16P17m3. try clear HP4P6P8P9P11P12P15P16P17m2. try clear HP4P6P8P9P11P12P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P11P12P15P16P17m2 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P11mtmp : rk(P4 :: P11 :: nil) >= 2) by (solve_hyps_min HP4P11eq HP4P11m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P11 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P11mtmp Hcomp Hincl);apply HT.
}
try clear HP4P11M1. try clear HP4P11M2. try clear HP4P11M3. try clear HP4P11m4. try clear HP4P11m3. try clear HP4P11m2. try clear HP4P11m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P11P12P15P16P17m3 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP4P8P9P11P12P15P16P17eq : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP4P8P9P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P8P9P11P12P15P16P17mtmp : rk(P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P8P9P11P12P15P16P17eq HP4P8P9P11P12P15P16P17m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P8 :: P9 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P9 :: P12 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) ((P8 :: P9 :: P12 :: nil) ++ (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P8P9P11P12P15P16P17mtmp;try rewrite HT2 in HP4P8P9P11P12P15P16P17mtmp.
	assert(HT := rule_4 (P8 :: P9 :: P12 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P12 :: nil) 4 1 2 HP4P8P9P11P12P15P16P17mtmp HP12mtmp HP8P9P12Mtmp Hincl); apply HT.
}
try clear HP4P8P9P11P12P15P16P17M1. try clear HP4P8P9P11P12P15P16P17M2. try clear HP4P8P9P11P12P15P16P17M3. try clear HP4P8P9P11P12P15P16P17m4. try clear HP4P8P9P11P12P15P16P17m3. try clear HP4P8P9P11P12P15P16P17m2. try clear HP4P8P9P11P12P15P16P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P11P12P15P16P17M3 : rk(P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) <= 3).
{
	try assert(HP4P11P12P15eq : rk(P4 :: P11 :: P12 :: P15 :: nil) = 3) by (apply LP4P11P12P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P11P12P15Mtmp : rk(P4 :: P11 :: P12 :: P15 :: nil) <= 3) by (solve_hyps_max HP4P11P12P15eq HP4P11P12P15M3).
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP4P15eq : rk(P4 :: P15 :: nil) = 2) by (apply LP4P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP4P15mtmp : rk(P4 :: P15 :: nil) >= 2) by (solve_hyps_min HP4P15eq HP4P15m2).
	assert(Hincl : incl (P4 :: P15 :: nil) (list_inter (P4 :: P11 :: P12 :: P15 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P4 :: P11 :: P12 :: P15 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P11 :: P12 :: P15 :: P4 :: P15 :: P16 :: P17 :: nil) ((P4 :: P11 :: P12 :: P15 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P11 :: P12 :: P15 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: P15 :: nil) 3 2 2 HP4P11P12P15Mtmp HP4P15P16P17Mtmp HP4P15mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP4P11P12P15M1. try clear HP4P11P12P15M2. try clear HP4P11P12P15M3. try clear HP4P11P12P15m4. try clear HP4P11P12P15m3. try clear HP4P11P12P15m2. try clear HP4P11P12P15m1. try clear HP4P15M1. try clear HP4P15M2. try clear HP4P15M3. try clear HP4P15m4. try clear HP4P15m3. try clear HP4P15m2. try clear HP4P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P11P12P15P16P17m2 : rk(P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P11P12P15P16P17m3 : rk(P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP3P4P11mtmp : rk(P3 :: P4 :: P11 :: nil) >= 3) by (solve_hyps_min HP3P4P11eq HP3P4P11m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P11 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P11 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 3 3 HP3P4P11mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P11M1. try clear HP3P4P11M2. try clear HP3P4P11M3. try clear HP3P4P11m4. try clear HP3P4P11m3. try clear HP3P4P11m2. try clear HP3P4P11m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P11P12P15P16P17m4 : rk(P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	assert(HP3P4P11P12mtmp : rk(P3 :: P4 :: P11 :: P12 :: nil) >= 4) by (solve_hyps_min HP3P4P11P12eq HP3P4P11P12m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P11 :: P12 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P11 :: P12 :: nil) (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) 4 4 HP3P4P11P12mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P11P12M1. try clear HP3P4P11P12M2. try clear HP3P4P11P12M3. try clear HP3P4P11P12m4. try clear HP3P4P11P12m3. try clear HP3P4P11P12m2. try clear HP3P4P11P12m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP11P12P17m2 : rk(P11 :: P12 :: P17 :: nil) >= 2).
{
	try assert(HP3P5P8P12eq : rk(P3 :: P5 :: P8 :: P12 :: nil) = 3) by (apply LP3P5P8P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP3P5P8P12Mtmp : rk(P3 :: P5 :: P8 :: P12 :: nil) <= 3) by (solve_hyps_max HP3P5P8P12eq HP3P5P8P12M3).
	try assert(HP3P5P8P11P12P17eq : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP3P5P8P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P8P11P12P17mtmp : rk(P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P5P8P11P12P17eq HP3P5P8P11P12P17m4).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P3 :: P5 :: P8 :: P12 :: nil) (P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P8 :: P11 :: P12 :: P17 :: nil) (P3 :: P5 :: P8 :: P12 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P8 :: P12 :: P11 :: P12 :: P17 :: nil) ((P3 :: P5 :: P8 :: P12 :: nil) ++ (P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P8P11P12P17mtmp;try rewrite HT2 in HP3P5P8P11P12P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P8 :: P12 :: nil) (P11 :: P12 :: P17 :: nil) (P12 :: nil) 4 1 3 HP3P5P8P11P12P17mtmp HP12mtmp HP3P5P8P12Mtmp Hincl); apply HT.
}
try clear HP3P5P8P12M1. try clear HP3P5P8P12M2. try clear HP3P5P8P12M3. try clear HP3P5P8P12m4. try clear HP3P5P8P12m3. try clear HP3P5P8P12m2. try clear HP3P5P8P12m1. try clear HP3P5P8P11P12P17M1. try clear HP3P5P8P11P12P17M2. try clear HP3P5P8P11P12P17M3. try clear HP3P5P8P11P12P17m4. try clear HP3P5P8P11P12P17m3. try clear HP3P5P8P11P12P17m2. try clear HP3P5P8P11P12P17m1. 

(* Application de la règle 3 code (6 dans la thèse) *)
assert(HP11P12P17M2 : rk(P11 :: P12 :: P17 :: nil) <= 2).
{
	try assert(HP3P11P12P17eq : rk(P3 :: P11 :: P12 :: P17 :: nil) = 3) by (apply LP3P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P11P12P17Mtmp : rk(P3 :: P11 :: P12 :: P17 :: nil) <= 3) by (solve_hyps_max HP3P11P12P17eq HP3P11P12P17M3).
	try assert(HP4P11P12P15P16P17eq : rk(P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP4P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P11P12P15P16P17Mtmp : rk(P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) <= 3) by (solve_hyps_max HP4P11P12P15P16P17eq HP4P11P12P15P16P17M3).
	try assert(HP3P4P11P12P15P16P17eq : rk(P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP3P4P11P12P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P11P12P15P16P17mtmp : rk(P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P11P12P15P16P17eq HP3P4P11P12P15P16P17m4).
	assert(Hincl : incl (P11 :: P12 :: P17 :: nil) (list_inter (P3 :: P11 :: P12 :: P17 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P3 :: P11 :: P12 :: P17 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P11 :: P12 :: P17 :: P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) ((P3 :: P11 :: P12 :: P17 :: nil) ++ (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P11P12P15P16P17mtmp;try rewrite HT2 in HP3P4P11P12P15P16P17mtmp.
	assert(HT := rule_3 (P3 :: P11 :: P12 :: P17 :: nil) (P4 :: P11 :: P12 :: P15 :: P16 :: P17 :: nil) (P11 :: P12 :: P17 :: nil) 3 3 4 HP3P11P12P17Mtmp HP4P11P12P15P16P17Mtmp HP3P4P11P12P15P16P17mtmp Hincl);apply HT.
}
try clear HP3P11P12P17M1. try clear HP3P11P12P17M2. try clear HP3P11P12P17M3. try clear HP3P11P12P17m4. try clear HP3P11P12P17m3. try clear HP3P11P12P17m2. try clear HP3P11P12P17m1. try clear HP4P11P12P15P16P17M1. try clear HP4P11P12P15P16P17M2. try clear HP4P11P12P15P16P17M3. try clear HP4P11P12P15P16P17m4. try clear HP4P11P12P15P16P17m3. try clear HP4P11P12P15P16P17m2. try clear HP4P11P12P15P16P17m1. try clear HP3P4P11P12P15P16P17M1. try clear HP3P4P11P12P15P16P17M2. try clear HP3P4P11P12P15P16P17M3. try clear HP3P4P11P12P15P16P17m4. try clear HP3P4P11P12P15P16P17m3. try clear HP3P4P11P12P15P16P17m2. try clear HP3P4P11P12P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P17m2 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P17m3 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P8P9P11P12P17m4 : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	assert(HP2P4P6P8mtmp : rk(P2 :: P4 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8eq HP2P4P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: P8 :: nil) (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 4 4 HP2P4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6P8M1. try clear HP2P4P6P8M2. try clear HP2P4P6P8M3. try clear HP2P4P6P8m4. try clear HP2P4P6P8m3. try clear HP2P4P6P8m2. try clear HP2P4P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P17m2 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP4P6mtmp : rk(P4 :: P6 :: nil) >= 2) by (solve_hyps_min HP4P6eq HP4P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 2 2 HP4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6M1. try clear HP4P6M2. try clear HP4P6M3. try clear HP4P6m4. try clear HP4P6m3. try clear HP4P6m2. try clear HP4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P6P8P9P11P12P17m3 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP4P6P8mtmp : rk(P4 :: P6 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P6P8eq HP4P6P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P6 :: P8 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 3 3 HP4P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P6P8M1. try clear HP4P6P8M2. try clear HP4P6P8M3. try clear HP4P6P8m4. try clear HP4P6P8m3. try clear HP4P6P8m2. try clear HP4P6P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P6P8P9P11P12P17m4 : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P4P6P8P9P11P12P17eq : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP2P4P6P8P9P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P6P8P9P11P12P17mtmp : rk(P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P6P8P9P11P12P17eq HP2P4P6P8P9P11P12P17m4).
	try assert(HP6P9eq : rk(P6 :: P9 :: nil) = 2) by (apply LP6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP6P9mtmp : rk(P6 :: P9 :: nil) >= 2) by (solve_hyps_min HP6P9eq HP6P9m2).
	assert(Hincl : incl (P6 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P8P9P11P12P17mtmp;try rewrite HT2 in HP2P4P6P8P9P11P12P17mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P6 :: P9 :: nil) 4 2 2 HP2P4P6P8P9P11P12P17mtmp HP6P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP6P9M1. try clear HP6P9M2. try clear HP6P9M3. try clear HP6P9m4. try clear HP6P9m3. try clear HP6P9m2. try clear HP6P9m1. try clear HP2P4P6P8P9P11P12P17M1. try clear HP2P4P6P8P9P11P12P17M2. try clear HP2P4P6P8P9P11P12P17M3. try clear HP2P4P6P8P9P11P12P17m4. try clear HP2P4P6P8P9P11P12P17m3. try clear HP2P4P6P8P9P11P12P17m2. try clear HP2P4P6P8P9P11P12P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P11P12P17m2 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P11P12P17m3 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P11P12P17m4 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP8P9P11P12P17m2 : rk(P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P11P12P17eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP1P2P5P8P9P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P9P11P12P17mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P11P12P17eq HP1P2P5P8P9P11P12P17m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P1 :: P2 :: P5 :: P9 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P11P12P17mtmp;try rewrite HT2 in HP1P2P5P8P9P11P12P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P9 :: nil) 4 1 3 HP1P2P5P8P9P11P12P17mtmp HP9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P5P8P9P11P12P17M1. try clear HP1P2P5P8P9P11P12P17M2. try clear HP1P2P5P8P9P11P12P17M3. try clear HP1P2P5P8P9P11P12P17m4. try clear HP1P2P5P8P9P11P12P17m3. try clear HP1P2P5P8P9P11P12P17m2. try clear HP1P2P5P8P9P11P12P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP8P9P11P12P17m3 : rk(P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	try assert(HP4P6P11eq : rk(P4 :: P6 :: P11 :: nil) = 2) by (apply LP4P6P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP4P6P11Mtmp : rk(P4 :: P6 :: P11 :: nil) <= 2) by (solve_hyps_max HP4P6P11eq HP4P6P11M2).
	try assert(HP4P6P8P9P11P12P17eq : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP4P6P8P9P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P6P8P9P11P12P17mtmp : rk(P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P6P8P9P11P12P17eq HP4P6P8P9P11P12P17m4).
	try assert(HP11eq : rk(P11 :: nil) = 1) by (apply LP11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP11mtmp : rk(P11 :: nil) >= 1) by (solve_hyps_min HP11eq HP11m1).
	assert(Hincl : incl (P11 :: nil) (list_inter (P4 :: P6 :: P11 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P6 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P4 :: P6 :: P11 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P6 :: P11 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) ((P4 :: P6 :: P11 :: nil) ++ (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P6P8P9P11P12P17mtmp;try rewrite HT2 in HP4P6P8P9P11P12P17mtmp.
	assert(HT := rule_4 (P4 :: P6 :: P11 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P11 :: nil) 4 1 2 HP4P6P8P9P11P12P17mtmp HP11mtmp HP4P6P11Mtmp Hincl); apply HT.
}
try clear HP4P6P11M1. try clear HP4P6P11M2. try clear HP4P6P11M3. try clear HP4P6P11m4. try clear HP4P6P11m3. try clear HP4P6P11m2. try clear HP4P6P11m1. try clear HP11M1. try clear HP11M2. try clear HP11M3. try clear HP11m4. try clear HP11m3. try clear HP11m2. try clear HP11m1. try clear HP4P6P8P9P11P12P17M1. try clear HP4P6P8P9P11P12P17M2. try clear HP4P6P8P9P11P12P17M3. try clear HP4P6P8P9P11P12P17m4. try clear HP4P6P8P9P11P12P17m3. try clear HP4P6P8P9P11P12P17m2. try clear HP4P6P8P9P11P12P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP8P9P11P12P17M3 : rk(P8 :: P9 :: P11 :: P12 :: P17 :: nil) <= 3).
{
	try assert(HP8P9P12eq : rk(P8 :: P9 :: P12 :: nil) = 2) by (apply LP8P9P12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP8P9P12Mtmp : rk(P8 :: P9 :: P12 :: nil) <= 2) by (solve_hyps_max HP8P9P12eq HP8P9P12M2).
	try assert(HP11P12P17eq : rk(P11 :: P12 :: P17 :: nil) = 2) by (apply LP11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP11P12P17Mtmp : rk(P11 :: P12 :: P17 :: nil) <= 2) by (solve_hyps_max HP11P12P17eq HP11P12P17M2).
	try assert(HP12eq : rk(P12 :: nil) = 1) by (apply LP12 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) ;try assumption).
	assert(HP12mtmp : rk(P12 :: nil) >= 1) by (solve_hyps_min HP12eq HP12m1).
	assert(Hincl : incl (P12 :: nil) (list_inter (P8 :: P9 :: P12 :: nil) (P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P8 :: P9 :: P12 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P9 :: P12 :: P11 :: P12 :: P17 :: nil) ((P8 :: P9 :: P12 :: nil) ++ (P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P8 :: P9 :: P12 :: nil) (P11 :: P12 :: P17 :: nil) (P12 :: nil) 2 2 1 HP8P9P12Mtmp HP11P12P17Mtmp HP12mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP8P9P12M1. try clear HP8P9P12M2. try clear HP8P9P12M3. try clear HP8P9P12m4. try clear HP8P9P12m3. try clear HP8P9P12m2. try clear HP8P9P12m1. try clear HP11P12P17M1. try clear HP11P12P17M2. try clear HP11P12P17M3. try clear HP11P12P17m4. try clear HP11P12P17m3. try clear HP11P12P17m2. try clear HP11P12P17m1. try clear HP12M1. try clear HP12M2. try clear HP12M3. try clear HP12m4. try clear HP12m3. try clear HP12m2. try clear HP12m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P13P14P17m2 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P13P14P17m3 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P7P8mtmp : rk(P2 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P7P8eq HP2P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P8P13P14P17M3 : rk(P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) (P2 :: P8 :: P13 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P8 :: P13 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P13 :: nil) 2 2 1 HP2P8P13Mtmp HP7P13P14P17Mtmp HP13mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP7P8P13P14P17M3 : rk(P7 :: P8 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP8eq : rk(P8 :: nil) = 1) by (apply LP8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP8Mtmp : rk(P8 :: nil) <= 1) by (solve_hyps_max HP8eq HP8M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P8 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P8 :: P13 :: P14 :: P17 :: nil) (P8 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P7 :: P13 :: P14 :: P17 :: nil) ((P8 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P8 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP8Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP8M1. try clear HP8M2. try clear HP8M3. try clear HP8m4. try clear HP8m3. try clear HP8m2. try clear HP8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP7P8P13P14P17m2 : rk(P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP7P8mtmp : rk(P7 :: P8 :: nil) >= 2) by (solve_hyps_min HP7P8eq HP7P8m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P7 :: P8 :: nil) (P7 :: P8 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P7 :: P8 :: nil) (P7 :: P8 :: P13 :: P14 :: P17 :: nil) 2 2 HP7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP7P8M1. try clear HP7P8M2. try clear HP7P8M3. try clear HP7P8m4. try clear HP7P8m3. try clear HP7P8m2. try clear HP7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P8P13P14P17m3 : rk(P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P7P8P13P14P17eq : rk(P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP2P7P8P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P8P13P14P17mtmp : rk(P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P7P8P13P14P17eq HP2P7P8P13P14P17m3).
	try assert(HP8P13eq : rk(P8 :: P13 :: nil) = 2) by (apply LP8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP8P13mtmp : rk(P8 :: P13 :: nil) >= 2) by (solve_hyps_min HP8P13eq HP8P13m2).
	assert(Hincl : incl (P8 :: P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P7 :: P8 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) (P2 :: P8 :: P13 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P7 :: P8 :: P13 :: P14 :: P17 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P7 :: P8 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P8P13P14P17mtmp;try rewrite HT2 in HP2P7P8P13P14P17mtmp.
	assert(HT := rule_4 (P2 :: P8 :: P13 :: nil) (P7 :: P8 :: P13 :: P14 :: P17 :: nil) (P8 :: P13 :: nil) 3 2 2 HP2P7P8P13P14P17mtmp HP8P13mtmp HP2P8P13Mtmp Hincl); apply HT.
}
try clear HP8P13M1. try clear HP8P13M2. try clear HP8P13M3. try clear HP8P13m4. try clear HP8P13m3. try clear HP8P13m2. try clear HP8P13m1. try clear HP2P7P8P13P14P17M1. try clear HP2P7P8P13P14P17M2. try clear HP2P7P8P13P14P17M3. try clear HP2P7P8P13P14P17m4. try clear HP2P7P8P13P14P17m3. try clear HP2P7P8P13P14P17m2. try clear HP2P7P8P13P14P17m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP8P17m2 : rk(P8 :: P17 :: nil) >= 2).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7P8P13P14P17eq : rk(P7 :: P8 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP7P8P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P8P13P14P17mtmp : rk(P7 :: P8 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP7P8P13P14P17eq HP7P8P13P14P17m3).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P8 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P8 :: P13 :: P14 :: P17 :: nil) (P8 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P8 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP7P8P13P14P17mtmp;try rewrite HT2 in HP7P8P13P14P17mtmp.
	assert(HT := rule_2 (P8 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 3 1 2 HP7P8P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP7P8P13P14P17M1. try clear HP7P8P13P14P17M2. try clear HP7P8P13P14P17M3. try clear HP7P8P13P14P17m4. try clear HP7P8P13P14P17m3. try clear HP7P8P13P14P17m2. try clear HP7P8P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P10P11P12P17m2 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P10P11P12P17m3 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P8P9P10P11P12P17m4 : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	assert(HP3P4P5P8mtmp : rk(P3 :: P4 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8eq HP3P4P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: P8 :: nil) (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 4 4 HP3P4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5P8M1. try clear HP3P4P5P8M2. try clear HP3P4P5P8M3. try clear HP3P4P5P8m4. try clear HP3P4P5P8m3. try clear HP3P4P5P8m2. try clear HP3P4P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P9P10P11P12P17m2 : rk(P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P8P9P10P11P12P17m3 : rk(P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP4P5P8mtmp : rk(P4 :: P5 :: P8 :: nil) >= 3) by (solve_hyps_min HP4P5P8eq HP4P5P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: P8 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 3 3 HP4P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5P8M1. try clear HP4P5P8M2. try clear HP4P5P8M3. try clear HP4P5P8m4. try clear HP4P5P8m3. try clear HP4P5P8m2. try clear HP4P5P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P8P9P10P11P12P17m4 : rk(P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P8P9P10P11P12P17eq : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP3P4P5P8P9P10P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P8P9P10P11P12P17mtmp : rk(P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P5P8P9P10P11P12P17eq HP3P4P5P8P9P10P11P12P17m4).
	try assert(HP5P9eq : rk(P5 :: P9 :: nil) = 2) by (apply LP5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hincl : incl (P5 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P3 :: P5 :: P9 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P8P9P10P11P12P17mtmp;try rewrite HT2 in HP3P4P5P8P9P10P11P12P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P5 :: P9 :: nil) 4 2 2 HP3P4P5P8P9P10P11P12P17mtmp HP5P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P4P5P8P9P10P11P12P17M1. try clear HP3P4P5P8P9P10P11P12P17M2. try clear HP3P4P5P8P9P10P11P12P17M3. try clear HP3P4P5P8P9P10P11P12P17m4. try clear HP3P4P5P8P9P10P11P12P17m3. try clear HP3P4P5P8P9P10P11P12P17m2. try clear HP3P4P5P8P9P10P11P12P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P10P11P12P17m2 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P10P11P12P17m3 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P9P10P11P12P17m4 : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP8P9P10P11P12P17m2 : rk(P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 2).
{
	try assert(HP1P2P5P9eq : rk(P1 :: P2 :: P5 :: P9 :: nil) = 3) by (apply LP1P2P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP1P2P5P9Mtmp : rk(P1 :: P2 :: P5 :: P9 :: nil) <= 3) by (solve_hyps_max HP1P2P5P9eq HP1P2P5P9M3).
	try assert(HP1P2P5P8P9P10P11P12P17eq : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP1P2P5P8P9P10P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P9P10P11P12P17mtmp : rk(P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8P9P10P11P12P17eq HP1P2P5P8P9P10P11P12P17m4).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P1 :: P2 :: P5 :: P9 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P1 :: P2 :: P5 :: P9 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P9 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) ((P1 :: P2 :: P5 :: P9 :: nil) ++ (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P8P9P10P11P12P17mtmp;try rewrite HT2 in HP1P2P5P8P9P10P11P12P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P5 :: P9 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P9 :: nil) 4 1 3 HP1P2P5P8P9P10P11P12P17mtmp HP9mtmp HP1P2P5P9Mtmp Hincl); apply HT.
}
try clear HP1P2P5P9M1. try clear HP1P2P5P9M2. try clear HP1P2P5P9M3. try clear HP1P2P5P9m4. try clear HP1P2P5P9m3. try clear HP1P2P5P9m2. try clear HP1P2P5P9m1. try clear HP1P2P5P8P9P10P11P12P17M1. try clear HP1P2P5P8P9P10P11P12P17M2. try clear HP1P2P5P8P9P10P11P12P17M3. try clear HP1P2P5P8P9P10P11P12P17m4. try clear HP1P2P5P8P9P10P11P12P17m3. try clear HP1P2P5P8P9P10P11P12P17m2. try clear HP1P2P5P8P9P10P11P12P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP8P9P10P11P12P17m3 : rk(P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4P5P8P9P10P11P12P17eq : rk(P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) = 4) by (apply LP4P5P8P9P10P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P8P9P10P11P12P17mtmp : rk(P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P5P8P9P10P11P12P17eq HP4P5P8P9P10P11P12P17m4).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P4 :: P5 :: P10 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P8P9P10P11P12P17mtmp;try rewrite HT2 in HP4P5P8P9P10P11P12P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P10 :: nil) 4 1 2 HP4P5P8P9P10P11P12P17mtmp HP10mtmp HP4P5P10Mtmp Hincl); apply HT.
}
try clear HP4P5P8P9P10P11P12P17M1. try clear HP4P5P8P9P10P11P12P17M2. try clear HP4P5P8P9P10P11P12P17M3. try clear HP4P5P8P9P10P11P12P17m4. try clear HP4P5P8P9P10P11P12P17m3. try clear HP4P5P8P9P10P11P12P17m2. try clear HP4P5P8P9P10P11P12P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP8P9P10P11P12P17M3 : rk(P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) <= 3).
{
	try assert(HP8P10P17eq : rk(P8 :: P10 :: P17 :: nil) = 2) by (apply LP8P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP8P10P17Mtmp : rk(P8 :: P10 :: P17 :: nil) <= 2) by (solve_hyps_max HP8P10P17eq HP8P10P17M2).
	try assert(HP8P9P11P12P17eq : rk(P8 :: P9 :: P11 :: P12 :: P17 :: nil) = 3) by (apply LP8P9P11P12P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP8P9P11P12P17Mtmp : rk(P8 :: P9 :: P11 :: P12 :: P17 :: nil) <= 3) by (solve_hyps_max HP8P9P11P12P17eq HP8P9P11P12P17M3).
	try assert(HP8P17eq : rk(P8 :: P17 :: nil) = 2) by (apply LP8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP8P17mtmp : rk(P8 :: P17 :: nil) >= 2) by (solve_hyps_min HP8P17eq HP8P17m2).
	assert(Hincl : incl (P8 :: P17 :: nil) (list_inter (P8 :: P10 :: P17 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) (P8 :: P10 :: P17 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P8 :: P10 :: P17 :: P8 :: P9 :: P11 :: P12 :: P17 :: nil) ((P8 :: P10 :: P17 :: nil) ++ (P8 :: P9 :: P11 :: P12 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P8 :: P10 :: P17 :: nil) (P8 :: P9 :: P11 :: P12 :: P17 :: nil) (P8 :: P17 :: nil) 2 3 2 HP8P10P17Mtmp HP8P9P11P12P17Mtmp HP8P17mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP8P10P17M1. try clear HP8P10P17M2. try clear HP8P10P17M3. try clear HP8P10P17m4. try clear HP8P10P17m3. try clear HP8P10P17m2. try clear HP8P10P17m1. try clear HP8P9P11P12P17M1. try clear HP8P9P11P12P17M2. try clear HP8P9P11P12P17M3. try clear HP8P9P11P12P17m4. try clear HP8P9P11P12P17m3. try clear HP8P9P11P12P17m2. try clear HP8P9P11P12P17m1. try clear HP8P17M1. try clear HP8P17M2. try clear HP8P17M3. try clear HP8P17m4. try clear HP8P17m3. try clear HP8P17m2. try clear HP8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P17m2 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P17m3 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P8P17m4 : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P7P13P14P17m2 : rk(P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P7P13P14P17m3 : rk(P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P7P13P14P17m4 : rk(P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P13mtmp : rk(P1 :: P2 :: P5 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P5P13eq HP1P2P5P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P13 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P13 :: nil) (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P2P5P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P13M1. try clear HP1P2P5P13M2. try clear HP1P2P5P13M3. try clear HP1P2P5P13m4. try clear HP1P2P5P13m3. try clear HP1P2P5P13m2. try clear HP1P2P5P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P15P16P17m2 : rk(P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P15P16P17m3 : rk(P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P4P5P15P16P17m4 : rk(P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP1P4P5P15eq : rk(P1 :: P4 :: P5 :: P15 :: nil) = 4) by (apply LP1P4P5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P17m2 : rk(P1 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P17 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P17m3 : rk(P1 :: P5 :: P17 :: nil) >= 3).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP1P4P5P15P16P17eq : rk(P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP1P4P5P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P15P16P17mtmp : rk(P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P15P16P17eq HP1P4P5P15P16P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P1 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) (P1 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P1 :: P5 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P15P16P17mtmp;try rewrite HT2 in HP1P4P5P15P16P17mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P17 :: nil) 4 1 2 HP1P4P5P15P16P17mtmp HP17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP1P4P5P15P16P17M1. try clear HP1P4P5P15P16P17M2. try clear HP1P4P5P15P16P17M3. try clear HP1P4P5P15P16P17m4. try clear HP1P4P5P15P16P17m3. try clear HP1P4P5P15P16P17m2. try clear HP1P4P5P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P7P13P14P17m2 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P7P13P14P17M3 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P7 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: nil) 2 2 1 HP1P5P7Mtmp HP7P13P14P17Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P7P13P14P17m3 : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P5P13mtmp : rk(P1 :: P5 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P5P13eq HP1P5P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: P13 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: P13 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P5P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5P13M1. try clear HP1P5P13M2. try clear HP1P5P13M3. try clear HP1P5P13m4. try clear HP1P5P13m3. try clear HP1P5P13m2. try clear HP1P5P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P17m2 : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P17m3 : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P17m4 : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13P14P17eq : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P7P13P14P17Mtmp : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13P14P17eq HP1P5P7P13P14P17M3).
	try assert(HP1P2P5P7P13P14P17eq : rk(P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P2P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P7P13P14P17mtmp : rk(P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P7P13P14P17eq HP1P2P5P7P13P14P17m4).
	try assert(HP1P5P17eq : rk(P1 :: P5 :: P17 :: nil) = 3) by (apply LP1P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P17mtmp : rk(P1 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P5P17eq HP1P5P17m3).
	assert(Hincl : incl (P1 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P2 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P2 :: P5 :: P17 :: nil) ++ (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P7P13P14P17mtmp;try rewrite HT2 in HP1P2P5P7P13P14P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P17 :: nil) 4 3 3 HP1P2P5P7P13P14P17mtmp HP1P5P17mtmp HP1P5P7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP1P2P5P7P13P14P17M1. try clear HP1P2P5P7P13P14P17M2. try clear HP1P2P5P7P13P14P17M3. try clear HP1P2P5P7P13P14P17m4. try clear HP1P2P5P7P13P14P17m3. try clear HP1P2P5P7P13P14P17m2. try clear HP1P2P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P17m2 : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P17m3 : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P8P17m4 : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P17m2 : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P5 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P5P17m3 : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P5 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P5P17m4 : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P5P8P17eq : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P17Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P17eq HP1P2P5P8P17M4).
	try assert(HP1P2P3P5P8P17eq : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P3P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P5P8P17mtmp : rk(P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P8P17eq HP1P2P3P5P8P17m4).
	try assert(HP1P2P5P17eq : rk(P1 :: P2 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P17mtmp : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P17eq HP1P2P5P17m4).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P3 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil) ((P1 :: P2 :: P3 :: P5 :: P17 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P5P8P17mtmp;try rewrite HT2 in HP1P2P3P5P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P5P8P17mtmp HP1P2P5P17mtmp HP1P2P5P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P3P5P8P17M1. try clear HP1P2P3P5P8P17M2. try clear HP1P2P3P5P8P17M3. try clear HP1P2P3P5P8P17m4. try clear HP1P2P3P5P8P17m3. try clear HP1P2P3P5P8P17m2. try clear HP1P2P3P5P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P9P10P11P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P9P10P11P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P5P9P10P11P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P5P17mtmp : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P17eq HP1P2P3P5P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 4 4 HP1P2P3P5P17mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P13P14P17m2 : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P13P14P17m3 : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P13P14P17m4 : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P4P5P13mtmp : rk(P1 :: P4 :: P5 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P4P5P13eq HP1P4P5P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P4P5P13mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P17m2 : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P17m3 : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P17 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P4P5P17m4 : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13P14P17eq : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P7P13P14P17Mtmp : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13P14P17eq HP1P5P7P13P14P17M3).
	try assert(HP1P4P5P7P13P14P17eq : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P4P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P7P13P14P17mtmp : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P13P14P17eq HP1P4P5P7P13P14P17m4).
	try assert(HP1P5P17eq : rk(P1 :: P5 :: P17 :: nil) = 3) by (apply LP1P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P17mtmp : rk(P1 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P5P17eq HP1P5P17m3).
	assert(Hincl : incl (P1 :: P5 :: P17 :: nil) (list_inter (P1 :: P4 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P4 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P4 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P13P14P17mtmp;try rewrite HT2 in HP1P4P5P7P13P14P17mtmp.
	assert(HT := rule_2 (P1 :: P4 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P17 :: nil) 4 3 3 HP1P4P5P7P13P14P17mtmp HP1P5P17mtmp HP1P5P7P13P14P17Mtmp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P8P17m2 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P8P17m3 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P8P17m4 : rk(P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P17m2 : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P5P17m3 : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P5P17m4 : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P5P8P17eq : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P17Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P17eq HP1P2P5P8P17M4).
	try assert(HP1P2P4P5P8P17eq : rk(P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P4P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P8P17mtmp : rk(P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P4P5P8P17eq HP1P2P4P5P8P17m4).
	try assert(HP1P2P5P17eq : rk(P1 :: P2 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P17mtmp : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P17eq HP1P2P5P17m4).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P5P8P17mtmp;try rewrite HT2 in HP1P2P4P5P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 4 4 4 HP1P2P4P5P8P17mtmp HP1P2P5P17mtmp HP1P2P5P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P4P5P8P17M1. try clear HP1P2P4P5P8P17M2. try clear HP1P2P4P5P8P17M3. try clear HP1P2P4P5P8P17m4. try clear HP1P2P4P5P8P17m3. try clear HP1P2P4P5P8P17m2. try clear HP1P2P4P5P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P9P10P11P17m2 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P9P10P11P17m3 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P9P10P11P17m4 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P5P17eq : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P17Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P5P17eq HP1P2P4P5P17M4).
	try assert(HP1P2P3P4P5P9P10P11P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P9P10P11P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P9P10P11P17eq HP1P2P3P4P5P9P10P11P17m4).
	try assert(HP1P4P5P17eq : rk(P1 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P17mtmp : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P17eq HP1P4P5P17m4).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P9P10P11P17mtmp;try rewrite HT2 in HP1P2P3P4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P9P10P11P17mtmp HP1P4P5P17mtmp HP1P2P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5P9P10P11P17M1. try clear HP1P2P3P4P5P9P10P11P17M2. try clear HP1P2P3P4P5P9P10P11P17M3. try clear HP1P2P3P4P5P9P10P11P17m4. try clear HP1P2P3P4P5P9P10P11P17m3. try clear HP1P2P3P4P5P9P10P11P17m2. try clear HP1P2P3P4P5P9P10P11P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P15P16P17m2 : rk(P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P15P16P17m3 : rk(P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP3P4P5P15P16P17m4 : rk(P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP3P4P5P15eq : rk(P3 :: P4 :: P5 :: P15 :: nil) = 4) by (apply LP3P4P5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP3P4P5P15M1. try clear HP3P4P5P15M2. try clear HP3P4P5P15M3. try clear HP3P4P5P15m4. try clear HP3P4P5P15m3. try clear HP3P4P5P15m2. try clear HP3P4P5P15m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P7P13P14P17M3 : rk(P4 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4Mtmp : rk(P4 :: nil) <= 1) by (solve_hyps_max HP4eq HP4M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P7 :: P13 :: P14 :: P17 :: nil) (P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P7 :: P13 :: P14 :: P17 :: nil) ((P4 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP4Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P7P13P14P17m2 : rk(P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP4P7mtmp : rk(P4 :: P7 :: nil) >= 2) by (solve_hyps_min HP4P7eq HP4P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P7 :: nil) (P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P7 :: nil) (P4 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P7P13P14P17m3 : rk(P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP4P7P13mtmp : rk(P4 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP4P7P13eq HP4P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P4 :: P7 :: P13 :: nil) (P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P7 :: P13 :: nil) (P4 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP4P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP4P7P13M1. try clear HP4P7P13M2. try clear HP4P7P13M3. try clear HP4P7P13m4. try clear HP4P7P13m3. try clear HP4P7P13m2. try clear HP4P7P13m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P17m2 : rk(P4 :: P17 :: nil) >= 2).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP4P7P13P14P17eq : rk(P4 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP4P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P7P13P14P17mtmp : rk(P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P7P13P14P17eq HP4P7P13P14P17m3).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P4 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P7 :: P13 :: P14 :: P17 :: nil) (P4 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P4 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P7P13P14P17mtmp;try rewrite HT2 in HP4P7P13P14P17mtmp.
	assert(HT := rule_2 (P4 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 3 1 2 HP4P7P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP4P7P13P14P17M1. try clear HP4P7P13P14P17M2. try clear HP4P7P13P14P17M3. try clear HP4P7P13P14P17m4. try clear HP4P7P13P14P17m3. try clear HP4P7P13P14P17m2. try clear HP4P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P17m2 : rk(P3 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P17m3 : rk(P3 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P17 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P17m4 : rk(P3 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP3P4P5P15P16P17eq : rk(P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP3P4P5P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P15P16P17mtmp : rk(P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P5P15P16P17eq HP3P4P5P15P16P17m4).
	try assert(HP4P17eq : rk(P4 :: P17 :: nil) = 2) by (apply LP4P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P17mtmp : rk(P4 :: P17 :: nil) >= 2) by (solve_hyps_min HP4P17eq HP4P17m2).
	assert(Hincl : incl (P4 :: P17 :: nil) (list_inter (P3 :: P4 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) (P3 :: P4 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P4 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P3 :: P4 :: P5 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P15P16P17mtmp;try rewrite HT2 in HP3P4P5P15P16P17mtmp.
	assert(HT := rule_2 (P3 :: P4 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: P17 :: nil) 4 2 2 HP3P4P5P15P16P17mtmp HP4P17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP3P4P5P15P16P17M1. try clear HP3P4P5P15P16P17M2. try clear HP3P4P5P15P16P17M3. try clear HP3P4P5P15P16P17m4. try clear HP3P4P5P15P16P17m3. try clear HP3P4P5P15P16P17m2. try clear HP3P4P5P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P8P17m2 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P8P17m3 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P8P17m4 : rk(P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P13P14P17m2 : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P13P14P17m3 : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P13P14P17m4 : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P3P5P13mtmp : rk(P1 :: P3 :: P5 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P3P5P13eq HP1P3P5P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P13 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P13 :: nil) (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P3P5P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P13M1. try clear HP1P3P5P13M2. try clear HP1P3P5P13M3. try clear HP1P3P5P13m4. try clear HP1P3P5P13m3. try clear HP1P3P5P13m2. try clear HP1P3P5P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P17m2 : rk(P1 :: P3 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P17m3 : rk(P1 :: P3 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P5P17m4 : rk(P1 :: P3 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13P14P17eq : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P7P13P14P17Mtmp : rk(P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13P14P17eq HP1P5P7P13P14P17M3).
	try assert(HP1P3P5P7P13P14P17eq : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P3P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P7P13P14P17mtmp : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P5P7P13P14P17eq HP1P3P5P7P13P14P17m4).
	try assert(HP1P5P17eq : rk(P1 :: P5 :: P17 :: nil) = 3) by (apply LP1P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P17mtmp : rk(P1 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P5P17eq HP1P5P17m3).
	assert(Hincl : incl (P1 :: P5 :: P17 :: nil) (list_inter (P1 :: P3 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P3 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P5 :: P17 :: P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P3 :: P5 :: P17 :: nil) ++ (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P13P14P17mtmp;try rewrite HT2 in HP1P3P5P7P13P14P17mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P5 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P17 :: nil) 4 3 3 HP1P3P5P7P13P14P17mtmp HP1P5P17mtmp HP1P5P7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP1P5P7P13P14P17M1. try clear HP1P5P7P13P14P17M2. try clear HP1P5P7P13P14P17M3. try clear HP1P5P7P13P14P17m4. try clear HP1P5P7P13P14P17m3. try clear HP1P5P7P13P14P17m2. try clear HP1P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P17m2 : rk(P1 :: P3 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P17m3 : rk(P1 :: P3 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P8P17m4 : rk(P1 :: P3 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P3P5P8mtmp : rk(P1 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P3P5P8eq HP1P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: P8 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5P8M1. try clear HP1P3P5P8M2. try clear HP1P3P5P8M3. try clear HP1P3P5P8m4. try clear HP1P3P5P8m3. try clear HP1P3P5P8m2. try clear HP1P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P17m2 : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P17m3 : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P17m4 : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P3P5P8P17eq : rk(P1 :: P3 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P3P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P8P17Mtmp : rk(P1 :: P3 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P3P5P8P17eq HP1P3P5P8P17M4).
	try assert(HP1P3P4P5P8P17eq : rk(P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P3P4P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P8P17mtmp : rk(P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P8P17eq HP1P3P4P5P8P17m4).
	try assert(HP1P3P5P17eq : rk(P1 :: P3 :: P5 :: P17 :: nil) = 4) by (apply LP1P3P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P17mtmp : rk(P1 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P5P17eq HP1P3P5P17m4).
	assert(Hincl : incl (P1 :: P3 :: P5 :: P17 :: nil) (list_inter (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: P1 :: P3 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P5 :: P17 :: P1 :: P3 :: P5 :: P8 :: P17 :: nil) ((P1 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P3 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P8P17mtmp;try rewrite HT2 in HP1P3P4P5P8P17mtmp.
	assert(HT := rule_2 (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P5 :: P8 :: P17 :: nil) (P1 :: P3 :: P5 :: P17 :: nil) 4 4 4 HP1P3P4P5P8P17mtmp HP1P3P5P17mtmp HP1P3P5P8P17Mtmp Hincl);apply HT.
}
try clear HP1P3P5P8P17M1. try clear HP1P3P5P8P17M2. try clear HP1P3P5P8P17M3. try clear HP1P3P5P8P17m4. try clear HP1P3P5P8P17m3. try clear HP1P3P5P8P17m2. try clear HP1P3P5P8P17m1. try clear HP1P3P5P17M1. try clear HP1P3P5P17M2. try clear HP1P3P5P17M3. try clear HP1P3P5P17m4. try clear HP1P3P5P17m3. try clear HP1P3P5P17m2. try clear HP1P3P5P17m1. try clear HP1P3P4P5P8P17M1. try clear HP1P3P4P5P8P17M2. try clear HP1P3P4P5P8P17M3. try clear HP1P3P4P5P8P17m4. try clear HP1P3P4P5P8P17m3. try clear HP1P3P4P5P8P17m2. try clear HP1P3P4P5P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P9P10P11P17m2 : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP3P4mtmp : rk(P3 :: P4 :: nil) >= 2) by (solve_hyps_min HP3P4eq HP3P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP3P4mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4M1. try clear HP3P4M2. try clear HP3P4M3. try clear HP3P4m4. try clear HP3P4m3. try clear HP3P4m2. try clear HP3P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P4P5P9P10P11P17m3 : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	assert(HP3P4P5mtmp : rk(P3 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP3P4P5eq HP3P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P4 :: P5 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 3 3 HP3P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P4P5M1. try clear HP3P4P5M2. try clear HP3P4P5M3. try clear HP3P4P5m4. try clear HP3P4P5m3. try clear HP3P4P5m2. try clear HP3P4P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P4P5P9P10P11P17m4 : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP1P3P4P5P17eq : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P17Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P3P4P5P17eq HP1P3P4P5P17M4).
	try assert(HP1P3P4P5P9P10P11P17eq : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP1P3P4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P9P10P11P17mtmp : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P9P10P11P17eq HP1P3P4P5P9P10P11P17m4).
	try assert(HP3P4P5P17eq : rk(P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P17mtmp : rk(P3 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P5P17eq HP3P4P5P17m4).
	assert(Hincl : incl (P3 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P5 :: P17 :: P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) ((P1 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P9P10P11P17mtmp;try rewrite HT2 in HP1P3P4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P3 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P3P4P5P9P10P11P17mtmp HP3P4P5P17mtmp HP1P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP3P4P5P17M1. try clear HP3P4P5P17M2. try clear HP3P4P5P17M3. try clear HP3P4P5P17m4. try clear HP3P4P5P17m3. try clear HP3P4P5P17m2. try clear HP3P4P5P17m1. try clear HP1P3P4P5P9P10P11P17M1. try clear HP1P3P4P5P9P10P11P17M2. try clear HP1P3P4P5P9P10P11P17M3. try clear HP1P3P4P5P9P10P11P17m4. try clear HP1P3P4P5P9P10P11P17m3. try clear HP1P3P4P5P9P10P11P17m2. try clear HP1P3P4P5P9P10P11P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P6P9P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P6P9P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P5P6P9P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P5P17mtmp : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P17eq HP1P2P3P5P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) 4 4 HP1P2P3P5P17mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P8P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P8P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P8P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P5P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P5P8P17eq : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P17Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P17eq HP1P2P5P8P17M4).
	try assert(HP1P2P3P4P5P8P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P8P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P8P17eq HP1P2P3P4P5P8P17m4).
	try assert(HP1P2P5P17eq : rk(P1 :: P2 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P17mtmp : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P17eq HP1P2P5P17m4).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil) ((P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P8P17mtmp;try rewrite HT2 in HP1P2P3P4P5P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P8P17mtmp HP1P2P5P17mtmp HP1P2P5P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P3P4P5P8P17M1. try clear HP1P2P3P4P5P8P17M2. try clear HP1P2P3P4P5P8P17M3. try clear HP1P2P3P4P5P8P17m4. try clear HP1P2P3P4P5P8P17m3. try clear HP1P2P3P4P5P8P17m2. try clear HP1P2P3P4P5P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P9P17m2 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P9P17m3 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P5P6P9P17m4 : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P3P4P5P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P17Mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P3P4P5P17eq HP1P2P3P4P5P17M4).
	try assert(HP1P2P3P4P5P6P9P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P6P9P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P6P9P17eq HP1P2P3P4P5P6P9P17m4).
	try assert(HP1P2P5P17eq : rk(P1 :: P2 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P17mtmp : rk(P1 :: P2 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P17eq HP1P2P5P17m4).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P6 :: P9 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) ((P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P6P9P17mtmp;try rewrite HT2 in HP1P2P3P4P5P6P9P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P1 :: P2 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P6P9P17mtmp HP1P2P5P17mtmp HP1P2P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5P17M1. try clear HP1P2P3P4P5P17M2. try clear HP1P2P3P4P5P17M3. try clear HP1P2P3P4P5P17m4. try clear HP1P2P3P4P5P17m3. try clear HP1P2P3P4P5P17m2. try clear HP1P2P3P4P5P17m1. try clear HP1P2P5P17M1. try clear HP1P2P5P17M2. try clear HP1P2P5P17M3. try clear HP1P2P5P17m4. try clear HP1P2P5P17m3. try clear HP1P2P5P17m2. try clear HP1P2P5P17m1. try clear HP1P2P3P4P5P6P9P17M1. try clear HP1P2P3P4P5P6P9P17M2. try clear HP1P2P3P4P5P6P9P17M3. try clear HP1P2P3P4P5P6P9P17m4. try clear HP1P2P3P4P5P6P9P17m3. try clear HP1P2P3P4P5P6P9P17m2. try clear HP1P2P3P4P5P6P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P6P15P16P17m2 : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P6P15P16P17m3 : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P4P5P6P15P16P17m4 : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP1P4P5P15eq : rk(P1 :: P4 :: P5 :: P15 :: nil) = 4) by (apply LP1P4P5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP1P4P5P15M1. try clear HP1P4P5P15M2. try clear HP1P4P5P15M3. try clear HP1P4P5P15m4. try clear HP1P4P5P15m3. try clear HP1P4P5P15m2. try clear HP1P4P5P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P6P15P16P17m2 : rk(P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P6P15P16P17m3 : rk(P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P4P5P6P15P16P17eq : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP1P4P5P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P6P15P16P17mtmp : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P4P5P6P15P16P17eq HP1P4P5P6P15P16P17m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P15P16P17mtmp;try rewrite HT2 in HP1P4P5P6P15P16P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P4P5P6P15P16P17mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P6P15P16P17m4 : rk(P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P6P15eq : rk(P1 :: P5 :: P6 :: P15 :: nil) = 3) by (apply LP1P5P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP1P5P6P15Mtmp : rk(P1 :: P5 :: P6 :: P15 :: nil) <= 3) by (solve_hyps_max HP1P5P6P15eq HP1P5P6P15M3).
	try assert(HP1P4P5P6P15P16P17eq : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP1P4P5P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P6P15P16P17mtmp : rk(P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P6P15P16P17eq HP1P4P5P6P15P16P17m4).
	try assert(HP5P6P15eq : rk(P5 :: P6 :: P15 :: nil) = 3) by (apply LP5P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
	assert(HP5P6P15mtmp : rk(P5 :: P6 :: P15 :: nil) >= 3) by (solve_hyps_min HP5P6P15eq HP5P6P15m3).
	assert(Hincl : incl (P5 :: P6 :: P15 :: nil) (list_inter (P1 :: P5 :: P6 :: P15 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) (P1 :: P5 :: P6 :: P15 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P15 :: P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) ((P1 :: P5 :: P6 :: P15 :: nil) ++ (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P6P15P16P17mtmp;try rewrite HT2 in HP1P4P5P6P15P16P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P15 :: nil) (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) (P5 :: P6 :: P15 :: nil) 4 3 3 HP1P4P5P6P15P16P17mtmp HP5P6P15mtmp HP1P5P6P15Mtmp Hincl); apply HT.
}
try clear HP1P5P6P15M1. try clear HP1P5P6P15M2. try clear HP1P5P6P15M3. try clear HP1P5P6P15m4. try clear HP1P5P6P15m3. try clear HP1P5P6P15m2. try clear HP1P5P6P15m1. try clear HP5P6P15M1. try clear HP5P6P15M2. try clear HP5P6P15M3. try clear HP5P6P15m4. try clear HP5P6P15m3. try clear HP5P6P15m2. try clear HP5P6P15m1. try clear HP1P4P5P6P15P16P17M1. try clear HP1P4P5P6P15P16P17M2. try clear HP1P4P5P6P15P16P17M3. try clear HP1P4P5P6P15P16P17m4. try clear HP1P4P5P6P15P16P17m3. try clear HP1P4P5P6P15P16P17m2. try clear HP1P4P5P6P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P6P17m2 : rk(P5 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P6 :: nil) (P5 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P6 :: nil) (P5 :: P6 :: P17 :: nil) 2 2 HP5P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P6P17m3 : rk(P5 :: P6 :: P17 :: nil) >= 3).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP4P5P6P15P16P17eq : rk(P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP4P5P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P6P15P16P17mtmp : rk(P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P5P6P15P16P17eq HP4P5P6P15P16P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P5 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P6 :: P15 :: P16 :: P17 :: nil) (P5 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P5 :: P6 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P6P15P16P17mtmp;try rewrite HT2 in HP4P5P6P15P16P17mtmp.
	assert(HT := rule_2 (P5 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P17 :: nil) 4 1 2 HP4P5P6P15P16P17mtmp HP17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP4P5P6P15P16P17M1. try clear HP4P5P6P15P16P17M2. try clear HP4P5P6P15P16P17M3. try clear HP4P5P6P15P16P17m4. try clear HP4P5P6P15P16P17m3. try clear HP4P5P6P15P16P17m2. try clear HP4P5P6P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P8P17m2 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P8P17m3 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P5P6P8P17m4 : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P5P8mtmp : rk(P1 :: P2 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P5P8eq HP1P2P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: P8 :: nil) (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) 4 4 HP1P2P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5P8M1. try clear HP1P2P5P8M2. try clear HP1P2P5P8M3. try clear HP1P2P5P8m4. try clear HP1P2P5P8m3. try clear HP1P2P5P8m2. try clear HP1P2P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P5P6P17m2 : rk(P1 :: P5 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P5mtmp : rk(P1 :: P5 :: nil) >= 2) by (solve_hyps_min HP1P5eq HP1P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P5 :: nil) (P1 :: P5 :: P6 :: P17 :: nil) 2 2 HP1P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P5M1. try clear HP1P5M2. try clear HP1P5M3. try clear HP1P5m4. try clear HP1P5m3. try clear HP1P5m2. try clear HP1P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P5P6P17M3 : rk(P1 :: P5 :: P6 :: P17 :: nil) <= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P5 :: P6 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P5 :: P6 :: P17 :: nil) (P1 :: P5 :: P6 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P17 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P5 :: P6 :: nil) (P17 :: nil) (nil) 2 1 0 HP1P5P6Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P5P6P17m3 : rk(P1 :: P5 :: P6 :: P17 :: nil) >= 3).
{
	try assert(HP1P2P5P8P17eq : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P8P17Mtmp : rk(P1 :: P2 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P5P8P17eq HP1P2P5P8P17M4).
	try assert(HP1P2P5P6P8P17eq : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P5P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P6P8P17mtmp : rk(P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P8P17eq HP1P2P5P6P8P17m4).
	try assert(HP1P5P17eq : rk(P1 :: P5 :: P17 :: nil) = 3) by (apply LP1P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P17mtmp : rk(P1 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P5P17eq HP1P5P17m3).
	assert(Hincl : incl (P1 :: P5 :: P17 :: nil) (list_inter (P1 :: P5 :: P6 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P8 :: P17 :: nil) (P1 :: P5 :: P6 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P17 :: P1 :: P2 :: P5 :: P8 :: P17 :: nil) ((P1 :: P5 :: P6 :: P17 :: nil) ++ (P1 :: P2 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P8P17mtmp;try rewrite HT2 in HP1P2P5P6P8P17mtmp.
	assert(HT := rule_2 (P1 :: P5 :: P6 :: P17 :: nil) (P1 :: P2 :: P5 :: P8 :: P17 :: nil) (P1 :: P5 :: P17 :: nil) 4 3 4 HP1P2P5P6P8P17mtmp HP1P5P17mtmp HP1P2P5P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P5P8P17M1. try clear HP1P2P5P8P17M2. try clear HP1P2P5P8P17M3. try clear HP1P2P5P8P17m4. try clear HP1P2P5P8P17m3. try clear HP1P2P5P8P17m2. try clear HP1P2P5P8P17m1. try clear HP1P5P17M1. try clear HP1P5P17M2. try clear HP1P5P17M3. try clear HP1P5P17m4. try clear HP1P5P17m3. try clear HP1P5P17m2. try clear HP1P5P17m1. try clear HP1P2P5P6P8P17M1. try clear HP1P2P5P6P8P17M2. try clear HP1P2P5P6P8P17M3. try clear HP1P2P5P6P8P17m4. try clear HP1P2P5P6P8P17m3. try clear HP1P2P5P6P8P17m2. try clear HP1P2P5P6P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P5P6P9P17m2 : rk(P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P5mtmp : rk(P2 :: P5 :: nil) >= 2) by (solve_hyps_min HP2P5eq HP2P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P5 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P5 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil) 2 2 HP2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P5M1. try clear HP2P5M2. try clear HP2P5M3. try clear HP2P5m4. try clear HP2P5m3. try clear HP2P5m2. try clear HP2P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P6P9P17m3 : rk(P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P6eq : rk(P1 :: P5 :: P6 :: nil) = 2) by (apply LP1P5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P6Mtmp : rk(P1 :: P5 :: P6 :: nil) <= 2) by (solve_hyps_max HP1P5P6eq HP1P5P6M2).
	try assert(HP1P2P5P6P9P17eq : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) = 3) by (apply LP1P2P5P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P6P9P17mtmp : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P2P5P6P9P17eq HP1P2P5P6P9P17m3).
	try assert(HP5P6eq : rk(P5 :: P6 :: nil) = 2) by (apply LP5P6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P6mtmp : rk(P5 :: P6 :: nil) >= 2) by (solve_hyps_min HP5P6eq HP5P6m2).
	assert(Hincl : incl (P5 :: P6 :: nil) (list_inter (P1 :: P5 :: P6 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P1 :: P5 :: P6 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) ((P1 :: P5 :: P6 :: nil) ++ (P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P9P17mtmp;try rewrite HT2 in HP1P2P5P6P9P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P5 :: P6 :: nil) 3 2 2 HP1P2P5P6P9P17mtmp HP5P6mtmp HP1P5P6Mtmp Hincl); apply HT.
}
try clear HP1P5P6M1. try clear HP1P5P6M2. try clear HP1P5P6M3. try clear HP1P5P6m4. try clear HP1P5P6m3. try clear HP1P5P6m2. try clear HP1P5P6m1. try clear HP5P6M1. try clear HP5P6M2. try clear HP5P6M3. try clear HP5P6m4. try clear HP5P6m3. try clear HP5P6m2. try clear HP5P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P5P6P9P17m4 : rk(P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P6P17eq : rk(P1 :: P5 :: P6 :: P17 :: nil) = 3) by (apply LP1P5P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P5P6P17Mtmp : rk(P1 :: P5 :: P6 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P5P6P17eq HP1P5P6P17M3).
	try assert(HP1P2P5P6P9P17eq : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) = 4) by (apply LP1P2P5P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P5P6P9P17mtmp : rk(P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P5P6P9P17eq HP1P2P5P6P9P17m4).
	try assert(HP5P6P17eq : rk(P5 :: P6 :: P17 :: nil) = 3) by (apply LP5P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP5P6P17mtmp : rk(P5 :: P6 :: P17 :: nil) >= 3) by (solve_hyps_min HP5P6P17eq HP5P6P17m3).
	assert(Hincl : incl (P5 :: P6 :: P17 :: nil) (list_inter (P1 :: P5 :: P6 :: P17 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P1 :: P5 :: P6 :: P17 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P6 :: P17 :: P2 :: P5 :: P6 :: P9 :: P17 :: nil) ((P1 :: P5 :: P6 :: P17 :: nil) ++ (P2 :: P5 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P5P6P9P17mtmp;try rewrite HT2 in HP1P2P5P6P9P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P6 :: P17 :: nil) (P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P5 :: P6 :: P17 :: nil) 4 3 3 HP1P2P5P6P9P17mtmp HP5P6P17mtmp HP1P5P6P17Mtmp Hincl); apply HT.
}
try clear HP1P5P6P17M1. try clear HP1P5P6P17M2. try clear HP1P5P6P17M3. try clear HP1P5P6P17m4. try clear HP1P5P6P17m3. try clear HP1P5P6P17m2. try clear HP1P5P6P17m1. try clear HP5P6P17M1. try clear HP5P6P17M2. try clear HP5P6P17M3. try clear HP5P6P17m4. try clear HP5P6P17m3. try clear HP5P6P17m2. try clear HP5P6P17m1. try clear HP1P2P5P6P9P17M1. try clear HP1P2P5P6P9P17M2. try clear HP1P2P5P6P9P17M3. try clear HP1P2P5P6P9P17m4. try clear HP1P2P5P6P9P17m3. try clear HP1P2P5P6P9P17m2. try clear HP1P2P5P6P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P9P13P14P17m2 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P9P13P14P17m3 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P9P13P14P17m4 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P7P8P9P13P14P17m2 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P9P13P14P17m3 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P8P9P13P14P17eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P2P6P7P8P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P8P9P13P14P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P8P9P13P14P17eq HP1P2P6P7P8P9P13P14P17m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P9P13P14P17mtmp;try rewrite HT2 in HP1P2P6P7P8P9P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P8P9P13P14P17mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P8P9P13P14P17m4 : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP1P6P7P8eq : rk(P1 :: P6 :: P7 :: P8 :: nil) = 3) by (apply LP1P6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7P8Mtmp : rk(P1 :: P6 :: P7 :: P8 :: nil) <= 3) by (solve_hyps_max HP1P6P7P8eq HP1P6P7P8M3).
	try assert(HP1P2P6P7P8P9P13P14P17eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P2P6P7P8P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P8P9P13P14P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P8P9P13P14P17eq HP1P2P6P7P8P9P13P14P17m4).
	try assert(HP6P7P8eq : rk(P6 :: P7 :: P8 :: nil) = 3) by (apply LP6P7P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7P8mtmp : rk(P6 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP6P7P8eq HP6P7P8m3).
	assert(Hincl : incl (P6 :: P7 :: P8 :: nil) (list_inter (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P8 :: P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) ((P1 :: P6 :: P7 :: P8 :: nil) ++ (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P9P13P14P17mtmp;try rewrite HT2 in HP1P2P6P7P8P9P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: P8 :: nil) (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: P8 :: nil) 4 3 3 HP1P2P6P7P8P9P13P14P17mtmp HP6P7P8mtmp HP1P6P7P8Mtmp Hincl); apply HT.
}
try clear HP1P6P7P8M1. try clear HP1P6P7P8M2. try clear HP1P6P7P8M3. try clear HP1P6P7P8m4. try clear HP1P6P7P8m3. try clear HP1P6P7P8m2. try clear HP1P6P7P8m1. try clear HP6P7P8M1. try clear HP6P7P8M2. try clear HP6P7P8M3. try clear HP6P7P8m4. try clear HP6P7P8m3. try clear HP6P7P8m2. try clear HP6P7P8m1. try clear HP1P2P6P7P8P9P13P14P17M1. try clear HP1P2P6P7P8P9P13P14P17M2. try clear HP1P2P6P7P8P9P13P14P17M3. try clear HP1P2P6P7P8P9P13P14P17m4. try clear HP1P2P6P7P8P9P13P14P17m3. try clear HP1P2P6P7P8P9P13P14P17m2. try clear HP1P2P6P7P8P9P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P9P13P14P17m2 : rk(P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P8P9P13P14P17m3 : rk(P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P7P8mtmp : rk(P2 :: P7 :: P8 :: nil) >= 3) by (solve_hyps_min HP2P7P8eq HP2P7P8m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P8 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7P8M1. try clear HP2P7P8M2. try clear HP2P7P8M3. try clear HP2P7P8m4. try clear HP2P7P8m3. try clear HP2P7P8m2. try clear HP2P7P8m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P8P9P13P14P17m4 : rk(P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P6P7P8P9P13P14P17eq : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P6P7P8P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P7P8P9P13P14P17mtmp : rk(P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P6P7P8P9P13P14P17eq HP2P6P7P8P9P13P14P17m4).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P2 :: P6 :: P9 :: P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P8P9P13P14P17mtmp;try rewrite HT2 in HP2P6P7P8P9P13P14P17mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P2 :: P9 :: nil) 4 2 2 HP2P6P7P8P9P13P14P17mtmp HP2P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P7P8P9P13P14P17M1. try clear HP2P6P7P8P9P13P14P17M2. try clear HP2P6P7P8P9P13P14P17M3. try clear HP2P6P7P8P9P13P14P17m4. try clear HP2P6P7P8P9P13P14P17m3. try clear HP2P6P7P8P9P13P14P17m2. try clear HP2P6P7P8P9P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P9P13P14P17m2 : rk(P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P5P7P9P13P14P17m3 : rk(P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P7P9P13P14P17m2 : rk(P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P9P13P14P17m3 : rk(P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P5P7P9P13P14P17eq : rk(P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P3P5P7P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P7P9P13P14P17mtmp : rk(P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P3P5P7P9P13P14P17eq HP1P3P5P7P9P13P14P17m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P9P13P14P17mtmp;try rewrite HT2 in HP1P3P5P7P9P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P3P5P7P9P13P14P17mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P3P5P7P9P13P14P17M1. try clear HP1P3P5P7P9P13P14P17M2. try clear HP1P3P5P7P9P13P14P17M3. try clear HP1P3P5P7P9P13P14P17m4. try clear HP1P3P5P7P9P13P14P17m3. try clear HP1P3P5P7P9P13P14P17m2. try clear HP1P3P5P7P9P13P14P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP7P9P13P14P17M3 : rk(P7 :: P9 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9Mtmp : rk(P9 :: nil) <= 1) by (solve_hyps_max HP9eq HP9M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P9 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P9 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P9 :: P7 :: P13 :: P14 :: P17 :: nil) ((P9 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P9 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP9Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P9P13P14P17m2 : rk(P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P5P7P9P13P14P17eq : rk(P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP3P5P7P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P7P9P13P14P17mtmp : rk(P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP3P5P7P9P13P14P17eq HP3P5P7P9P13P14P17m3).
	try assert(HP9eq : rk(P9 :: nil) = 1) by (apply LP9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP9mtmp : rk(P9 :: nil) >= 1) by (solve_hyps_min HP9eq HP9m1).
	assert(Hincl : incl (P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P3 :: P5 :: P9 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P7P9P13P14P17mtmp;try rewrite HT2 in HP3P5P7P9P13P14P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P9 :: nil) 3 1 2 HP3P5P7P9P13P14P17mtmp HP9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP9M1. try clear HP9M2. try clear HP9M3. try clear HP9m4. try clear HP9m3. try clear HP9m2. try clear HP9m1. try clear HP3P5P7P9P13P14P17M1. try clear HP3P5P7P9P13P14P17M2. try clear HP3P5P7P9P13P14P17M3. try clear HP3P5P7P9P13P14P17m4. try clear HP3P5P7P9P13P14P17m3. try clear HP3P5P7P9P13P14P17m2. try clear HP3P5P7P9P13P14P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P9P13P14P17m3 : rk(P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP2P8P13eq : rk(P2 :: P8 :: P13 :: nil) = 2) by (apply LP2P8P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP2P8P13Mtmp : rk(P2 :: P8 :: P13 :: nil) <= 2) by (solve_hyps_max HP2P8P13eq HP2P8P13M2).
	try assert(HP2P7P8P9P13P14P17eq : rk(P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P7P8P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P8P9P13P14P17mtmp : rk(P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P7P8P9P13P14P17eq HP2P7P8P9P13P14P17m4).
	try assert(HP13eq : rk(P13 :: nil) = 1) by (apply LP13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP13mtmp : rk(P13 :: nil) >= 1) by (solve_hyps_min HP13eq HP13m1).
	assert(Hincl : incl (P13 :: nil) (list_inter (P2 :: P8 :: P13 :: nil) (P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P8 :: P9 :: P13 :: P14 :: P17 :: nil) (P2 :: P8 :: P13 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P13 :: P7 :: P9 :: P13 :: P14 :: P17 :: nil) ((P2 :: P8 :: P13 :: nil) ++ (P7 :: P9 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P8P9P13P14P17mtmp;try rewrite HT2 in HP2P7P8P9P13P14P17mtmp.
	assert(HT := rule_4 (P2 :: P8 :: P13 :: nil) (P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P13 :: nil) 4 1 2 HP2P7P8P9P13P14P17mtmp HP13mtmp HP2P8P13Mtmp Hincl); apply HT.
}
try clear HP2P8P13M1. try clear HP2P8P13M2. try clear HP2P8P13M3. try clear HP2P8P13m4. try clear HP2P8P13m3. try clear HP2P8P13m2. try clear HP2P8P13m1. try clear HP13M1. try clear HP13M2. try clear HP13M3. try clear HP13m4. try clear HP13m3. try clear HP13m2. try clear HP13m1. try clear HP2P7P8P9P13P14P17M1. try clear HP2P7P8P9P13P14P17M2. try clear HP2P7P8P9P13P14P17M3. try clear HP2P7P8P9P13P14P17m4. try clear HP2P7P8P9P13P14P17m3. try clear HP2P7P8P9P13P14P17m2. try clear HP2P7P8P9P13P14P17m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP9P17m2 : rk(P9 :: P17 :: nil) >= 2).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7P9P13P14P17eq : rk(P7 :: P9 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP7P9P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P9P13P14P17mtmp : rk(P7 :: P9 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP7P9P13P14P17eq HP7P9P13P14P17m3).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P9 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P9 :: P13 :: P14 :: P17 :: nil) (P9 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P9 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P9 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP7P9P13P14P17mtmp;try rewrite HT2 in HP7P9P13P14P17mtmp.
	assert(HT := rule_2 (P9 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 3 1 2 HP7P9P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP7P9P13P14P17M1. try clear HP7P9P13P14P17M2. try clear HP7P9P13P14P17M3. try clear HP7P9P13P14P17m4. try clear HP7P9P13P14P17m3. try clear HP7P9P13P14P17m2. try clear HP7P9P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P6P8P17m2 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P6P8P17m3 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P6P8P17m4 : rk(P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P13P14P17m2 : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P13P14P17m3 : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P13P14P17m4 : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P13mtmp : rk(P1 :: P2 :: P6 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P6P13eq HP1P2P6P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P13 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P13 :: nil) (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P2P6P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P13M1. try clear HP1P2P6P13M2. try clear HP1P2P6P13M3. try clear HP1P2P6P13m4. try clear HP1P2P6P13m3. try clear HP1P2P6P13m2. try clear HP1P2P6P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P6P15P16P17m2 : rk(P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P6P15P16P17m3 : rk(P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP1P4P6mtmp : rk(P1 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P4P6eq HP1P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P6 :: nil) (P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 3 3 HP1P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P6M1. try clear HP1P4P6M2. try clear HP1P4P6M3. try clear HP1P4P6m4. try clear HP1P4P6m3. try clear HP1P4P6m2. try clear HP1P4P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP1P4P6P15P16P17m4 : rk(P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP1P4P6P15eq : rk(P1 :: P4 :: P6 :: P15 :: nil) = 4) by (apply LP1P4P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP1P4P6P15M1. try clear HP1P4P6P15M2. try clear HP1P4P6P15M3. try clear HP1P4P6P15m4. try clear HP1P4P6P15m3. try clear HP1P4P6P15m2. try clear HP1P4P6P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P17m2 : rk(P1 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P17 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P17m3 : rk(P1 :: P6 :: P17 :: nil) >= 3).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP1P4P6P15P16P17eq : rk(P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP1P4P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P6P15P16P17mtmp : rk(P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P6P15P16P17eq HP1P4P6P15P16P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P1 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) (P1 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P1 :: P6 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P6P15P16P17mtmp;try rewrite HT2 in HP1P4P6P15P16P17mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P17 :: nil) 4 1 2 HP1P4P6P15P16P17mtmp HP17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP1P4P6P15P16P17M1. try clear HP1P4P6P15P16P17M2. try clear HP1P4P6P15P16P17M3. try clear HP1P4P6P15P16P17m4. try clear HP1P4P6P15P16P17m3. try clear HP1P4P6P15P16P17m2. try clear HP1P4P6P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P7P13P14P17m2 : rk(P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P7P13P14P17M3 : rk(P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7mtmp : rk(P7 :: nil) >= 1) by (solve_hyps_min HP7eq HP7m1).
	assert(Hincl : incl (P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P7 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P6 :: P7 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: nil) 2 2 1 HP1P6P7Mtmp HP7P13P14P17Mtmp HP7mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P7P13P14P17m3 : rk(P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P6P13mtmp : rk(P1 :: P6 :: P13 :: nil) >= 3) by (solve_hyps_min HP1P6P13eq HP1P6P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: P13 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: P13 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P6P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6P13M1. try clear HP1P6P13M2. try clear HP1P6P13M3. try clear HP1P6P13m4. try clear HP1P6P13m3. try clear HP1P6P13m2. try clear HP1P6P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P17m2 : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P17m3 : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P17m4 : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP1P6P7P13P14P17eq : rk(P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P6P7P13P14P17Mtmp : rk(P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P6P7P13P14P17eq HP1P6P7P13P14P17M3).
	try assert(HP1P2P6P7P13P14P17eq : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P2P6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P13P14P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P13P14P17eq HP1P2P6P7P13P14P17m4).
	try assert(HP1P6P17eq : rk(P1 :: P6 :: P17 :: nil) = 3) by (apply LP1P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P6P17mtmp : rk(P1 :: P6 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P6P17eq HP1P6P17m3).
	assert(Hincl : incl (P1 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P6 :: P17 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P2 :: P6 :: P17 :: P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P6 :: P17 :: P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P2 :: P6 :: P17 :: nil) ++ (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P13P14P17mtmp;try rewrite HT2 in HP1P2P6P7P13P14P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P6 :: P17 :: nil) (P1 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P17 :: nil) 4 3 3 HP1P2P6P7P13P14P17mtmp HP1P6P17mtmp HP1P6P7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP1P6P7P13P14P17M1. try clear HP1P6P7P13P14P17M2. try clear HP1P6P7P13P14P17M3. try clear HP1P6P7P13P14P17m4. try clear HP1P6P7P13P14P17m3. try clear HP1P6P7P13P14P17m2. try clear HP1P6P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P17m2 : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P17m3 : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P8P17m4 : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P6P17m2 : rk(P1 :: P2 :: P3 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P6 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P6P17m3 : rk(P1 :: P2 :: P3 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P6 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P6P17m4 : rk(P1 :: P2 :: P3 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P6P8P17eq : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P8P17Mtmp : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P6P8P17eq HP1P2P6P8P17M4).
	try assert(HP1P2P3P6P8P17eq : rk(P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P3P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P6P8P17mtmp : rk(P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P8P17eq HP1P2P3P6P8P17m4).
	try assert(HP1P2P6P17eq : rk(P1 :: P2 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P17mtmp : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P17eq HP1P2P6P17m4).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P3 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil) ((P1 :: P2 :: P3 :: P6 :: P17 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P6P8P17mtmp;try rewrite HT2 in HP1P2P3P6P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 4 4 4 HP1P2P3P6P8P17mtmp HP1P2P6P17mtmp HP1P2P6P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P3P6P8P17M1. try clear HP1P2P3P6P8P17M2. try clear HP1P2P3P6P8P17M3. try clear HP1P2P3P6P8P17m4. try clear HP1P2P3P6P8P17m3. try clear HP1P2P3P6P8P17m2. try clear HP1P2P3P6P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P9P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P9P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P6P9P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P6P17mtmp : rk(P1 :: P2 :: P3 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P17eq HP1P2P3P6P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) 4 4 HP1P2P3P6P17mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P15P16P17m2 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P15P16P17m3 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P6P15P16P17m4 : rk(P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP2P4P6P15eq : rk(P2 :: P4 :: P6 :: P15 :: nil) = 4) by (apply LP2P4P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP2P4P6P15M1. try clear HP2P4P6P15M2. try clear HP2P4P6P15M3. try clear HP2P4P6P15m4. try clear HP2P4P6P15m3. try clear HP2P4P6P15m2. try clear HP2P4P6P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P17m2 : rk(P2 :: P4 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P6 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P6P17m3 : rk(P2 :: P4 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP2P4P6mtmp : rk(P2 :: P4 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P4P6eq HP2P4P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P6 :: nil) (P2 :: P4 :: P6 :: P17 :: nil) 3 3 HP2P4P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P6M1. try clear HP2P4P6M2. try clear HP2P4P6M3. try clear HP2P4P6m4. try clear HP2P4P6m3. try clear HP2P4P6m2. try clear HP2P4P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P6P17m4 : rk(P2 :: P4 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP2P4P6P15P16P17eq : rk(P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P4P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P6P15P16P17mtmp : rk(P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P6P15P16P17eq HP2P4P6P15P16P17m4).
	try assert(HP4P17eq : rk(P4 :: P17 :: nil) = 2) by (apply LP4P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P17mtmp : rk(P4 :: P17 :: nil) >= 2) by (solve_hyps_min HP4P17eq HP4P17m2).
	assert(Hincl : incl (P4 :: P17 :: nil) (list_inter (P2 :: P4 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) (P2 :: P4 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P6 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P2 :: P4 :: P6 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P6P15P16P17mtmp;try rewrite HT2 in HP2P4P6P15P16P17mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P6 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: P17 :: nil) 4 2 2 HP2P4P6P15P16P17mtmp HP4P17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP2P4P6P15P16P17M1. try clear HP2P4P6P15P16P17M2. try clear HP2P4P6P15P16P17M3. try clear HP2P4P6P15P16P17m4. try clear HP2P4P6P15P16P17m3. try clear HP2P4P6P15P16P17m2. try clear HP2P4P6P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P6P8P17m2 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P6P8P17m3 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P6P8P17m4 : rk(P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P6P17m2 : rk(P1 :: P2 :: P4 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P6P17m3 : rk(P1 :: P2 :: P4 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P6P17m4 : rk(P1 :: P2 :: P4 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P6P8P17eq : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P8P17Mtmp : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P6P8P17eq HP1P2P6P8P17M4).
	try assert(HP1P2P4P6P8P17eq : rk(P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P4P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P6P8P17mtmp : rk(P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P4P6P8P17eq HP1P2P4P6P8P17m4).
	try assert(HP1P2P6P17eq : rk(P1 :: P2 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P17mtmp : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P17eq HP1P2P6P17m4).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil) ((P1 :: P2 :: P4 :: P6 :: P17 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P6P8P17mtmp;try rewrite HT2 in HP1P2P4P6P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 4 4 4 HP1P2P4P6P8P17mtmp HP1P2P6P17mtmp HP1P2P6P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P4P6P8P17M1. try clear HP1P2P4P6P8P17M2. try clear HP1P2P4P6P8P17M3. try clear HP1P2P4P6P8P17m4. try clear HP1P2P4P6P8P17m3. try clear HP1P2P4P6P8P17m2. try clear HP1P2P4P6P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P9P17m2 : rk(P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P9P17m3 : rk(P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P6P9P17m4 : rk(P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P6P17eq : rk(P1 :: P2 :: P4 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P4P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P6P17Mtmp : rk(P1 :: P2 :: P4 :: P6 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P6P17eq HP1P2P4P6P17M4).
	try assert(HP1P2P3P4P6P9P17eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) = 4) by (apply LP1P2P3P4P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P6P9P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P9P17eq HP1P2P3P4P6P9P17m4).
	try assert(HP2P4P6P17eq : rk(P2 :: P4 :: P6 :: P17 :: nil) = 4) by (apply LP2P4P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P6P17mtmp : rk(P2 :: P4 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P6P17eq HP2P4P6P17m4).
	assert(Hincl : incl (P2 :: P4 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P6 :: P17 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) (P1 :: P2 :: P4 :: P6 :: P17 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P6 :: P17 :: P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) ((P1 :: P2 :: P4 :: P6 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P9P17mtmp;try rewrite HT2 in HP1P2P3P4P6P9P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P6 :: P17 :: nil) (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) (P2 :: P4 :: P6 :: P17 :: nil) 4 4 4 HP1P2P3P4P6P9P17mtmp HP2P4P6P17mtmp HP1P2P4P6P17Mtmp Hincl); apply HT.
}
try clear HP1P2P4P6P17M1. try clear HP1P2P4P6P17M2. try clear HP1P2P4P6P17M3. try clear HP1P2P4P6P17m4. try clear HP1P2P4P6P17m3. try clear HP1P2P4P6P17m2. try clear HP1P2P4P6P17m1. try clear HP2P4P6P17M1. try clear HP2P4P6P17M2. try clear HP2P4P6P17M3. try clear HP2P4P6P17m4. try clear HP2P4P6P17m3. try clear HP2P4P6P17m2. try clear HP2P4P6P17m1. try clear HP1P2P3P4P6P9P17M1. try clear HP1P2P3P4P6P9P17M2. try clear HP1P2P3P4P6P9P17M3. try clear HP1P2P3P4P6P9P17m4. try clear HP1P2P3P4P6P9P17m3. try clear HP1P2P3P4P6P9P17m2. try clear HP1P2P3P4P6P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P7P13P14P17m2 : rk(P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P13P14P17m3 : rk(P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P13P14P17eq : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P2P6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P13P14P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P13P14P17eq HP1P2P6P7P13P14P17m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P13P14P17mtmp;try rewrite HT2 in HP1P2P6P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P13P14P17mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P13P14P17m4 : rk(P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP1P6P7P13eq : rk(P1 :: P6 :: P7 :: P13 :: nil) = 3) by (apply LP1P6P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P6P7P13Mtmp : rk(P1 :: P6 :: P7 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P6P7P13eq HP1P6P7P13M3).
	try assert(HP1P2P6P7P13P14P17eq : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P2P6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P13P14P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P13P14P17eq HP1P2P6P7P13P14P17m4).
	try assert(HP6P7P13eq : rk(P6 :: P7 :: P13 :: nil) = 3) by (apply LP6P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP6P7P13mtmp : rk(P6 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP6P7P13eq HP6P7P13m3).
	assert(Hincl : incl (P6 :: P7 :: P13 :: nil) (list_inter (P1 :: P6 :: P7 :: P13 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P6 :: P7 :: P13 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P13 :: P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P6 :: P7 :: P13 :: nil) ++ (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P13P14P17mtmp;try rewrite HT2 in HP1P2P6P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: P13 :: nil) (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: P13 :: nil) 4 3 3 HP1P2P6P7P13P14P17mtmp HP6P7P13mtmp HP1P6P7P13Mtmp Hincl); apply HT.
}
try clear HP1P6P7P13M1. try clear HP1P6P7P13M2. try clear HP1P6P7P13M3. try clear HP1P6P7P13m4. try clear HP1P6P7P13m3. try clear HP1P6P7P13m2. try clear HP1P6P7P13m1. try clear HP1P2P6P7P13P14P17M1. try clear HP1P2P6P7P13P14P17M2. try clear HP1P2P6P7P13P14P17M3. try clear HP1P2P6P7P13P14P17m4. try clear HP1P2P6P7P13P14P17m3. try clear HP1P2P6P7P13P14P17m2. try clear HP1P2P6P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P17m2 : rk(P2 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P17 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P6P17m3 : rk(P2 :: P6 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP2P6P7P13P14P17eq : rk(P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P7P13P14P17mtmp : rk(P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P6P7P13P14P17eq HP2P6P7P13P14P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P2 :: P6 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P6 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P6 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P13P14P17mtmp;try rewrite HT2 in HP2P6P7P13P14P17mtmp.
	assert(HT := rule_2 (P2 :: P6 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 4 1 2 HP2P6P7P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP2P6P7P13P14P17M1. try clear HP2P6P7P13P14P17M2. try clear HP2P6P7P13P14P17M3. try clear HP2P6P7P13P14P17m4. try clear HP2P6P7P13P14P17m3. try clear HP2P6P7P13P14P17m2. try clear HP2P6P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P8P17m2 : rk(P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P8P17m3 : rk(P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P8P17m4 : rk(P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P6P8mtmp : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P6P8eq HP2P3P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 4 4 HP2P3P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P15P16P17m2 : rk(P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P15P16P17m3 : rk(P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P6P15P16P17m4 : rk(P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P6P15eq : rk(P2 :: P3 :: P6 :: P15 :: nil) = 4) by (apply LP2P3P6P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP2P3P6P15M1. try clear HP2P3P6P15M2. try clear HP2P3P6P15M3. try clear HP2P3P6P15m4. try clear HP2P3P6P15m3. try clear HP2P3P6P15m2. try clear HP2P3P6P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P13P14P17m2 : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P13P14P17m3 : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P13P14P17m4 : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP2P3P7P13mtmp : rk(P2 :: P3 :: P7 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P3P7P13eq HP2P3P7P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: P13 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: P13 :: nil) (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP2P3P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P7P13M1. try clear HP2P3P7P13M2. try clear HP2P3P7P13M3. try clear HP2P3P7P13m4. try clear HP2P3P7P13m3. try clear HP2P3P7P13m2. try clear HP2P3P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P17m2 : rk(P2 :: P3 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P17m3 : rk(P2 :: P3 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP2P3P7P13P14P17eq : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P3P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P7P13P14P17mtmp : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P7P13P14P17eq HP2P3P7P13P14P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P2 :: P3 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P3 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P3 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P7P13P14P17mtmp;try rewrite HT2 in HP2P3P7P13P14P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 4 1 2 HP2P3P7P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P15P16P17m2 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P3P4P15P16P17M3 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) <= 3).
{
	try assert(HP2P3P4eq : rk(P2 :: P3 :: P4 :: nil) = 2) by (apply LP2P3P4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P3P4Mtmp : rk(P2 :: P3 :: P4 :: nil) <= 2) by (solve_hyps_max HP2P3P4eq HP2P3P4M2).
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP4eq : rk(P4 :: nil) = 1) by (apply LP4 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP4mtmp : rk(P4 :: nil) >= 1) by (solve_hyps_min HP4eq HP4m1).
	assert(Hincl : incl (P4 :: nil) (list_inter (P2 :: P3 :: P4 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) (P2 :: P3 :: P4 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P4 :: P15 :: P16 :: P17 :: nil) ((P2 :: P3 :: P4 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P3 :: P4 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: nil) 2 2 1 HP2P3P4Mtmp HP4P15P16P17Mtmp HP4mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2P3P4M1. try clear HP2P3P4M2. try clear HP2P3P4M3. try clear HP2P3P4m4. try clear HP2P3P4m3. try clear HP2P3P4m2. try clear HP2P3P4m1. try clear HP4M1. try clear HP4M2. try clear HP4M3. try clear HP4m4. try clear HP4m3. try clear HP4m2. try clear HP4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P15P16P17m3 : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP2P3P15eq : rk(P2 :: P3 :: P15 :: nil) = 3) by (apply LP2P3P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP2P3P15M1. try clear HP2P3P15M2. try clear HP2P3P15M3. try clear HP2P3P15m4. try clear HP2P3P15m3. try clear HP2P3P15m2. try clear HP2P3P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P17m2 : rk(P2 :: P3 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P17m3 : rk(P2 :: P3 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P6P17m4 : rk(P2 :: P3 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P4P15P16P17eq : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP2P3P4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P15P16P17Mtmp : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P3P4P15P16P17eq HP2P3P4P15P16P17M3).
	try assert(HP2P3P4P6P15P16P17eq : rk(P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P3P4P6P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P6P15P16P17mtmp : rk(P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P6P15P16P17eq HP2P3P4P6P15P16P17m4).
	try assert(HP2P3P17eq : rk(P2 :: P3 :: P17 :: nil) = 3) by (apply LP2P3P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P17mtmp : rk(P2 :: P3 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P3P17eq HP2P3P17m3).
	assert(Hincl : incl (P2 :: P3 :: P17 :: nil) (list_inter (P2 :: P3 :: P6 :: P17 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P6 :: P15 :: P16 :: P17 :: nil) (P2 :: P3 :: P6 :: P17 :: P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P6 :: P17 :: P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) ((P2 :: P3 :: P6 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P6P15P16P17mtmp;try rewrite HT2 in HP2P3P4P6P15P16P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P6 :: P17 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) (P2 :: P3 :: P17 :: nil) 4 3 3 HP2P3P4P6P15P16P17mtmp HP2P3P17mtmp HP2P3P4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP2P3P4P6P15P16P17M1. try clear HP2P3P4P6P15P16P17M2. try clear HP2P3P4P6P15P16P17M3. try clear HP2P3P4P6P15P16P17m4. try clear HP2P3P4P6P15P16P17m3. try clear HP2P3P4P6P15P16P17m2. try clear HP2P3P4P6P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P8P17m2 : rk(P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P8P17m3 : rk(P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P6P8P17m4 : rk(P2 :: P3 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P6P8mtmp : rk(P2 :: P3 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P6P8eq HP2P3P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: P8 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil) 4 4 HP2P3P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6P8M1. try clear HP2P3P6P8M2. try clear HP2P3P6P8M3. try clear HP2P3P6P8m4. try clear HP2P3P6P8m3. try clear HP2P3P6P8m2. try clear HP2P3P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P17m2 : rk(P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P6P17m3 : rk(P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP2P3P6mtmp : rk(P2 :: P3 :: P6 :: nil) >= 3) by (solve_hyps_min HP2P3P6eq HP2P3P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P6 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: nil) 3 3 HP2P3P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P6M1. try clear HP2P3P6M2. try clear HP2P3P6M3. try clear HP2P3P6m4. try clear HP2P3P6m3. try clear HP2P3P6m2. try clear HP2P3P6m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P6P17m4 : rk(P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P6P8P17eq : rk(P2 :: P3 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P6P8P17Mtmp : rk(P2 :: P3 :: P6 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P6P8P17eq HP2P3P6P8P17M4).
	try assert(HP2P3P4P6P8P17eq : rk(P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P4P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P6P8P17mtmp : rk(P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P6P8P17eq HP2P3P4P6P8P17m4).
	try assert(HP2P3P6P17eq : rk(P2 :: P3 :: P6 :: P17 :: nil) = 4) by (apply LP2P3P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P6P17mtmp : rk(P2 :: P3 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P6P17eq HP2P3P6P17m4).
	assert(Hincl : incl (P2 :: P3 :: P6 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P6 :: P17 :: P2 :: P3 :: P6 :: P8 :: P17 :: nil) ((P2 :: P3 :: P4 :: P6 :: P17 :: nil) ++ (P2 :: P3 :: P6 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P6P8P17mtmp;try rewrite HT2 in HP2P3P4P6P8P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P2 :: P3 :: P6 :: P8 :: P17 :: nil) (P2 :: P3 :: P6 :: P17 :: nil) 4 4 4 HP2P3P4P6P8P17mtmp HP2P3P6P17mtmp HP2P3P6P8P17Mtmp Hincl);apply HT.
}
try clear HP2P3P6P8P17M1. try clear HP2P3P6P8P17M2. try clear HP2P3P6P8P17M3. try clear HP2P3P6P8P17m4. try clear HP2P3P6P8P17m3. try clear HP2P3P6P8P17m2. try clear HP2P3P6P8P17m1. try clear HP2P3P6P17M1. try clear HP2P3P6P17M2. try clear HP2P3P6P17M3. try clear HP2P3P6P17m4. try clear HP2P3P6P17m3. try clear HP2P3P6P17m2. try clear HP2P3P6P17m1. try clear HP2P3P4P6P8P17M1. try clear HP2P3P4P6P8P17M2. try clear HP2P3P4P6P8P17M3. try clear HP2P3P4P6P8P17m4. try clear HP2P3P4P6P8P17m3. try clear HP2P3P4P6P8P17m2. try clear HP2P3P4P6P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P9P17m2 : rk(P2 :: P6 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P9 :: P17 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P6P9P17M3 : rk(P2 :: P6 :: P9 :: P17 :: nil) <= 3).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P6 :: P9 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P9 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P17 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P6 :: P9 :: nil) (P17 :: nil) (nil) 2 1 0 HP2P6P9Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P9P17m3 : rk(P2 :: P6 :: P9 :: P17 :: nil) >= 3).
{
	try assert(HP2P3P4P6P17eq : rk(P2 :: P3 :: P4 :: P6 :: P17 :: nil) = 4) by (apply LP2P3P4P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P6P17Mtmp : rk(P2 :: P3 :: P4 :: P6 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P4P6P17eq HP2P3P4P6P17M4).
	try assert(HP2P3P4P6P9P17eq : rk(P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) = 4) by (apply LP2P3P4P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P6P9P17mtmp : rk(P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P6P9P17eq HP2P3P4P6P9P17m4).
	try assert(HP2P6P17eq : rk(P2 :: P6 :: P17 :: nil) = 3) by (apply LP2P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P17mtmp : rk(P2 :: P6 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P6P17eq HP2P6P17m3).
	assert(Hincl : incl (P2 :: P6 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P6 :: P9 :: P17 :: nil) (P2 :: P3 :: P4 :: P6 :: P17 :: P2 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P6 :: P17 :: P2 :: P6 :: P9 :: P17 :: nil) ((P2 :: P3 :: P4 :: P6 :: P17 :: nil) ++ (P2 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P6P9P17mtmp;try rewrite HT2 in HP2P3P4P6P9P17mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: nil) (P2 :: P6 :: P17 :: nil) 4 3 4 HP2P3P4P6P9P17mtmp HP2P6P17mtmp HP2P3P4P6P17Mtmp Hincl); apply HT.
}
try clear HP2P3P4P6P17M1. try clear HP2P3P4P6P17M2. try clear HP2P3P4P6P17M3. try clear HP2P3P4P6P17m4. try clear HP2P3P4P6P17m3. try clear HP2P3P4P6P17m2. try clear HP2P3P4P6P17m1. try clear HP2P6P17M1. try clear HP2P6P17M2. try clear HP2P6P17M3. try clear HP2P6P17m4. try clear HP2P6P17m3. try clear HP2P6P17m2. try clear HP2P6P17m1. try clear HP2P3P4P6P9P17M1. try clear HP2P3P4P6P9P17M2. try clear HP2P3P4P6P9P17M3. try clear HP2P3P4P6P9P17m4. try clear HP2P3P4P6P9P17m3. try clear HP2P3P4P6P9P17m2. try clear HP2P3P4P6P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP5P9P17m2 : rk(P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P5 :: P9 :: nil) (P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P5 :: P9 :: nil) (P5 :: P9 :: P17 :: nil) 2 2 HP5P9mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP5P9P17m3 : rk(P5 :: P9 :: P17 :: nil) >= 3).
{
	try assert(HP2P6P9P17eq : rk(P2 :: P6 :: P9 :: P17 :: nil) = 3) by (apply LP2P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P9P17Mtmp : rk(P2 :: P6 :: P9 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P6P9P17eq HP2P6P9P17M3).
	try assert(HP2P5P6P9P17eq : rk(P2 :: P5 :: P6 :: P9 :: P17 :: nil) = 4) by (apply LP2P5P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P5P6P9P17mtmp : rk(P2 :: P5 :: P6 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P5P6P9P17eq HP2P5P6P9P17m4).
	try assert(HP9P17eq : rk(P9 :: P17 :: nil) = 2) by (apply LP9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP9P17mtmp : rk(P9 :: P17 :: nil) >= 2) by (solve_hyps_min HP9P17eq HP9P17m2).
	assert(Hincl : incl (P9 :: P17 :: nil) (list_inter (P5 :: P9 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P5 :: P6 :: P9 :: P17 :: nil) (P5 :: P9 :: P17 :: P2 :: P6 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P5 :: P9 :: P17 :: P2 :: P6 :: P9 :: P17 :: nil) ((P5 :: P9 :: P17 :: nil) ++ (P2 :: P6 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P5P6P9P17mtmp;try rewrite HT2 in HP2P5P6P9P17mtmp.
	assert(HT := rule_2 (P5 :: P9 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: nil) (P9 :: P17 :: nil) 4 2 3 HP2P5P6P9P17mtmp HP9P17mtmp HP2P6P9P17Mtmp Hincl);apply HT.
}
try clear HP2P5P6P9P17M1. try clear HP2P5P6P9P17M2. try clear HP2P5P6P9P17M3. try clear HP2P5P6P9P17m4. try clear HP2P5P6P9P17m3. try clear HP2P5P6P9P17m2. try clear HP2P5P6P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P9P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P9P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P5P9P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P5P17mtmp : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P17eq HP1P2P3P5P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 4 4 HP1P2P3P5P17mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P9P17m2 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P9P17m3 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P9P17m4 : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P5P17eq : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P17Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P5P17eq HP1P2P4P5P17M4).
	try assert(HP1P2P3P4P5P9P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P9P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P9P17eq HP1P2P3P4P5P9P17m4).
	try assert(HP1P4P5P17eq : rk(P1 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P17mtmp : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P17eq HP1P4P5P17m4).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P9P17mtmp;try rewrite HT2 in HP1P2P3P4P5P9P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P1 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P9P17mtmp HP1P4P5P17mtmp HP1P2P4P5P17Mtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P7P13P14P17m2 : rk(P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P13P14P17m3 : rk(P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P3P5P7P13P14P17eq : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P3P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P7P13P14P17mtmp : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P3P5P7P13P14P17eq HP1P3P5P7P13P14P17m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P13P14P17mtmp;try rewrite HT2 in HP1P3P5P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P3P5P7P13P14P17mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P7P13P14P17m4 : rk(P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13eq : rk(P1 :: P5 :: P7 :: P13 :: nil) = 3) by (apply LP1P5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P7P13Mtmp : rk(P1 :: P5 :: P7 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13eq HP1P5P7P13M3).
	try assert(HP1P3P5P7P13P14P17eq : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P3P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P5P7P13P14P17mtmp : rk(P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P5P7P13P14P17eq HP1P3P5P7P13P14P17m4).
	try assert(HP5P7P13eq : rk(P5 :: P7 :: P13 :: nil) = 3) by (apply LP5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP5P7P13mtmp : rk(P5 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP5P7P13eq HP5P7P13m3).
	assert(Hincl : incl (P5 :: P7 :: P13 :: nil) (list_inter (P1 :: P5 :: P7 :: P13 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P13 :: P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: P13 :: nil) ++ (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P5P7P13P14P17mtmp;try rewrite HT2 in HP1P3P5P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P13 :: nil) (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: P13 :: nil) 4 3 3 HP1P3P5P7P13P14P17mtmp HP5P7P13mtmp HP1P5P7P13Mtmp Hincl); apply HT.
}
try clear HP1P3P5P7P13P14P17M1. try clear HP1P3P5P7P13P14P17M2. try clear HP1P3P5P7P13P14P17M3. try clear HP1P3P5P7P13P14P17m4. try clear HP1P3P5P7P13P14P17m3. try clear HP1P3P5P7P13P14P17m2. try clear HP1P3P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P17m2 : rk(P3 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P17 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP3P5P17m3 : rk(P3 :: P5 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP3P5P7P13P14P17eq : rk(P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP3P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P7P13P14P17mtmp : rk(P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P5P7P13P14P17eq HP3P5P7P13P14P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P3 :: P5 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P3 :: P5 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P3 :: P5 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P5P7P13P14P17mtmp;try rewrite HT2 in HP3P5P7P13P14P17mtmp.
	assert(HT := rule_2 (P3 :: P5 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 4 1 2 HP3P5P7P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP3P5P7P13P14P17M1. try clear HP3P5P7P13P14P17M2. try clear HP3P5P7P13P14P17M3. try clear HP3P5P7P13P14P17m4. try clear HP3P5P7P13P14P17m3. try clear HP3P5P7P13P14P17m2. try clear HP3P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP3P5P9P17m2 : rk(P3 :: P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP3P5mtmp : rk(P3 :: P5 :: nil) >= 2) by (solve_hyps_min HP3P5eq HP3P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P3 :: P5 :: nil) (P3 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P3 :: P5 :: nil) (P3 :: P5 :: P9 :: P17 :: nil) 2 2 HP3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP3P5M1. try clear HP3P5M2. try clear HP3P5M3. try clear HP3P5m4. try clear HP3P5m3. try clear HP3P5m2. try clear HP3P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP3P5P9P17M3 : rk(P3 :: P5 :: P9 :: P17 :: nil) <= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P3 :: P5 :: P9 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P5 :: P9 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P17 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P3 :: P5 :: P9 :: nil) (P17 :: nil) (nil) 2 1 0 HP3P5P9Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP3P5P9P17m3 : rk(P3 :: P5 :: P9 :: P17 :: nil) >= 3).
{
	try assert(HP1P3P4P5P17eq : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P17Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P3P4P5P17eq HP1P3P4P5P17M4).
	try assert(HP1P3P4P5P9P17eq : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) = 4) by (apply LP1P3P4P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P9P17mtmp : rk(P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P9P17eq HP1P3P4P5P9P17m4).
	try assert(HP3P5P17eq : rk(P3 :: P5 :: P17 :: nil) = 3) by (apply LP3P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P17mtmp : rk(P3 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP3P5P17eq HP3P5P17m3).
	assert(Hincl : incl (P3 :: P5 :: P17 :: nil) (list_inter (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: P3 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P5 :: P17 :: P3 :: P5 :: P9 :: P17 :: nil) ((P1 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P3 :: P5 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P9P17mtmp;try rewrite HT2 in HP1P3P4P5P9P17mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: nil) (P3 :: P5 :: P17 :: nil) 4 3 4 HP1P3P4P5P9P17mtmp HP3P5P17mtmp HP1P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP3P5P17M1. try clear HP3P5P17M2. try clear HP3P5P17M3. try clear HP3P5P17m4. try clear HP3P5P17m3. try clear HP3P5P17m2. try clear HP3P5P17m1. try clear HP1P3P4P5P9P17M1. try clear HP1P3P4P5P9P17M2. try clear HP1P3P4P5P9P17M3. try clear HP1P3P4P5P9P17m4. try clear HP1P3P4P5P9P17m3. try clear HP1P3P4P5P9P17m2. try clear HP1P3P4P5P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P9P10P11P17m2 : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P9P10P11P17m3 : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	try assert(HP3P5P9eq : rk(P3 :: P5 :: P9 :: nil) = 2) by (apply LP3P5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP3P5P9Mtmp : rk(P3 :: P5 :: P9 :: nil) <= 2) by (solve_hyps_max HP3P5P9eq HP3P5P9M2).
	try assert(HP3P4P5P9P10P11P17eq : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP3P4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P9P10P11P17mtmp : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3) by (solve_hyps_min HP3P4P5P9P10P11P17eq HP3P4P5P9P10P11P17m3).
	try assert(HP5P9eq : rk(P5 :: P9 :: nil) = 2) by (apply LP5P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP5P9mtmp : rk(P5 :: P9 :: nil) >= 2) by (solve_hyps_min HP5P9eq HP5P9m2).
	assert(Hincl : incl (P5 :: P9 :: nil) (list_inter (P3 :: P5 :: P9 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P3 :: P5 :: P9 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) ((P3 :: P5 :: P9 :: nil) ++ (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P9P10P11P17mtmp;try rewrite HT2 in HP3P4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P5 :: P9 :: nil) 3 2 2 HP3P4P5P9P10P11P17mtmp HP5P9mtmp HP3P5P9Mtmp Hincl); apply HT.
}
try clear HP3P5P9M1. try clear HP3P5P9M2. try clear HP3P5P9M3. try clear HP3P5P9m4. try clear HP3P5P9m3. try clear HP3P5P9m2. try clear HP3P5P9m1. try clear HP5P9M1. try clear HP5P9M2. try clear HP5P9M3. try clear HP5P9m4. try clear HP5P9m3. try clear HP5P9m2. try clear HP5P9m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P9P10P11P17m4 : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP3P5P9P17eq : rk(P3 :: P5 :: P9 :: P17 :: nil) = 3) by (apply LP3P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P9P17Mtmp : rk(P3 :: P5 :: P9 :: P17 :: nil) <= 3) by (solve_hyps_max HP3P5P9P17eq HP3P5P9P17M3).
	try assert(HP3P4P5P9P10P11P17eq : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP3P4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P4P5P9P10P11P17mtmp : rk(P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP3P4P5P9P10P11P17eq HP3P4P5P9P10P11P17m4).
	try assert(HP5P9P17eq : rk(P5 :: P9 :: P17 :: nil) = 3) by (apply LP5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP5P9P17mtmp : rk(P5 :: P9 :: P17 :: nil) >= 3) by (solve_hyps_min HP5P9P17eq HP5P9P17m3).
	assert(Hincl : incl (P5 :: P9 :: P17 :: nil) (list_inter (P3 :: P5 :: P9 :: P17 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P3 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P3 :: P5 :: P9 :: P17 :: P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) ((P3 :: P5 :: P9 :: P17 :: nil) ++ (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP3P4P5P9P10P11P17mtmp;try rewrite HT2 in HP3P4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P3 :: P5 :: P9 :: P17 :: nil) (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P5 :: P9 :: P17 :: nil) 4 3 3 HP3P4P5P9P10P11P17mtmp HP5P9P17mtmp HP3P5P9P17Mtmp Hincl); apply HT.
}
try clear HP5P9P17M1. try clear HP5P9P17M2. try clear HP5P9P17M3. try clear HP5P9P17m4. try clear HP5P9P17m3. try clear HP5P9P17m2. try clear HP5P9P17m1. try clear HP3P4P5P9P10P11P17M1. try clear HP3P4P5P9P10P11P17M2. try clear HP3P4P5P9P10P11P17M3. try clear HP3P4P5P9P10P11P17m4. try clear HP3P4P5P9P10P11P17m3. try clear HP3P4P5P9P10P11P17m2. try clear HP3P4P5P9P10P11P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P10P13P14P17m2 : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P4mtmp : rk(P1 :: P4 :: nil) >= 2) by (solve_hyps_min HP1P4eq HP1P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P4mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4M1. try clear HP1P4M2. try clear HP1P4M3. try clear HP1P4m4. try clear HP1P4m3. try clear HP1P4m2. try clear HP1P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P10P13P14P17m3 : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P4P5mtmp : rk(P1 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P4P5eq HP1P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5M1. try clear HP1P4P5M2. try clear HP1P4P5M3. try clear HP1P4P5m4. try clear HP1P4P5m3. try clear HP1P4P5m2. try clear HP1P4P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P4P5P7P10P13P14P17m4 : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P4P5P13mtmp : rk(P1 :: P4 :: P5 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P4P5P13eq HP1P4P5P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P4 :: P5 :: P13 :: nil) (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P4P5P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P4P5P13M1. try clear HP1P4P5P13M2. try clear HP1P4P5P13M3. try clear HP1P4P5P13m4. try clear HP1P4P5P13m3. try clear HP1P4P5P13m2. try clear HP1P4P5P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P7P10P13P14P17m2 : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P10P13P14P17m3 : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P10P13P14P17eq : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P4P5P7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P7P10P13P14P17mtmp : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P4P5P7P10P13P14P17eq HP1P4P5P7P10P13P14P17m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P10P13P14P17mtmp;try rewrite HT2 in HP1P4P5P7P10P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P4P5P7P10P13P14P17mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P10P13P14P17m4 : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13eq : rk(P1 :: P5 :: P7 :: P13 :: nil) = 3) by (apply LP1P5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P7P13Mtmp : rk(P1 :: P5 :: P7 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13eq HP1P5P7P13M3).
	try assert(HP1P4P5P7P10P13P14P17eq : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P4P5P7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P7P10P13P14P17mtmp : rk(P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P10P13P14P17eq HP1P4P5P7P10P13P14P17m4).
	try assert(HP5P7P13eq : rk(P5 :: P7 :: P13 :: nil) = 3) by (apply LP5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP5P7P13mtmp : rk(P5 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP5P7P13eq HP5P7P13m3).
	assert(Hincl : incl (P5 :: P7 :: P13 :: nil) (list_inter (P1 :: P5 :: P7 :: P13 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P13 :: P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: P13 :: nil) ++ (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P10P13P14P17mtmp;try rewrite HT2 in HP1P4P5P7P10P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P13 :: nil) (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: P13 :: nil) 4 3 3 HP1P4P5P7P10P13P14P17mtmp HP5P7P13mtmp HP1P5P7P13Mtmp Hincl); apply HT.
}
try clear HP1P4P5P7P10P13P14P17M1. try clear HP1P4P5P7P10P13P14P17M2. try clear HP1P4P5P7P10P13P14P17M3. try clear HP1P4P5P7P10P13P14P17m4. try clear HP1P4P5P7P10P13P14P17m3. try clear HP1P4P5P7P10P13P14P17m2. try clear HP1P4P5P7P10P13P14P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP7P10P13P14P17M3 : rk(P7 :: P10 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10Mtmp : rk(P10 :: nil) <= 1) by (solve_hyps_max HP10eq HP10M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P10 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P10 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P10 :: P7 :: P13 :: P14 :: P17 :: nil) ((P10 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P10 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP10Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P10P13P14P17m2 : rk(P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4P5P7P10P13P14P17eq : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP4P5P7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P7P10P13P14P17mtmp : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P5P7P10P13P14P17eq HP4P5P7P10P13P14P17m3).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P4 :: P5 :: P10 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P7P10P13P14P17mtmp;try rewrite HT2 in HP4P5P7P10P13P14P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P10 :: nil) 3 1 2 HP4P5P7P10P13P14P17mtmp HP10mtmp HP4P5P10Mtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP7P10P13P14P17m3 : rk(P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP4P5P10P13eq : rk(P4 :: P5 :: P10 :: P13 :: nil) = 3) by (apply LP4P5P10P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP4P5P10P13Mtmp : rk(P4 :: P5 :: P10 :: P13 :: nil) <= 3) by (solve_hyps_max HP4P5P10P13eq HP4P5P10P13M3).
	try assert(HP4P5P7P10P13P14P17eq : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP4P5P7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P7P10P13P14P17mtmp : rk(P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P5P7P10P13P14P17eq HP4P5P7P10P13P14P17m4).
	try assert(HP10P13eq : rk(P10 :: P13 :: nil) = 2) by (apply LP10P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP10P13mtmp : rk(P10 :: P13 :: nil) >= 2) by (solve_hyps_min HP10P13eq HP10P13m2).
	assert(Hincl : incl (P10 :: P13 :: nil) (list_inter (P4 :: P5 :: P10 :: P13 :: nil) (P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P4 :: P5 :: P10 :: P13 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P13 :: P7 :: P10 :: P13 :: P14 :: P17 :: nil) ((P4 :: P5 :: P10 :: P13 :: nil) ++ (P7 :: P10 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P7P10P13P14P17mtmp;try rewrite HT2 in HP4P5P7P10P13P14P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: P13 :: nil) (P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P10 :: P13 :: nil) 4 2 3 HP4P5P7P10P13P14P17mtmp HP10P13mtmp HP4P5P10P13Mtmp Hincl); apply HT.
}
try clear HP4P5P10P13M1. try clear HP4P5P10P13M2. try clear HP4P5P10P13M3. try clear HP4P5P10P13m4. try clear HP4P5P10P13m3. try clear HP4P5P10P13m2. try clear HP4P5P10P13m1. try clear HP10P13M1. try clear HP10P13M2. try clear HP10P13M3. try clear HP10P13m4. try clear HP10P13m3. try clear HP10P13m2. try clear HP10P13m1. try clear HP4P5P7P10P13P14P17M1. try clear HP4P5P7P10P13P14P17M2. try clear HP4P5P7P10P13P14P17M3. try clear HP4P5P7P10P13P14P17m4. try clear HP4P5P7P10P13P14P17m3. try clear HP4P5P7P10P13P14P17m2. try clear HP4P5P7P10P13P14P17m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP10P17m2 : rk(P10 :: P17 :: nil) >= 2).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP7P10P13P14P17eq : rk(P7 :: P10 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP7P10P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P10P13P14P17mtmp : rk(P7 :: P10 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP7P10P13P14P17eq HP7P10P13P14P17m3).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P10 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P7 :: P10 :: P13 :: P14 :: P17 :: nil) (P10 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P10 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P10 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP7P10P13P14P17mtmp;try rewrite HT2 in HP7P10P13P14P17mtmp.
	assert(HT := rule_2 (P10 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 3 1 2 HP7P10P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP7P10P13P14P17M1. try clear HP7P10P13P14P17M2. try clear HP7P10P13P14P17M3. try clear HP7P10P13P14P17m4. try clear HP7P10P13P14P17m3. try clear HP7P10P13P14P17m2. try clear HP7P10P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P10P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P5P10P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP1P2P5mtmp : rk(P1 :: P2 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P2P5eq HP1P2P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P5 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 3 3 HP1P2P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P5M1. try clear HP1P2P5M2. try clear HP1P2P5M3. try clear HP1P2P5m4. try clear HP1P2P5m3. try clear HP1P2P5m2. try clear HP1P2P5m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P5P10P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P5P17mtmp : rk(P1 :: P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P5P17eq HP1P2P3P5P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P5 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 4 4 HP1P2P3P5P17mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P5P17M1. try clear HP1P2P3P5P17M2. try clear HP1P2P3P5P17M3. try clear HP1P2P3P5P17m4. try clear HP1P2P3P5P17m3. try clear HP1P2P3P5P17m2. try clear HP1P2P3P5P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P10P17m2 : rk(P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP1P3mtmp : rk(P1 :: P3 :: nil) >= 2) by (solve_hyps_min HP1P3eq HP1P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 2 2 HP1P3mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3M1. try clear HP1P3M2. try clear HP1P3M3. try clear HP1P3m4. try clear HP1P3m3. try clear HP1P3m2. try clear HP1P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P3P4P5P10P17m3 : rk(P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP1P3P5mtmp : rk(P1 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP1P3P5eq HP1P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P3 :: P5 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 3 3 HP1P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP1P3P5M1. try clear HP1P3P5M2. try clear HP1P3P5M3. try clear HP1P3P5m4. try clear HP1P3P5m3. try clear HP1P3P5m2. try clear HP1P3P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P3P4P5P10P17m4 : rk(P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P5P17eq : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P17Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P5P17eq HP1P2P4P5P17M4).
	try assert(HP1P2P3P4P5P10P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P10P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P10P17eq HP1P2P3P4P5P10P17m4).
	try assert(HP1P4P5P17eq : rk(P1 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P17mtmp : rk(P1 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P17eq HP1P4P5P17m4).
	assert(Hincl : incl (P1 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P10P17mtmp;try rewrite HT2 in HP1P2P3P4P5P10P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P1 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P10P17mtmp HP1P4P5P17mtmp HP1P2P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P4P5P17M1. try clear HP1P4P5P17M2. try clear HP1P4P5P17M3. try clear HP1P4P5P17m4. try clear HP1P4P5P17m3. try clear HP1P4P5P17m2. try clear HP1P4P5P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P7P13P14P17m2 : rk(P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P13P14P17m3 : rk(P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	try assert(HP1P5P7eq : rk(P1 :: P5 :: P7 :: nil) = 2) by (apply LP1P5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P5P7Mtmp : rk(P1 :: P5 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P5P7eq HP1P5P7M2).
	try assert(HP1P4P5P7P13P14P17eq : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP1P4P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P7P13P14P17mtmp : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P4P5P7P13P14P17eq HP1P4P5P7P13P14P17m3).
	try assert(HP5P7eq : rk(P5 :: P7 :: nil) = 2) by (apply LP5P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP5P7mtmp : rk(P5 :: P7 :: nil) >= 2) by (solve_hyps_min HP5P7eq HP5P7m2).
	assert(Hincl : incl (P5 :: P7 :: nil) (list_inter (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: nil) ++ (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P13P14P17mtmp;try rewrite HT2 in HP1P4P5P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: nil) 3 2 2 HP1P4P5P7P13P14P17mtmp HP5P7mtmp HP1P5P7Mtmp Hincl); apply HT.
}
try clear HP1P5P7M1. try clear HP1P5P7M2. try clear HP1P5P7M3. try clear HP1P5P7m4. try clear HP1P5P7m3. try clear HP1P5P7m2. try clear HP1P5P7m1. try clear HP5P7M1. try clear HP5P7M2. try clear HP5P7M3. try clear HP5P7m4. try clear HP5P7m3. try clear HP5P7m2. try clear HP5P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P7P13P14P17m4 : rk(P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	try assert(HP1P5P7P13eq : rk(P1 :: P5 :: P7 :: P13 :: nil) = 3) by (apply LP1P5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP1P5P7P13Mtmp : rk(P1 :: P5 :: P7 :: P13 :: nil) <= 3) by (solve_hyps_max HP1P5P7P13eq HP1P5P7P13M3).
	try assert(HP1P4P5P7P13P14P17eq : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P4P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P4P5P7P13P14P17mtmp : rk(P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P4P5P7P13P14P17eq HP1P4P5P7P13P14P17m4).
	try assert(HP5P7P13eq : rk(P5 :: P7 :: P13 :: nil) = 3) by (apply LP5P7P13 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) ;try assumption).
	assert(HP5P7P13mtmp : rk(P5 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP5P7P13eq HP5P7P13m3).
	assert(Hincl : incl (P5 :: P7 :: P13 :: nil) (list_inter (P1 :: P5 :: P7 :: P13 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P5 :: P7 :: P13 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P5 :: P7 :: P13 :: P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P5 :: P7 :: P13 :: nil) ++ (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P4P5P7P13P14P17mtmp;try rewrite HT2 in HP1P4P5P7P13P14P17mtmp.
	assert(HT := rule_4 (P1 :: P5 :: P7 :: P13 :: nil) (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P5 :: P7 :: P13 :: nil) 4 3 3 HP1P4P5P7P13P14P17mtmp HP5P7P13mtmp HP1P5P7P13Mtmp Hincl); apply HT.
}
try clear HP1P5P7P13M1. try clear HP1P5P7P13M2. try clear HP1P5P7P13M3. try clear HP1P5P7P13m4. try clear HP1P5P7P13m3. try clear HP1P5P7P13m2. try clear HP1P5P7P13m1. try clear HP5P7P13M1. try clear HP5P7P13M2. try clear HP5P7P13M3. try clear HP5P7P13m4. try clear HP5P7P13m3. try clear HP5P7P13m2. try clear HP5P7P13m1. try clear HP1P4P5P7P13P14P17M1. try clear HP1P4P5P7P13P14P17M2. try clear HP1P4P5P7P13P14P17M3. try clear HP1P4P5P7P13P14P17m4. try clear HP1P4P5P7P13P14P17m3. try clear HP1P4P5P7P13P14P17m2. try clear HP1P4P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P17m2 : rk(P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP4P5P17m3 : rk(P4 :: P5 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP4P5P7P13P14P17eq : rk(P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP4P5P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P7P13P14P17mtmp : rk(P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P5P7P13P14P17eq HP4P5P7P13P14P17m4).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P4 :: P5 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P7 :: P13 :: P14 :: P17 :: nil) (P4 :: P5 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P4 :: P5 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P7P13P14P17mtmp;try rewrite HT2 in HP4P5P7P13P14P17mtmp.
	assert(HT := rule_2 (P4 :: P5 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P17 :: nil) 4 1 2 HP4P5P7P13P14P17mtmp HP17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP4P5P7P13P14P17M1. try clear HP4P5P7P13P14P17M2. try clear HP4P5P7P13P14P17M3. try clear HP4P5P7P13P14P17m4. try clear HP4P5P7P13P14P17m3. try clear HP4P5P7P13P14P17m2. try clear HP4P5P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P5P10P17m2 : rk(P4 :: P5 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP4P5mtmp : rk(P4 :: P5 :: nil) >= 2) by (solve_hyps_min HP4P5eq HP4P5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P5 :: nil) (P4 :: P5 :: P10 :: P17 :: nil) 2 2 HP4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP4P5M1. try clear HP4P5M2. try clear HP4P5M3. try clear HP4P5m4. try clear HP4P5m3. try clear HP4P5m2. try clear HP4P5m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P5P10P17M3 : rk(P4 :: P5 :: P10 :: P17 :: nil) <= 3).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P4 :: P5 :: P10 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P10 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P4 :: P5 :: P10 :: nil) (P17 :: nil) (nil) 2 1 0 HP4P5P10Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP4P5P10P17m3 : rk(P4 :: P5 :: P10 :: P17 :: nil) >= 3).
{
	try assert(HP1P3P4P5P17eq : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P17Mtmp : rk(P1 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P3P4P5P17eq HP1P3P4P5P17M4).
	try assert(HP1P3P4P5P10P17eq : rk(P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) = 4) by (apply LP1P3P4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P3P4P5P10P17mtmp : rk(P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P3P4P5P10P17eq HP1P3P4P5P10P17m4).
	try assert(HP4P5P17eq : rk(P4 :: P5 :: P17 :: nil) = 3) by (apply LP4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P17mtmp : rk(P4 :: P5 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P5P17eq HP4P5P17m3).
	assert(Hincl : incl (P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P1 :: P3 :: P4 :: P5 :: P17 :: P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P3 :: P4 :: P5 :: P17 :: P4 :: P5 :: P10 :: P17 :: nil) ((P1 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P4 :: P5 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P3P4P5P10P17mtmp;try rewrite HT2 in HP1P3P4P5P10P17mtmp.
	assert(HT := rule_4 (P1 :: P3 :: P4 :: P5 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: nil) (P4 :: P5 :: P17 :: nil) 4 3 4 HP1P3P4P5P10P17mtmp HP4P5P17mtmp HP1P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P3P4P5P17M1. try clear HP1P3P4P5P17M2. try clear HP1P3P4P5P17M3. try clear HP1P3P4P5P17m4. try clear HP1P3P4P5P17m3. try clear HP1P3P4P5P17m2. try clear HP1P3P4P5P17m1. try clear HP4P5P17M1. try clear HP4P5P17M2. try clear HP4P5P17M3. try clear HP4P5P17m4. try clear HP4P5P17m3. try clear HP4P5P17m2. try clear HP4P5P17m1. try clear HP1P3P4P5P10P17M1. try clear HP1P3P4P5P10P17M2. try clear HP1P3P4P5P10P17M3. try clear HP1P3P4P5P10P17m4. try clear HP1P3P4P5P10P17m3. try clear HP1P3P4P5P10P17m2. try clear HP1P3P4P5P10P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP9P10P11P17m2 : rk(P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	try assert(HP4P5P10eq : rk(P4 :: P5 :: P10 :: nil) = 2) by (apply LP4P5P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP4P5P10Mtmp : rk(P4 :: P5 :: P10 :: nil) <= 2) by (solve_hyps_max HP4P5P10eq HP4P5P10M2).
	try assert(HP4P5P9P10P11P17eq : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P9P10P11P17mtmp : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P5P9P10P11P17eq HP4P5P9P10P11P17m3).
	try assert(HP10eq : rk(P10 :: nil) = 1) by (apply LP10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP10mtmp : rk(P10 :: nil) >= 1) by (solve_hyps_min HP10eq HP10m1).
	assert(Hincl : incl (P10 :: nil) (list_inter (P4 :: P5 :: P10 :: nil) (P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P4 :: P5 :: P10 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P9 :: P10 :: P11 :: P17 :: nil) ((P4 :: P5 :: P10 :: nil) ++ (P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P9P10P11P17mtmp;try rewrite HT2 in HP4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: nil) (P9 :: P10 :: P11 :: P17 :: nil) (P10 :: nil) 3 1 2 HP4P5P9P10P11P17mtmp HP10mtmp HP4P5P10Mtmp Hincl); apply HT.
}
try clear HP4P5P10M1. try clear HP4P5P10M2. try clear HP4P5P10M3. try clear HP4P5P10m4. try clear HP4P5P10m3. try clear HP4P5P10m2. try clear HP4P5P10m1. try clear HP10M1. try clear HP10M2. try clear HP10M3. try clear HP10m4. try clear HP10m3. try clear HP10m2. try clear HP10m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP9P10P11P17m3 : rk(P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	try assert(HP4P5P10P17eq : rk(P4 :: P5 :: P10 :: P17 :: nil) = 3) by (apply LP4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P10P17Mtmp : rk(P4 :: P5 :: P10 :: P17 :: nil) <= 3) by (solve_hyps_max HP4P5P10P17eq HP4P5P10P17M3).
	try assert(HP4P5P9P10P11P17eq : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP4P5P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P9P10P11P17mtmp : rk(P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP4P5P9P10P11P17eq HP4P5P9P10P11P17m4).
	try assert(HP10P17eq : rk(P10 :: P17 :: nil) = 2) by (apply LP10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP10P17mtmp : rk(P10 :: P17 :: nil) >= 2) by (solve_hyps_min HP10P17eq HP10P17m2).
	assert(Hincl : incl (P10 :: P17 :: nil) (list_inter (P4 :: P5 :: P10 :: P17 :: nil) (P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P5 :: P9 :: P10 :: P11 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P4 :: P5 :: P10 :: P17 :: P9 :: P10 :: P11 :: P17 :: nil) ((P4 :: P5 :: P10 :: P17 :: nil) ++ (P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P5P9P10P11P17mtmp;try rewrite HT2 in HP4P5P9P10P11P17mtmp.
	assert(HT := rule_4 (P4 :: P5 :: P10 :: P17 :: nil) (P9 :: P10 :: P11 :: P17 :: nil) (P10 :: P17 :: nil) 4 2 3 HP4P5P9P10P11P17mtmp HP10P17mtmp HP4P5P10P17Mtmp Hincl); apply HT.
}
try clear HP4P5P9P10P11P17M1. try clear HP4P5P9P10P11P17M2. try clear HP4P5P9P10P11P17M3. try clear HP4P5P9P10P11P17m4. try clear HP4P5P9P10P11P17m3. try clear HP4P5P9P10P11P17m2. try clear HP4P5P9P10P11P17m1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP9P10P11P17M3 : rk(P9 :: P10 :: P11 :: P17 :: nil) <= 3).
{
	assert(HP8P9P10P11P12P17Mtmp : rk(P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) <= 3) by (solve_hyps_max HP8P9P10P11P12P17eq HP8P9P10P11P12P17M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P9 :: P10 :: P11 :: P17 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P9 :: P10 :: P11 :: P17 :: nil) (P8 :: P9 :: P10 :: P11 :: P12 :: P17 :: nil) 3 3 HP8P9P10P11P12P17Mtmp Hcomp Hincl);apply HT.
}
try clear HP8P9P10P11P12P17M1. try clear HP8P9P10P11P12P17M2. try clear HP8P9P10P11P12P17M3. try clear HP8P9P10P11P12P17m4. try clear HP8P9P10P11P12P17m3. try clear HP8P9P10P11P12P17m2. try clear HP8P9P10P11P12P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P7P9P10P11P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P7P9P10P11P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P6P7P9P10P11P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P6P17mtmp : rk(P1 :: P2 :: P3 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P6P17eq HP1P2P3P6P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P6 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 4 4 HP1P2P3P6P17mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P6P17M1. try clear HP1P2P3P6P17M2. try clear HP1P2P3P6P17M3. try clear HP1P2P3P6P17m4. try clear HP1P2P3P6P17m3. try clear HP1P2P3P6P17m2. try clear HP1P2P3P6P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P8P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P8P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P8P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P6P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P4P6P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P6P8P17eq : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P8P17Mtmp : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P6P8P17eq HP1P2P6P8P17M4).
	try assert(HP1P2P3P4P6P8P17eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P3P4P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P6P8P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P8P17eq HP1P2P3P4P6P8P17m4).
	try assert(HP1P2P6P17eq : rk(P1 :: P2 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P17mtmp : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P17eq HP1P2P6P17m4).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil) ((P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P8P17mtmp;try rewrite HT2 in HP1P2P3P4P6P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 4 4 4 HP1P2P3P4P6P8P17mtmp HP1P2P6P17mtmp HP1P2P6P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P3P4P6P8P17M1. try clear HP1P2P3P4P6P8P17M2. try clear HP1P2P3P4P6P8P17M3. try clear HP1P2P3P4P6P8P17m4. try clear HP1P2P3P4P6P8P17m3. try clear HP1P2P3P4P6P8P17m2. try clear HP1P2P3P4P6P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P9P10P11P17m2 : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P9P10P11P17m3 : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP1P2P6P7P9P10P11P17m4 : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P3P4P6P17eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P3P4P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P6P17Mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P3P4P6P17eq HP1P2P3P4P6P17M4).
	try assert(HP1P2P3P4P6P7P9P10P11P17eq : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP1P2P3P4P6P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P6P7P9P10P11P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P6P7P9P10P11P17eq HP1P2P3P4P6P7P9P10P11P17m4).
	try assert(HP1P2P6P17eq : rk(P1 :: P2 :: P6 :: P17 :: nil) = 4) by (apply LP1P2P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P17mtmp : rk(P1 :: P2 :: P6 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P17eq HP1P2P6P17m4).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) ((P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) ++ (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P6P7P9P10P11P17mtmp;try rewrite HT2 in HP1P2P3P4P6P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P3 :: P4 :: P6 :: P17 :: nil) (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P2 :: P6 :: P17 :: nil) 4 4 4 HP1P2P3P4P6P7P9P10P11P17mtmp HP1P2P6P17mtmp HP1P2P3P4P6P17Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P6P17M1. try clear HP1P2P3P4P6P17M2. try clear HP1P2P3P4P6P17M3. try clear HP1P2P3P4P6P17m4. try clear HP1P2P3P4P6P17m3. try clear HP1P2P3P4P6P17m2. try clear HP1P2P3P4P6P17m1. try clear HP1P2P6P17M1. try clear HP1P2P6P17M2. try clear HP1P2P6P17M3. try clear HP1P2P6P17m4. try clear HP1P2P6P17m3. try clear HP1P2P6P17m2. try clear HP1P2P6P17m1. try clear HP1P2P3P4P6P7P9P10P11P17M1. try clear HP1P2P3P4P6P7P9P10P11P17M2. try clear HP1P2P3P4P6P7P9P10P11P17M3. try clear HP1P2P3P4P6P7P9P10P11P17m4. try clear HP1P2P3P4P6P7P9P10P11P17m3. try clear HP1P2P3P4P6P7P9P10P11P17m2. try clear HP1P2P3P4P6P7P9P10P11P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP6P7P13P14P17M3 : rk(P6 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP6eq : rk(P6 :: nil) = 1) by (apply LP6 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6Mtmp : rk(P6 :: nil) <= 1) by (solve_hyps_max HP6eq HP6M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P6 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P7 :: P13 :: P14 :: P17 :: nil) ((P6 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P6 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP6Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP6M1. try clear HP6M2. try clear HP6M3. try clear HP6m4. try clear HP6m3. try clear HP6m2. try clear HP6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P7P13P14P17m2 : rk(P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P6 :: P7 :: nil) (P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P7 :: nil) (P6 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP6P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P7P13P14P17m3 : rk(P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP6P7P13mtmp : rk(P6 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP6P7P13eq HP6P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P6 :: P7 :: P13 :: nil) (P6 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P7 :: P13 :: nil) (P6 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP6P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP6P7P13M1. try clear HP6P7P13M2. try clear HP6P7P13M3. try clear HP6P7P13m4. try clear HP6P7P13m3. try clear HP6P7P13m2. try clear HP6P7P13m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP4P7P15P16P17M3 : rk(P4 :: P7 :: P15 :: P16 :: P17 :: nil) <= 3).
{
	try assert(HP7eq : rk(P7 :: nil) = 1) by (apply LP7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP7Mtmp : rk(P7 :: nil) <= 1) by (solve_hyps_max HP7eq HP7M1).
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P7 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P7 :: P15 :: P16 :: P17 :: nil) (P7 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P7 :: P4 :: P15 :: P16 :: P17 :: nil) ((P7 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P7 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (nil) 1 2 0 HP7Mtmp HP4P15P16P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP7M1. try clear HP7M2. try clear HP7M3. try clear HP7m4. try clear HP7m3. try clear HP7m2. try clear HP7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP4P7P15P16P17m2 : rk(P4 :: P7 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP4P7mtmp : rk(P4 :: P7 :: nil) >= 2) by (solve_hyps_min HP4P7eq HP4P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P4 :: P7 :: nil) (P4 :: P7 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P4 :: P7 :: nil) (P4 :: P7 :: P15 :: P16 :: P17 :: nil) 2 2 HP4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP4P7M1. try clear HP4P7M2. try clear HP4P7M3. try clear HP4P7m4. try clear HP4P7m3. try clear HP4P7m2. try clear HP4P7m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP4P7P15P16P17m3 : rk(P4 :: P7 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	try assert(HP4P7P15eq : rk(P4 :: P7 :: P15 :: nil) = 3) by (apply LP4P7P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP4P7P15M1. try clear HP4P7P15M2. try clear HP4P7P15M3. try clear HP4P7P15m4. try clear HP4P7P15m3. try clear HP4P7P15m2. try clear HP4P7P15m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP7P17m2 : rk(P7 :: P17 :: nil) >= 2).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP4P7P15P16P17eq : rk(P4 :: P7 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP4P7P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P7P15P16P17mtmp : rk(P4 :: P7 :: P15 :: P16 :: P17 :: nil) >= 3) by (solve_hyps_min HP4P7P15P16P17eq HP4P7P15P16P17m3).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17mtmp : rk(P17 :: nil) >= 1) by (solve_hyps_min HP17eq HP17m1).
	assert(Hincl : incl (P17 :: nil) (list_inter (P7 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P4 :: P7 :: P15 :: P16 :: P17 :: nil) (P7 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P7 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P7 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP4P7P15P16P17mtmp;try rewrite HT2 in HP4P7P15P16P17mtmp.
	assert(HT := rule_2 (P7 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P17 :: nil) 3 1 2 HP4P7P15P16P17mtmp HP17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP4P7P15P16P17M1. try clear HP4P7P15P16P17M2. try clear HP4P7P15P16P17M3. try clear HP4P7P15P16P17m4. try clear HP4P7P15P16P17m3. try clear HP4P7P15P16P17m2. try clear HP4P7P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP6P7P17m2 : rk(P6 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P6 :: P7 :: nil) (P6 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P6 :: P7 :: nil) (P6 :: P7 :: P17 :: nil) 2 2 HP6P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP6P7P17m3 : rk(P6 :: P7 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP6P7P13P14P17eq : rk(P6 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP6P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP6P7P13P14P17mtmp : rk(P6 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP6P7P13P14P17eq HP6P7P13P14P17m3).
	try assert(HP7P17eq : rk(P7 :: P17 :: nil) = 2) by (apply LP7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P17mtmp : rk(P7 :: P17 :: nil) >= 2) by (solve_hyps_min HP7P17eq HP7P17m2).
	assert(Hincl : incl (P7 :: P17 :: nil) (list_inter (P6 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P6 :: P7 :: P13 :: P14 :: P17 :: nil) (P6 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P6 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P6 :: P7 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP6P7P13P14P17mtmp;try rewrite HT2 in HP6P7P13P14P17mtmp.
	assert(HT := rule_2 (P6 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: P17 :: nil) 3 2 2 HP6P7P13P14P17mtmp HP7P17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP6P7P13P14P17M1. try clear HP6P7P13P14P17M2. try clear HP6P7P13P14P17M3. try clear HP6P7P13P14P17m4. try clear HP6P7P13P14P17m3. try clear HP6P7P13P14P17m2. try clear HP6P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P17m2 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P17m3 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P6mtmp : rk(P1 :: P2 :: P6 :: nil) >= 3) by (solve_hyps_min HP1P2P6eq HP1P2P6m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) 3 3 HP1P2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6M1. try clear HP1P2P6M2. try clear HP1P2P6M3. try clear HP1P2P6m4. try clear HP1P2P6m3. try clear HP1P2P6m2. try clear HP1P2P6m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P6P7P8P17m4 : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P6P8mtmp : rk(P1 :: P2 :: P6 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P6P8eq HP1P2P6P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P6 :: P8 :: nil) (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) 4 4 HP1P2P6P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P6P8M1. try clear HP1P2P6P8M2. try clear HP1P2P6P8M3. try clear HP1P2P6P8m4. try clear HP1P2P6P8m3. try clear HP1P2P6P8m2. try clear HP1P2P6P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P6P7P17m2 : rk(P1 :: P6 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP1P6mtmp : rk(P1 :: P6 :: nil) >= 2) by (solve_hyps_min HP1P6eq HP1P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P6 :: nil) (P1 :: P6 :: P7 :: P17 :: nil) 2 2 HP1P6mtmp Hcomp Hincl);apply HT.
}
try clear HP1P6M1. try clear HP1P6M2. try clear HP1P6M3. try clear HP1P6m4. try clear HP1P6m3. try clear HP1P6m2. try clear HP1P6m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP1P6P7P17M3 : rk(P1 :: P6 :: P7 :: P17 :: nil) <= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P1 :: P6 :: P7 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P6 :: P7 :: P17 :: nil) (P1 :: P6 :: P7 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P17 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P1 :: P6 :: P7 :: nil) (P17 :: nil) (nil) 2 1 0 HP1P6P7Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P6P7P17m3 : rk(P1 :: P6 :: P7 :: P17 :: nil) >= 3).
{
	try assert(HP1P2P6P8P17eq : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P6P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P8P17Mtmp : rk(P1 :: P2 :: P6 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P6P8P17eq HP1P2P6P8P17M4).
	try assert(HP1P2P6P7P8P17eq : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P6P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P8P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P8P17eq HP1P2P6P7P8P17m4).
	try assert(HP1P6P17eq : rk(P1 :: P6 :: P17 :: nil) = 3) by (apply LP1P6P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P6P17mtmp : rk(P1 :: P6 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P6P17eq HP1P6P17m3).
	assert(Hincl : incl (P1 :: P6 :: P17 :: nil) (list_inter (P1 :: P6 :: P7 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P8 :: P17 :: nil) (P1 :: P6 :: P7 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P17 :: P1 :: P2 :: P6 :: P8 :: P17 :: nil) ((P1 :: P6 :: P7 :: P17 :: nil) ++ (P1 :: P2 :: P6 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P8P17mtmp;try rewrite HT2 in HP1P2P6P7P8P17mtmp.
	assert(HT := rule_2 (P1 :: P6 :: P7 :: P17 :: nil) (P1 :: P2 :: P6 :: P8 :: P17 :: nil) (P1 :: P6 :: P17 :: nil) 4 3 4 HP1P2P6P7P8P17mtmp HP1P6P17mtmp HP1P2P6P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P6P8P17M1. try clear HP1P2P6P8P17M2. try clear HP1P2P6P8P17M3. try clear HP1P2P6P8P17m4. try clear HP1P2P6P8P17m3. try clear HP1P2P6P8P17m2. try clear HP1P2P6P8P17m1. try clear HP1P6P17M1. try clear HP1P6P17M2. try clear HP1P6P17M3. try clear HP1P6P17m4. try clear HP1P6P17m3. try clear HP1P6P17m2. try clear HP1P6P17m1. try clear HP1P2P6P7P8P17M1. try clear HP1P2P6P7P8P17M2. try clear HP1P2P6P7P8P17M3. try clear HP1P2P6P7P8P17m4. try clear HP1P2P6P7P8P17m3. try clear HP1P2P6P7P8P17m2. try clear HP1P2P6P7P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P6P7P9P10P11P17m2 : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP2P6mtmp : rk(P2 :: P6 :: nil) >= 2) by (solve_hyps_min HP2P6eq HP2P6m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P6 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP2P6mtmp Hcomp Hincl);apply HT.
}
try clear HP2P6M1. try clear HP2P6M2. try clear HP2P6M3. try clear HP2P6m4. try clear HP2P6m3. try clear HP2P6m2. try clear HP2P6m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P9P10P11P17m3 : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	try assert(HP1P6P7eq : rk(P1 :: P6 :: P7 :: nil) = 2) by (apply LP1P6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP1P6P7Mtmp : rk(P1 :: P6 :: P7 :: nil) <= 2) by (solve_hyps_max HP1P6P7eq HP1P6P7M2).
	try assert(HP1P2P6P7P9P10P11P17eq : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP1P2P6P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P9P10P11P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3) by (solve_hyps_min HP1P2P6P7P9P10P11P17eq HP1P2P6P7P9P10P11P17m3).
	try assert(HP6P7eq : rk(P6 :: P7 :: nil) = 2) by (apply LP6P7 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP6P7mtmp : rk(P6 :: P7 :: nil) >= 2) by (solve_hyps_min HP6P7eq HP6P7m2).
	assert(Hincl : incl (P6 :: P7 :: nil) (list_inter (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) ((P1 :: P6 :: P7 :: nil) ++ (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P9P10P11P17mtmp;try rewrite HT2 in HP1P2P6P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P6 :: P7 :: nil) 3 2 2 HP1P2P6P7P9P10P11P17mtmp HP6P7mtmp HP1P6P7Mtmp Hincl); apply HT.
}
try clear HP1P6P7M1. try clear HP1P6P7M2. try clear HP1P6P7M3. try clear HP1P6P7m4. try clear HP1P6P7m3. try clear HP1P6P7m2. try clear HP1P6P7m1. try clear HP6P7M1. try clear HP6P7M2. try clear HP6P7M3. try clear HP6P7m4. try clear HP6P7m3. try clear HP6P7m2. try clear HP6P7m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P6P7P9P10P11P17m4 : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP1P6P7P17eq : rk(P1 :: P6 :: P7 :: P17 :: nil) = 3) by (apply LP1P6P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P6P7P17Mtmp : rk(P1 :: P6 :: P7 :: P17 :: nil) <= 3) by (solve_hyps_max HP1P6P7P17eq HP1P6P7P17M3).
	try assert(HP1P2P6P7P9P10P11P17eq : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP1P2P6P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P6P7P9P10P11P17mtmp : rk(P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P6P7P9P10P11P17eq HP1P2P6P7P9P10P11P17m4).
	try assert(HP6P7P17eq : rk(P6 :: P7 :: P17 :: nil) = 3) by (apply LP6P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP6P7P17mtmp : rk(P6 :: P7 :: P17 :: nil) >= 3) by (solve_hyps_min HP6P7P17eq HP6P7P17m3).
	assert(Hincl : incl (P6 :: P7 :: P17 :: nil) (list_inter (P1 :: P6 :: P7 :: P17 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P1 :: P6 :: P7 :: P17 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P6 :: P7 :: P17 :: P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) ((P1 :: P6 :: P7 :: P17 :: nil) ++ (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P6P7P9P10P11P17mtmp;try rewrite HT2 in HP1P2P6P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P1 :: P6 :: P7 :: P17 :: nil) (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P6 :: P7 :: P17 :: nil) 4 3 3 HP1P2P6P7P9P10P11P17mtmp HP6P7P17mtmp HP1P6P7P17Mtmp Hincl); apply HT.
}
try clear HP1P6P7P17M1. try clear HP1P6P7P17M2. try clear HP1P6P7P17M3. try clear HP1P6P7P17m4. try clear HP1P6P7P17m3. try clear HP1P6P7P17m2. try clear HP1P6P7P17m1. try clear HP6P7P17M1. try clear HP6P7P17M2. try clear HP6P7P17M3. try clear HP6P7P17m4. try clear HP6P7P17m3. try clear HP6P7P17m2. try clear HP6P7P17m1. try clear HP1P2P6P7P9P10P11P17M1. try clear HP1P2P6P7P9P10P11P17M2. try clear HP1P2P6P7P9P10P11P17M3. try clear HP1P2P6P7P9P10P11P17m4. try clear HP1P2P6P7P9P10P11P17m3. try clear HP1P2P6P7P9P10P11P17m2. try clear HP1P2P6P7P9P10P11P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P15P16P17m2 : rk(P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P15P16P17m3 : rk(P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P4P5P15P16P17m4 : rk(P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP2P4P5P15eq : rk(P2 :: P4 :: P5 :: P15 :: nil) = 4) by (apply LP2P4P5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP2P4P5P15M1. try clear HP2P4P5P15M2. try clear HP2P4P5P15M3. try clear HP2P4P5P15m4. try clear HP2P4P5P15m3. try clear HP2P4P5P15m2. try clear HP2P4P5P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P17m2 : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P17m3 : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P17 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P17m4 : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP4P15P16P17eq : rk(P4 :: P15 :: P16 :: P17 :: nil) = 2) by (apply LP4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P15P16P17Mtmp : rk(P4 :: P15 :: P16 :: P17 :: nil) <= 2) by (solve_hyps_max HP4P15P16P17eq HP4P15P16P17M2).
	try assert(HP2P4P5P15P16P17eq : rk(P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P4P5P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P15P16P17mtmp : rk(P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P15P16P17eq HP2P4P5P15P16P17m4).
	try assert(HP4P17eq : rk(P4 :: P17 :: nil) = 2) by (apply LP4P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P17mtmp : rk(P4 :: P17 :: nil) >= 2) by (solve_hyps_min HP4P17eq HP4P17m2).
	assert(Hincl : incl (P4 :: P17 :: nil) (list_inter (P2 :: P4 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) (P2 :: P4 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P5 :: P17 :: P4 :: P15 :: P16 :: P17 :: nil) ((P2 :: P4 :: P5 :: P17 :: nil) ++ (P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P15P16P17mtmp;try rewrite HT2 in HP2P4P5P15P16P17mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P5 :: P17 :: nil) (P4 :: P15 :: P16 :: P17 :: nil) (P4 :: P17 :: nil) 4 2 2 HP2P4P5P15P16P17mtmp HP4P17mtmp HP4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP4P15P16P17M1. try clear HP4P15P16P17M2. try clear HP4P15P16P17M3. try clear HP4P15P16P17m4. try clear HP4P15P16P17m3. try clear HP4P15P16P17m2. try clear HP4P15P16P17m1. try clear HP4P17M1. try clear HP4P17M2. try clear HP4P17M3. try clear HP4P17m4. try clear HP4P17m3. try clear HP4P17m2. try clear HP4P17m1. try clear HP2P4P5P15P16P17M1. try clear HP2P4P5P15P16P17M2. try clear HP2P4P5P15P16P17M3. try clear HP2P4P5P15P16P17m4. try clear HP2P4P5P15P16P17m3. try clear HP2P4P5P15P16P17m2. try clear HP2P4P5P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P9P17m2 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P9P17m3 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P9P17m4 : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P5P17eq : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P17Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P5P17eq HP1P2P4P5P17M4).
	try assert(HP1P2P3P4P5P9P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P9P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P9P17eq HP1P2P3P4P5P9P17m4).
	try assert(HP2P4P5P17eq : rk(P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P17mtmp : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P17eq HP2P4P5P17m4).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P9P17mtmp;try rewrite HT2 in HP1P2P3P4P5P9P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P2 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P9P17mtmp HP2P4P5P17mtmp HP1P2P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P2P3P4P5P9P17M1. try clear HP1P2P3P4P5P9P17M2. try clear HP1P2P3P4P5P9P17M3. try clear HP1P2P3P4P5P9P17m4. try clear HP1P2P3P4P5P9P17m3. try clear HP1P2P3P4P5P9P17m2. try clear HP1P2P3P4P5P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P15P16P17m2 : rk(P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P15P16P17m3 : rk(P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HP2P3P4P5P15P16P17m4 : rk(P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P5P15eq : rk(P2 :: P3 :: P5 :: P15 :: nil) = 4) by (apply LP2P3P5P15 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) ;try assumption).
try clear HP2P3P5P15M1. try clear HP2P3P5P15M2. try clear HP2P3P5P15M3. try clear HP2P3P5P15m4. try clear HP2P3P5P15m3. try clear HP2P3P5P15m2. try clear HP2P3P5P15m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P17m2 : rk(P2 :: P3 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P17m3 : rk(P2 :: P3 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P17m4 : rk(P2 :: P3 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P4P15P16P17eq : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) = 3) by (apply LP2P3P4P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P15P16P17Mtmp : rk(P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P3P4P15P16P17eq HP2P3P4P15P16P17M3).
	try assert(HP2P3P4P5P15P16P17eq : rk(P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) = 4) by (apply LP2P3P4P5P15P16P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P15P16P17mtmp : rk(P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P15P16P17eq HP2P3P4P5P15P16P17m4).
	try assert(HP2P3P17eq : rk(P2 :: P3 :: P17 :: nil) = 3) by (apply LP2P3P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P17mtmp : rk(P2 :: P3 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P3P17eq HP2P3P17m3).
	assert(Hincl : incl (P2 :: P3 :: P17 :: nil) (list_inter (P2 :: P3 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P15 :: P16 :: P17 :: nil) (P2 :: P3 :: P5 :: P17 :: P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P5 :: P17 :: P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) ((P2 :: P3 :: P5 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P15P16P17mtmp;try rewrite HT2 in HP2P3P4P5P15P16P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P15 :: P16 :: P17 :: nil) (P2 :: P3 :: P17 :: nil) 4 3 3 HP2P3P4P5P15P16P17mtmp HP2P3P17mtmp HP2P3P4P15P16P17Mtmp Hincl);apply HT.
}
try clear HP2P3P4P15P16P17M1. try clear HP2P3P4P15P16P17M2. try clear HP2P3P4P15P16P17M3. try clear HP2P3P4P15P16P17m4. try clear HP2P3P4P15P16P17m3. try clear HP2P3P4P15P16P17m2. try clear HP2P3P4P15P16P17m1. try clear HP2P3P17M1. try clear HP2P3P17M2. try clear HP2P3P17M3. try clear HP2P3P17m4. try clear HP2P3P17m3. try clear HP2P3P17m2. try clear HP2P3P17m1. try clear HP2P3P4P5P15P16P17M1. try clear HP2P3P4P5P15P16P17M2. try clear HP2P3P4P5P15P16P17M3. try clear HP2P3P4P5P15P16P17m4. try clear HP2P3P4P5P15P16P17m3. try clear HP2P3P4P5P15P16P17m2. try clear HP2P3P4P5P15P16P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P8P17m2 : rk(P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P8P17m3 : rk(P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P8P17m4 : rk(P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P5P8mtmp : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8eq HP2P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) 4 4 HP2P3P5P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P17m2 : rk(P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P17m3 : rk(P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P8P17m4 : rk(P2 :: P3 :: P5 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P5P8mtmp : rk(P2 :: P3 :: P5 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P5P8eq HP2P3P5P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: P8 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil) 4 4 HP2P3P5P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5P8M1. try clear HP2P3P5P8M2. try clear HP2P3P5P8M3. try clear HP2P3P5P8m4. try clear HP2P3P5P8m3. try clear HP2P3P5P8m2. try clear HP2P3P5P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P17m2 : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P17m3 : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P17m4 : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P5P8P17eq : rk(P2 :: P3 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P5P8P17Mtmp : rk(P2 :: P3 :: P5 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P5P8P17eq HP2P3P5P8P17M4).
	try assert(HP2P3P4P5P8P17eq : rk(P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P4P5P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P8P17mtmp : rk(P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P8P17eq HP2P3P4P5P8P17m4).
	try assert(HP2P3P5P17eq : rk(P2 :: P3 :: P5 :: P17 :: nil) = 4) by (apply LP2P3P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P5P17mtmp : rk(P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P5P17eq HP2P3P5P17m4).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P8 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P3 :: P5 :: P8 :: P17 :: nil) ((P2 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P2 :: P3 :: P5 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P8P17mtmp;try rewrite HT2 in HP2P3P4P5P8P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P5 :: P8 :: P17 :: nil) (P2 :: P3 :: P5 :: P17 :: nil) 4 4 4 HP2P3P4P5P8P17mtmp HP2P3P5P17mtmp HP2P3P5P8P17Mtmp Hincl);apply HT.
}
try clear HP2P3P5P8P17M1. try clear HP2P3P5P8P17M2. try clear HP2P3P5P8P17M3. try clear HP2P3P5P8P17m4. try clear HP2P3P5P8P17m3. try clear HP2P3P5P8P17m2. try clear HP2P3P5P8P17m1. try clear HP2P3P4P5P8P17M1. try clear HP2P3P4P5P8P17M2. try clear HP2P3P4P5P8P17M3. try clear HP2P3P4P5P8P17m4. try clear HP2P3P4P5P8P17m3. try clear HP2P3P4P5P8P17m2. try clear HP2P3P4P5P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P9P17m2 : rk(P2 :: P3 :: P5 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P5P9P17m3 : rk(P2 :: P3 :: P5 :: P9 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P5P9P17m4 : rk(P2 :: P3 :: P5 :: P9 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P4P5P17eq : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP2P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P17Mtmp : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P4P5P17eq HP2P3P4P5P17M4).
	try assert(HP2P3P4P5P9P17eq : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) = 4) by (apply LP2P3P4P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P9P17mtmp : rk(P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P9P17eq HP2P3P4P5P9P17m4).
	try assert(HP2P3P5P17eq : rk(P2 :: P3 :: P5 :: P17 :: nil) = 4) by (apply LP2P3P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P5P17mtmp : rk(P2 :: P3 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P5P17eq HP2P3P5P17m4).
	assert(Hincl : incl (P2 :: P3 :: P5 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P9 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P3 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P3 :: P5 :: P9 :: P17 :: nil) ((P2 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P2 :: P3 :: P5 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P9P17mtmp;try rewrite HT2 in HP2P3P4P5P9P17mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P5 :: P9 :: P17 :: nil) (P2 :: P3 :: P5 :: P17 :: nil) 4 4 4 HP2P3P4P5P9P17mtmp HP2P3P5P17mtmp HP2P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP2P3P5P17M1. try clear HP2P3P5P17M2. try clear HP2P3P5P17M3. try clear HP2P3P5P17m4. try clear HP2P3P5P17m3. try clear HP2P3P5P17m2. try clear HP2P3P5P17m1. try clear HP2P3P4P5P9P17M1. try clear HP2P3P4P5P9P17M2. try clear HP2P3P4P5P9P17M3. try clear HP2P3P4P5P9P17m4. try clear HP2P3P4P5P9P17m3. try clear HP2P3P4P5P9P17m2. try clear HP2P3P4P5P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P9P17m2 : rk(P2 :: P9 :: P17 :: nil) >= 2).
{
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P9 :: nil) (P2 :: P9 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P9 :: nil) (P2 :: P9 :: P17 :: nil) 2 2 HP2P9mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P9P17m3 : rk(P2 :: P9 :: P17 :: nil) >= 3).
{
	try assert(HP3P5P9P17eq : rk(P3 :: P5 :: P9 :: P17 :: nil) = 3) by (apply LP3P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP3P5P9P17Mtmp : rk(P3 :: P5 :: P9 :: P17 :: nil) <= 3) by (solve_hyps_max HP3P5P9P17eq HP3P5P9P17M3).
	try assert(HP2P3P5P9P17eq : rk(P2 :: P3 :: P5 :: P9 :: P17 :: nil) = 4) by (apply LP2P3P5P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P5P9P17mtmp : rk(P2 :: P3 :: P5 :: P9 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P5P9P17eq HP2P3P5P9P17m4).
	try assert(HP9P17eq : rk(P9 :: P17 :: nil) = 2) by (apply LP9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP9P17mtmp : rk(P9 :: P17 :: nil) >= 2) by (solve_hyps_min HP9P17eq HP9P17m2).
	assert(Hincl : incl (P9 :: P17 :: nil) (list_inter (P2 :: P9 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P5 :: P9 :: P17 :: nil) (P2 :: P9 :: P17 :: P3 :: P5 :: P9 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P9 :: P17 :: P3 :: P5 :: P9 :: P17 :: nil) ((P2 :: P9 :: P17 :: nil) ++ (P3 :: P5 :: P9 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P5P9P17mtmp;try rewrite HT2 in HP2P3P5P9P17mtmp.
	assert(HT := rule_2 (P2 :: P9 :: P17 :: nil) (P3 :: P5 :: P9 :: P17 :: nil) (P9 :: P17 :: nil) 4 2 3 HP2P3P5P9P17mtmp HP9P17mtmp HP3P5P9P17Mtmp Hincl);apply HT.
}
try clear HP3P5P9P17M1. try clear HP3P5P9P17M2. try clear HP3P5P9P17M3. try clear HP3P5P9P17m4. try clear HP3P5P9P17m3. try clear HP3P5P9P17m2. try clear HP3P5P9P17m1. try clear HP9P17M1. try clear HP9P17M2. try clear HP9P17M3. try clear HP9P17m4. try clear HP9P17m3. try clear HP9P17m2. try clear HP9P17m1. try clear HP2P3P5P9P17M1. try clear HP2P3P5P9P17M2. try clear HP2P3P5P9P17M3. try clear HP2P3P5P9P17m4. try clear HP2P3P5P9P17m3. try clear HP2P3P5P9P17m2. try clear HP2P3P5P9P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P9P10P11P17m2 : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P9P10P11P17m3 : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	try assert(HP2P6P9eq : rk(P2 :: P6 :: P9 :: nil) = 2) by (apply LP2P6P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P6P9Mtmp : rk(P2 :: P6 :: P9 :: nil) <= 2) by (solve_hyps_max HP2P6P9eq HP2P6P9M2).
	try assert(HP2P6P7P9P10P11P17eq : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP2P6P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P7P9P10P11P17mtmp : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P6P7P9P10P11P17eq HP2P6P7P9P10P11P17m3).
	try assert(HP2P9eq : rk(P2 :: P9 :: nil) = 2) by (apply LP2P9 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) ;try assumption).
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hincl : incl (P2 :: P9 :: nil) (list_inter (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P6 :: P9 :: P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) ((P2 :: P6 :: P9 :: nil) ++ (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P9P10P11P17mtmp;try rewrite HT2 in HP2P6P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P9 :: nil) 3 2 2 HP2P6P7P9P10P11P17mtmp HP2P9mtmp HP2P6P9Mtmp Hincl); apply HT.
}
try clear HP2P6P9M1. try clear HP2P6P9M2. try clear HP2P6P9M3. try clear HP2P6P9m4. try clear HP2P6P9m3. try clear HP2P6P9m2. try clear HP2P6P9m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P9P10P11P17m4 : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP2P6P9P17eq : rk(P2 :: P6 :: P9 :: P17 :: nil) = 3) by (apply LP2P6P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P9P17Mtmp : rk(P2 :: P6 :: P9 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P6P9P17eq HP2P6P9P17M3).
	try assert(HP2P6P7P9P10P11P17eq : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP2P6P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P6P7P9P10P11P17mtmp : rk(P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P6P7P9P10P11P17eq HP2P6P7P9P10P11P17m4).
	try assert(HP2P9P17eq : rk(P2 :: P9 :: P17 :: nil) = 3) by (apply LP2P9P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P9P17mtmp : rk(P2 :: P9 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P9P17eq HP2P9P17m3).
	assert(Hincl : incl (P2 :: P9 :: P17 :: nil) (list_inter (P2 :: P6 :: P9 :: P17 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P6 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P6 :: P9 :: P17 :: P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P6 :: P9 :: P17 :: P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) ((P2 :: P6 :: P9 :: P17 :: nil) ++ (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P6P7P9P10P11P17mtmp;try rewrite HT2 in HP2P6P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P2 :: P6 :: P9 :: P17 :: nil) (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P9 :: P17 :: nil) 4 3 3 HP2P6P7P9P10P11P17mtmp HP2P9P17mtmp HP2P6P9P17Mtmp Hincl); apply HT.
}
try clear HP2P6P9P17M1. try clear HP2P6P9P17M2. try clear HP2P6P9P17M3. try clear HP2P6P9P17m4. try clear HP2P6P9P17m3. try clear HP2P6P9P17m2. try clear HP2P6P9P17m1. try clear HP2P9P17M1. try clear HP2P9P17M2. try clear HP2P9P17M3. try clear HP2P9P17m4. try clear HP2P9P17m3. try clear HP2P9P17m2. try clear HP2P9P17m1. try clear HP2P6P7P9P10P11P17M1. try clear HP2P6P7P9P10P11P17M2. try clear HP2P6P7P9P10P11P17M3. try clear HP2P6P7P9P10P11P17m4. try clear HP2P6P7P9P10P11P17m3. try clear HP2P6P7P9P10P11P17m2. try clear HP2P6P7P9P10P11P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P10P17m2 : rk(P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P5P10P17m3 : rk(P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP2P3P5mtmp : rk(P2 :: P3 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P3P5eq HP2P3P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P5 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) 3 3 HP2P3P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P5M1. try clear HP2P3P5M2. try clear HP2P3P5M3. try clear HP2P3P5m4. try clear HP2P3P5m3. try clear HP2P3P5m2. try clear HP2P3P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P5P10P17m4 : rk(P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P5P17eq : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP1P2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P5P17Mtmp : rk(P1 :: P2 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P5P17eq HP1P2P4P5P17M4).
	try assert(HP1P2P3P4P5P10P17eq : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) = 4) by (apply LP1P2P3P4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P5P10P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P5P10P17eq HP1P2P3P4P5P10P17m4).
	try assert(HP2P4P5P17eq : rk(P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P17mtmp : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P17eq HP2P4P5P17m4).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P1 :: P2 :: P4 :: P5 :: P17 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P5 :: P17 :: P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) ((P1 :: P2 :: P4 :: P5 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P5P10P17mtmp;try rewrite HT2 in HP1P2P3P4P5P10P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P5 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P2 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP1P2P3P4P5P10P17mtmp HP2P4P5P17mtmp HP1P2P4P5P17Mtmp Hincl); apply HT.
}
try clear HP1P2P4P5P17M1. try clear HP1P2P4P5P17M2. try clear HP1P2P4P5P17M3. try clear HP1P2P4P5P17m4. try clear HP1P2P4P5P17m3. try clear HP1P2P4P5P17m2. try clear HP1P2P4P5P17m1. try clear HP1P2P3P4P5P10P17M1. try clear HP1P2P3P4P5P10P17M2. try clear HP1P2P3P4P5P10P17M3. try clear HP1P2P3P4P5P10P17m4. try clear HP1P2P3P4P5P10P17m3. try clear HP1P2P3P4P5P10P17m2. try clear HP1P2P3P4P5P10P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10P17m2 : rk(P2 :: P4 :: P5 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P5P10P17m3 : rk(P2 :: P4 :: P5 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP2P4P5mtmp : rk(P2 :: P4 :: P5 :: nil) >= 3) by (solve_hyps_min HP2P4P5eq HP2P4P5m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P5 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil) 3 3 HP2P4P5mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P5M1. try clear HP2P4P5M2. try clear HP2P4P5M3. try clear HP2P4P5m4. try clear HP2P4P5m3. try clear HP2P4P5m2. try clear HP2P4P5m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P4P5P10P17m4 : rk(P2 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P4P5P17eq : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP2P3P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P17Mtmp : rk(P2 :: P3 :: P4 :: P5 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P4P5P17eq HP2P3P4P5P17M4).
	try assert(HP2P3P4P5P10P17eq : rk(P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) = 4) by (apply LP2P3P4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P5P10P17mtmp : rk(P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P5P10P17eq HP2P3P4P5P10P17m4).
	try assert(HP2P4P5P17eq : rk(P2 :: P4 :: P5 :: P17 :: nil) = 4) by (apply LP2P4P5P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P17mtmp : rk(P2 :: P4 :: P5 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P17eq HP2P4P5P17m4).
	assert(Hincl : incl (P2 :: P4 :: P5 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P5 :: P10 :: P17 :: nil) (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P5 :: P17 :: P2 :: P4 :: P5 :: P10 :: P17 :: nil) ((P2 :: P3 :: P4 :: P5 :: P17 :: nil) ++ (P2 :: P4 :: P5 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P5P10P17mtmp;try rewrite HT2 in HP2P3P4P5P10P17mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P5 :: P17 :: nil) (P2 :: P4 :: P5 :: P10 :: P17 :: nil) (P2 :: P4 :: P5 :: P17 :: nil) 4 4 4 HP2P3P4P5P10P17mtmp HP2P4P5P17mtmp HP2P3P4P5P17Mtmp Hincl); apply HT.
}
try clear HP2P3P4P5P17M1. try clear HP2P3P4P5P17M2. try clear HP2P3P4P5P17M3. try clear HP2P3P4P5P17m4. try clear HP2P3P4P5P17m3. try clear HP2P3P4P5P17m2. try clear HP2P3P4P5P17m1. try clear HP2P4P5P17M1. try clear HP2P4P5P17M2. try clear HP2P4P5P17M3. try clear HP2P4P5P17m4. try clear HP2P4P5P17m3. try clear HP2P4P5P17m2. try clear HP2P4P5P17m1. try clear HP2P3P4P5P10P17M1. try clear HP2P3P4P5P10P17M2. try clear HP2P3P4P5P10P17M3. try clear HP2P3P4P5P10P17m4. try clear HP2P3P4P5P10P17m3. try clear HP2P3P4P5P10P17m2. try clear HP2P3P4P5P10P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P10P17m2 : rk(P2 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P10 :: nil) (P2 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P10 :: nil) (P2 :: P10 :: P17 :: nil) 2 2 HP2P10mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P10P17m3 : rk(P2 :: P10 :: P17 :: nil) >= 3).
{
	try assert(HP4P5P10P17eq : rk(P4 :: P5 :: P10 :: P17 :: nil) = 3) by (apply LP4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP4P5P10P17Mtmp : rk(P4 :: P5 :: P10 :: P17 :: nil) <= 3) by (solve_hyps_max HP4P5P10P17eq HP4P5P10P17M3).
	try assert(HP2P4P5P10P17eq : rk(P2 :: P4 :: P5 :: P10 :: P17 :: nil) = 4) by (apply LP2P4P5P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P5P10P17mtmp : rk(P2 :: P4 :: P5 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P5P10P17eq HP2P4P5P10P17m4).
	try assert(HP10P17eq : rk(P10 :: P17 :: nil) = 2) by (apply LP10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP10P17mtmp : rk(P10 :: P17 :: nil) >= 2) by (solve_hyps_min HP10P17eq HP10P17m2).
	assert(Hincl : incl (P10 :: P17 :: nil) (list_inter (P2 :: P10 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P5 :: P10 :: P17 :: nil) (P2 :: P10 :: P17 :: P4 :: P5 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P10 :: P17 :: P4 :: P5 :: P10 :: P17 :: nil) ((P2 :: P10 :: P17 :: nil) ++ (P4 :: P5 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P5P10P17mtmp;try rewrite HT2 in HP2P4P5P10P17mtmp.
	assert(HT := rule_2 (P2 :: P10 :: P17 :: nil) (P4 :: P5 :: P10 :: P17 :: nil) (P10 :: P17 :: nil) 4 2 3 HP2P4P5P10P17mtmp HP10P17mtmp HP4P5P10P17Mtmp Hincl);apply HT.
}
try clear HP4P5P10P17M1. try clear HP4P5P10P17M2. try clear HP4P5P10P17M3. try clear HP4P5P10P17m4. try clear HP4P5P10P17m3. try clear HP4P5P10P17m2. try clear HP4P5P10P17m1. try clear HP10P17M1. try clear HP10P17M2. try clear HP10P17M3. try clear HP10P17m4. try clear HP10P17m3. try clear HP10P17m2. try clear HP10P17m1. try clear HP2P4P5P10P17M1. try clear HP2P4P5P10P17M2. try clear HP2P4P5P10P17M3. try clear HP2P4P5P10P17m4. try clear HP2P4P5P10P17m3. try clear HP2P4P5P10P17m2. try clear HP2P4P5P10P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P8P17m2 : rk(P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P8P17m3 : rk(P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P8P17m4 : rk(P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P13P14P17m2 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P13P14P17m3 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P13P14P17m4 : rk(P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP1P2P7P13mtmp : rk(P1 :: P2 :: P7 :: P13 :: nil) >= 4) by (solve_hyps_min HP1P2P7P13eq HP1P2P7P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P13 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P13 :: nil) (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP1P2P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7P13M1. try clear HP1P2P7P13M2. try clear HP1P2P7P13M3. try clear HP1P2P7P13m4. try clear HP1P2P7P13m3. try clear HP1P2P7P13m2. try clear HP1P2P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P17m2 : rk(P1 :: P2 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P17m3 : rk(P1 :: P2 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P7P17m4 : rk(P1 :: P2 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP1P2P7P13P14P17eq : rk(P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP1P2P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P7P13P14P17mtmp : rk(P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P7P13P14P17eq HP1P2P7P13P14P17m4).
	try assert(HP7P17eq : rk(P7 :: P17 :: nil) = 2) by (apply LP7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P17mtmp : rk(P7 :: P17 :: nil) >= 2) by (solve_hyps_min HP7P17eq HP7P17m2).
	assert(Hincl : incl (P7 :: P17 :: nil) (list_inter (P1 :: P2 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P7 :: P13 :: P14 :: P17 :: nil) (P1 :: P2 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P1 :: P2 :: P7 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P7P13P14P17mtmp;try rewrite HT2 in HP1P2P7P13P14P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: P17 :: nil) 4 2 2 HP1P2P7P13P14P17mtmp HP7P17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP1P2P7P13P14P17M1. try clear HP1P2P7P13P14P17M2. try clear HP1P2P7P13P14P17M3. try clear HP1P2P7P13P14P17m4. try clear HP1P2P7P13P14P17m3. try clear HP1P2P7P13P14P17m2. try clear HP1P2P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P17m2 : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P17m3 : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P7P8P17m4 : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P17m2 : rk(P1 :: P2 :: P3 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P7 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P7P17m3 : rk(P1 :: P2 :: P3 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P7 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P3P7P17m4 : rk(P1 :: P2 :: P3 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P7P8P17eq : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P7P8P17Mtmp : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P7P8P17eq HP1P2P7P8P17M4).
	try assert(HP1P2P3P7P8P17eq : rk(P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P3P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P7P8P17mtmp : rk(P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P7P8P17eq HP1P2P3P7P8P17m4).
	try assert(HP1P2P7P17eq : rk(P1 :: P2 :: P7 :: P17 :: nil) = 4) by (apply LP1P2P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P7P17mtmp : rk(P1 :: P2 :: P7 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P7P17eq HP1P2P7P17m4).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P17 :: nil) (list_inter (P1 :: P2 :: P3 :: P7 :: P17 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) (P1 :: P2 :: P3 :: P7 :: P17 :: P1 :: P2 :: P7 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P3 :: P7 :: P17 :: P1 :: P2 :: P7 :: P8 :: P17 :: nil) ((P1 :: P2 :: P3 :: P7 :: P17 :: nil) ++ (P1 :: P2 :: P7 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P7P8P17mtmp;try rewrite HT2 in HP1P2P3P7P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P3 :: P7 :: P17 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil) (P1 :: P2 :: P7 :: P17 :: nil) 4 4 4 HP1P2P3P7P8P17mtmp HP1P2P7P17mtmp HP1P2P7P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P3P7P8P17M1. try clear HP1P2P3P7P8P17M2. try clear HP1P2P3P7P8P17M3. try clear HP1P2P3P7P8P17m4. try clear HP1P2P3P7P8P17m3. try clear HP1P2P3P7P8P17m2. try clear HP1P2P3P7P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P7P10P17m2 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P3P4P7P10P17m3 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 3 *)
assert(HP1P2P3P4P7P10P17m4 : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 4).
{
	assert(HP1P2P3P7P17mtmp : rk(P1 :: P2 :: P3 :: P7 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P7P17eq HP1P2P3P7P17m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P3 :: P7 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P3 :: P7 :: P17 :: nil) (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) 4 4 HP1P2P3P7P17mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P3P7P17M1. try clear HP1P2P3P7P17M2. try clear HP1P2P3P7P17M3. try clear HP1P2P3P7P17m4. try clear HP1P2P3P7P17m3. try clear HP1P2P3P7P17m2. try clear HP1P2P3P7P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P13P14P17m2 : rk(P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P13P14P17m3 : rk(P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P4P7mtmp : rk(P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P4P7eq HP2P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P4P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P13P14P17m4 : rk(P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4).
{
	assert(HP2P4P7P13mtmp : rk(P2 :: P4 :: P7 :: P13 :: nil) >= 4) by (solve_hyps_min HP2P4P7P13eq HP2P4P7P13m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: P13 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: P13 :: nil) (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) 4 4 HP2P4P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P7P13M1. try clear HP2P4P7P13M2. try clear HP2P4P7P13M3. try clear HP2P4P7P13m4. try clear HP2P4P7P13m3. try clear HP2P4P7P13m2. try clear HP2P4P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P17m2 : rk(P2 :: P4 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP2P4mtmp : rk(P2 :: P4 :: nil) >= 2) by (solve_hyps_min HP2P4eq HP2P4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: nil) (P2 :: P4 :: P7 :: P17 :: nil) 2 2 HP2P4mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4M1. try clear HP2P4M2. try clear HP2P4M3. try clear HP2P4m4. try clear HP2P4m3. try clear HP2P4m2. try clear HP2P4m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P4P7P17m3 : rk(P2 :: P4 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP2P4P7mtmp : rk(P2 :: P4 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P4P7eq HP2P4P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P4 :: P7 :: nil) (P2 :: P4 :: P7 :: P17 :: nil) 3 3 HP2P4P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P4P7M1. try clear HP2P4P7M2. try clear HP2P4P7M3. try clear HP2P4P7m4. try clear HP2P4P7m3. try clear HP2P4P7m2. try clear HP2P4P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P4P7P17m4 : rk(P2 :: P4 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP2P4P7P13P14P17eq : rk(P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P4P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P7P13P14P17mtmp : rk(P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P7P13P14P17eq HP2P4P7P13P14P17m4).
	try assert(HP7P17eq : rk(P7 :: P17 :: nil) = 2) by (apply LP7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P17mtmp : rk(P7 :: P17 :: nil) >= 2) by (solve_hyps_min HP7P17eq HP7P17m2).
	assert(Hincl : incl (P7 :: P17 :: nil) (list_inter (P2 :: P4 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P4 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P4 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P4 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P4 :: P7 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P4P7P13P14P17mtmp;try rewrite HT2 in HP2P4P7P13P14P17mtmp.
	assert(HT := rule_2 (P2 :: P4 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: P17 :: nil) 4 2 2 HP2P4P7P13P14P17mtmp HP7P17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP2P4P7P13P14P17M1. try clear HP2P4P7P13P14P17M2. try clear HP2P4P7P13P14P17M3. try clear HP2P4P7P13P14P17m4. try clear HP2P4P7P13P14P17m3. try clear HP2P4P7P13P14P17m2. try clear HP2P4P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P7P8P17m2 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P7P8P17m3 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P7P8P17m4 : rk(P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP1P2P7P8mtmp : rk(P1 :: P2 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP1P2P7P8eq HP1P2P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: P8 :: nil) (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) 4 4 HP1P2P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7P8M1. try clear HP1P2P7P8M2. try clear HP1P2P7P8M3. try clear HP1P2P7P8m4. try clear HP1P2P7P8m3. try clear HP1P2P7P8m2. try clear HP1P2P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P7P17m2 : rk(P1 :: P2 :: P4 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP1P2mtmp : rk(P1 :: P2 :: nil) >= 2) by (solve_hyps_min HP1P2eq HP1P2m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: nil) 2 2 HP1P2mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2M1. try clear HP1P2M2. try clear HP1P2M3. try clear HP1P2m4. try clear HP1P2m3. try clear HP1P2m2. try clear HP1P2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP1P2P4P7P17m3 : rk(P1 :: P2 :: P4 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP1P2P7mtmp : rk(P1 :: P2 :: P7 :: nil) >= 3) by (solve_hyps_min HP1P2P7eq HP1P2P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P1 :: P2 :: P7 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: nil) 3 3 HP1P2P7mtmp Hcomp Hincl);apply HT.
}
try clear HP1P2P7M1. try clear HP1P2P7M2. try clear HP1P2P7M3. try clear HP1P2P7m4. try clear HP1P2P7m3. try clear HP1P2P7m2. try clear HP1P2P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP1P2P4P7P17m4 : rk(P1 :: P2 :: P4 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P7P8P17eq : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P7P8P17Mtmp : rk(P1 :: P2 :: P7 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P7P8P17eq HP1P2P7P8P17M4).
	try assert(HP1P2P4P7P8P17eq : rk(P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP1P2P4P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P7P8P17mtmp : rk(P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P4P7P8P17eq HP1P2P4P7P8P17m4).
	try assert(HP1P2P7P17eq : rk(P1 :: P2 :: P7 :: P17 :: nil) = 4) by (apply LP1P2P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P7P17mtmp : rk(P1 :: P2 :: P7 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P7P17eq HP1P2P7P17m4).
	assert(Hincl : incl (P1 :: P2 :: P7 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: P17 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P4 :: P7 :: P8 :: P17 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: P1 :: P2 :: P7 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P17 :: P1 :: P2 :: P7 :: P8 :: P17 :: nil) ((P1 :: P2 :: P4 :: P7 :: P17 :: nil) ++ (P1 :: P2 :: P7 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P4P7P8P17mtmp;try rewrite HT2 in HP1P2P4P7P8P17mtmp.
	assert(HT := rule_2 (P1 :: P2 :: P4 :: P7 :: P17 :: nil) (P1 :: P2 :: P7 :: P8 :: P17 :: nil) (P1 :: P2 :: P7 :: P17 :: nil) 4 4 4 HP1P2P4P7P8P17mtmp HP1P2P7P17mtmp HP1P2P7P8P17Mtmp Hincl);apply HT.
}
try clear HP1P2P7P8P17M1. try clear HP1P2P7P8P17M2. try clear HP1P2P7P8P17M3. try clear HP1P2P7P8P17m4. try clear HP1P2P7P8P17m3. try clear HP1P2P7P8P17m2. try clear HP1P2P7P8P17m1. try clear HP1P2P7P17M1. try clear HP1P2P7P17M2. try clear HP1P2P7P17M3. try clear HP1P2P7P17m4. try clear HP1P2P7P17m3. try clear HP1P2P7P17m2. try clear HP1P2P7P17m1. try clear HP1P2P4P7P8P17M1. try clear HP1P2P4P7P8P17M2. try clear HP1P2P4P7P8P17M3. try clear HP1P2P4P7P8P17m4. try clear HP1P2P4P7P8P17m3. try clear HP1P2P4P7P8P17m2. try clear HP1P2P4P7P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P10P17m2 : rk(P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P10P17m3 : rk(P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P7P10P17m4 : rk(P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 4).
{
	try assert(HP1P2P4P7P17eq : rk(P1 :: P2 :: P4 :: P7 :: P17 :: nil) = 4) by (apply LP1P2P4P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P4P7P17Mtmp : rk(P1 :: P2 :: P4 :: P7 :: P17 :: nil) <= 4) by (solve_hyps_max HP1P2P4P7P17eq HP1P2P4P7P17M4).
	try assert(HP1P2P3P4P7P10P17eq : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) = 4) by (apply LP1P2P3P4P7P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP1P2P3P4P7P10P17mtmp : rk(P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP1P2P3P4P7P10P17eq HP1P2P3P4P7P10P17m4).
	try assert(HP2P4P7P17eq : rk(P2 :: P4 :: P7 :: P17 :: nil) = 4) by (apply LP2P4P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P4P7P17mtmp : rk(P2 :: P4 :: P7 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P4P7P17eq HP2P4P7P17m4).
	assert(Hincl : incl (P2 :: P4 :: P7 :: P17 :: nil) (list_inter (P1 :: P2 :: P4 :: P7 :: P17 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P1 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) (P1 :: P2 :: P4 :: P7 :: P17 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P1 :: P2 :: P4 :: P7 :: P17 :: P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) ((P1 :: P2 :: P4 :: P7 :: P17 :: nil) ++ (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP1P2P3P4P7P10P17mtmp;try rewrite HT2 in HP1P2P3P4P7P10P17mtmp.
	assert(HT := rule_4 (P1 :: P2 :: P4 :: P7 :: P17 :: nil) (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) (P2 :: P4 :: P7 :: P17 :: nil) 4 4 4 HP1P2P3P4P7P10P17mtmp HP2P4P7P17mtmp HP1P2P4P7P17Mtmp Hincl); apply HT.
}
try clear HP1P2P4P7P17M1. try clear HP1P2P4P7P17M2. try clear HP1P2P4P7P17M3. try clear HP1P2P4P7P17m4. try clear HP1P2P4P7P17m3. try clear HP1P2P4P7P17m2. try clear HP1P2P4P7P17m1. try clear HP2P4P7P17M1. try clear HP2P4P7P17M2. try clear HP2P4P7P17M3. try clear HP2P4P7P17m4. try clear HP2P4P7P17m3. try clear HP2P4P7P17m2. try clear HP2P4P7P17m1. try clear HP1P2P3P4P7P10P17M1. try clear HP1P2P3P4P7P10P17M2. try clear HP1P2P3P4P7P10P17M3. try clear HP1P2P3P4P7P10P17m4. try clear HP1P2P3P4P7P10P17m3. try clear HP1P2P3P4P7P10P17m2. try clear HP1P2P3P4P7P10P17m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P13P14P17M3 : rk(P2 :: P7 :: P13 :: P14 :: P17 :: nil) <= 3).
{
	try assert(HP2eq : rk(P2 :: nil) = 1) by (apply LP2 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2Mtmp : rk(P2 :: nil) <= 1) by (solve_hyps_max HP2eq HP2M1).
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (nil) 1 2 0 HP2Mtmp HP7P13P14P17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP2M1. try clear HP2M2. try clear HP2M3. try clear HP2m4. try clear HP2m3. try clear HP2m2. try clear HP2m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P13P14P17m2 : rk(P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P13 :: P14 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P13P14P17m3 : rk(P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3).
{
	assert(HP2P7P13mtmp : rk(P2 :: P7 :: P13 :: nil) >= 3) by (solve_hyps_min HP2P7P13eq HP2P7P13m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: P13 :: nil) (P2 :: P7 :: P13 :: P14 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: P13 :: nil) (P2 :: P7 :: P13 :: P14 :: P17 :: nil) 3 3 HP2P7P13mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7P13M1. try clear HP2P7P13M2. try clear HP2P7P13M3. try clear HP2P7P13m4. try clear HP2P7P13m3. try clear HP2P7P13m2. try clear HP2P7P13m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P17m2 : rk(P2 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P7P17m3 : rk(P2 :: P7 :: P17 :: nil) >= 3).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP2P7P13P14P17eq : rk(P2 :: P7 :: P13 :: P14 :: P17 :: nil) = 3) by (apply LP2P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P13P14P17mtmp : rk(P2 :: P7 :: P13 :: P14 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P7P13P14P17eq HP2P7P13P14P17m3).
	try assert(HP7P17eq : rk(P7 :: P17 :: nil) = 2) by (apply LP7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P17mtmp : rk(P7 :: P17 :: nil) >= 2) by (solve_hyps_min HP7P17eq HP7P17m2).
	assert(Hincl : incl (P7 :: P17 :: nil) (list_inter (P2 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P7 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P13P14P17mtmp;try rewrite HT2 in HP2P7P13P14P17mtmp.
	assert(HT := rule_2 (P2 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: P17 :: nil) 3 2 2 HP2P7P13P14P17mtmp HP7P17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP2P7P13P14P17M1. try clear HP2P7P13P14P17M2. try clear HP2P7P13P14P17M3. try clear HP2P7P13P14P17m4. try clear HP2P7P13P14P17m3. try clear HP2P7P13P14P17m2. try clear HP2P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P8P17m2 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P8P17m3 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P8P17m4 : rk(P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P7P8mtmp : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8eq HP2P3P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) 4 4 HP2P3P7P8mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P17m2 : rk(P2 :: P3 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P17m3 : rk(P2 :: P3 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P7P17m4 : rk(P2 :: P3 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP7P13P14P17eq : rk(P7 :: P13 :: P14 :: P17 :: nil) = 2) by (apply LP7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P13P14P17Mtmp : rk(P7 :: P13 :: P14 :: P17 :: nil) <= 2) by (solve_hyps_max HP7P13P14P17eq HP7P13P14P17M2).
	try assert(HP2P3P7P13P14P17eq : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) = 4) by (apply LP2P3P7P13P14P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P7P13P14P17mtmp : rk(P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P7P13P14P17eq HP2P3P7P13P14P17m4).
	try assert(HP7P17eq : rk(P7 :: P17 :: nil) = 2) by (apply LP7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP7P17mtmp : rk(P7 :: P17 :: nil) >= 2) by (solve_hyps_min HP7P17eq HP7P17m2).
	assert(Hincl : incl (P7 :: P17 :: nil) (list_inter (P2 :: P3 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P7 :: P13 :: P14 :: P17 :: nil) (P2 :: P3 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P7 :: P17 :: P7 :: P13 :: P14 :: P17 :: nil) ((P2 :: P3 :: P7 :: P17 :: nil) ++ (P7 :: P13 :: P14 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P7P13P14P17mtmp;try rewrite HT2 in HP2P3P7P13P14P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P7 :: P17 :: nil) (P7 :: P13 :: P14 :: P17 :: nil) (P7 :: P17 :: nil) 4 2 2 HP2P3P7P13P14P17mtmp HP7P17mtmp HP7P13P14P17Mtmp Hincl);apply HT.
}
try clear HP7P13P14P17M1. try clear HP7P13P14P17M2. try clear HP7P13P14P17M3. try clear HP7P13P14P17m4. try clear HP7P13P14P17m3. try clear HP7P13P14P17m2. try clear HP7P13P14P17m1. try clear HP7P17M1. try clear HP7P17M2. try clear HP7P17M3. try clear HP7P17m4. try clear HP7P17m3. try clear HP7P17m2. try clear HP7P17m1. try clear HP2P3P7P13P14P17M1. try clear HP2P3P7P13P14P17M2. try clear HP2P3P7P13P14P17M3. try clear HP2P3P7P13P14P17m4. try clear HP2P3P7P13P14P17m3. try clear HP2P3P7P13P14P17m2. try clear HP2P3P7P13P14P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P17m2 : rk(P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P17m3 : rk(P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P7P8P17m4 : rk(P2 :: P3 :: P7 :: P8 :: P17 :: nil) >= 4).
{
	assert(HP2P3P7P8mtmp : rk(P2 :: P3 :: P7 :: P8 :: nil) >= 4) by (solve_hyps_min HP2P3P7P8eq HP2P3P7P8m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: P8 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil) 4 4 HP2P3P7P8mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P7P8M1. try clear HP2P3P7P8M2. try clear HP2P3P7P8M3. try clear HP2P3P7P8m4. try clear HP2P3P7P8m3. try clear HP2P3P7P8m2. try clear HP2P3P7P8m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P17m2 : rk(P2 :: P3 :: P4 :: P7 :: P17 :: nil) >= 2).
{
	assert(HP2P3mtmp : rk(P2 :: P3 :: nil) >= 2) by (solve_hyps_min HP2P3eq HP2P3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: nil) 2 2 HP2P3mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3M1. try clear HP2P3M2. try clear HP2P3M3. try clear HP2P3m4. try clear HP2P3m3. try clear HP2P3m2. try clear HP2P3m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P3P4P7P17m3 : rk(P2 :: P3 :: P4 :: P7 :: P17 :: nil) >= 3).
{
	assert(HP2P3P7mtmp : rk(P2 :: P3 :: P7 :: nil) >= 3) by (solve_hyps_min HP2P3P7eq HP2P3P7m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P3 :: P7 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: nil) 3 3 HP2P3P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P3P7M1. try clear HP2P3P7M2. try clear HP2P3P7M3. try clear HP2P3P7m4. try clear HP2P3P7m3. try clear HP2P3P7m2. try clear HP2P3P7m1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) *)
assert(HP2P3P4P7P17m4 : rk(P2 :: P3 :: P4 :: P7 :: P17 :: nil) >= 4).
{
	try assert(HP2P3P7P8P17eq : rk(P2 :: P3 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P7P8P17Mtmp : rk(P2 :: P3 :: P7 :: P8 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P7P8P17eq HP2P3P7P8P17M4).
	try assert(HP2P3P4P7P8P17eq : rk(P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) = 4) by (apply LP2P3P4P7P8P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P7P8P17mtmp : rk(P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P7P8P17eq HP2P3P4P7P8P17m4).
	try assert(HP2P3P7P17eq : rk(P2 :: P3 :: P7 :: P17 :: nil) = 4) by (apply LP2P3P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P7P17mtmp : rk(P2 :: P3 :: P7 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P7P17eq HP2P3P7P17m4).
	assert(Hincl : incl (P2 :: P3 :: P7 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P7 :: P17 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P7 :: P8 :: P17 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P7 :: P17 :: P2 :: P3 :: P7 :: P8 :: P17 :: nil) ((P2 :: P3 :: P4 :: P7 :: P17 :: nil) ++ (P2 :: P3 :: P7 :: P8 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P7P8P17mtmp;try rewrite HT2 in HP2P3P4P7P8P17mtmp.
	assert(HT := rule_2 (P2 :: P3 :: P4 :: P7 :: P17 :: nil) (P2 :: P3 :: P7 :: P8 :: P17 :: nil) (P2 :: P3 :: P7 :: P17 :: nil) 4 4 4 HP2P3P4P7P8P17mtmp HP2P3P7P17mtmp HP2P3P7P8P17Mtmp Hincl);apply HT.
}
try clear HP2P3P7P8P17M1. try clear HP2P3P7P8P17M2. try clear HP2P3P7P8P17M3. try clear HP2P3P7P8P17m4. try clear HP2P3P7P8P17m3. try clear HP2P3P7P8P17m2. try clear HP2P3P7P8P17m1. try clear HP2P3P7P17M1. try clear HP2P3P7P17M2. try clear HP2P3P7P17M3. try clear HP2P3P7P17m4. try clear HP2P3P7P17m3. try clear HP2P3P7P17m2. try clear HP2P3P7P17m1. try clear HP2P3P4P7P8P17M1. try clear HP2P3P4P7P8P17M2. try clear HP2P3P4P7P8P17M3. try clear HP2P3P4P7P8P17m4. try clear HP2P3P4P7P8P17m3. try clear HP2P3P4P7P8P17m2. try clear HP2P3P4P7P8P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P7P10P17m2 : rk(P2 :: P7 :: P10 :: P17 :: nil) >= 2).
{
	assert(HP2P7mtmp : rk(P2 :: P7 :: nil) >= 2) by (solve_hyps_min HP2P7eq HP2P7m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P7 :: nil) (P2 :: P7 :: P10 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P7 :: nil) (P2 :: P7 :: P10 :: P17 :: nil) 2 2 HP2P7mtmp Hcomp Hincl);apply HT.
}
try clear HP2P7M1. try clear HP2P7M2. try clear HP2P7M3. try clear HP2P7m4. try clear HP2P7m3. try clear HP2P7m2. try clear HP2P7m1. 

(* Application de la règle 1 code (5 dans la thèse) *)
assert(HP2P7P10P17M3 : rk(P2 :: P7 :: P10 :: P17 :: nil) <= 3).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP17eq : rk(P17 :: nil) = 1) by (apply LP17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP17Mtmp : rk(P17 :: nil) <= 1) by (solve_hyps_max HP17eq HP17M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P7 :: P10 :: nil) (P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P10 :: P17 :: nil) (P2 :: P7 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P17 :: nil) ((P2 :: P7 :: P10 :: nil) ++ (P17 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P2 :: P7 :: P10 :: nil) (P17 :: nil) (nil) 2 1 0 HP2P7P10Mtmp HP17Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HP17M1. try clear HP17M2. try clear HP17M3. try clear HP17m4. try clear HP17m3. try clear HP17m2. try clear HP17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P7P10P17m3 : rk(P2 :: P7 :: P10 :: P17 :: nil) >= 3).
{
	try assert(HP2P3P4P7P17eq : rk(P2 :: P3 :: P4 :: P7 :: P17 :: nil) = 4) by (apply LP2P3P4P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P7P17Mtmp : rk(P2 :: P3 :: P4 :: P7 :: P17 :: nil) <= 4) by (solve_hyps_max HP2P3P4P7P17eq HP2P3P4P7P17M4).
	try assert(HP2P3P4P7P10P17eq : rk(P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) = 4) by (apply LP2P3P4P7P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P3P4P7P10P17mtmp : rk(P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P3P4P7P10P17eq HP2P3P4P7P10P17m4).
	try assert(HP2P7P17eq : rk(P2 :: P7 :: P17 :: nil) = 3) by (apply LP2P7P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P17mtmp : rk(P2 :: P7 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P7P17eq HP2P7P17m3).
	assert(Hincl : incl (P2 :: P7 :: P17 :: nil) (list_inter (P2 :: P3 :: P4 :: P7 :: P17 :: nil) (P2 :: P7 :: P10 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P3 :: P4 :: P7 :: P10 :: P17 :: nil) (P2 :: P3 :: P4 :: P7 :: P17 :: P2 :: P7 :: P10 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P3 :: P4 :: P7 :: P17 :: P2 :: P7 :: P10 :: P17 :: nil) ((P2 :: P3 :: P4 :: P7 :: P17 :: nil) ++ (P2 :: P7 :: P10 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P3P4P7P10P17mtmp;try rewrite HT2 in HP2P3P4P7P10P17mtmp.
	assert(HT := rule_4 (P2 :: P3 :: P4 :: P7 :: P17 :: nil) (P2 :: P7 :: P10 :: P17 :: nil) (P2 :: P7 :: P17 :: nil) 4 3 4 HP2P3P4P7P10P17mtmp HP2P7P17mtmp HP2P3P4P7P17Mtmp Hincl); apply HT.
}
try clear HP2P3P4P7P17M1. try clear HP2P3P4P7P17M2. try clear HP2P3P4P7P17M3. try clear HP2P3P4P7P17m4. try clear HP2P3P4P7P17m3. try clear HP2P3P4P7P17m2. try clear HP2P3P4P7P17m1. try clear HP2P7P17M1. try clear HP2P7P17M2. try clear HP2P7P17M3. try clear HP2P7P17m4. try clear HP2P7P17m3. try clear HP2P7P17m2. try clear HP2P7P17m1. try clear HP2P3P4P7P10P17M1. try clear HP2P3P4P7P10P17M2. try clear HP2P3P4P7P10P17M3. try clear HP2P3P4P7P10P17m4. try clear HP2P3P4P7P10P17m3. try clear HP2P3P4P7P10P17m2. try clear HP2P3P4P7P10P17m1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 2 *)
assert(HP2P9P10P11P17m2 : rk(P2 :: P9 :: P10 :: P11 :: P17 :: nil) >= 2).
{
	assert(HP2P9mtmp : rk(P2 :: P9 :: nil) >= 2) by (solve_hyps_min HP2P9eq HP2P9m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P2 :: P9 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P2 :: P9 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil) 2 2 HP2P9mtmp Hcomp Hincl);apply HT.
}
try clear HP2P9M1. try clear HP2P9M2. try clear HP2P9M3. try clear HP2P9m4. try clear HP2P9m3. try clear HP2P9m2. try clear HP2P9m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P9P10P11P17m3 : rk(P2 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3).
{
	try assert(HP2P7P10eq : rk(P2 :: P7 :: P10 :: nil) = 2) by (apply LP2P7P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P7P10Mtmp : rk(P2 :: P7 :: P10 :: nil) <= 2) by (solve_hyps_max HP2P7P10eq HP2P7P10M2).
	try assert(HP2P7P9P10P11P17eq : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP2P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P9P10P11P17mtmp : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P7P9P10P11P17eq HP2P7P9P10P11P17m3).
	try assert(HP2P10eq : rk(P2 :: P10 :: nil) = 2) by (apply LP2P10 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) ;try assumption).
	assert(HP2P10mtmp : rk(P2 :: P10 :: nil) >= 2) by (solve_hyps_min HP2P10eq HP2P10m2).
	assert(Hincl : incl (P2 :: P10 :: nil) (list_inter (P2 :: P7 :: P10 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P7 :: P10 :: P2 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P2 :: P9 :: P10 :: P11 :: P17 :: nil) ((P2 :: P7 :: P10 :: nil) ++ (P2 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P9P10P11P17mtmp;try rewrite HT2 in HP2P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P2 :: P7 :: P10 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P10 :: nil) 3 2 2 HP2P7P9P10P11P17mtmp HP2P10mtmp HP2P7P10Mtmp Hincl); apply HT.
}
try clear HP2P7P10M1. try clear HP2P7P10M2. try clear HP2P7P10M3. try clear HP2P7P10m4. try clear HP2P7P10m3. try clear HP2P7P10m2. try clear HP2P7P10m1. try clear HP2P10M1. try clear HP2P10M2. try clear HP2P10M3. try clear HP2P10m4. try clear HP2P10m3. try clear HP2P10m2. try clear HP2P10m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP2P9P10P11P17m4 : rk(P2 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4).
{
	try assert(HP2P7P10P17eq : rk(P2 :: P7 :: P10 :: P17 :: nil) = 3) by (apply LP2P7P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P10P17Mtmp : rk(P2 :: P7 :: P10 :: P17 :: nil) <= 3) by (solve_hyps_max HP2P7P10P17eq HP2P7P10P17M3).
	try assert(HP2P7P9P10P11P17eq : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP2P7P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P7P9P10P11P17mtmp : rk(P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P7P9P10P11P17eq HP2P7P9P10P11P17m4).
	try assert(HP2P10P17eq : rk(P2 :: P10 :: P17 :: nil) = 3) by (apply LP2P10P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P10P17mtmp : rk(P2 :: P10 :: P17 :: nil) >= 3) by (solve_hyps_min HP2P10P17eq HP2P10P17m3).
	assert(Hincl : incl (P2 :: P10 :: P17 :: nil) (list_inter (P2 :: P7 :: P10 :: P17 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P7 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P7 :: P10 :: P17 :: P2 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P7 :: P10 :: P17 :: P2 :: P9 :: P10 :: P11 :: P17 :: nil) ((P2 :: P7 :: P10 :: P17 :: nil) ++ (P2 :: P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P7P9P10P11P17mtmp;try rewrite HT2 in HP2P7P9P10P11P17mtmp.
	assert(HT := rule_4 (P2 :: P7 :: P10 :: P17 :: nil) (P2 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P10 :: P17 :: nil) 4 3 3 HP2P7P9P10P11P17mtmp HP2P10P17mtmp HP2P7P10P17Mtmp Hincl); apply HT.
}
try clear HP2P7P10P17M1. try clear HP2P7P10P17M2. try clear HP2P7P10P17M3. try clear HP2P7P10P17m4. try clear HP2P7P10P17m3. try clear HP2P7P10P17m2. try clear HP2P7P10P17m1. try clear HP2P10P17M1. try clear HP2P10P17M2. try clear HP2P10P17M3. try clear HP2P10P17m4. try clear HP2P10P17m3. try clear HP2P10P17m2. try clear HP2P10P17m1. try clear HP2P7P9P10P11P17M1. try clear HP2P7P9P10P11P17M2. try clear HP2P7P9P10P11P17M3. try clear HP2P7P9P10P11P17m4. try clear HP2P7P9P10P11P17m3. try clear HP2P7P9P10P11P17m2. try clear HP2P7P9P10P11P17m1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) *)
assert(HP9P10P11m2 : rk(P9 :: P10 :: P11 :: nil) >= 2).
{
	try assert(HP2P8eq : rk(P2 :: P8 :: nil) = 2) by (apply LP2P8 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) ;try assumption).
	assert(HP2P8Mtmp : rk(P2 :: P8 :: nil) <= 2) by (solve_hyps_max HP2P8eq HP2P8M2).
	try assert(HP2P8P9P10P11eq : rk(P2 :: P8 :: P9 :: P10 :: P11 :: nil) = 4) by (apply LP2P8P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P8P9P10P11mtmp : rk(P2 :: P8 :: P9 :: P10 :: P11 :: nil) >= 4) by (solve_hyps_min HP2P8P9P10P11eq HP2P8P9P10P11m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P2 :: P8 :: nil) (P9 :: P10 :: P11 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P8 :: P9 :: P10 :: P11 :: nil) (P2 :: P8 :: P9 :: P10 :: P11 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P8 :: P9 :: P10 :: P11 :: nil) ((P2 :: P8 :: nil) ++ (P9 :: P10 :: P11 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P8P9P10P11mtmp;try rewrite HT2 in HP2P8P9P10P11mtmp.
	assert(HT := rule_4 (P2 :: P8 :: nil) (P9 :: P10 :: P11 :: nil) (nil) 4 0 2 HP2P8P9P10P11mtmp Hmtmp HP2P8Mtmp Hincl); apply HT.
}
try clear HP2P8M1. try clear HP2P8M2. try clear HP2P8M3. try clear HP2P8m4. try clear HP2P8m3. try clear HP2P8m2. try clear HP2P8m1. try clear HP2P8P9P10P11M1. try clear HP2P8P9P10P11M2. try clear HP2P8P9P10P11M3. try clear HP2P8P9P10P11m4. try clear HP2P8P9P10P11m3. try clear HP2P8P9P10P11m2. try clear HP2P8P9P10P11m1. 

(* Application de la règle 3 code (6 dans la thèse) *)
assert(HP9P10P11M2 : rk(P9 :: P10 :: P11 :: nil) <= 2).
{
	try assert(HP2P9P10P11eq : rk(P2 :: P9 :: P10 :: P11 :: nil) = 3) by (apply LP2P9P10P11 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) ;try assumption).
	assert(HP2P9P10P11Mtmp : rk(P2 :: P9 :: P10 :: P11 :: nil) <= 3) by (solve_hyps_max HP2P9P10P11eq HP2P9P10P11M3).
	try assert(HP9P10P11P17eq : rk(P9 :: P10 :: P11 :: P17 :: nil) = 3) by (apply LP9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP9P10P11P17Mtmp : rk(P9 :: P10 :: P11 :: P17 :: nil) <= 3) by (solve_hyps_max HP9P10P11P17eq HP9P10P11P17M3).
	try assert(HP2P9P10P11P17eq : rk(P2 :: P9 :: P10 :: P11 :: P17 :: nil) = 4) by (apply LP2P9P10P11P17 with (P1 := P1) (P2 := P2) (P3 := P3) (P4 := P4) (P5 := P5) (P6 := P6) (P7 := P7) (P8 := P8) (P9 := P9) (P10 := P10) (P11 := P11) (P12 := P12) (P13 := P13) (P14 := P14) (P15 := P15) (P16 := P16) (P17 := P17) ;try assumption).
	assert(HP2P9P10P11P17mtmp : rk(P2 :: P9 :: P10 :: P11 :: P17 :: nil) >= 4) by (solve_hyps_min HP2P9P10P11P17eq HP2P9P10P11P17m4).
	assert(Hincl : incl (P9 :: P10 :: P11 :: nil) (list_inter (P2 :: P9 :: P10 :: P11 :: nil) (P9 :: P10 :: P11 :: P17 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P2 :: P9 :: P10 :: P11 :: P17 :: nil) (P2 :: P9 :: P10 :: P11 :: P9 :: P10 :: P11 :: P17 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P2 :: P9 :: P10 :: P11 :: P9 :: P10 :: P11 :: P17 :: nil) ((P2 :: P9 :: P10 :: P11 :: nil) ++ (P9 :: P10 :: P11 :: P17 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HP2P9P10P11P17mtmp;try rewrite HT2 in HP2P9P10P11P17mtmp.
	assert(HT := rule_3 (P2 :: P9 :: P10 :: P11 :: nil) (P9 :: P10 :: P11 :: P17 :: nil) (P9 :: P10 :: P11 :: nil) 3 3 4 HP2P9P10P11Mtmp HP9P10P11P17Mtmp HP2P9P10P11P17mtmp Hincl);apply HT.
}
try clear HP2P9P10P11M1. try clear HP2P9P10P11M2. try clear HP2P9P10P11M3. try clear HP2P9P10P11m4. try clear HP2P9P10P11m3. try clear HP2P9P10P11m2. try clear HP2P9P10P11m1. try clear HP9P10P11P17M1. try clear HP9P10P11P17M2. try clear HP9P10P11P17M3. try clear HP9P10P11P17m4. try clear HP9P10P11P17m3. try clear HP9P10P11P17m2. try clear HP9P10P11P17m1. try clear HP2P9P10P11P17M1. try clear HP2P9P10P11P17M2. try clear HP2P9P10P11P17M3. try clear HP2P9P10P11P17m4. try clear HP2P9P10P11P17m3. try clear HP2P9P10P11P17m2. try clear HP2P9P10P11P17m1. 

assert(HP9P10P11M : rk(P9 :: P10 :: P11 ::  nil) <= 3) by (solve_hyps_max HP9P10P11eq HP9P10P11M3).
assert(HP9P10P11m : rk(P9 :: P10 :: P11 ::  nil) >= 1) by (solve_hyps_min HP9P10P11eq HP9P10P11m1).
intuition.
Qed.

