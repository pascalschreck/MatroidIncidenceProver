Load "preamble3D.v".


(* dans la couche 0 *)
Lemma LPQRPp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPp requis par la preuve de (?)PQRPp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPp requis par la preuve de (?)PQRPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpm3 : rk(P :: Q :: R :: Pp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpM3 : rk(P :: Q :: R :: Pp :: nil) <= 3).
{
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpM : rk(P :: Q :: R :: Pp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpm : rk(P :: Q :: R :: Pp ::  nil) >= 1) by (solve_hyps_min HPQRPpeq HPQRPpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQp requis par la preuve de (?)PQRQp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQp requis par la preuve de (?)PQRQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpm3 : rk(P :: Q :: R :: Qp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpM3 : rk(P :: Q :: R :: Qp :: nil) <= 3).
{
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpM : rk(P :: Q :: R :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpm : rk(P :: Q :: R :: Qp ::  nil) >= 1) by (solve_hyps_min HPQRQpeq HPQRQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQp requis par la preuve de (?)PRPpQp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQp requis par la preuve de (?)PRPpQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpQpm3 : rk(P :: R :: Pp :: Qp :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpQpM3 : rk(P :: R :: Pp :: Qp :: nil) <= 3).
{
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: R :: Pp :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}

assert(HPRPpQpM : rk(P :: R :: Pp :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpm : rk(P :: R :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HPRPpQpeq HPRPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRRpm3 : rk(P :: Q :: R :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRRpM3 : rk(P :: Q :: R :: Rp :: nil) <= 3).
{
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}

assert(HPQRRpM : rk(P :: Q :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRRpm : rk(P :: Q :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HPQRRpeq HPQRRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRp requis par la preuve de (?)PQPpRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRp requis par la preuve de (?)PQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpm3 : rk(P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpM3 : rk(P :: Q :: Pp :: Rp :: nil) <= 3).
{
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: Pp :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}

assert(HPQPpRpM : rk(P :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpm : rk(P :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HPQPpRpeq HPQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQs *)
(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPQPsQsOoalpha *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalpha requis par la preuve de (?)PQRPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalpha requis par la preuve de (?)PQRPsQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalpham3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalpham4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsQsOoalphaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalpham : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPsQsOoalpha *)
(* dans constructLemma(), requis par LPalpha *)
(* dans la couche 0 *)
Lemma LPPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpalpham3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QRp requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPPpRpalphaM3 : rk(P :: Pp :: Rp :: alpha :: nil) <= 3).
{
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: alpha :: nil) ((P :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (Pp :: Rp :: alpha :: nil) (nil) 1 2 0 HPMtmp HPpRpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Rp :: alpha ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : Q :: Rp ::   de rang : 1 et 2 *)
assert(HPPpRpalpham2 : rk(P :: Pp :: Rp :: alpha :: nil) >= 2).
{
	assert(HQRpMtmp : rk(Q :: Rp :: nil) <= 2) by (solve_hyps_max HQRpeq HQRpM2).
	assert(HPQPpRpalphamtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpRpalphaeq HPQPpRpalpham3).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (Q :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: alpha :: nil) (Q :: Rp :: P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Rp :: P :: Pp :: Rp :: alpha :: nil) ((Q :: Rp :: nil) ++ (P :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpalphamtmp;try rewrite HT2 in HPQPpRpalphamtmp.
	assert(HT := rule_4 (Q :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) (Rp :: nil) 3 1 2 HPQPpRpalphamtmp HRpmtmp HQRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpalpham3 : rk(P :: Pp :: Rp :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HPPpRpalphaM : rk(P :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpalpham : rk(P :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpalphaeq HPPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Palpha requis par la preuve de (?)Palpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HPalpham2 : rk(P :: alpha :: nil) >= 2).
{
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(HPPpRpalphaeq : rk(P :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpalphamtmp : rk(P :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpalphaeq HPPpRpalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: alpha :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: alpha :: nil) (P :: alpha :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: alpha :: Pp :: Rp :: alpha :: nil) ((P :: alpha :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpalphamtmp;try rewrite HT2 in HPPpRpalphamtmp.
	assert(HT := rule_2 (P :: alpha :: nil) (Pp :: Rp :: alpha :: nil) (alpha :: nil) 3 1 2 HPPpRpalphamtmp Halphamtmp HPpRpalphaMtmp Hincl);apply HT.
}

assert(HPalphaM : rk(P :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPalphaeq HPalphaM2).
assert(HPalpham : rk(P :: alpha ::  nil) >= 1) by (solve_hyps_min HPalphaeq HPalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PQOo requis par la preuve de (?)PQPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ROo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ROo requis par la preuve de (?)ROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HROom2 : rk(R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: Q :: R :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (R :: Oo :: nil) (R :: nil) 4 1 3 HPQROomtmp HRmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PQ requis par la preuve de (?)PQOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPQOom2 : rk(P :: Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPQmtmp : rk(P :: Q :: nil) >= 1) by (solve_hyps_min HPQeq HPQm1).
	assert(Hincl : incl (P :: Q :: nil) (list_inter (P :: Q :: R :: nil) (P :: Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Q :: Oo :: nil) (P :: Q :: nil) 4 1 3 HPQROomtmp HPQmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HPQOom3 : rk(P :: Q :: Oo :: nil) >= 3).
{
	assert(HROoMtmp : rk(R :: Oo :: nil) <= 2) by (solve_hyps_max HROoeq HROoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Q :: Oo :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: Oo :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Oo :: R :: Oo :: nil) ((P :: Q :: Oo :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_2 (P :: Q :: Oo :: nil) (R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HROoMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalpha requis par la preuve de (?)PQPpPsQsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalpham3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalpham2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphaeq HPQPpPsQsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPQPsQsOoalpham3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalpham4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphamtmp;try rewrite HT2 in HPQRPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsQsOoalphaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalpham : rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphaeq HPQPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPsOoalpha *)
(* dans constructLemma(), requis par LPpPsOoScalpha *)
(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpRpOo *)
(* dans constructLemma(), requis par LPQPpRpOoalpha *)
(* dans constructLemma(), requis par LPQPpOo *)
(* dans la couche 0 *)
Lemma LPQRPpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoalpha requis par la preuve de (?)PQRPpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoalpha requis par la preuve de (?)PQRPpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoalpham3 : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoalpham4 : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpOoalphaM : rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOoalpham : rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpOo *)
(* dans constructLemma(), requis par LPQRPpalpha *)
(* dans la couche 0 *)
Lemma LPQRalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQRalpha requis par la preuve de (?)PQRalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalpha requis par la preuve de (?)PQRalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPQRalphaM3 : rk(P :: Q :: R :: alpha :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: nil) (Q :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: P :: R :: alpha :: nil) ((Q :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HQMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRalpham3 : rk(P :: Q :: R :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

assert(HPQRalphaM : rk(P :: Q :: R :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRalpham : rk(P :: Q :: R :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRalphaeq HPQRalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpalpham3 : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQRPpalphaM3 : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3).
{
	assert(HPQRPpeq : rk(P :: Q :: R :: Pp :: nil) = 3) by (apply LPQRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpMtmp : rk(P :: Q :: R :: Pp :: nil) <= 3) by (solve_hyps_max HPQRPpeq HPQRPpM3).
	assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: R :: Pp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Pp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRPpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQRPpalphaM : rk(P :: Q :: R :: Pp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpalpham : rk(P :: Q :: R :: Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpalphaeq HPQRPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOo requis par la preuve de (?)PQPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOo requis par la preuve de (?)PQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpOom3 : rk(P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPQPpOom4 : rk(P :: Q :: Pp :: Oo :: nil) >= 4).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (list_inter (P :: Q :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (P :: Q :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: Pp :: nil) 4 3 3 HPQRPpOoalphamtmp HPQPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

assert(HPQPpOoM : rk(P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpOom : rk(P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpOoeq HPQPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpOoalpha requis par la preuve de (?)PQPpRpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpOoalpha requis par la preuve de (?)PQPpRpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpOoalpham3 : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpOoalpham4 : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}

assert(HPQPpRpOoalphaM : rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpOoalpham : rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpOoalphaeq HPQPpRpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpRpOo *)
(* dans la couche 0 *)
Lemma LPQPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpalpham3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQPpRpalphaM3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3).
{
	assert(HPQPpRpeq : rk(P :: Q :: Pp :: Rp :: nil) = 3) by (apply LPQPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpMtmp : rk(P :: Q :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPQPpRpeq HPQPpRpM3).
	assert(HPPpRpalphaeq : rk(P :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpalphaMtmp : rk(P :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPPpRpalphaeq HPPpRpalphaM3).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Q :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Q :: Pp :: Rp :: P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Rp :: P :: Pp :: Rp :: alpha :: nil) ((P :: Q :: Pp :: Rp :: nil) ++ (P :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 3 3 3 HPQPpRpMtmp HPPpRpalphaMtmp HPPpRpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQPpRpalphaM : rk(P :: Q :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpalpham : rk(P :: Q :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpalphaeq HPQPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpOo requis par la preuve de (?)PPpRpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpOo requis par la preuve de (?)PPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpOom3 : rk(P :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Oo :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPPpRpOom4 : rk(P :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQPpRpalphaeq : rk(P :: Q :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPQPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpalphaMtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQPpRpalphaeq HPQPpRpalphaM3).
	assert(HPQPpRpOoalphaeq : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) = 4) by (apply LPQPpRpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpOoalphamtmp : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpRpOoalphaeq HPQPpRpOoalpham4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) (P :: Pp :: Rp :: Oo :: P :: Q :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: Oo :: P :: Q :: Pp :: Rp :: alpha :: nil) ((P :: Pp :: Rp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpOoalphamtmp;try rewrite HT2 in HPQPpRpOoalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 4 3 3 HPQPpRpOoalphamtmp HPPpRpmtmp HPQPpRpalphaMtmp Hincl);apply HT.
}

assert(HPPpRpOoM : rk(P :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpOom : rk(P :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPPpRpOoeq HPPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOoScalpha requis par la preuve de (?)PPpRpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOoScalpha requis par la preuve de (?)PPpRpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}

assert(HPPpRpPsOoScalphaM : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsOoScalpham : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPpOoSc *)
(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LPQPpQpQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpQsOoSc requis par la preuve de (?)PQRPpQpQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpQsOoSc requis par la preuve de (?)PQRPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpQsOoScm3 : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpQsOoScm4 : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpQsOoScM : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpQsOoScm : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpQpQsOoSceq HPQRPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpQpQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOo requis par la preuve de (?)PQRPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOo requis par la preuve de (?)PQRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOom3 : rk(P :: Q :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOom4 : rk(P :: Q :: R :: Pp :: Oo :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpOoM : rk(P :: Q :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOom : rk(P :: Q :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpOoeq HPQRPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpQsOoSc requis par la preuve de (?)PQPpQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpQsOoSc requis par la preuve de (?)PQPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpQpQsOoScm3 : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpQsOoScm4 : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpQpQsOoSceq : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQRPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpQpQsOoScmtmp : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpQpQsOoSceq HPQRPpQpQsOoScm4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpQsOoScmtmp;try rewrite HT2 in HPQRPpQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpQsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpQpQsOoScM : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpQsOoScm : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpQpQsOoSceq HPQPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpOoalpha requis par la preuve de (?)PQRPpQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpOoalpha requis par la preuve de (?)PQRPpQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpOoalpham3 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpOoalpham4 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpOoalphaM : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpOoalpham : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpQpOoalphaeq HPQRPpQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpalpha requis par la preuve de (?)PQRPpQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpalpha requis par la preuve de (?)PQRPpQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpalpham3 : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQRPpQpalphaM3 : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) <= 3).
{
	assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRPpalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQRPpQpalphaM : rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpalpham : rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpQpalphaeq HPQRPpQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpOom3 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Oo :: nil) 3 3 HQPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HQPpQpOom4 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRPpQpalphaeq : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPQRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpQpalphaMtmp : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpQpalphaeq HPQRPpQpalphaM3).
	assert(HPQRPpQpOoalphaeq : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpQpOoalphamtmp : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpQpOoalphaeq HPQRPpQpOoalpham4).
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (list_inter (Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) (Q :: Pp :: Qp :: Oo :: P :: Q :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Qp :: Oo :: P :: Q :: R :: Pp :: Qp :: alpha :: nil) ((Q :: Pp :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpOoalphamtmp;try rewrite HT2 in HPQRPpQpOoalphamtmp.
	assert(HT := rule_2 (Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil) (Q :: Pp :: Qp :: nil) 4 3 3 HPQRPpQpOoalphamtmp HQPpQpmtmp HPQRPpQpalphaMtmp Hincl);apply HT.
}

assert(HQPpQpOoM : rk(Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpOom : rk(Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpOoeq HQPpQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LPQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpOo requis par la preuve de (?)PQRPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpOo requis par la preuve de (?)PQRPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpOoM : rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpOom : rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpOoeq HPQRPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpOo requis par la preuve de (?)PQPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpOo requis par la preuve de (?)PQPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpQpOom3 : rk(P :: Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpOom4 : rk(P :: Q :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpQpOoeq : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQRPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpQpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpOoeq HPQRPpQpOom4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Oo :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpOomtmp;try rewrite HT2 in HPQRPpQpOomtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpOomtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpQpOoM : rk(P :: Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpOom : rk(P :: Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpQpOoeq HPQPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpQsOoSc requis par la preuve de (?)QPpQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpQsOoSc requis par la preuve de (?)QPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpQsOoScm3 : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HQPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HQPpQpQsOoScm4 : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQPpQpOoeq : rk(P :: Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpQpOoMtmp : rk(P :: Q :: Pp :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpQpOoeq HPQPpQpOoM4).
	assert(HPQPpQpQsOoSceq : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpQpQsOoScmtmp : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpQpQsOoSceq HPQPpQpQsOoScm4).
	assert(HQPpQpOoeq : rk(Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQPpQpOomtmp : rk(Q :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpOoeq HQPpQpOom4).
	assert(Hincl : incl (Q :: Pp :: Qp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Qp :: Oo :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: Pp :: Qp :: Oo :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Qp :: Oo :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Qp :: Oo :: nil) ++ (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpQsOoScmtmp;try rewrite HT2 in HPQPpQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Qp :: Oo :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (Q :: Pp :: Qp :: Oo :: nil) 4 4 4 HPQPpQpQsOoScmtmp HQPpQpOomtmp HPQPpQpOoMtmp Hincl); apply HT.
}

assert(HQPpQpQsOoScM : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpQsOoScm : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HQPpQpQsOoSceq HQPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpOoSc *)
(* dans la couche 0 *)
Lemma LQQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpPsQsOoScm3 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpPsQsOoScm4 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOoalpham3 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOoalpham4 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PQRQpalpha requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpalpham3 : rk(P :: Q :: R :: Qp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQRQpalphaM3 : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3).
{
	assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpOom3 : rk(P :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -4 et 5*)
assert(HPQQpOom4 : rk(P :: Q :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	assert(HPQRQpOoalphamtmp : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham4).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (list_inter (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: alpha :: nil) (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOoalphamtmp;try rewrite HT2 in HPQRQpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: Qp :: nil) 4 3 3 HPQRQpOoalphamtmp HPQQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom4 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpPsQsOoScm3 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPQQpPsQsOoScm4 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRQpOoMtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRQpOoeq HPQRQpOoM4).
	assert(HPQRQpPsQsOoScmtmp : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm4).
	assert(HPQQpOomtmp : rk(P :: Q :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQQpOoeq HPQQpOom4).
	assert(Hincl : incl (P :: Q :: Qp :: Oo :: nil) (list_inter (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Qp :: Oo :: nil) ++ (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpPsQsOoScmtmp;try rewrite HT2 in HPQRQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: Qp :: Oo :: nil) 4 4 4 HPQRQpPsQsOoScmtmp HPQQpOomtmp HPQRQpOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpQsOoSc requis par la preuve de (?)PQQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpQsOoScm3 : rk(P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: Qp :: Qs :: Oo :: Sc ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Oo ::   de rang : 2 et 2 *)
assert(HQQpQsOoScm2 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOoMtmp : rk(P :: Oo :: nil) <= 2) by (solve_hyps_max HPOoeq HPOoM2).
	assert(HPQQpQsOoScmtmp : rk(P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPQQpQsOoSceq HPQQpQsOoScm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Oo :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpQsOoScmtmp;try rewrite HT2 in HPQQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: nil) 3 1 2 HPQQpQsOoScmtmp HOomtmp HPOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HQQpQsOoScm3 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPQQpPsQsOoScmtmp : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQQpPsQsOoSceq HPQQpPsQsOoScm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Ps :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpPsQsOoScmtmp;try rewrite HT2 in HPQQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: nil) 4 1 2 HPQQpPsQsOoScmtmp HOomtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HQQpQsOoScM3 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) <= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Qs :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Q :: Qs :: Oo :: Qp :: Qs :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Qs :: Sc :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Qs :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (Qp :: Qs :: Sc :: nil) (Qs :: nil) 2 2 1 HQQsOoMtmp HQpQsScMtmp HQsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HQQpQsOoScM : rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpQsOoScm : rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HQQpQsOoSceq HQQpQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpOoSc requis par la preuve de (?)PpOoSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoScm3 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoScm4 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpOoSc requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Pp :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPpOoScm2 : rk(Pp :: Oo :: Sc :: nil) >= 2).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpOoScmtmp : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpOoSceq HPQRPpOoScm4).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: Pp :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: Pp :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (Pp :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoScmtmp;try rewrite HT2 in HPQRPpOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Oo :: Sc :: nil) (Pp :: Oo :: nil) 4 2 4 HPQRPpOoScmtmp HPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPpOoScm3 : rk(Pp :: Oo :: Sc :: nil) >= 3).
{
	assert(HQQpQsOoSceq : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) = 3) by (apply LQQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpQsOoScMtmp : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HQQpQsOoSceq HQQpQsOoScM3).
	assert(HQPpQpQsOoSceq : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LQPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQPpQpQsOoScmtmp : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HQPpQpQsOoSceq HQPpQpQsOoScm4).
	assert(HOoScmtmp : rk(Oo :: Sc :: nil) >= 2) by (solve_hyps_min HOoSceq HOoScm2).
	assert(Hincl : incl (Oo :: Sc :: nil) (list_inter (Pp :: Oo :: Sc :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (Pp :: Oo :: Sc :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: Sc :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((Pp :: Oo :: Sc :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpQsOoScmtmp;try rewrite HT2 in HQPpQpQsOoScmtmp.
	assert(HT := rule_2 (Pp :: Oo :: Sc :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: Sc :: nil) 4 2 3 HQPpQpQsOoScmtmp HOoScmtmp HQQpQsOoScMtmp Hincl);apply HT.
}

assert(HPpOoScM : rk(Pp :: Oo :: Sc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpOoSceq HPpOoScM3).
assert(HPpOoScm : rk(Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPpOoSceq HPpOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpOoSc *)
(* dans constructLemma(), requis par LPPpPsOoSc *)
(* dans constructLemma(), requis par LPQPpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoSc requis par la preuve de (?)PQRPpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoSc requis par la preuve de (?)PQRPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScm3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScm4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpPsOoScM : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpPsOoScm : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpPsOoSceq HPQRPpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoSc requis par la preuve de (?)PQPpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoSc requis par la preuve de (?)PQPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOoScm3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpPsOoScm4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpPsOoSceq : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpPsOoSceq HPQRPpPsOoScm4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpPsOoScmtmp;try rewrite HT2 in HPQRPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpPsOoScM : rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsOoScm : rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpPsOoSc *)
(* dans constructLemma(), requis par LPQPsOo *)
(* dans constructLemma(), requis par LPQOo *)
(* dans la couche 0 *)
Lemma LROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ROo requis par la preuve de (?)ROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HROom2 : rk(R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: Q :: R :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (R :: Oo :: nil) (R :: nil) 4 1 3 HPQROomtmp HRmtmp HPQRMtmp Hincl); apply HT.
}

assert(HROoM : rk(R :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HROoeq HROoM2).
assert(HROom : rk(R :: Oo ::  nil) >= 1) by (solve_hyps_min HROoeq HROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PQ requis par la preuve de (?)PQOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPQOom2 : rk(P :: Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPQmtmp : rk(P :: Q :: nil) >= 1) by (solve_hyps_min HPQeq HPQm1).
	assert(Hincl : incl (P :: Q :: nil) (list_inter (P :: Q :: R :: nil) (P :: Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Q :: Oo :: nil) (P :: Q :: nil) 4 1 3 HPQROomtmp HPQmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 4*)
assert(HPQOom3 : rk(P :: Q :: Oo :: nil) >= 3).
{
	assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HROoMtmp : rk(R :: Oo :: nil) <= 2) by (solve_hyps_max HROoeq HROoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Q :: Oo :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: Oo :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Oo :: R :: Oo :: nil) ((P :: Q :: Oo :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_2 (P :: Q :: Oo :: nil) (R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HROoMtmp Hincl);apply HT.
}

assert(HPQOoM : rk(P :: Q :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQOoeq HPQOoM3).
assert(HPQOom : rk(P :: Q :: Oo ::  nil) >= 1) by (solve_hyps_min HPQOoeq HPQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQPs requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOp requis par la preuve de (?)PQPs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOp requis par la preuve de (?)PQPpPsOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOpm3 : rk(P :: Q :: Pp :: Ps :: Op :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQPs requis par la preuve de (?)PQPs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HPQPsm2 : rk(P :: Q :: Ps :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpmtmp : rk(P :: Q :: Pp :: Ps :: Op :: nil) >= 3) by (solve_hyps_min HPQPpPsOpeq HPQPpPsOpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: Ps :: nil) (P :: Pp :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: nil) (P :: Q :: Ps :: P :: Pp :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: P :: Pp :: Op :: nil) ((P :: Q :: Ps :: nil) ++ (P :: Pp :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpmtmp;try rewrite HT2 in HPQPpPsOpmtmp.
	assert(HT := rule_2 (P :: Q :: Ps :: nil) (P :: Pp :: Op :: nil) (P :: nil) 3 1 2 HPQPpPsOpmtmp HPmtmp HPPpOpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPQPsOoM3 : rk(P :: Q :: Ps :: Oo :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (P :: Ps :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: nil) (Q :: P :: Ps :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: P :: Ps :: Oo :: nil) ((Q :: nil) ++ (P :: Ps :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (P :: Ps :: Oo :: nil) (nil) 1 2 0 HQMtmp HPPsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPQPsOom2 : rk(P :: Q :: Ps :: Oo :: nil) >= 2).
{
	assert(HPQPsmtmp : rk(P :: Q :: Ps :: nil) >= 2) by (solve_hyps_min HPQPseq HPQPsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Ps :: nil) (P :: Q :: Ps :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Ps :: nil) (P :: Q :: Ps :: Oo :: nil) 2 2 HPQPsmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOom3 : rk(P :: Q :: Ps :: Oo :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

assert(HPQPsOoM : rk(P :: Q :: Ps :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOom : rk(P :: Q :: Ps :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPsOoeq HPQPsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPpPsOoScm2 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPPpPsOoScM3 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) <= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: nil) (Ps :: nil) 2 2 1 HPPsOoMtmp HPpPsScMtmp HPsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Ps :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPPpPsOoScm3 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	assert(HPPsOomtmp : rk(P :: Ps :: Oo :: nil) >= 2) by (solve_hyps_min HPPsOoeq HPPsOom2).
	assert(Hincl : incl (P :: Ps :: Oo :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Ps :: Oo :: P :: Pp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: P :: Pp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (P :: Pp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: nil) 4 2 3 HPQPpPsOoScmtmp HPPsOomtmp HPQPsOoMtmp Hincl); apply HT.
}

assert(HPPpPsOoScM : rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpPsOoScm : rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpPsOoSceq HPPpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPpOoScm2 : rk(P :: Pp :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPPpOoScm3 : rk(P :: Pp :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Ps :: Oo :: P :: Pp :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: P :: Pp :: Oo :: Sc :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (P :: Pp :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil) (P :: Oo :: nil) 4 2 3 HPQPpPsOoScmtmp HPOomtmp HPQPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpOoScM3 : rk(P :: Pp :: Oo :: Sc :: nil) <= 3).
{
	assert(HPPpPsOoSceq : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) = 3) by (apply LPPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpPsOoScMtmp : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HPPpPsOoSceq HPPpPsOoScM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Oo :: Sc :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Pp :: Oo :: Sc :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpPsOoScMtmp Hcomp Hincl);apply HT.
}

assert(HPPpOoScM : rk(P :: Pp :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpOoScm : rk(P :: Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpOoSceq HPPpOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PsOo requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOpOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOpOoScalpha requis par la preuve de (?)PPpRpPsOpOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsOpOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsOoScalpham2 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsOpOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsOpOoScalphaeq HPPpRpPsOpOoScalpham3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOpOoScalphamtmp;try rewrite HT2 in HPPpRpPsOpOoScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsOpOoScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps :: Oo ::  de rang :  1 et 2 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsOoScalpham3 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	assert(HPsOomtmp : rk(Ps :: Oo :: nil) >= 1) by (solve_hyps_min HPsOoeq HPsOom1).
	assert(Hincl : incl (Ps :: Oo :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Ps :: Oo :: nil) 4 1 2 HPPpRpPsOoScalphamtmp HPsOomtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: Oo :: Sc ::  de rang :  3 et 3 	 A : P :: Pp :: Oo :: Sc ::   de rang : 3 et 3 *)
assert(HPpRpPsOoScalpham4 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPPpOoSceq : rk(P :: Pp :: Oo :: Sc :: nil) = 3) by (apply LPPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpOoScMtmp : rk(P :: Pp :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HPPpOoSceq HPPpOoScM3).
	assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	assert(HPpOoSceq : rk(Pp :: Oo :: Sc :: nil) = 3) by (apply LPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpOoScmtmp : rk(Pp :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPpOoSceq HPpOoScm3).
	assert(Hincl : incl (Pp :: Oo :: Sc :: nil) (list_inter (P :: Pp :: Oo :: Sc :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Pp :: Oo :: Sc :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: Sc :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Pp :: Oo :: Sc :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: Sc :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Oo :: Sc :: nil) 4 3 3 HPPpRpPsOoScalphamtmp HPpOoScmtmp HPPpOoScMtmp Hincl); apply HT.
}

assert(HPpRpPsOoScalphaM : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsOoScalpham : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsOoScalphaeq HPpRpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpPsOoScalpha *)
(* dans constructLemma(), requis par LPpalpha *)
(* dans la couche 0 *)
Lemma LPRPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpalpham3 : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QPp requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPRPpalphaM3 : rk(P :: R :: Pp :: alpha :: nil) <= 3).
{
	assert(HPpMtmp : rk(Pp :: nil) <= 1) by (solve_hyps_max HPpeq HPpM1).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: alpha :: nil) (Pp :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: P :: R :: alpha :: nil) ((Pp :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HPpMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : Q :: Pp ::   de rang : 1 et 2 *)
assert(HPRPpalpham2 : rk(P :: R :: Pp :: alpha :: nil) >= 2).
{
	assert(HQPpMtmp : rk(Q :: Pp :: nil) <= 2) by (solve_hyps_max HQPpeq HQPpM2).
	assert(HPQRPpalphamtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3) by (solve_hyps_min HPQRPpalphaeq HPQRPpalpham3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Q :: Pp :: nil) (P :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: alpha :: nil) (Q :: Pp :: P :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: P :: R :: Pp :: alpha :: nil) ((Q :: Pp :: nil) ++ (P :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpalphamtmp;try rewrite HT2 in HPQRPpalphamtmp.
	assert(HT := rule_4 (Q :: Pp :: nil) (P :: R :: Pp :: alpha :: nil) (Pp :: nil) 3 1 2 HPQRPpalphamtmp HPpmtmp HQPpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpalpham3 : rk(P :: R :: Pp :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

assert(HPRPpalphaM : rk(P :: R :: Pp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpalpham : rk(P :: R :: Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpalphaeq HPRPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ppalpha requis par la preuve de (?)Ppalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPpalpham2 : rk(Pp :: alpha :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPpalphaeq : rk(P :: R :: Pp :: alpha :: nil) = 3) by (apply LPRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpalphamtmp : rk(P :: R :: Pp :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpalphaeq HPRPpalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: alpha :: nil) (P :: R :: alpha :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Pp :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpalphamtmp;try rewrite HT2 in HPRPpalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Pp :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPpalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPpalphaM : rk(Pp :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpalphaeq HPpalphaM2).
assert(HPpalpham : rk(Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPpalphaeq HPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScalpham3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScalpham4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpOo requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPpPsOoScalpham2 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 2).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpPsOoScalphamtmp : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpPsOoScalphaeq HPQRPpPsOoScalpham4).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Q :: R :: Pp :: Oo :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpPsOoScalphamtmp;try rewrite HT2 in HPQRPpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Oo :: nil) 4 2 4 HPQRPpPsOoScalphamtmp HPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPpPsOoScalpham3 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPpOoSceq : rk(Pp :: Oo :: Sc :: nil) = 3) by (apply LPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpOoScmtmp : rk(Pp :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPpOoSceq HPpOoScm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Oo :: Sc :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Oo :: Sc :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPpOoScmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: alpha ::  de rang :  2 et 2 	 A : Pp :: Rp :: alpha ::   de rang : 2 et 2 *)
assert(HPpPsOoScalpham4 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(HPpRpPsOoScalphaeq : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpRpPsOoScalphamtmp : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPpRpPsOoScalphaeq HPpRpPsOoScalpham4).
	assert(HPpalphaeq : rk(Pp :: alpha :: nil) = 2) by (apply LPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpalphamtmp : rk(Pp :: alpha :: nil) >= 2) by (solve_hyps_min HPpalphaeq HPpalpham2).
	assert(Hincl : incl (Pp :: alpha :: nil) (list_inter (Pp :: Rp :: alpha :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Rp :: alpha :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Rp :: alpha :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) ((Pp :: Rp :: alpha :: nil) ++ (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpRpPsOoScalphamtmp;try rewrite HT2 in HPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (Pp :: Rp :: alpha :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: alpha :: nil) 4 2 2 HPpRpPsOoScalphamtmp HPpalphamtmp HPpRpalphaMtmp Hincl); apply HT.
}

assert(HPpPsOoScalphaM : rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpPsOoScalpham : rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpPsOoScalphaeq HPpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsOoalpha *)
(* dans constructLemma(), requis par LPsalpha *)
(* dans constructLemma(), requis par LPRPsalpha *)
(* dans constructLemma(), requis par LPRPpPsScalpha *)
(* dans constructLemma(), requis par LPRPpSc *)
(* dans la couche 0 *)
Lemma LPQRPpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpScalpha requis par la preuve de (?)PQRPpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpScalpha requis par la preuve de (?)PQRPpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpScalpham3 : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpScalpham4 : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpScalphaM : rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpScalpham : rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpSc requis par la preuve de (?)PRPpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpSc requis par la preuve de (?)PRPpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpScm3 : rk(P :: R :: Pp :: Sc :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Sc :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPRPpScm4 : rk(P :: R :: Pp :: Sc :: nil) >= 4).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpScalphaeq : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) = 4) by (apply LPQRPpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpScalphamtmp : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham4).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Sc :: alpha :: nil) (P :: R :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Sc :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpScalphamtmp;try rewrite HT2 in HPQRPpScalphamtmp.
	assert(HT := rule_2 (P :: R :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 4 3 3 HPQRPpScalphamtmp HPRPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

assert(HPRPpScM : rk(P :: R :: Pp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpScm : rk(P :: R :: Pp :: Sc ::  nil) >= 1) by (solve_hyps_min HPRPpSceq HPRPpScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsScalpha requis par la preuve de (?)PRPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsScalpha requis par la preuve de (?)PRPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsScalpham3 : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsScalpham4 : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPRPpPsScalphaM : rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpPsScalpham : rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsalpha requis par la preuve de (?)PQRPsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsalpham3 : rk(P :: Q :: R :: Ps :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QPs requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPRPsalphaM3 : rk(P :: R :: Ps :: alpha :: nil) <= 3).
{
	assert(HPsMtmp : rk(Ps :: nil) <= 1) by (solve_hyps_max HPseq HPsM1).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ps :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (Ps :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: P :: R :: alpha :: nil) ((Ps :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HPsMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: alpha ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Q :: Ps ::   de rang : 1 et 2 *)
assert(HPRPsalpham2 : rk(P :: R :: Ps :: alpha :: nil) >= 2).
{
	assert(HQPsMtmp : rk(Q :: Ps :: nil) <= 2) by (solve_hyps_max HQPseq HQPsM2).
	assert(HPQRPsalphamtmp : rk(P :: Q :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPQRPsalphaeq HPQRPsalpham3).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Q :: Ps :: nil) (P :: R :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: alpha :: nil) (Q :: Ps :: P :: R :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Ps :: P :: R :: Ps :: alpha :: nil) ((Q :: Ps :: nil) ++ (P :: R :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsalphamtmp;try rewrite HT2 in HPQRPsalphamtmp.
	assert(HT := rule_4 (Q :: Ps :: nil) (P :: R :: Ps :: alpha :: nil) (Ps :: nil) 3 1 2 HPQRPsalphamtmp HPsmtmp HQPsMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsalpham3 : rk(P :: R :: Ps :: alpha :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPRPpPsScalphaeq : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) = 4) by (apply LPRPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpPsScalphamtmp : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsScalphamtmp;try rewrite HT2 in HPRPpPsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

assert(HPRPsalphaM : rk(P :: R :: Ps :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsalpham : rk(P :: R :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsalphaeq HPRPsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Psalpha requis par la preuve de (?)Psalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsalpham2 : rk(Ps :: alpha :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsalphaeq : rk(P :: R :: Ps :: alpha :: nil) = 3) by (apply LPRPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPsalphamtmp : rk(P :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsalphaeq HPRPsalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (P :: R :: alpha :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsalphamtmp;try rewrite HT2 in HPRPsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPsalphaM : rk(Ps :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPsalphaeq HPsalphaM2).
assert(HPsalpham : rk(Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPsalphaeq HPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsOoalpha *)
(* dans la couche 0 *)
Lemma LPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Ps :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOoScalpham3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPpPsScalpham2 : rk(Pp :: Ps :: Sc :: alpha :: nil) >= 2).
{
	assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	assert(HPQPpPsOoScalphamtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsOoScalphaeq HPQPpPsOoScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Q :: Ps :: Oo :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: Pp :: Ps :: Sc :: alpha :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScalphamtmp;try rewrite HT2 in HPQPpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (Ps :: nil) 4 1 3 HPQPpPsOoScalphamtmp HPsmtmp HPQPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HPpPsScalphaM3 : rk(Pp :: Ps :: Sc :: alpha :: nil) <= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: Ps :: Sc :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (alpha :: nil) (nil) 2 1 0 HPpPsScMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPpPsScalpham3 : rk(Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPpPsScalphaeq : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) = 4) by (apply LPRPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpPsScalphamtmp : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) (P :: R :: alpha :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Pp :: Ps :: Sc :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsScalphamtmp;try rewrite HT2 in HPRPpPsScalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (alpha :: nil) 4 1 2 HPRPpPsScalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPpPsScalphaM : rk(Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpPsScalpham : rk(Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpPsScalphaeq HPpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PRPsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PROo requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsOoalpham2 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsOpOoalphaeq HPRPpPsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsOpOoalphamtmp;try rewrite HT2 in HPRPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPRPsOoalpham3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPRPsOoalphaM3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: R :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPRalphaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Oo :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsOoalpham2 : rk(Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsOoalphamtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsOoalphamtmp;try rewrite HT2 in HPRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Oo :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPsOoalpham3 : rk(Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPpPsScalphaeq : rk(Pp :: Ps :: Sc :: alpha :: nil) = 3) by (apply LPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpPsScalphaMtmp : rk(Pp :: Ps :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpPsScalphaeq HPpPsScalphaM3).
	assert(HPpPsOoScalphaeq : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpPsOoScalphamtmp : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPpPsOoScalphaeq HPpPsOoScalpham4).
	assert(HPsalphaeq : rk(Ps :: alpha :: nil) = 2) by (apply LPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsalphamtmp : rk(Ps :: alpha :: nil) >= 2) by (solve_hyps_min HPsalphaeq HPsalpham2).
	assert(Hincl : incl (Ps :: alpha :: nil) (list_inter (Ps :: Oo :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Ps :: Oo :: alpha :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Oo :: alpha :: Pp :: Ps :: Sc :: alpha :: nil) ((Ps :: Oo :: alpha :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpPsOoScalphamtmp;try rewrite HT2 in HPpPsOoScalphamtmp.
	assert(HT := rule_2 (Ps :: Oo :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (Ps :: alpha :: nil) 4 2 3 HPpPsOoScalphamtmp HPsalphamtmp HPpPsScalphaMtmp Hincl);apply HT.
}

assert(HPsOoalphaM : rk(Ps :: Oo :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsOoalphaeq HPsOoalphaM3).
assert(HPsOoalpham : rk(Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPsOoalphaeq HPsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPPsOoalpha *)
(* dans la couche 0 *)
Lemma LPRPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PROo requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsOoalpham2 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsOpOoalphaeq HPRPpPsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsOpOoalphamtmp;try rewrite HT2 in HPRPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPRPsOoalpham3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPRPsOoalphaM3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: R :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPRalphaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPRPsOoalphaM : rk(P :: R :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsOoalpham : rk(P :: R :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPsOoalpham2 : rk(P :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Ps :: Oo :: alpha :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HPPsOoalphaM3 : rk(P :: Ps :: Oo :: alpha :: nil) <= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: Ps :: Oo :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (alpha :: nil) (nil) 2 1 0 HPPsOoMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Oo :: alpha ::  de rang :  3 et 3 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsOoalpham3 : rk(P :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsOoalphaeq : rk(P :: R :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPsOoalphamtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham3).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsOoalphamtmp;try rewrite HT2 in HPRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPPsOoalphaM : rk(P :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsOoalpham : rk(P :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsOoalphaeq HPPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)QPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HQPsQsOoalpham2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalpham3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphamtmp;try rewrite HT2 in HPQRPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalpham4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsOoalphamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphaeq HPQPsQsOoalpham4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphamtmp;try rewrite HT2 in HPQPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

assert(HQPsQsOoalphaM : rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalpham : rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphaeq HQPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQs *)
(* dans constructLemma(), requis par LQQsOoalpha *)
(* dans la couche 0 *)
Lemma LPQRQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQsOoalpha requis par la preuve de (?)PQRQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQsOoalpha requis par la preuve de (?)PQRQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQsOoalpham3 : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQsOoalpham4 : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRQsOoalphaM : rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQsOoalpham : rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qs :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)QQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HQQsOoalpham2 : rk(Q :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Qs :: Oo :: alpha :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HQQsOoalphaM3 : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: Qs :: Oo :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qs :: Oo :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: nil) ((Q :: Qs :: Oo :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (alpha :: nil) (nil) 2 1 0 HQQsOoMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQQsOoalpham3 : rk(Q :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRQsOoalphaeq : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQsOoalphamtmp : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsOoalphamtmp;try rewrite HT2 in HPQRQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil) (alpha :: nil) 4 1 2 HPQRQsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HQQsOoalphaM : rk(Q :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQsOoalpham : rk(Q :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HQQsOoalphaeq HQQsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQs : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PsQs requis par la preuve de (?)PsQs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPsQsm2 : rk(Ps :: Qs :: nil) >= 2).
{
	assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphaeq : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LQPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQPsQsOoalphamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphaeq HQPsQsOoalpham4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Ps :: Qs :: nil) (Q :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Qs :: Q :: Qs :: Oo :: alpha :: nil) ((Ps :: Qs :: nil) ++ (Q :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphamtmp;try rewrite HT2 in HQPsQsOoalphamtmp.
	assert(HT := rule_2 (Ps :: Qs :: nil) (Q :: Qs :: Oo :: alpha :: nil) (Qs :: nil) 4 1 3 HQPsQsOoalphamtmp HQsmtmp HQQsOoalphaMtmp Hincl);apply HT.
}

assert(HPsQsM : rk(Ps :: Qs ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPsQseq HPsQsM2).
assert(HPsQsm : rk(Ps :: Qs ::  nil) >= 1) by (solve_hyps_min HPsQseq HPsQsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}

assert(HPOoM : rk(P :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPOoeq HPOoM2).
assert(HPOom : rk(P :: Oo ::  nil) >= 1) by (solve_hyps_min HPOoeq HPOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}

assert(HQOoM : rk(Q :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQOoeq HQOoM2).
assert(HQOom : rk(Q :: Oo ::  nil) >= 1) by (solve_hyps_min HQOoeq HQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}

assert(HPROoM : rk(P :: R :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPROoeq HPROoM3).
assert(HPROom : rk(P :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HPROoeq HPROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QROo requis par la preuve de (?)QROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QR requis par la preuve de (?)QROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QROo requis par la preuve de (?)QROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQROom2 : rk(Q :: R :: Oo :: nil) >= 2).
{
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQRmtmp : rk(Q :: R :: nil) >= 1) by (solve_hyps_min HQReq HQRm1).
	assert(Hincl : incl (Q :: R :: nil) (list_inter (P :: Q :: R :: nil) (Q :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: R :: Oo :: nil) (Q :: R :: nil) 4 1 3 HPQROomtmp HQRmtmp HPQRMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Oo ::   de rang : 2 et 2 *)
assert(HQROom3 : rk(Q :: R :: Oo :: nil) >= 3).
{
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPOoMtmp : rk(P :: Oo :: nil) <= 2) by (solve_hyps_max HPOoeq HPOoM2).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Oo :: nil) (Q :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Oo :: Q :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Oo :: Q :: R :: Oo :: nil) ((P :: Oo :: nil) ++ (Q :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Oo :: nil) (Q :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HPOoMtmp Hincl); apply HT.
}

assert(HQROoM : rk(Q :: R :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQROoeq HQROoM3).
assert(HQROom : rk(Q :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HQROoeq HQROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

assert(HPpOoM : rk(Pp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpOoeq HPpOoM2).
assert(HPpOom : rk(Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPpOoeq HPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpOo requis par la preuve de (?)PRPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpOo requis par la preuve de (?)PRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpOom3 : rk(P :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Oo :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPRPpOom4 : rk(P :: R :: Pp :: Oo :: nil) >= 4).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (P :: R :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (P :: R :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 4 3 3 HPQRPpOoalphamtmp HPRPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

assert(HPRPpOoM : rk(P :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpOom : rk(P :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPRPpOoeq HPRPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpOo *)
(* dans la couche 0 *)
Lemma LPQRQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOoalpham3 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOoalpham4 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpOoalphaM : rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpOoalpham : rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpOo *)
(* dans la couche 0 *)
Lemma LPQRQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpalpham3 : rk(P :: Q :: R :: Qp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQRQpalphaM3 : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3).
{
	assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQRQpalphaM : rk(P :: Q :: R :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpalpham : rk(P :: Q :: R :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpalphaeq HPQRQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpOom3 : rk(P :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPQQpOom4 : rk(P :: Q :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	assert(HPQRQpOoalphaeq : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPQRQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpOoalphamtmp : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham4).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (list_inter (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: alpha :: nil) (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOoalphamtmp;try rewrite HT2 in HPQRQpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: Qp :: nil) 4 3 3 HPQRQpOoalphamtmp HPQQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}

assert(HPQQpOoM : rk(P :: Q :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQQpOom : rk(P :: Q :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQQpOoeq HPQQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom4 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpOoM : rk(P :: Q :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpOom : rk(P :: Q :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRQpOoeq HPQRQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpOo *)
(* dans la couche 0 *)
Lemma LPRPpQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpOoalpha requis par la preuve de (?)PRPpQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpOoalpha requis par la preuve de (?)PRPpQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpQpOoalpham3 : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpOoalpham4 : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPRPpOoeq : rk(P :: R :: Pp :: Oo :: nil) = 4) by (apply LPRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpOomtmp : rk(P :: R :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPRPpOoeq HPRPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Oo :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Oo :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) 4 4 HPRPpOomtmp Hcomp Hincl);apply HT.
}

assert(HPRPpQpOoalphaM : rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpOoalpham : rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpOoalphaeq HPRPpQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpOo *)
(* dans la couche 0 *)
Lemma LPRPpQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpalpha requis par la preuve de (?)PRPpQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpalpha requis par la preuve de (?)PRPpQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpQpalpham3 : rk(P :: R :: Pp :: Qp :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPRPpQpalphaM3 : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3).
{
	assert(HPRPpQpeq : rk(P :: R :: Pp :: Qp :: nil) = 3) by (apply LPRPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpQpMtmp : rk(P :: R :: Pp :: Qp :: nil) <= 3) by (solve_hyps_max HPRPpQpeq HPRPpQpM3).
	assert(HPRPpalphaeq : rk(P :: R :: Pp :: alpha :: nil) = 3) by (apply LPRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpalphaMtmp : rk(P :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpalphaeq HPRPpalphaM3).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Qp :: nil) (P :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: alpha :: nil) (P :: R :: Pp :: Qp :: P :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Qp :: P :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Qp :: nil) ++ (P :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: R :: Pp :: Qp :: nil) (P :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 3 3 3 HPRPpQpMtmp HPRPpalphaMtmp HPRPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPRPpQpalphaM : rk(P :: R :: Pp :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpalpham : rk(P :: R :: Pp :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpalphaeq HPRPpQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpOom3 : rk(P :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Oo :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPPpQpOom4 : rk(P :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HPRPpQpalphaeq : rk(P :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpQpalphaMtmp : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpQpalphaeq HPRPpQpalphaM3).
	assert(HPRPpQpOoalphaeq : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPRPpQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpQpOoalphamtmp : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpQpOoalphaeq HPRPpQpOoalpham4).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (list_inter (P :: Pp :: Qp :: Oo :: nil) (P :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) (P :: Pp :: Qp :: Oo :: P :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: Oo :: P :: R :: Pp :: Qp :: alpha :: nil) ((P :: Pp :: Qp :: Oo :: nil) ++ (P :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpQpOoalphamtmp;try rewrite HT2 in HPRPpQpOoalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Qp :: Oo :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) (P :: Pp :: Qp :: nil) 4 3 3 HPRPpQpOoalphamtmp HPPpQpmtmp HPRPpQpalphaMtmp Hincl);apply HT.
}

assert(HPPpQpOoM : rk(P :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpOom : rk(P :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPPpQpOoeq HPPpQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpRpOo *)
(* dans la couche 0 *)
Lemma LPQRPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpOo requis par la preuve de (?)PQRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpOo requis par la preuve de (?)PQRPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpOom3 : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpOom4 : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpRpOoM : rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpOom : rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpRpOoeq HPQRPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpOo requis par la preuve de (?)PQPpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpOo requis par la preuve de (?)PQPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpOom3 : rk(P :: Q :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpRpOom4 : rk(P :: Q :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpRpOoeq : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPQRPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpRpOomtmp : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpRpOoeq HPQRPpRpOom4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Oo :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpOomtmp;try rewrite HT2 in HPQRPpRpOomtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpRpOomtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpRpOoM : rk(P :: Q :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpOom : rk(P :: Q :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpRpOoeq HPQPpRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpOo *)
(* dans la couche 0 *)
Lemma LPQRQpRpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpOoalpha requis par la preuve de (?)PQRQpRpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpOoalpha requis par la preuve de (?)PQRQpRpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpRpOoalpham3 : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpRpOoalpham4 : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpRpOoalphaM : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpOoalpham : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpOoalphaeq HPQRQpRpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpOo *)
(* dans la couche 0 *)
Lemma LPQRQpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpalpha requis par la preuve de (?)PQRQpRpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpalpha requis par la preuve de (?)PQRQpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpRpalpham3 : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -4*)
assert(HPQRQpRpalphaM3 : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 3) by (apply LPQRRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRRpMtmp : rk(P :: Q :: R :: Rp :: nil) <= 3) by (solve_hyps_max HPQRRpeq HPQRRpM3).
	assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (P :: Q :: R :: Rp :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Rp :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: R :: Rp :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRRpMtmp HPQRQpalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQRQpRpalphaM : rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpalpham : rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpalphaeq HPQRQpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpOo requis par la preuve de (?)QQpRpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpOo requis par la preuve de (?)QQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpOom3 : rk(Q :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Oo :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HQQpRpOom4 : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQRQpRpalphaeq : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) = 3) by (apply LPQRQpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpRpalphaMtmp : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpRpalphaeq HPQRQpRpalphaM3).
	assert(HPQRQpRpOoalphaeq : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) = 4) by (apply LPQRQpRpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpRpOoalphamtmp : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpRpOoalphaeq HPQRQpRpOoalpham4).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (list_inter (Q :: Qp :: Rp :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) (Q :: Qp :: Rp :: Oo :: P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: Oo :: P :: Q :: R :: Qp :: Rp :: alpha :: nil) ((Q :: Qp :: Rp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpRpOoalphamtmp;try rewrite HT2 in HPQRQpRpOoalphamtmp.
	assert(HT := rule_2 (Q :: Qp :: Rp :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (Q :: Qp :: Rp :: nil) 4 3 3 HPQRQpRpOoalphamtmp HQQpRpmtmp HPQRQpRpalphaMtmp Hincl);apply HT.
}

assert(HQQpRpOoM : rk(Q :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpOom : rk(Q :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpOoeq HQQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpSc requis par la preuve de (?)PQPpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpSc requis par la preuve de (?)PQPpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpScm3 : rk(P :: Q :: Pp :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPQPpScm4 : rk(P :: Q :: Pp :: Sc :: nil) >= 4).
{
	assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	assert(HPQRPpScalphaeq : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) = 4) by (apply LPQRPpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpScalphamtmp : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham4).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (list_inter (P :: Q :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Sc :: alpha :: nil) (P :: Q :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: Pp :: Sc :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpScalphamtmp;try rewrite HT2 in HPQRPpScalphamtmp.
	assert(HT := rule_2 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: Pp :: nil) 4 3 3 HPQRPpScalphamtmp HPQPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}

assert(HPQPpScM : rk(P :: Q :: Pp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpScm : rk(P :: Q :: Pp :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpSceq HPQPpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpSc *)
(* dans constructLemma(), requis par LPpQpPsSc *)
(* dans constructLemma(), requis par LPPpQpPsOoSc *)
(* dans constructLemma(), requis par LPQPpQpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpPsOoSc requis par la preuve de (?)PQRPpQpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpPsOoSc requis par la preuve de (?)PQRPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpPsOoScm3 : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpPsOoScm4 : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpPsOoScM : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpPsOoScm : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpQpPsOoSceq HPQRPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpPsOoSc requis par la preuve de (?)PQPpQpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpPsOoSc requis par la preuve de (?)PQPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpQpPsOoScm3 : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpPsOoScm4 : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpQpPsOoSceq : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpQpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpQpPsOoSceq HPQRPpQpPsOoScm4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpPsOoScmtmp;try rewrite HT2 in HPQRPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpQpPsOoScM : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpPsOoScm : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpQpPsOoSceq HPQPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoSc requis par la preuve de (?)PPpQpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoSc requis par la preuve de (?)PPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsOoScm3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPPpQpPsOoScm4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQPpQpOoeq : rk(P :: Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpQpOoMtmp : rk(P :: Q :: Pp :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpQpOoeq HPQPpQpOoM4).
	assert(HPQPpQpPsOoSceq : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpQpPsOoScmtmp : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpQpPsOoSceq HPQPpQpPsOoScm4).
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Qp :: Oo :: P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Qp :: Oo :: P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Qp :: Oo :: nil) ++ (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpPsOoScmtmp;try rewrite HT2 in HPQPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Pp :: Qp :: Oo :: nil) 4 4 4 HPQPpQpPsOoScmtmp HPPpQpOomtmp HPQPpQpOoMtmp Hincl); apply HT.
}

assert(HPPpQpPsOoScM : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsOoScm : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpQpPsOoSceq HPPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpQpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsSc requis par la preuve de (?)PPpQpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsScm3 : rk(P :: Pp :: Qp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPpQpPsScM3 : rk(Pp :: Qp :: Ps :: Sc :: nil) <= 3).
{
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: nil) (Qp :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Pp :: Ps :: Sc :: nil) ((Qp :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HQpMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HPpQpPsScm2 : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPPpQpPsScmtmp : rk(P :: Pp :: Qp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPPpQpPsSceq HPPpQpPsScm3).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Pp :: Qp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Sc :: nil) (P :: Ps :: Pp :: Qp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Pp :: Qp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Pp :: Qp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsScmtmp;try rewrite HT2 in HPPpQpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Pp :: Qp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPPpQpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsScm3 : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpQpPsOoSceq : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpPsOoScmtmp : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPPpQpPsOoSceq HPPpQpPsOoScm4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOoScmtmp;try rewrite HT2 in HPPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPPpQpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

assert(HPpQpPsScM : rk(Pp :: Qp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsScm : rk(Pp :: Qp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HPpQpPsSceq HPpQpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QpSc requis par la preuve de (?)QpSc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HQpScm2 : rk(Qp :: Sc :: nil) >= 2).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPpQpPsSceq : rk(Pp :: Qp :: Ps :: Sc :: nil) = 3) by (apply LPpQpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpQpPsScmtmp : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPpQpPsSceq HPpQpPsScm3).
	assert(HScmtmp : rk(Sc :: nil) >= 1) by (solve_hyps_min HSceq HScm1).
	assert(Hincl : incl (Sc :: nil) (list_inter (Qp :: Sc :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: nil) (Qp :: Sc :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Sc :: Pp :: Ps :: Sc :: nil) ((Qp :: Sc :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpQpPsScmtmp;try rewrite HT2 in HPpQpPsScmtmp.
	assert(HT := rule_2 (Qp :: Sc :: nil) (Pp :: Ps :: Sc :: nil) (Sc :: nil) 3 1 2 HPpQpPsScmtmp HScmtmp HPpPsScMtmp Hincl);apply HT.
}

assert(HQpScM : rk(Qp :: Sc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQpSceq HQpScM2).
assert(HQpScm : rk(Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HQpSceq HQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQRQpSc *)
(* dans la couche 0 *)
Lemma LPQRQpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpScalpha requis par la preuve de (?)PQRQpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpScalpha requis par la preuve de (?)PQRQpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpScalpham3 : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpScalpham4 : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpScalphaM : rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpScalpham : rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpScalphaeq HPQRQpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpSc requis par la preuve de (?)QRQpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpSc requis par la preuve de (?)QRQpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpScm3 : rk(Q :: R :: Qp :: Sc :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Sc :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HQRQpScm4 : rk(Q :: R :: Qp :: Sc :: nil) >= 4).
{
	assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	assert(HPQRQpScalphaeq : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) = 4) by (apply LPQRQpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpScalphamtmp : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpScalphaeq HPQRQpScalpham4).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (list_inter (Q :: R :: Qp :: Sc :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Sc :: alpha :: nil) (Q :: R :: Qp :: Sc :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: Qp :: Sc :: P :: Q :: R :: Qp :: alpha :: nil) ((Q :: R :: Qp :: Sc :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpScalphamtmp;try rewrite HT2 in HPQRQpScalphamtmp.
	assert(HT := rule_2 (Q :: R :: Qp :: Sc :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (Q :: R :: Qp :: nil) 4 3 3 HPQRQpScalphamtmp HQRQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}

assert(HQRQpScM : rk(Q :: R :: Qp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpScm : rk(Q :: R :: Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HQRQpSceq HQRQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpSc *)
(* dans la couche 0 *)
Lemma LPRPpQpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpScalpha requis par la preuve de (?)PRPpQpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpScalpha requis par la preuve de (?)PRPpQpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpQpScalpham3 : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpScalpham4 : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 4).
{
	assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPRPpQpScalphaM : rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpScalpham : rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpScalphaeq HPRPpQpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpSc requis par la preuve de (?)PPpQpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpSc requis par la preuve de (?)PPpQpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpScm3 : rk(P :: Pp :: Qp :: Sc :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPPpQpScm4 : rk(P :: Pp :: Qp :: Sc :: nil) >= 4).
{
	assert(HPRPpQpalphaeq : rk(P :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpQpalphaMtmp : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpQpalphaeq HPRPpQpalphaM3).
	assert(HPRPpQpScalphaeq : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) = 4) by (apply LPRPpQpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpQpScalphamtmp : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpQpScalphaeq HPRPpQpScalpham4).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (list_inter (P :: Pp :: Qp :: Sc :: nil) (P :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) (P :: Pp :: Qp :: Sc :: P :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: Sc :: P :: R :: Pp :: Qp :: alpha :: nil) ((P :: Pp :: Qp :: Sc :: nil) ++ (P :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpQpScalphamtmp;try rewrite HT2 in HPRPpQpScalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Qp :: Sc :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) (P :: Pp :: Qp :: nil) 4 3 3 HPRPpQpScalphamtmp HPPpQpmtmp HPRPpQpalphaMtmp Hincl);apply HT.
}

assert(HPPpQpScM : rk(P :: Pp :: Qp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpScm : rk(P :: Pp :: Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpQpSceq HPPpQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpSc *)
(* dans constructLemma(), requis par LPpRpPsSc *)
(* dans constructLemma(), requis par LPPpRpPsOoSc *)
(* dans constructLemma(), requis par LPQPpRpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpPsOoSc requis par la preuve de (?)PQRPpRpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpPsOoSc requis par la preuve de (?)PQRPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpPsOoScm3 : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpPsOoScm4 : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpRpPsOoScM : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpPsOoScm : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpRpPsOoSceq HPQRPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpPsOoSc requis par la preuve de (?)PQPpRpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpPsOoSc requis par la preuve de (?)PQPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpPsOoScm3 : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpRpPsOoScm4 : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpRpPsOoSceq : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPpRpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpRpPsOoSceq HPQRPpRpPsOoScm4).
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpPsOoScmtmp;try rewrite HT2 in HPQRPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpRpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}

assert(HPQPpRpPsOoScM : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpPsOoScm : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpRpPsOoSceq HPQPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOoSc requis par la preuve de (?)PPpRpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOoSc requis par la preuve de (?)PPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsOoScm3 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Pp :: Rp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Rp :: Oo ::   de rang : 4 et 4 *)
assert(HPPpRpPsOoScm4 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQPpRpOoeq : rk(P :: Q :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPQPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpOoMtmp : rk(P :: Q :: Pp :: Rp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpRpOoeq HPQPpRpOoM4).
	assert(HPQPpRpPsOoSceq : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpPsOoScmtmp : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpRpPsOoSceq HPQPpRpPsOoScm4).
	assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Rp :: Oo :: P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Rp :: Oo :: P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Rp :: Oo :: nil) ++ (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpPsOoScmtmp;try rewrite HT2 in HPQPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Pp :: Rp :: Oo :: nil) 4 4 4 HPQPpRpPsOoScmtmp HPPpRpOomtmp HPQPpRpOoMtmp Hincl); apply HT.
}

assert(HPPpRpPsOoScM : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsOoScm : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpRpPsOoSceq HPPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsSc requis par la preuve de (?)PPpRpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsScm3 : rk(P :: Pp :: Rp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPpRpPsScM3 : rk(Pp :: Rp :: Ps :: Sc :: nil) <= 3).
{
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: nil) (Rp :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Pp :: Ps :: Sc :: nil) ((Rp :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HRpMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HPpRpPsScm2 : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPPpRpPsScmtmp : rk(P :: Pp :: Rp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPPpRpPsSceq HPPpRpPsScm3).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Pp :: Rp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Sc :: nil) (P :: Ps :: Pp :: Rp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Pp :: Rp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Pp :: Rp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsScmtmp;try rewrite HT2 in HPPpRpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Pp :: Rp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPPpRpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsScm3 : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpRpPsOoSceq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpPsOoScmtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoSceq HPPpRpPsOoScm4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScmtmp;try rewrite HT2 in HPPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPPpRpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

assert(HPpRpPsScM : rk(Pp :: Rp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsScm : rk(Pp :: Rp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HPpRpPsSceq HPpRpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Rp :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RpSc requis par la preuve de (?)RpSc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HRpScm2 : rk(Rp :: Sc :: nil) >= 2).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPpRpPsSceq : rk(Pp :: Rp :: Ps :: Sc :: nil) = 3) by (apply LPpRpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpRpPsScmtmp : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPpRpPsSceq HPpRpPsScm3).
	assert(HScmtmp : rk(Sc :: nil) >= 1) by (solve_hyps_min HSceq HScm1).
	assert(Hincl : incl (Sc :: nil) (list_inter (Rp :: Sc :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: nil) (Rp :: Sc :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Sc :: Pp :: Ps :: Sc :: nil) ((Rp :: Sc :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpRpPsScmtmp;try rewrite HT2 in HPpRpPsScmtmp.
	assert(HT := rule_2 (Rp :: Sc :: nil) (Pp :: Ps :: Sc :: nil) (Sc :: nil) 3 1 2 HPpRpPsScmtmp HScmtmp HPpPsScMtmp Hincl);apply HT.
}

assert(HRpScM : rk(Rp :: Sc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRpSceq HRpScM2).
assert(HRpScm : rk(Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HRpSceq HRpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpRpSc *)
(* dans la couche 0 *)
Lemma LPQPpRpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpScalpha requis par la preuve de (?)PQPpRpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpScalpha requis par la preuve de (?)PQPpRpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpRpScalpham3 : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpScalpham4 : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPQPpRpScalphaM : rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpScalpham : rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpScalphaeq HPQPpRpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpSc requis par la preuve de (?)PPpRpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpSc requis par la preuve de (?)PPpRpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpScm3 : rk(P :: Pp :: Rp :: Sc :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPPpRpScm4 : rk(P :: Pp :: Rp :: Sc :: nil) >= 4).
{
	assert(HPQPpRpalphaeq : rk(P :: Q :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPQPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpalphaMtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQPpRpalphaeq HPQPpRpalphaM3).
	assert(HPQPpRpScalphaeq : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) = 4) by (apply LPQPpRpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpRpScalphamtmp : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpRpScalphaeq HPQPpRpScalpham4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Pp :: Rp :: Sc :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) (P :: Pp :: Rp :: Sc :: P :: Q :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: Sc :: P :: Q :: Pp :: Rp :: alpha :: nil) ((P :: Pp :: Rp :: Sc :: nil) ++ (P :: Q :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpScalphamtmp;try rewrite HT2 in HPQPpRpScalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: Sc :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 4 3 3 HPQPpRpScalphamtmp HPPpRpmtmp HPQPpRpalphaMtmp Hincl);apply HT.
}

assert(HPPpRpScM : rk(P :: Pp :: Rp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpScm : rk(P :: Pp :: Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpRpSceq HPPpRpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpSc *)
(* dans la couche 0 *)
Lemma LPQRQpRpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpScalpha requis par la preuve de (?)PQRQpRpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpScalpha requis par la preuve de (?)PQRQpRpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpRpScalpham3 : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpRpScalpham4 : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpRpScalphaM : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpScalpham : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpScalphaeq HPQRQpRpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpSc requis par la preuve de (?)QQpRpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpSc requis par la preuve de (?)QQpRpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpScm3 : rk(Q :: Qp :: Rp :: Sc :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Sc :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HQQpRpScm4 : rk(Q :: Qp :: Rp :: Sc :: nil) >= 4).
{
	assert(HPQRQpRpalphaeq : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) = 3) by (apply LPQRQpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpRpalphaMtmp : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpRpalphaeq HPQRQpRpalphaM3).
	assert(HPQRQpRpScalphaeq : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) = 4) by (apply LPQRQpRpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpRpScalphamtmp : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpRpScalphaeq HPQRQpRpScalpham4).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (list_inter (Q :: Qp :: Rp :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) (Q :: Qp :: Rp :: Sc :: P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: Sc :: P :: Q :: R :: Qp :: Rp :: alpha :: nil) ((Q :: Qp :: Rp :: Sc :: nil) ++ (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpRpScalphamtmp;try rewrite HT2 in HPQRQpRpScalphamtmp.
	assert(HT := rule_2 (Q :: Qp :: Rp :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (Q :: Qp :: Rp :: nil) 4 3 3 HPQRQpRpScalphamtmp HQQpRpmtmp HPQRQpRpalphaMtmp Hincl);apply HT.
}

assert(HQQpRpScM : rk(Q :: Qp :: Rp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpScm : rk(Q :: Qp :: Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HQQpRpSceq HQQpRpScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsSc requis par la preuve de (?)PQPpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsScm3 : rk(P :: Q :: Pp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HQPpPsScM3 : rk(Q :: Pp :: Ps :: Sc :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Ps :: Sc :: nil) (Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Ps :: Sc :: nil) ((Q :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HQMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HQPpPsScm2 : rk(Q :: Pp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPQPpPsScmtmp : rk(P :: Q :: Pp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPQPpPsSceq HPQPpPsScm3).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Q :: Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Q :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Q :: Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScmtmp;try rewrite HT2 in HPQPpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Q :: Pp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPQPpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HQPpPsScm3 : rk(Q :: Pp :: Ps :: Sc :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Q :: Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Q :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Q :: Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Q :: Pp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPQPpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

assert(HQPpPsScM : rk(Q :: Pp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpPsScm : rk(Q :: Pp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HQPpPsSceq HQPpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoScm3 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpOoScm4 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpOoScM : rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOoScm : rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpOoSceq HPQRPpOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpPsQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRQpPsQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpPsQsOoScm3 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpPsQsOoScm4 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRQpPsQsOoScM : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpPsQsOoScm : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQQpPsQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpPsQsOoScm3 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPQQpPsQsOoScm4 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRQpOoeq : rk(P :: Q :: R :: Qp :: Oo :: nil) = 4) by (apply LPQRQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpOoMtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRQpOoeq HPQRQpOoM4).
	assert(HPQRQpPsQsOoSceq : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQRQpPsQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQpPsQsOoScmtmp : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm4).
	assert(HPQQpOoeq : rk(P :: Q :: Qp :: Oo :: nil) = 4) by (apply LPQQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQQpOomtmp : rk(P :: Q :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQQpOoeq HPQQpOom4).
	assert(Hincl : incl (P :: Q :: Qp :: Oo :: nil) (list_inter (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Qp :: Oo :: nil) ++ (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpPsQsOoScmtmp;try rewrite HT2 in HPQRQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: Qp :: Oo :: nil) 4 4 4 HPQRQpPsQsOoScmtmp HPQQpOomtmp HPQRQpOoMtmp Hincl); apply HT.
}

assert(HPQQpPsQsOoScM : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQQpPsQsOoScm : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQQpPsQsOoSceq HPQQpPsQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQalpha requis par la preuve de (?)PQalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalpha requis par la preuve de (?)PQalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalpha requis par la preuve de (?)PQPpOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpOpalpham3 : rk(P :: Q :: Pp :: Op :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQalpha requis par la preuve de (?)PQalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalpham2 : rk(P :: Q :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphamtmp : rk(P :: Q :: Pp :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpOpalphaeq HPQPpOpalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphamtmp;try rewrite HT2 in HPQPpOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: nil) (P :: nil) 3 1 2 HPQPpOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HPQalpham3 : rk(P :: Q :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRalphamtmp : rk(P :: Q :: R :: alpha :: nil) >= 3) by (solve_hyps_min HPQRalphaeq HPQRalpham3).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: Q :: alpha :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: nil) (P :: Q :: alpha :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: alpha :: P :: R :: alpha :: nil) ((P :: Q :: alpha :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRalphamtmp;try rewrite HT2 in HPQRalphamtmp.
	assert(HT := rule_2 (P :: Q :: alpha :: nil) (P :: R :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPQRalphamtmp HPalphamtmp HPRalphaMtmp Hincl);apply HT.
}

assert(HPQalphaM : rk(P :: Q :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQalphaeq HPQalphaM3).
assert(HPQalpham : rk(P :: Q :: alpha ::  nil) >= 1) by (solve_hyps_min HPQalphaeq HPQalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LRalpha *)
(* dans la couche 0 *)
Lemma LRPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpRpalpha requis par la preuve de (?)PRPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpRpalpham3 : rk(P :: R :: Pp :: Rp :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Rp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PRp requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HRPpRpalphaM3 : rk(R :: Pp :: Rp :: alpha :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (R :: Pp :: Rp :: alpha :: nil) (R :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Pp :: Rp :: alpha :: nil) ((R :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (Pp :: Rp :: alpha :: nil) (nil) 1 2 0 HRMtmp HPpRpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: R :: Pp :: Rp :: alpha ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: Rp ::   de rang : 1 et 2 *)
assert(HRPpRpalpham2 : rk(R :: Pp :: Rp :: alpha :: nil) >= 2).
{
	assert(HPRpMtmp : rk(P :: Rp :: nil) <= 2) by (solve_hyps_max HPRpeq HPRpM2).
	assert(HPRPpRpalphamtmp : rk(P :: R :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpRpalphaeq HPRPpRpalpham3).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Rp :: alpha :: nil) (P :: Rp :: R :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Rp :: R :: Pp :: Rp :: alpha :: nil) ((P :: Rp :: nil) ++ (R :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpRpalphamtmp;try rewrite HT2 in HPRPpRpalphamtmp.
	assert(HT := rule_4 (P :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil) (Rp :: nil) 3 1 2 HPRPpRpalphamtmp HRpmtmp HPRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HRPpRpalpham3 : rk(R :: Pp :: Rp :: alpha :: nil) >= 3).
{
	assert(HRPpRpmtmp : rk(R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HRPpRpeq HRPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (R :: Pp :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (R :: Pp :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil) 3 3 HRPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HRPpRpalphaM : rk(R :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRPpRpalpham : rk(R :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HRPpRpalphaeq HRPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ralpha requis par la preuve de (?)Ralpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HRalpham2 : rk(R :: alpha :: nil) >= 2).
{
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(HRPpRpalphaeq : rk(R :: Pp :: Rp :: alpha :: nil) = 3) by (apply LRPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HRPpRpalphamtmp : rk(R :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HRPpRpalphaeq HRPpRpalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (R :: alpha :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (R :: Pp :: Rp :: alpha :: nil) (R :: alpha :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: alpha :: Pp :: Rp :: alpha :: nil) ((R :: alpha :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HRPpRpalphamtmp;try rewrite HT2 in HRPpRpalphamtmp.
	assert(HT := rule_2 (R :: alpha :: nil) (Pp :: Rp :: alpha :: nil) (alpha :: nil) 3 1 2 HRPpRpalphamtmp Halphamtmp HPpRpalphaMtmp Hincl);apply HT.
}

assert(HRalphaM : rk(R :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRalphaeq HRalphaM2).
assert(HRalpham : rk(R :: alpha ::  nil) >= 1) by (solve_hyps_min HRalphaeq HRalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPsalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPsalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Q :: Pp :: Ps :: Sc ::   de rang : 3 et 3 *)
assert(HPPsalpham2 : rk(P :: Ps :: alpha :: nil) >= 2).
{
	assert(HQPpPsSceq : rk(Q :: Pp :: Ps :: Sc :: nil) = 3) by (apply LQPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQPpPsScMtmp : rk(Q :: Pp :: Ps :: Sc :: nil) <= 3) by (solve_hyps_max HQPpPsSceq HQPpPsScM3).
	assert(HPQPpPsScalphamtmp : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) (Q :: Pp :: Ps :: Sc :: P :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Ps :: Sc :: P :: Ps :: alpha :: nil) ((Q :: Pp :: Ps :: Sc :: nil) ++ (P :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScalphamtmp;try rewrite HT2 in HPQPpPsScalphamtmp.
	assert(HT := rule_4 (Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: alpha :: nil) (Ps :: nil) 4 1 3 HPQPpPsScalphamtmp HPsmtmp HQPpPsScMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: alpha ::  de rang :  3 et 3 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsalpham3 : rk(P :: Ps :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsalphaeq : rk(P :: R :: Ps :: alpha :: nil) = 3) by (apply LPRPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPsalphamtmp : rk(P :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsalphaeq HPRPsalpham3).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsalphamtmp;try rewrite HT2 in HPRPsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPPsalphaM : rk(P :: Ps :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPsalphaeq HPPsalphaM3).
assert(HPPsalpham : rk(P :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsalphaeq HPPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPsalpha *)
(* dans constructLemma(), requis par LPQPsOoalpha *)
(* dans la couche 0 *)
Lemma LPQRPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsOoalpha requis par la preuve de (?)PQRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsOoalpha requis par la preuve de (?)PQRPsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsOoalpham3 : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsOoalpham4 : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsOoalphaM : rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsOoalpham : rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPsOoalphaeq HPQRPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpOoalpha requis par la preuve de (?)PQPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOpOoalpham3 : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsOoalpham2 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpOoalphamtmp : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsOpOoalphaeq HPQPpPsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpOoalphamtmp;try rewrite HT2 in HPQPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOoalpham3 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsOoalpham4 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsOoalphaeq : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) = 4) by (apply LPQRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsOoalphamtmp : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsOoalphaeq HPQRPsOoalpham4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsOoalphamtmp;try rewrite HT2 in HPQRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsOoalphaM : rk(P :: Q :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOoalpham : rk(P :: Q :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsOoalphaeq HPQPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpalpha requis par la preuve de (?)PQPpPsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOpalpham3 : rk(P :: Q :: Pp :: Ps :: Op :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsalpham2 : rk(P :: Q :: Ps :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpalphamtmp : rk(P :: Q :: Pp :: Ps :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsOpalphaeq HPQPpPsOpalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpalphamtmp;try rewrite HT2 in HPQPpPsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsalpham3 : rk(P :: Q :: Ps :: alpha :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsScalphamtmp : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScalphamtmp;try rewrite HT2 in HPQPpPsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: alpha :: nil) (Ps :: nil) 4 1 2 HPQPpPsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQPsalpham4 : rk(P :: Q :: Ps :: alpha :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsOoalphaeq : rk(P :: Q :: Ps :: Oo :: alpha :: nil) = 4) by (apply LPQPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsOoalphamtmp : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsOoalphaeq HPQPsOoalpham4).
	assert(HPPsalphaeq : rk(P :: Ps :: alpha :: nil) = 3) by (apply LPPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsalphamtmp : rk(P :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPPsalphaeq HPPsalpham3).
	assert(Hincl : incl (P :: Ps :: alpha :: nil) (list_inter (P :: Q :: Ps :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: Q :: Ps :: alpha :: P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: alpha :: P :: Ps :: Oo :: alpha :: nil) ((P :: Q :: Ps :: alpha :: nil) ++ (P :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsOoalphamtmp;try rewrite HT2 in HPQPsOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Ps :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil) (P :: Ps :: alpha :: nil) 4 3 3 HPQPsOoalphamtmp HPPsalphamtmp HPPsOoalphaMtmp Hincl);apply HT.
}

assert(HPQPsalphaM : rk(P :: Q :: Ps :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsalpham : rk(P :: Q :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsalphaeq HPQPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsalpha *)
(* dans la couche 0 *)
Lemma LPRQsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Qs :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQsalpha requis par la preuve de (?)PQRQsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQsalpham3 : rk(P :: Q :: R :: Qs :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QQs requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPRQsalphaM3 : rk(P :: R :: Qs :: alpha :: nil) <= 3).
{
	assert(HQsMtmp : rk(Qs :: nil) <= 1) by (solve_hyps_max HQseq HQsM1).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qs :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Qs :: alpha :: nil) (Qs :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qs :: P :: R :: alpha :: nil) ((Qs :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qs :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HQsMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: alpha ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs ::   de rang : 1 et 2 *)
assert(HPRQsalpham2 : rk(P :: R :: Qs :: alpha :: nil) >= 2).
{
	assert(HQQsMtmp : rk(Q :: Qs :: nil) <= 2) by (solve_hyps_max HQQseq HQQsM2).
	assert(HPQRQsalphamtmp : rk(P :: Q :: R :: Qs :: alpha :: nil) >= 3) by (solve_hyps_min HPQRQsalphaeq HPQRQsalpham3).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: nil) (P :: R :: Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: alpha :: nil) (Q :: Qs :: P :: R :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: P :: R :: Qs :: alpha :: nil) ((Q :: Qs :: nil) ++ (P :: R :: Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsalphamtmp;try rewrite HT2 in HPQRQsalphamtmp.
	assert(HT := rule_4 (Q :: Qs :: nil) (P :: R :: Qs :: alpha :: nil) (Qs :: nil) 3 1 2 HPQRQsalphamtmp HQsmtmp HQQsMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRQsalpham3 : rk(P :: R :: Qs :: alpha :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRQsOoalphaeq : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRQsOoalphamtmp : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: Oo :: alpha :: nil) (Q :: Qs :: Oo :: P :: R :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Qs :: alpha :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsOoalphamtmp;try rewrite HT2 in HPQRQsOoalphamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Qs :: alpha :: nil) (Qs :: nil) 4 1 2 HPQRQsOoalphamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

assert(HPRQsalphaM : rk(P :: R :: Qs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRQsalpham : rk(P :: R :: Qs :: alpha ::  nil) >= 1) by (solve_hyps_min HPRQsalphaeq HPRQsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qs :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Qsalpha requis par la preuve de (?)Qsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Qs :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQsalpham2 : rk(Qs :: alpha :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRQsalphaeq : rk(P :: R :: Qs :: alpha :: nil) = 3) by (apply LPRQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRQsalphamtmp : rk(P :: R :: Qs :: alpha :: nil) >= 3) by (solve_hyps_min HPRQsalphaeq HPRQsalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Qs :: alpha :: nil) (P :: R :: alpha :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Qs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRQsalphamtmp;try rewrite HT2 in HPRQsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Qs :: alpha :: nil) (alpha :: nil) 3 1 2 HPRQsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HQsalphaM : rk(Qs :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQsalphaeq HQsalphaM2).
assert(HQsalpham : rk(Qs :: alpha ::  nil) >= 1) by (solve_hyps_min HQsalphaeq HQsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans constructLemma(), requis par LPPsRsalpha *)
(* dans la couche 0 *)
Lemma LPRPsRsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPpPsRsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsOoalpham2 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpOoalphaeq HPRPpPsRsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpOoalphamtmp;try rewrite HT2 in HPRPpPsRsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPsRsOoalpham3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROoeq : rk(P :: R :: Oo :: nil) = 3) by (apply LPROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HPRPsRsOoalphaM3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) <= 3).
{
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HPRPsOoalphaeq : rk(P :: R :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPsOoalphaMtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPRPsOoalphaeq HPRPsOoalphaM3).
	assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HROomtmp : rk(R :: Oo :: nil) >= 2) by (solve_hyps_min HROoeq HROom2).
	assert(Hincl : incl (R :: Oo :: nil) (list_inter (R :: Rs :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (R :: Rs :: Oo :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: P :: R :: Ps :: Oo :: alpha :: nil) ((R :: Rs :: Oo :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: Rs :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (R :: Oo :: nil) 2 3 2 HRRsOoMtmp HPRPsOoalphaMtmp HROomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPRPsRsOoalphaM : rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsRsOoalpham : rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsRsOoalphaeq HPRPsRsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsRsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Rs :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPpPsRsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsOpalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham2 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpalphaeq HPRPpPsRsOpalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpalphamtmp;try rewrite HT2 in HPRPpPsRsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham3 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPRPpPsRsScalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsScalphamtmp;try rewrite HT2 in HPRPpPsRsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsRsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPpPsRsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsOoalpham2 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpOoalphaeq HPRPpPsRsOpOoalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpOoalphamtmp;try rewrite HT2 in HPRPpPsRsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPsRsOoalpham3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROoeq : rk(P :: R :: Oo :: nil) = 3) by (apply LPROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : Rs ::  de rang :  1 et 1 	 A : R :: Rs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsRsalpham2 : rk(P :: Ps :: Rs :: alpha :: nil) >= 2).
{
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HPRPsRsOoalphamtmp : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsOoalphaeq HPRPsRsOoalpham3).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (R :: Rs :: Oo :: nil) (P :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (R :: Rs :: Oo :: P :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: P :: Ps :: Rs :: alpha :: nil) ((R :: Rs :: Oo :: nil) ++ (P :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsOoalphamtmp;try rewrite HT2 in HPRPsRsOoalphamtmp.
	assert(HT := rule_4 (R :: Rs :: Oo :: nil) (P :: Ps :: Rs :: alpha :: nil) (Rs :: nil) 3 1 2 HPRPsRsOoalphamtmp HRsmtmp HRRsOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: alpha ::  de rang :  3 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsRsalpham3 : rk(P :: Ps :: Rs :: alpha :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsRsalphamtmp : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsalphaeq HPRPsRsalpham3).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Rs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsalphamtmp;try rewrite HT2 in HPRPsRsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Rs :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsRsalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPsRsalphaM3 : rk(P :: Ps :: Rs :: alpha :: nil) <= 3).
{
	assert(HPRPsRsOoalphaeq : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) = 3) by (apply LPRPsRsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPsRsOoalphaMtmp : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPRPsRsOoalphaeq HPRPsRsOoalphaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Ps :: Rs :: alpha :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Ps :: Rs :: alpha :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPRPsRsOoalphaMtmp Hcomp Hincl);apply HT.
}

assert(HPPsRsalphaM : rk(P :: Ps :: Rs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsRsalpham : rk(P :: Ps :: Rs :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsRsalphaeq HPPsRsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans constructLemma(), requis par LPpRpPsRsScalpha *)
(* dans la couche 0 *)
Lemma LPpRpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOpScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOpScalpha requis par la preuve de (?)PPpRpPsOpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsOpScalpham3 : rk(P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsScalpham2 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsOpScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsOpScalphaeq HPPpRpPsOpScalpham3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOpScalphamtmp;try rewrite HT2 in HPPpRpPsOpScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsOpScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsScalpham3 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Ps :: nil) 4 1 2 HPPpRpPsOoScalphamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPpRpPsScalphaM3 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) <= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: Pp :: Rp :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (Pp :: Rp :: alpha :: nil) (Pp :: nil) 2 2 1 HPpPsScMtmp HPpRpalphaMtmp HPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPpRpPsScalphaM : rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsScalpham : rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsScalphaeq HPpRpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsRsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOpScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOpScalpha requis par la preuve de (?)PPpRpPsRsOpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsRsOpScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsRsScalpham2 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsRsOpScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsRsOpScalphaeq HPPpRpPsRsOpScalpham3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsOpScalphamtmp;try rewrite HT2 in HPPpRpPsRsOpScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsRsOpScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsRsScalpham3 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpRpPsRsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsRsOoScalphaeq HPPpRpPsRsOoScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsOoScalphamtmp;try rewrite HT2 in HPPpRpPsRsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Ps :: nil) 4 1 2 HPPpRpPsRsOoScalphamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HPpRpPsRsScalphaM3 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) <= 3).
{
	assert(HRpRsScMtmp : rk(Rp :: Rs :: Sc :: nil) <= 2) by (solve_hyps_max HRpRsSceq HRpRsScM2).
	assert(HPpRpPsScalphaeq : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) = 3) by (apply LPpRpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpRpPsScalphaMtmp : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpRpPsScalphaeq HPpRpPsScalphaM3).
	assert(HRpSceq : rk(Rp :: Sc :: nil) = 2) by (apply LRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HRpScmtmp : rk(Rp :: Sc :: nil) >= 2) by (solve_hyps_min HRpSceq HRpScm2).
	assert(Hincl : incl (Rp :: Sc :: nil) (list_inter (Rp :: Rs :: Sc :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Rp :: Rs :: Sc :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Rs :: Sc :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((Rp :: Rs :: Sc :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Rs :: Sc :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Rp :: Sc :: nil) 2 3 2 HRpRsScMtmp HPpRpPsScalphaMtmp HRpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPpRpPsRsScalphaM : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsRsScalpham : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsRsScalphaeq HPpRpPsRsScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans la couche 0 *)
Lemma LPPpRpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsScalpha requis par la preuve de (?)PPpRpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsScalpha requis par la preuve de (?)PPpRpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsRsScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	assert(HPPpRpSceq : rk(P :: Pp :: Rp :: Sc :: nil) = 4) by (apply LPPpRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpScmtmp : rk(P :: Pp :: Rp :: Sc :: nil) >= 4) by (solve_hyps_min HPPpRpSceq HPPpRpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Sc :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Sc :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPPpRpScmtmp Hcomp Hincl);apply HT.
}

assert(HPPpRpPsRsScalphaM : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsRsScalpham : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsRsScalphaeq HPPpRpPsRsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsRsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Rs :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPpPsRsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsOpalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham2 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpalphaeq HPRPpPsRsOpalpham3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpalphamtmp;try rewrite HT2 in HPRPpPsRsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham3 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPRPpPsRsScalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsScalphamtmp;try rewrite HT2 in HPRPpPsRsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsRsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: alpha ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsRsalpham2 : rk(Ps :: Rs :: alpha :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsRsalphamtmp : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsalphaeq HPRPsRsalpham3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: alpha :: nil) (P :: R :: alpha :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Rs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsalphamtmp;try rewrite HT2 in HPRPsRsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Rs :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsRsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HPsRsalphaM2 : rk(Ps :: Rs :: alpha :: nil) <= 2).
{
	assert(HPPsRsalphaeq : rk(P :: Ps :: Rs :: alpha :: nil) = 3) by (apply LPPsRsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsRsalphaMtmp : rk(P :: Ps :: Rs :: alpha :: nil) <= 3) by (solve_hyps_max HPPsRsalphaeq HPPsRsalphaM3).
	assert(HPpRpPsRsScalphaeq : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) = 3) by (apply LPpRpPsRsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpRpPsRsScalphaMtmp : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpRpPsRsScalphaeq HPpRpPsRsScalphaM3).
	assert(HPPpRpPsRsScalphaeq : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsRsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpPsRsScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsRsScalphaeq HPPpRpPsRsScalpham4).
	assert(Hincl : incl (Ps :: Rs :: alpha :: nil) (list_inter (P :: Ps :: Rs :: alpha :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (P :: Ps :: Rs :: alpha :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Rs :: alpha :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Ps :: Rs :: alpha :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsScalphamtmp;try rewrite HT2 in HPPpRpPsRsScalphamtmp.
	assert(HT := rule_3 (P :: Ps :: Rs :: alpha :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Ps :: Rs :: alpha :: nil) 3 3 4 HPPsRsalphaMtmp HPpRpPsRsScalphaMtmp HPPpRpPsRsScalphamtmp Hincl);apply HT.
}


assert(HPsRsalphaM : rk(Ps :: Rs :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsRsalphaeq HPsRsalphaM3).
assert(HPsRsalpham : rk(Ps :: Rs :: alpha ::  nil) >= 1) by (solve_hyps_min HPsRsalphaeq HPsRsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPQPpPsScalphaM : rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsScalpham : rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPRPpPsRsScalphaM : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpPsRsScalpham : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOoScalpham3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}

assert(HPQPpPsOoScalphaM : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsOoScalpham : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpPsOoScalphaeq HPQPpPsOoScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScalpham3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpPsOoScalpham4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpPsOoScalphaM : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpPsOoScalpham : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpPsOoScalphaeq HPQRPpPsOoScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsRsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpRpPsRsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 3).
{
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4).
{
	assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}

assert(HPPpRpPsRsOoScalphaM : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsRsOoScalpham : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsRsOoScalphaeq HPPpRpPsRsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQbeta *)
(* dans la couche 0 *)
Lemma LQQpRpbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpRpbeta requis par la preuve de (?)PQQpRpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQQpRpbetam3 : rk(P :: Q :: Qp :: Rp :: beta :: nil) >= 3).
{
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Rp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Rp :: beta :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PRp requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HQQpRpbetaM3 : rk(Q :: Qp :: Rp :: beta :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: beta :: nil) (Q :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: beta :: nil) ((Q :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (Qp :: Rp :: beta :: nil) (nil) 1 2 0 HQMtmp HQpRpbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: Qp :: Rp :: beta ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: Rp ::   de rang : 1 et 2 *)
assert(HQQpRpbetam2 : rk(Q :: Qp :: Rp :: beta :: nil) >= 2).
{
	assert(HPRpMtmp : rk(P :: Rp :: nil) <= 2) by (solve_hyps_max HPRpeq HPRpM2).
	assert(HPQQpRpbetamtmp : rk(P :: Q :: Qp :: Rp :: beta :: nil) >= 3) by (solve_hyps_min HPQQpRpbetaeq HPQQpRpbetam3).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Rp :: beta :: nil) (P :: Rp :: Q :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Rp :: Q :: Qp :: Rp :: beta :: nil) ((P :: Rp :: nil) ++ (Q :: Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpRpbetamtmp;try rewrite HT2 in HPQQpRpbetamtmp.
	assert(HT := rule_4 (P :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil) (Rp :: nil) 3 1 2 HPQQpRpbetamtmp HRpmtmp HPRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpbetam3 : rk(Q :: Qp :: Rp :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HQQpRpbetaM : rk(Q :: Qp :: Rp :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpbetam : rk(Q :: Qp :: Rp :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpbetaeq HQQpRpbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Qbeta requis par la preuve de (?)Qbeta pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HQbetam2 : rk(Q :: beta :: nil) >= 2).
{
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	assert(HQQpRpbetaeq : rk(Q :: Qp :: Rp :: beta :: nil) = 3) by (apply LQQpRpbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpbetamtmp : rk(Q :: Qp :: Rp :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpbetaeq HQQpRpbetam3).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: beta :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: beta :: nil) (Q :: beta :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: beta :: Qp :: Rp :: beta :: nil) ((Q :: beta :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpbetamtmp;try rewrite HT2 in HQQpRpbetamtmp.
	assert(HT := rule_2 (Q :: beta :: nil) (Qp :: Rp :: beta :: nil) (beta :: nil) 3 1 2 HQQpRpbetamtmp Hbetamtmp HQpRpbetaMtmp Hincl);apply HT.
}

assert(HQbetaM : rk(Q :: beta ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQbetaeq HQbetaM2).
assert(HQbetam : rk(Q :: beta ::  nil) >= 1) by (solve_hyps_min HQbetaeq HQbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans constructLemma(), requis par LQQsRsbeta *)
(* dans constructLemma(), requis par LQRQsRsOobeta *)
(* dans la couche 0 *)
Lemma LQRQsOobeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qs :: Oo :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsOpOobeta requis par la preuve de (?)QRQsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsOpOobeta requis par la preuve de (?)QRQpQsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsOobetam2 : rk(Q :: R :: Qs :: Oo :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsOpOobetaeq HQRQpQsOpOobetam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsOpOobetamtmp;try rewrite HT2 in HQRQpQsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsOobetam3 : rk(Q :: R :: Qs :: Oo :: beta :: nil) >= 3).
{
	assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HQRQsOobetaM3 : rk(Q :: R :: Qs :: Oo :: beta :: nil) <= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Q :: R :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Oo :: beta :: nil) (Q :: Qs :: Oo :: Q :: R :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Q :: R :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Q :: R :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (Q :: R :: beta :: nil) (Q :: nil) 2 2 1 HQQsOoMtmp HQRbetaMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HQRQsOobetaM : rk(Q :: R :: Qs :: Oo :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQsOobetam : rk(Q :: R :: Qs :: Oo :: beta ::  nil) >= 1) by (solve_hyps_min HQRQsOobetaeq HQRQsOobetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQsRsOobeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQpQsRsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsOobetam2 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpOobetaeq HQRQpQsRsOpOobetam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpOobetamtmp;try rewrite HT2 in HQRQpQsRsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsRsOobetam3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3).
{
	assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HQRQsRsOobetaM3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) <= 3).
{
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HQRQsOobetaeq : rk(Q :: R :: Qs :: Oo :: beta :: nil) = 3) by (apply LQRQsOobeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQRQsOobetaMtmp : rk(Q :: R :: Qs :: Oo :: beta :: nil) <= 3) by (solve_hyps_max HQRQsOobetaeq HQRQsOobetaM3).
	assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HROomtmp : rk(R :: Oo :: nil) >= 2) by (solve_hyps_min HROoeq HROom2).
	assert(Hincl : incl (R :: Oo :: nil) (list_inter (R :: Rs :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (R :: Rs :: Oo :: Q :: R :: Qs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: Q :: R :: Qs :: Oo :: beta :: nil) ((R :: Rs :: Oo :: nil) ++ (Q :: R :: Qs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: Rs :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) (R :: Oo :: nil) 2 3 2 HRRsOoMtmp HQRQsOobetaMtmp HROomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HQRQsRsOobetaM : rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQsRsOobetam : rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) >= 1) by (solve_hyps_min HQRQsRsOobetaeq HQRQsRsOobetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQsRsbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qs :: Rs :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQpQsRsOpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsOpbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam2 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpbetaeq HQRQpQsRsOpbetam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpbetamtmp;try rewrite HT2 in HQRQpQsRsOpbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpbetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Qp :: Qs :: Sc ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam3 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3).
{
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQRQpQsRsScbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsScbetamtmp;try rewrite HT2 in HQRQpQsRsScbetamtmp.
	assert(HT := rule_4 (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Qs :: nil) 4 1 2 HQRQpQsRsScbetamtmp HQsmtmp HQpQsScMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQpQsRsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsOobetam2 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpOobetaeq HQRQpQsRsOpOobetam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpOobetamtmp;try rewrite HT2 in HQRQpQsRsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsRsOobetam3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3).
{
	assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Rs ::  de rang :  1 et 1 	 A : R :: Rs :: Oo ::   de rang : 2 et 2 *)
assert(HQQsRsbetam2 : rk(Q :: Qs :: Rs :: beta :: nil) >= 2).
{
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HQRQsRsOobetamtmp : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsOobetaeq HQRQsRsOobetam3).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (R :: Rs :: Oo :: nil) (Q :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (R :: Rs :: Oo :: Q :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: Q :: Qs :: Rs :: beta :: nil) ((R :: Rs :: Oo :: nil) ++ (Q :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsOobetamtmp;try rewrite HT2 in HQRQsRsOobetamtmp.
	assert(HT := rule_4 (R :: Rs :: Oo :: nil) (Q :: Qs :: Rs :: beta :: nil) (Rs :: nil) 3 1 2 HQRQsRsOobetamtmp HRsmtmp HRRsOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: beta ::  de rang :  3 et 4 	 AiB : Q :: beta ::  de rang :  2 et 2 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(HQQsRsbetam3 : rk(Q :: Qs :: Rs :: beta :: nil) >= 3).
{
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRQsRsbetamtmp : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsbetaeq HQRQsRsbetam3).
	assert(HQbetaeq : rk(Q :: beta :: nil) = 2) by (apply LQbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQbetamtmp : rk(Q :: beta :: nil) >= 2) by (solve_hyps_min HQbetaeq HQbetam2).
	assert(Hincl : incl (Q :: beta :: nil) (list_inter (Q :: R :: beta :: nil) (Q :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: R :: beta :: Q :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: Q :: Qs :: Rs :: beta :: nil) ((Q :: R :: beta :: nil) ++ (Q :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsbetamtmp;try rewrite HT2 in HQRQsRsbetamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (Q :: Qs :: Rs :: beta :: nil) (Q :: beta :: nil) 3 2 2 HQRQsRsbetamtmp HQbetamtmp HQRbetaMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQsRsbetaM3 : rk(Q :: Qs :: Rs :: beta :: nil) <= 3).
{
	assert(HQRQsRsOobetaeq : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) = 3) by (apply LQRQsRsOobeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQRQsRsOobetaMtmp : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) <= 3) by (solve_hyps_max HQRQsRsOobetaeq HQRQsRsOobetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qs :: Rs :: beta :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Q :: Qs :: Rs :: beta :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQRQsRsOobetaMtmp Hcomp Hincl);apply HT.
}

assert(HQQsRsbetaM : rk(Q :: Qs :: Rs :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQsRsbetam : rk(Q :: Qs :: Rs :: beta ::  nil) >= 1) by (solve_hyps_min HQQsRsbetaeq HQQsRsbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans constructLemma(), requis par LQpRpQsRsScbeta *)
(* dans la couche 0 *)
Lemma LQpRpQsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4).
{
	assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOpScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOpScbeta requis par la preuve de (?)QQpRpQsOpScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsOpScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQpRpQsScbetam2 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQQpRpQsOpScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpQsOpScbetaeq HQQpRpQsOpScbetam3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsOpScbetamtmp;try rewrite HT2 in HQQpRpQsOpScbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qp :: nil) 3 1 2 HQQpRpQsOpScbetamtmp HQpmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HQpRpQsScbetam3 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQQpRpQsOoScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsOoScbetaeq HQQpRpQsOoScbetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsOoScbetamtmp;try rewrite HT2 in HQQpRpQsOoScbetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qs :: nil) 4 1 2 HQQpRpQsOoScbetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HQpRpQsScbetaM3 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) <= 3).
{
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Qp :: Rp :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: Qs :: Sc :: nil) (Qp :: Rp :: beta :: nil) (Qp :: nil) 2 2 1 HQpQsScMtmp HQpRpbetaMtmp HQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HQpRpQsScbetaM : rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQpRpQsScbetam : rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQpRpQsScbetaeq HQpRpQsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpRpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsRsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4).
{
	assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOpScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOpScbeta requis par la preuve de (?)QQpRpQsRsOpScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsRsOpScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQpRpQsRsScbetam2 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQQpRpQsRsOpScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpQsRsOpScbetaeq HQQpRpQsRsOpScbetam3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsOpScbetamtmp;try rewrite HT2 in HQQpRpQsRsOpScbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: nil) 3 1 2 HQQpRpQsRsOpScbetamtmp HQpmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HQpRpQsRsScbetam3 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQQpRpQsRsOoScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsRsOoScbetaeq HQQpRpQsRsOoScbetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsOoScbetamtmp;try rewrite HT2 in HQQpRpQsRsOoScbetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qs :: nil) 4 1 2 HQQpRpQsRsOoScbetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HQpRpQsRsScbetaM3 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) <= 3).
{
	assert(HRpRsScMtmp : rk(Rp :: Rs :: Sc :: nil) <= 2) by (solve_hyps_max HRpRsSceq HRpRsScM2).
	assert(HQpRpQsScbetaeq : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) = 3) by (apply LQpRpQsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQpRpQsScbetaMtmp : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) <= 3) by (solve_hyps_max HQpRpQsScbetaeq HQpRpQsScbetaM3).
	assert(HRpSceq : rk(Rp :: Sc :: nil) = 2) by (apply LRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HRpScmtmp : rk(Rp :: Sc :: nil) >= 2) by (solve_hyps_min HRpSceq HRpScm2).
	assert(Hincl : incl (Rp :: Sc :: nil) (list_inter (Rp :: Rs :: Sc :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Rp :: Rs :: Sc :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Rs :: Sc :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Rp :: Rs :: Sc :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Rs :: Sc :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Rp :: Sc :: nil) 2 3 2 HRpRsScMtmp HQpRpQsScbetaMtmp HRpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HQpRpQsRsScbetaM : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQpRpQsRsScbetam : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQpRpQsRsScbetaeq HQpRpQsRsScbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans la couche 0 *)
Lemma LQQpRpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsScbeta requis par la preuve de (?)QQpRpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsScbeta requis par la preuve de (?)QQpRpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsRsScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	assert(HQQpRpSceq : rk(Q :: Qp :: Rp :: Sc :: nil) = 4) by (apply LQQpRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpScmtmp : rk(Q :: Qp :: Rp :: Sc :: nil) >= 4) by (solve_hyps_min HQQpRpSceq HQQpRpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Sc :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Sc :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQQpRpScmtmp Hcomp Hincl);apply HT.
}

assert(HQQpRpQsRsScbetaM : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsRsScbetam : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsRsScbetaeq HQQpRpQsRsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQsRsbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qs :: Rs :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQpQsRsOpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsOpbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam2 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpbetaeq HQRQpQsRsOpbetam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpbetamtmp;try rewrite HT2 in HQRQpQsRsOpbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpbetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Qp :: Qs :: Sc ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam3 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3).
{
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQRQpQsRsScbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsScbetamtmp;try rewrite HT2 in HQRQpQsRsScbetamtmp.
	assert(HT := rule_4 (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Qs :: nil) 4 1 2 HQRQpQsRsScbetamtmp HQsmtmp HQpQsScMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: beta ::  de rang :  3 et 4 	 AiB : beta ::  de rang :  1 et 1 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(HQsRsbetam2 : rk(Qs :: Rs :: beta :: nil) >= 2).
{
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRQsRsbetamtmp : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsbetaeq HQRQsRsbetam3).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: R :: beta :: nil) (Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: R :: beta :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: Qs :: Rs :: beta :: nil) ((Q :: R :: beta :: nil) ++ (Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsbetamtmp;try rewrite HT2 in HQRQsRsbetamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (Qs :: Rs :: beta :: nil) (beta :: nil) 3 1 2 HQRQsRsbetamtmp Hbetamtmp HQRbetaMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HQsRsbetaM2 : rk(Qs :: Rs :: beta :: nil) <= 2).
{
	assert(HQQsRsbetaeq : rk(Q :: Qs :: Rs :: beta :: nil) = 3) by (apply LQQsRsbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsRsbetaMtmp : rk(Q :: Qs :: Rs :: beta :: nil) <= 3) by (solve_hyps_max HQQsRsbetaeq HQQsRsbetaM3).
	assert(HQpRpQsRsScbetaeq : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) = 3) by (apply LQpRpQsRsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQpRpQsRsScbetaMtmp : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) <= 3) by (solve_hyps_max HQpRpQsRsScbetaeq HQpRpQsRsScbetaM3).
	assert(HQQpRpQsRsScbetaeq : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) = 4) by (apply LQQpRpQsRsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpQsRsScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsRsScbetaeq HQQpRpQsRsScbetam4).
	assert(Hincl : incl (Qs :: Rs :: beta :: nil) (list_inter (Q :: Qs :: Rs :: beta :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Q :: Qs :: Rs :: beta :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Rs :: beta :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qs :: Rs :: beta :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsScbetamtmp;try rewrite HT2 in HQQpRpQsRsScbetamtmp.
	assert(HT := rule_3 (Q :: Qs :: Rs :: beta :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qs :: Rs :: beta :: nil) 3 3 4 HQQsRsbetaMtmp HQpRpQsRsScbetaMtmp HQQpRpQsRsScbetamtmp Hincl);apply HT.
}


assert(HQsRsbetaM : rk(Qs :: Rs :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQsRsbetaeq HQsRsbetaM3).
assert(HQsRsbetam : rk(Qs :: Rs :: beta ::  nil) >= 1) by (solve_hyps_min HQsRsbetaeq HQsRsbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}

assert(HQRQpQsRsScbetaM : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpQsRsScbetam : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpQsOoScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4).
{
	assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}

assert(HQQpRpQsOoScbetaM : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsOoScbetam : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsOoScbetaeq HQQpRpQsOoScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpQsRsOoScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQQpRpQsRsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 3).
{
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4).
{
	assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}

assert(HQQpRpQsRsOoScbetaM : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsRsOoScbetam : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsRsOoScbetaeq HQQpRpQsRsOoScbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQalphabeta *)
(* dans la couche 0 *)
Lemma LPQRalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRalphabeta requis par la preuve de (?)PQRalphabeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalphabeta requis par la preuve de (?)PQRalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRalphabetam3 : rk(P :: Q :: R :: alpha :: beta :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPQRalphabetaM3 : rk(P :: Q :: R :: alpha :: beta :: nil) <= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: R :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: R :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: R :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: R :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: R :: alpha :: nil) (Q :: R :: beta :: nil) (R :: nil) 2 2 1 HPRalphaMtmp HQRbetaMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQRalphabetaM : rk(P :: Q :: R :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRalphabetam : rk(P :: Q :: R :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRalphabetaeq HPQRalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphabeta requis par la preuve de (?)PQalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphabeta requis par la preuve de (?)PQPpOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpOpalphabetam3 : rk(P :: Q :: Pp :: Op :: alpha :: beta :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphabetam2 : rk(P :: Q :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphabetamtmp : rk(P :: Q :: Pp :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpOpalphabetaeq HPQPpOpalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphabetamtmp;try rewrite HT2 in HPQPpOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetam3 : rk(P :: Q :: alpha :: beta :: nil) >= 3).
{
	assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetaM3 : rk(P :: Q :: alpha :: beta :: nil) <= 3).
{
	assert(HPQRalphabetaeq : rk(P :: Q :: R :: alpha :: beta :: nil) = 3) by (apply LPQRalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRalphabetaMtmp : rk(P :: Q :: R :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPQRalphabetaeq HPQRalphabetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: beta :: nil) (P :: Q :: R :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: alpha :: beta :: nil) (P :: Q :: R :: alpha :: beta :: nil) 3 3 HPQRalphabetaMtmp Hcomp Hincl);apply HT.
}

assert(HPQalphabetaM : rk(P :: Q :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphabetam : rk(P :: Q :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQalphabetaeq HPQalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsalphabeta *)
(* dans la couche 0 *)
Lemma LPsQsRsalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsRsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsRsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPpPsQsRsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsRsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsRsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsRsOpOoalphabetaeq HPQPpPsQsRsOpOoalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsRsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsRsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsRsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsRsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsRsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsRsOoalphabetam2 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsRsOoalphabetam3 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsRsOoalphabetam4 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsRsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsRsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsRsOpalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsRsOpalphabeta requis par la preuve de (?)PRPpPsQsRsOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsQsRsOpalphabetam3 : rk(P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsRsalphabetam2 : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsRsOpalphabetamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPpPsQsRsOpalphabetaeq HPRPpPsQsRsOpalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsRsOpalphabetamtmp;try rewrite HT2 in HPRPpPsQsRsOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPRPpPsQsRsOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsRsalphabetam3 : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (Qs :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: Rs :: alpha :: beta ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsRsalphabetam2 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsRsalphabetamtmp : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPsQsRsalphabetaeq HPRPsQsRsalphabetam3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (P :: R :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsRsalphabetamtmp;try rewrite HT2 in HPRPsQsRsalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) (alpha :: nil) 3 1 2 HPRPsQsRsalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsRsalphabetam3 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3).
{
	assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsRsOoalphabetamtmp : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HQPsQsRsOoalphabetaeq HQPsQsRsOoalphabetam4).
	assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsRsOoalphabetamtmp;try rewrite HT2 in HQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsRsOoalphabetamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -2*)
assert(HPsQsRsalphabetaM3 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) <= 3).
{
	assert(HPsRsalphaeq : rk(Ps :: Rs :: alpha :: nil) = 2) by (apply LPsRsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsRsalphaMtmp : rk(Ps :: Rs :: alpha :: nil) <= 2) by (solve_hyps_max HPsRsalphaeq HPsRsalphaM2).
	assert(HQsRsbetaeq : rk(Qs :: Rs :: beta :: nil) = 2) by (apply LQsRsbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQsRsbetaMtmp : rk(Qs :: Rs :: beta :: nil) <= 2) by (solve_hyps_max HQsRsbetaeq HQsRsbetaM2).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (Ps :: Rs :: alpha :: nil) (Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ps :: Qs :: Rs :: alpha :: beta :: nil) (Ps :: Rs :: alpha :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Rs :: alpha :: Qs :: Rs :: beta :: nil) ((Ps :: Rs :: alpha :: nil) ++ (Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: Rs :: alpha :: nil) (Qs :: Rs :: beta :: nil) (Rs :: nil) 2 2 1 HPsRsalphaMtmp HQsRsbetaMtmp HRsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPsQsRsalphabetaM : rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsRsalphabetam : rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPsQsRsalphabetaeq HPsQsRsalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPpPsQsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetaeq HPQPpPsQsOpOoalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetamtmp;try rewrite HT2 in HPQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabeta requis par la preuve de (?)PRPpPsQsOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsQsOpalphabetam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetaeq HPRPpPsQsOpalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsalphabetam2 : rk(Ps :: Qs :: alpha :: beta :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetaeq HPRPsQsalphabetam3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetamtmp;try rewrite HT2 in HPRPsQsalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil) (alpha :: nil) 3 1 2 HPRPsQsalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsalphabetam3 : rk(Ps :: Qs :: alpha :: beta :: nil) >= 3).
{
	assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphabetamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphabetaeq HQPsQsOoalphabetam4).
	assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphabetamtmp;try rewrite HT2 in HQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsOoalphabetamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPsQsalphabetaM3 : rk(Ps :: Qs :: alpha :: beta :: nil) <= 3).
{
	assert(HPsQsRsalphabetaeq : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) = 3) by (apply LPsQsRsalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsQsRsalphabetaMtmp : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPsQsRsalphabetaeq HPsQsRsalphabetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) 3 3 HPsQsRsalphabetaMtmp Hcomp Hincl);apply HT.
}

assert(HPsQsalphabetaM : rk(Ps :: Qs :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsalphabetam : rk(Ps :: Qs :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPsQsalphabetaeq HPsQsalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphabeta *)
(* dans constructLemma(), requis par LPQPsQsOoalphabeta *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsQsOoalphabetaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphabetam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPpPsQsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetaeq HPQPpPsQsOpOoalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsQsOoalphabetaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphabetam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetamtmp;try rewrite HT2 in HPQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

assert(HQPsQsOoalphabetaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphabetam : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphabetaeq HQPsQsOoalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsRsOoalphabeta *)
(* dans constructLemma(), requis par LPQPsQsRsOoalphabeta *)
(* dans la couche 0 *)
Lemma LPQRPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsRsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsRsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsQsRsOoalphabetaM : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsRsOoalphabetam : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPpPsQsRsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsRsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsRsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsRsOpOoalphabetaeq HPQPpPsQsRsOpOoalphabetam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsRsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsRsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsRsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsRsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsRsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsQsRsOoalphabetaM : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsRsOoalphabetam : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsRsOoalphabetam2 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsRsOoalphabetam3 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsRsOoalphabetam4 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsRsOoalphabetaeq : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsRsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsRsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

assert(HQPsQsRsOoalphabetaM : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsRsOoalphabetam : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HQPsQsRsOoalphabetaeq HQPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPgamma *)
(* dans la couche 0 *)
Lemma LPPpQpgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpgamma requis par la preuve de (?)PQPpQpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpQpgammam3 : rk(P :: Q :: Pp :: Qp :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QQp requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPPpQpgammaM3 : rk(P :: Pp :: Qp :: gamma :: nil) <= 3).
{
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: gamma :: nil) (P :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: gamma :: nil) ((P :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (Pp :: Qp :: gamma :: nil) (nil) 1 2 0 HPMtmp HPpQpgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: gamma ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp ::   de rang : 1 et 2 *)
assert(HPPpQpgammam2 : rk(P :: Pp :: Qp :: gamma :: nil) >= 2).
{
	assert(HQQpMtmp : rk(Q :: Qp :: nil) <= 2) by (solve_hyps_max HQQpeq HQQpM2).
	assert(HPQPpQpgammamtmp : rk(P :: Q :: Pp :: Qp :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpQpgammaeq HPQPpQpgammam3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: gamma :: nil) (Q :: Qp :: P :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: P :: Pp :: Qp :: gamma :: nil) ((Q :: Qp :: nil) ++ (P :: Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpgammamtmp;try rewrite HT2 in HPQPpQpgammamtmp.
	assert(HT := rule_4 (Q :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil) (Qp :: nil) 3 1 2 HPQPpQpgammamtmp HQpmtmp HQQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpgammam3 : rk(P :: Pp :: Qp :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

assert(HPPpQpgammaM : rk(P :: Pp :: Qp :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpgammam : rk(P :: Pp :: Qp :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpgammaeq HPPpQpgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Pgamma requis par la preuve de (?)Pgamma pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HPgammam2 : rk(P :: gamma :: nil) >= 2).
{
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	assert(HPPpQpgammaeq : rk(P :: Pp :: Qp :: gamma :: nil) = 3) by (apply LPPpQpgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpgammamtmp : rk(P :: Pp :: Qp :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpgammaeq HPPpQpgammam3).
	assert(Hgammamtmp : rk(gamma :: nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
	assert(Hincl : incl (gamma :: nil) (list_inter (P :: gamma :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: gamma :: nil) (P :: gamma :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: gamma :: Pp :: Qp :: gamma :: nil) ((P :: gamma :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpgammamtmp;try rewrite HT2 in HPPpQpgammamtmp.
	assert(HT := rule_2 (P :: gamma :: nil) (Pp :: Qp :: gamma :: nil) (gamma :: nil) 3 1 2 HPPpQpgammamtmp Hgammamtmp HPpQpgammaMtmp Hincl);apply HT.
}

assert(HPgammaM : rk(P :: gamma ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPgammaeq HPgammaM2).
assert(HPgammam : rk(P :: gamma ::  nil) >= 1) by (solve_hyps_min HPgammaeq HPgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans constructLemma(), requis par LPPsQsgamma *)
(* dans constructLemma(), requis par LPQPsQsOogamma *)
(* dans la couche 0 *)
Lemma LPQPsOogamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpOogamma requis par la preuve de (?)PQPsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpOogamma requis par la preuve de (?)PQPpPsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsOogammam2 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsOpOogammaeq HPQPpPsOpOogammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpOogammamtmp;try rewrite HT2 in HPQPpPsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOogammam3 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPQPsOogammaM3 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) <= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: Q :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: gamma :: nil) (P :: Ps :: Oo :: P :: Q :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: Q :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: Q :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: Q :: gamma :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPQgammaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQPsOogammaM : rk(P :: Q :: Ps :: Oo :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOogammam : rk(P :: Q :: Ps :: Oo :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsOogammaeq HPQPsOogammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOogamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPpPsQsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOogammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOogammaeq HPQPpPsQsOpOogammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOogammamtmp;try rewrite HT2 in HPQPpPsQsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOogammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HPQPsQsOogammaM3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) <= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQPsOogammaeq : rk(P :: Q :: Ps :: Oo :: gamma :: nil) = 3) by (apply LPQPsOogamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsOogammaMtmp : rk(P :: Q :: Ps :: Oo :: gamma :: nil) <= 3) by (solve_hyps_max HPQPsOogammaeq HPQPsOogammaM3).
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hincl : incl (Q :: Oo :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (Q :: Qs :: Oo :: P :: Q :: Ps :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Q :: Ps :: Oo :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Q :: Ps :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) (Q :: Oo :: nil) 2 3 2 HQQsOoMtmp HPQPsOogammaMtmp HQOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQPsQsOogammaM : rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOogammam : rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOogammaeq HPQPsQsOogammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsQsgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Qs :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsScgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpgamma requis par la preuve de (?)PQPpPsQsOpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsgammam2 : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpgammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpgammaeq HPQPpPsQsOpgammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpgammamtmp;try rewrite HT2 in HPQPpPsQsOpgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpgammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsQsgammam3 : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsQsScgammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPQPpPsQsScgammaeq HPQPpPsQsScgammam4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsScgammamtmp;try rewrite HT2 in HPQPpPsQsScgammamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil) (Ps :: nil) 4 1 2 HPQPpPsQsScgammamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPpPsQsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOogammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOogammaeq HPQPpPsQsOpOogammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOogammamtmp;try rewrite HT2 in HPQPpPsQsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOogammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsQsgammam2 : rk(P :: Ps :: Qs :: gamma :: nil) >= 2).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQPsQsOogammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsOogammaeq HPQPsQsOogammam3).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (Q :: Qs :: Oo :: P :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Ps :: Qs :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOogammamtmp;try rewrite HT2 in HPQPsQsOogammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: gamma :: nil) (Qs :: nil) 3 1 2 HPQPsQsOogammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: gamma ::  de rang :  3 et 4 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPPsQsgammam3 : rk(P :: Ps :: Qs :: gamma :: nil) >= 3).
{
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(HPQPsQsgammamtmp : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsgammaeq HPQPsQsgammam3).
	assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: gamma :: nil) (P :: Q :: gamma :: P :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: Ps :: Qs :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsgammamtmp;try rewrite HT2 in HPQPsQsgammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: gamma :: nil) (P :: gamma :: nil) 3 2 2 HPQPsQsgammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPsQsgammaM3 : rk(P :: Ps :: Qs :: gamma :: nil) <= 3).
{
	assert(HPQPsQsOogammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) = 3) by (apply LPQPsQsOogamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsOogammaMtmp : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) <= 3) by (solve_hyps_max HPQPsQsOogammaeq HPQPsQsOogammaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Ps :: Qs :: gamma :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Ps :: Qs :: gamma :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQPsQsOogammaMtmp Hcomp Hincl);apply HT.
}

assert(HPPsQsgammaM : rk(P :: Ps :: Qs :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsQsgammam : rk(P :: Ps :: Qs :: gamma ::  nil) >= 1) by (solve_hyps_min HPPsQsgammaeq HPPsQsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans constructLemma(), requis par LPpQpPsQsScgamma *)
(* dans la couche 0 *)
Lemma LPpQpPsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4).
{
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOpScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOpScgamma requis par la preuve de (?)PPpQpPsOpScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsOpScgammam3 : rk(P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpQpPsScgammam2 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpQpPsOpScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpPsOpScgammaeq HPPpQpPsOpScgammam3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) (P :: Pp :: Op :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOpScgammamtmp;try rewrite HT2 in HPPpQpPsOpScgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Pp :: nil) 3 1 2 HPPpQpPsOpScgammamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsScgammam3 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpQpPsOoScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsOoScgammaeq HPPpQpPsOoScgammam4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOoScgammamtmp;try rewrite HT2 in HPPpQpPsOoScgammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Ps :: nil) 4 1 2 HPPpQpPsOoScgammamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HPpQpPsScgammaM3 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) <= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Pp :: Ps :: Sc :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: Pp :: Qp :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (Pp :: Qp :: gamma :: nil) (Pp :: nil) 2 2 1 HPpPsScMtmp HPpQpgammaMtmp HPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPpQpPsScgammaM : rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsScgammam : rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPpQpPsScgammaeq HPpQpPsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpQpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsQsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4).
{
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOpScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOpScgamma requis par la preuve de (?)PPpQpPsQsOpScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsQsOpScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpQpPsQsScgammam2 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpQpPsQsOpScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpPsQsOpScgammaeq HPPpQpPsQsOpScgammam3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) (P :: Pp :: Op :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsOpScgammamtmp;try rewrite HT2 in HPPpQpPsQsOpScgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Pp :: nil) 3 1 2 HPPpQpPsQsOpScgammamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsQsScgammam3 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpQpPsQsOoScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsQsOoScgammaeq HPPpQpPsQsOoScgammam4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsOoScgammamtmp;try rewrite HT2 in HPPpQpPsQsOoScgammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Ps :: nil) 4 1 2 HPPpQpPsQsOoScgammamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HPpQpPsQsScgammaM3 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) <= 3).
{
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HPpQpPsScgammaeq : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) = 3) by (apply LPpQpPsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpQpPsScgammaMtmp : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) <= 3) by (solve_hyps_max HPpQpPsScgammaeq HPpQpPsScgammaM3).
	assert(HQpSceq : rk(Qp :: Sc :: nil) = 2) by (apply LQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQpScmtmp : rk(Qp :: Sc :: nil) >= 2) by (solve_hyps_min HQpSceq HQpScm2).
	assert(Hincl : incl (Qp :: Sc :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Qp :: Qs :: Sc :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: Qs :: Sc :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Qp :: Sc :: nil) 2 3 2 HQpQsScMtmp HPpQpPsScgammaMtmp HQpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPpQpPsQsScgammaM : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsQsScgammam : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPpQpPsQsScgammaeq HPpQpPsQsScgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans la couche 0 *)
Lemma LPPpQpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsScgamma requis par la preuve de (?)PPpQpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsScgamma requis par la preuve de (?)PPpQpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsQsScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	assert(HPPpQpSceq : rk(P :: Pp :: Qp :: Sc :: nil) = 4) by (apply LPPpQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpScmtmp : rk(P :: Pp :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HPPpQpSceq HPPpQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Sc :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Sc :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPPpQpScmtmp Hcomp Hincl);apply HT.
}

assert(HPPpQpPsQsScgammaM : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsQsScgammam : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsQsScgammaeq HPPpQpPsQsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsQsgamma requis par la preuve de (?)PsQsgamma pour la règle 3  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)PsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPpPsQsOpOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphagammaeq HPQPpPsQsOpOoalphagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphagammamtmp;try rewrite HT2 in HPQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsQsgamma requis par la preuve de (?)PsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsgammam2 : rk(Ps :: Qs :: gamma :: nil) >= 2).
{
	assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphagammamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphagammaeq HQPsQsOoalphagammam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: gamma :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphagammamtmp;try rewrite HT2 in HQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: gamma :: nil) (Qs :: nil) 4 1 3 HQPsQsOoalphagammamtmp HQsmtmp HQQsOoalphaMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HPsQsgammaM2 : rk(Ps :: Qs :: gamma :: nil) <= 2).
{
	assert(HPPsQsgammaeq : rk(P :: Ps :: Qs :: gamma :: nil) = 3) by (apply LPPsQsgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsQsgammaMtmp : rk(P :: Ps :: Qs :: gamma :: nil) <= 3) by (solve_hyps_max HPPsQsgammaeq HPPsQsgammaM3).
	assert(HPpQpPsQsScgammaeq : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) = 3) by (apply LPpQpPsQsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPpQpPsQsScgammaMtmp : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) <= 3) by (solve_hyps_max HPpQpPsQsScgammaeq HPpQpPsQsScgammaM3).
	assert(HPPpQpPsQsScgammaeq : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) = 4) by (apply LPPpQpPsQsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpPsQsScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsQsScgammaeq HPPpQpPsQsScgammam4).
	assert(Hincl : incl (Ps :: Qs :: gamma :: nil) (list_inter (P :: Ps :: Qs :: gamma :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (P :: Ps :: Qs :: gamma :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Qs :: gamma :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Ps :: Qs :: gamma :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsScgammamtmp;try rewrite HT2 in HPPpQpPsQsScgammamtmp.
	assert(HT := rule_3 (P :: Ps :: Qs :: gamma :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Ps :: Qs :: gamma :: nil) 3 3 4 HPPsQsgammaMtmp HPpQpPsQsScgammaMtmp HPPpQpPsQsScgammamtmp Hincl);apply HT.
}


assert(HPsQsgammaM : rk(Ps :: Qs :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsQsgammaeq HPsQsgammaM3).
assert(HPsQsgammam : rk(Ps :: Qs :: gamma ::  nil) >= 1) by (solve_hyps_min HPsQsgammaeq HPsQsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsScgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPQPpPsQsScgammaM : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsQsScgammam : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPpPsQsScgammaeq HPQPpPsQsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsOoScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4).
{
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}

assert(HPPpQpPsOoScgammaM : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsOoScgammam : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsOoScgammaeq HPPpQpPsOoScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsQsOoScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPPpQpPsQsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 3).
{
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4).
{
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}

assert(HPPpQpPsQsOoScgammaM : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsQsOoScgammam : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsQsOoScgammaeq HPPpQpPsQsOoScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphagamma requis par la preuve de (?)PQalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphagamma requis par la preuve de (?)PQPpOpalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpOpalphagammam3 : rk(P :: Q :: Pp :: Op :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphagammam2 : rk(P :: Q :: alpha :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphagammamtmp : rk(P :: Q :: Pp :: Op :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpOpalphagammaeq HPQPpOpalphagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphagammamtmp;try rewrite HT2 in HPQPpOpalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpOpalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPQalphagammaM3 : rk(P :: Q :: alpha :: gamma :: nil) <= 3).
{
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (alpha :: nil) (P :: Q :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: gamma :: nil) (alpha :: P :: Q :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (alpha :: P :: Q :: gamma :: nil) ((alpha :: nil) ++ (P :: Q :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (alpha :: nil) (P :: Q :: gamma :: nil) (nil) 1 2 0 HalphaMtmp HPQgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphagammam3 : rk(P :: Q :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: gamma :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}

assert(HPQalphagammaM : rk(P :: Q :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphagammam : rk(P :: Q :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQalphagammaeq HPQalphagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphagamma *)
(* dans constructLemma(), requis par LPQPsQsOoalphagamma *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsQsOoalphagammaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphagammam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPpPsQsOpOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphagammaeq HPQPpPsQsOpOoalphagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsQsOoalphagammaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphagammam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphagammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsOoalphagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphagammamtmp;try rewrite HT2 in HPQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

assert(HQPsQsOoalphagammaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphagammam : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphagammaeq HQPsQsOoalphagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphabetagamma requis par la preuve de (?)PQPpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpOpalphabetagammam3 : rk(P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphabetagammam2 : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphabetagammamtmp : rk(P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpOpalphabetagammaeq HPQPpOpalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphabetagammamtmp;try rewrite HT2 in HPQPpOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetagammam3 : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQalphabetagammaM3 : rk(P :: Q :: alpha :: beta :: gamma :: nil) <= 3).
{
	assert(HPQalphabetaeq : rk(P :: Q :: alpha :: beta :: nil) = 3) by (apply LPQalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphabetaMtmp : rk(P :: Q :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPQalphabetaeq HPQalphabetaM3).
	assert(HPQalphagammaeq : rk(P :: Q :: alpha :: gamma :: nil) = 3) by (apply LPQalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphagammaMtmp : rk(P :: Q :: alpha :: gamma :: nil) <= 3) by (solve_hyps_max HPQalphagammaeq HPQalphagammaM3).
	assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (list_inter (P :: Q :: alpha :: beta :: nil) (P :: Q :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: P :: Q :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: alpha :: beta :: P :: Q :: alpha :: gamma :: nil) ((P :: Q :: alpha :: beta :: nil) ++ (P :: Q :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: alpha :: beta :: nil) (P :: Q :: alpha :: gamma :: nil) (P :: Q :: alpha :: nil) 3 3 3 HPQalphabetaMtmp HPQalphagammaMtmp HPQalphamtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPQalphabetagammaM : rk(P :: Q :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphabetagammam : rk(P :: Q :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQalphabetagammaeq HPQalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRalphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpOpalphabetagamma requis par la preuve de (?)PRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpOpalphabetagamma requis par la preuve de (?)PRPpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpOpalphabetagammam3 : rk(P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRalphabetagamma requis par la preuve de (?)PRalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRalphabetagammam2 : rk(P :: R :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpOpalphabetagammamtmp : rk(P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpOpalphabetagammaeq HPRPpOpalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpOpalphabetagammamtmp;try rewrite HT2 in HPRPpOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: R :: alpha :: beta :: gamma ::  de rang :  2 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPalphabetagammam2 : rk(P :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRalphabetagammamtmp : rk(P :: R :: alpha :: beta :: gamma :: nil) >= 2) by (solve_hyps_min HPRalphabetagammaeq HPRalphabetagammam2).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRalphabetagammamtmp;try rewrite HT2 in HPRalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 2 2 2 HPRalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: alpha :: beta :: gamma ::  de rang :  3 et 3 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPalphabetagammam3 : rk(P :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(HPQalphabetagammaeq : rk(P :: Q :: alpha :: beta :: gamma :: nil) = 3) by (apply LPQalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphabetagammamtmp : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQalphabetagammaeq HPQalphabetagammam3).
	assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: beta :: gamma :: nil) (P :: Q :: gamma :: P :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: alpha :: beta :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQalphabetagammamtmp;try rewrite HT2 in HPQalphabetagammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: alpha :: beta :: gamma :: nil) (P :: gamma :: nil) 3 2 2 HPQalphabetagammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPalphabetagammaM3 : rk(P :: alpha :: beta :: gamma :: nil) <= 3).
{
	assert(HPQalphabetagammaeq : rk(P :: Q :: alpha :: beta :: gamma :: nil) = 3) by (apply LPQalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQalphabetagammaMtmp : rk(P :: Q :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPQalphabetagammaeq HPQalphabetagammaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) 3 3 HPQalphabetagammaMtmp Hcomp Hincl);apply HT.
}

assert(HPalphabetagammaM : rk(P :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPalphabetagammam : rk(P :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPalphabetagammaeq HPalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsQsOpalphabetagammam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetagammamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetagammaeq HPRPpPsQsOpalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsalphabetagammam2 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetagammamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetagammaeq HPRPsQsalphabetagammam3).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetagammamtmp;try rewrite HT2 in HPRPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (alpha :: nil) 3 1 2 HPRPsQsalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsalphabetagammam3 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphabetagammamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphabetagammaeq HQPsQsOoalphabetagammam4).
	assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphabetagammamtmp;try rewrite HT2 in HQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsOoalphabetagammamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPsQsalphabetagammaM3 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) <= 3).
{
	assert(HPsQsalphabetaeq : rk(Ps :: Qs :: alpha :: beta :: nil) = 3) by (apply LPsQsalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsQsalphabetaMtmp : rk(Ps :: Qs :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPsQsalphabetaeq HPsQsalphabetaM3).
	assert(HPsQsgammaeq : rk(Ps :: Qs :: gamma :: nil) = 2) by (apply LPsQsgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsQsgammaMtmp : rk(Ps :: Qs :: gamma :: nil) <= 2) by (solve_hyps_max HPsQsgammaeq HPsQsgammaM2).
	assert(HPsQseq : rk(Ps :: Qs :: nil) = 2) by (apply LPsQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsQsmtmp : rk(Ps :: Qs :: nil) >= 2) by (solve_hyps_min HPsQseq HPsQsm2).
	assert(Hincl : incl (Ps :: Qs :: nil) (list_inter (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ps :: Qs :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Qs :: alpha :: beta :: Ps :: Qs :: gamma :: nil) ((Ps :: Qs :: alpha :: beta :: nil) ++ (Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: gamma :: nil) (Ps :: Qs :: nil) 3 2 2 HPsQsalphabetaMtmp HPsQsgammaMtmp HPsQsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HPsQsalphabetagammaM : rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsalphabetagammam : rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPsQsalphabetagammaeq HPsQsalphabetagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPsQsalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsScalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpalphabetagamma requis par la preuve de (?)PQPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpalphabetagammaeq HPQPpPsQsOpalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsQsalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsQsScalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPpPsQsScalphabetagammaeq HPQPpPsQsScalphabetagammam4).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsScalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsScalphabetagammamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Ps :: nil) 4 1 2 HPQPpPsQsScalphabetagammamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQPsalphaeq : rk(P :: Q :: Ps :: alpha :: nil) = 4) by (apply LPQPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsalphamtmp : rk(P :: Q :: Ps :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsalphaeq HPQPsalpham4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Ps :: alpha :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Ps :: alpha :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) 4 4 HPQPsalphamtmp Hcomp Hincl);apply HT.
}

assert(HPQPsQsalphabetagammaM : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsalphabetagammam : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsalphabetagammaeq HPQPsQsalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPRPpPsQsOpalphabetagammam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetagammamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetagammaeq HPRPpPsQsOpalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam2 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam3).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 3 1 2 HPQPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam3 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetagammamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetagammaeq HPRPsQsalphabetagammam3).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetagammamtmp;try rewrite HT2 in HPRPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 3 2 2 HPRPsQsalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam4 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(HPQPsQsalphabetagammaeq : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsalphabetagammaeq HPQPsQsalphabetagammam4).
	assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: Q :: gamma :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsalphabetagammamtmp;try rewrite HT2 in HPQPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: gamma :: nil) 4 2 2 HPQPsQsalphabetagammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}

assert(HPPsQsalphabetagammaM : rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsQsalphabetagammam : rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPPsQsalphabetagammaeq HPPsQsalphabetagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphabetagamma *)
(* dans constructLemma(), requis par LPQPsQsOoalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}

assert(HPQRPsQsOoalphabetagammaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphabetagammam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}

assert(HPQPsQsOoalphabetagammaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphabetagammam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetagammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam4).
	assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}

assert(HQPsQsOoalphabetagammaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphabetagammam : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphabetagammaeq HQPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsQsScalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQPpPsQsScalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4).
{
	assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}

assert(HPQPpPsQsScalphabetagammaM : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsQsScalphabetagammam : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPpPsQsScalphabetagammaeq HPQPpPsQsScalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(P :: Q :: Qp ::  nil) = 3 -> rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 ->
rk(Q :: Pp :: Qp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 -> rk(Q :: R :: Rp ::  nil) = 3 ->
rk(P :: Pp :: Rp ::  nil) = 3 -> rk(R :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(alpha :: beta :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HPQQpeq HQRQpeq HPPpQpeq HQPpQpeq HPRRpeq HQRRpeq HPPpRpeq
HRPpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq
HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq
HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq
HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour alphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalphabetagamma requis par la preuve de (?)PQRalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRalphabetagammam3 : rk(P :: Q :: R :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpOpalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpOpalphabetagamma requis par la preuve de (?)QRQpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQRQpOpalphabetagammam3 : rk(Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRalphabetagammam2 : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpOpalphabetagammamtmp : rk(Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HQRQpOpalphabetagammaeq HQRQpOpalphabetagammam3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) (Q :: Qp :: Op :: Q :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: alpha :: beta :: gamma :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpOpalphabetagammamtmp;try rewrite HT2 in HQRQpOpalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: alpha :: beta :: gamma :: nil) (Q :: nil) 3 1 2 HQRQpOpalphabetagammamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : P :: Q :: R :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : R :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQRalphabetagammam3 : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 3).
{
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRalphabetagammamtmp : rk(P :: Q :: R :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQRalphabetagammaeq HPQRalphabetagammam3).
	assert(HRalphaeq : rk(R :: alpha :: nil) = 2) by (apply LRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HRalphamtmp : rk(R :: alpha :: nil) >= 2) by (solve_hyps_min HRalphaeq HRalpham2).
	assert(Hincl : incl (R :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: R :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRalphabetagammamtmp;try rewrite HT2 in HPQRalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: R :: alpha :: beta :: gamma :: nil) (R :: alpha :: nil) 3 2 2 HPQRalphabetagammamtmp HRalphamtmp HPRalphaMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour alphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: R :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : beta ::  de rang :  1 et 1 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(Halphabetagammam2 : rk(alpha :: beta :: gamma :: nil) >= 2).
{
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRalphabetagammamtmp : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HQRalphabetagammaeq HQRalphabetagammam3).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: R :: beta :: nil) (alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: alpha :: beta :: gamma :: nil) (Q :: R :: beta :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: alpha :: beta :: gamma :: nil) ((Q :: R :: beta :: nil) ++ (alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRalphabetagammamtmp;try rewrite HT2 in HQRalphabetagammamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (alpha :: beta :: gamma :: nil) (beta :: nil) 3 1 2 HQRalphabetagammamtmp Hbetamtmp HQRbetaMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HalphabetagammaM2 : rk(alpha :: beta :: gamma :: nil) <= 2).
{
	assert(HPalphabetagammaeq : rk(P :: alpha :: beta :: gamma :: nil) = 3) by (apply LPalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPalphabetagammaMtmp : rk(P :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPalphabetagammaeq HPalphabetagammaM3).
	assert(HPsQsalphabetagammaeq : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) = 3) by (apply LPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPsQsalphabetagammaMtmp : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPsQsalphabetagammaeq HPsQsalphabetagammaM3).
	assert(HPPsQsalphabetagammaeq : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) = 4) by (apply LPPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ; assumption).
	assert(HPPsQsalphabetagammamtmp : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPPsQsalphabetagammaeq HPPsQsalphabetagammam4).
	assert(Hincl : incl (alpha :: beta :: gamma :: nil) (list_inter (P :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: alpha :: beta :: gamma :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: alpha :: beta :: gamma :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: alpha :: beta :: gamma :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPsQsalphabetagammamtmp;try rewrite HT2 in HPPsQsalphabetagammamtmp.
	assert(HT := rule_3 (P :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (alpha :: beta :: gamma :: nil) 3 3 4 HPalphabetagammaMtmp HPsQsalphabetagammaMtmp HPPsQsalphabetagammamtmp Hincl);apply HT.
}


assert(HalphabetagammaM : rk(alpha :: beta :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Halphabetagammaeq HalphabetagammaM3).
assert(Halphabetagammam : rk(alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min Halphabetagammaeq Halphabetagammam1).
intuition.
Qed.

