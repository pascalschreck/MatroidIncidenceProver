Require Export List.
Require Export Lia.
Require Export Morphisms.

Parameter Point : Set.
Parameter eq_dec : forall A B : Point, {A = B} + {~ A = B}.

Definition equivlist (l l':list Point) := forall x, List.In x l <-> List.In x l'.

Ltac simplgen H := simpl in H;generalize H.

Ltac my_inS :=
  intuition;unfold incl in *;unfold equivlist in *;
  repeat match goal with
  |[H : _ |- _] => progress intros
  |[H : _ |- _] => progress intro
  |[H : _ |- _] => progress intuition
  |[H : _ |- _] => split;intuition
  |[H : In _ (?P ::  _ ) |- _] => inversion H;clear H
  |[H : _ = _ |- _] => rewrite <-H
  |[H : In _ nil |- _] => inversion H
  end.

Parameter rk : list Point -> nat.
Parameter rk_compat : forall x x', equivlist x x' -> rk x = rk x'.

Global Instance rk_morph : Proper (equivlist ==> (@Logic.eq nat)) rk.
Proof.
intros;repeat red.
apply rk_compat.
Qed.

(*** Definition Inb ***)
Fixpoint Inb (a:Point) (l:list Point) {struct l} : bool :=
    match l with
      | nil => false
      | b :: m => if (eq_dec b a) then true else Inb a m
    end.

Lemma Inb_aux1 :
forall a l, Inb a l = true -> In a l.
Proof.
my_inS;induction l;my_inS.
- inversion H.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

Lemma Inb_aux2 :
forall a l, Inb a l = false -> ~In a l.
Proof.
my_inS;induction l;my_inS.
- rewrite H1 in *;simplgen H;case_eq(eq_dec a a);my_inS.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

(*** Definition list_inter ***)
Definition list_inter l1 l2 := filter (fun x : Point => Inb x l2) l1.

Lemma list_inter_split :
forall a l m, In a (list_inter l m) -> In a l /\ In a m.
Proof.
intros.
my_inS;induction l;my_inS.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS.
- inversion H.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS;apply Inb_aux1;my_inS.
Qed.

Lemma list_inter_closure :
forall a l m, In a m -> In a l -> In a (list_inter l m).
Proof.
my_inS;induction l;my_inS.
- simpl;case_eq(Inb a0 m);my_inS;assert(HH := Inb_aux2 a0 m H0);subst;my_inS.
- simpl;case_eq(Inb a0 m);my_inS.
Qed.

Ltac inv_unif :=
  unfold incl in *; try split; intros;
  repeat match goal with 
         | [H : In _ (?P ::  _ ) |- _] => inversion H;clear H
         | [H: _ = _ |- _] => rewrite <- H in *;try solve [contradiction|apply eq_sym in H;contradiction];clear H
         | [H : In _ nil |- _] => inversion H
         | [H : In _ (?L++?M) |- _] => apply in_app_iff in H; destruct H
         | [H :_ |- In _ (?L++?M) ] => apply in_app_iff
         | [H : In _ (list_inter _ _) |- _] => apply list_inter_split in H; destruct H
         | [H : _ |- In _ (list_inter _ _)] => apply list_inter_closure
         end.

Ltac solve_equivlist := first [apply in_eq | apply in_cons ; solve_equivlist].

Ltac my_inO := solve[inv_unif ; first[solve_equivlist | left;solve_equivlist | right;solve_equivlist]].

Parameter matroid1_a  : forall X, rk X >= 0.
Parameter matroid1_b : forall X, rk X <= length X.
Parameter matroid2 : forall X Y, incl X Y -> rk X <= rk Y.
Parameter matroid3 : forall X Y, rk(X ++ Y) + rk(list_inter X Y) <= rk X + rk Y.

(*** Lemmes matroides utiles ***)
Lemma matroid1_b_useful : forall (l : list Point) (m : nat), length l <= m -> rk l <= m.
Proof.
intros.
assert(HH := matroid1_b l).
lia.
Qed.

Lemma matroid3_useful : forall e e' ei : list Point,
 incl ei (list_inter e e') ->
 rk(e ++ e') + rk(ei) <= rk(e) + rk(e').
Proof.
intros.
assert (rk (e ++ e') + rk (list_inter e e') <= rk e + rk e').
apply matroid3.
assert (rk (ei) <= rk (list_inter e e')).
apply matroid2;auto.
lia.
Qed.

Lemma couple_equal : forall A B, rk(A :: B :: nil) = rk(B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_1 : forall A B C, rk(A :: B :: C :: nil) = rk(A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_2 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_3 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_4 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_5 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma rk_triple_max_3 : forall X Y Z : Point, rk(X :: Y :: Z :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_quadruple_max_4 : forall W X Y Z : Point,rk(W :: X :: Y :: Z :: nil) <= 4.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma quadruple_equal_1 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: B :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_2 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_3 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_4 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_5 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_6 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: C :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_7 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_8 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_9 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_10 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_11 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_12 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_13 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_14 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_15 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_16 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_17 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_18 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_19 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_20 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_21 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_22 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_23 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Ltac clear_all_rk :=
repeat match goal with
| H : rk _ = _ |- _ => clear H
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.

Parameter rk_singleton_ge : forall A, rk (A :: nil)  >= 1.
Parameter rk_couple_ge : forall A B, ~ A = B -> rk(A :: B :: nil) >= 2.
Parameter rk_three_points_on_lines : forall A B, exists C, rk (A :: B :: C :: nil) = 2 /\ rk (B :: C :: nil) = 2 /\ rk (A :: C :: nil) = 2.
Parameter rk_inter : forall A B C D, rk(A :: B :: C :: D :: nil) <= 3 -> exists J : Point, rk(A :: B :: J :: nil) = 2 /\ rk (C :: D :: J :: nil) = 2.
Parameter rk_lower_dim : exists A0 A1 A2 A3, rk( A0 :: A1 :: A2 :: A3 :: nil) = 4.
Parameter rk_upper_dim : forall e, rk(e) <= 4.

Lemma rk_singleton_1 : forall A, rk(A :: nil) <= 1.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_singleton : forall A, rk(A :: nil) = 1.
Proof.
intros.
assert(H := rk_singleton_ge A).
assert(HH := rk_singleton_1 A).
lia.
Qed.

Lemma matroid1_b_useful2 : forall (l : list Point) (a : Point), length (a :: l) >= 1 -> rk (a :: l) >= 1.
Proof.
intros.
assert(HH := rk_singleton a).
assert(HH0 := matroid2 (a :: nil) (a :: l)).
assert(HH1 : incl (a :: nil) (a :: l));[my_inO|].
assert(HH2 := HH0 HH1).
lia.
Qed.

Lemma rk_couple_2 : forall A B, rk(A :: B :: nil) <= 2.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_couple : forall A B : Point,~ A = B -> rk(A :: B :: nil) = 2.
Proof.
intros.
assert(HH := rk_couple_2 A B).
assert(HH0 := rk_couple_ge A B H).
lia.
Qed.

Lemma rk_triple_3 : forall A B C : Point, rk (A :: B :: C :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma couple_rk1 : forall A B, rk(A :: B :: nil) = 2 -> ~ A = B.
Proof.
intros.
intro.
rewrite H0 in H.
assert(HH : equivlist (B :: B :: nil) (B :: nil));[my_inO|].
rewrite HH in H.
assert(HH0 := rk_singleton_1 B).
lia.
Qed.

Lemma couple_rk2 : forall A B, rk(A :: B :: nil) = 1 -> A = B.
Proof.
intros.
case_eq(eq_dec A B).
intros.
assumption.
intros.
assert(HH := rk_couple A B n).
lia.
Qed.

Lemma rule_1 : forall A B AiB, forall MA MB mAiB, 
rk(A) <= MA -> rk(B) <= MB -> rk(AiB) >= mAiB -> incl AiB (list_inter A B) ->
rk(A ++ B) <= MA + MB - mAiB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_2 : forall A B AiB, forall mAuB mAiB MB, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(B) <= MB -> incl AiB (list_inter A B) ->
rk(A) >= mAuB + mAiB - MB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_3 : forall A B AiB, forall MA MB mAuB, 
rk(A) <= MA -> rk(B) <= MB -> rk(A ++ B) >= mAuB -> incl AiB (list_inter A B) ->
rk(AiB) <= MA + MB - mAuB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_4 : forall A B AiB, forall mAuB mAiB MA, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(A) <= MA -> incl AiB (list_inter A B) ->
rk(B) >= mAuB + mAiB - MA.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_5 : forall A B, forall mA mB, 
rk(A) >= mA -> mA >= mB -> incl A B ->
rk(B) >= mA.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_6 : forall A B, forall MA MB, 
rk(B) <= MB -> MB <= MA -> incl A B ->
rk(A) <= MB.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_7 : forall A B, forall mA mB, 
rk(B) >= mB -> mB >= mA -> incl B A ->
rk(A) >= mB.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Lemma rule_8 : forall A B, forall MA MB, 
rk(A) <= MA -> MA <= MB -> incl B A ->
rk(B) <= MA.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Parameter rk_pappus : forall A B C D E F G H I,
rk(A :: B :: nil) = 2 -> rk(A :: C :: nil) = 2 -> rk(A :: D :: nil) = 2 -> 
rk(A :: E :: nil) = 2 -> rk(A :: F :: nil) = 2 ->
rk(B :: C :: nil) = 2 -> rk(B :: D :: nil) = 2 -> rk(B :: E :: nil) = 2 ->
rk(B :: F :: nil) = 2 ->
rk(C :: D :: nil) = 2 -> rk(C :: E :: nil) = 2 -> rk(C :: F :: nil) = 2 ->
rk(D :: E :: nil) = 2 -> rk(D :: F :: nil) = 2 ->
rk(E :: F :: nil) = 2 ->
rk(A :: B :: C :: nil) = 2 -> rk(D :: E :: F :: nil) = 2 -> 
rk(A :: E :: G :: nil) = 2 -> rk(B :: D :: G :: nil) = 2 ->
rk(A :: F :: H :: nil) = 2 -> rk(C :: D :: H :: nil) = 2 ->
rk(B :: F :: I :: nil) = 2 -> rk(C :: E :: I :: nil) = 2 -> rk(G :: H :: I :: nil) = 2.

Ltac rk_couple_triple :=
  match goal with

| H : rk(?A :: ?B :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => assumption
| H : rk(?B :: ?A :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => rewrite couple_equal in H;assumption

| H : rk(?A :: ?B :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => assumption
| H : rk(?A :: ?C :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_1 in H;assumption
| H : rk(?B :: ?A :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_2 in H;assumption
| H : rk(?B :: ?C :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_3 in H;assumption
| H : rk(?C :: ?A :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_4 in H;assumption
| H : rk(?C :: ?B :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_5 in H;assumption
end.


Ltac clear_ineg_rk :=
repeat match goal with
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.


Ltac equalize_pts :=
repeat match goal with
| H : rk (?X0 :: ?X1 :: nil) = 1 |- _ => 
          let HH := fresh in assert(HH := couple_rk2 X0 X1 H);clear H;rewrite HH
end.

Ltac eliminate_hyps :=
repeat match goal with
| H : rk ?X = _, H0 : rk ?X >= _ |- _ => clear H0
| H : rk ?X = _, H0 : rk ?X <= _ |- _ => clear H0
| H : rk ?X >= _, H0 : rk ?X >= _ |- _ => clear H
| H : rk ?X <= _, H0 : rk ?X <= _ |- _ => clear H
| H : rk ?X >= ?Y, H0 : rk ?X <= ?Y |- _ =>  let HH := fresh in assert(HH : rk X = Y) by (lia)
end.

Lemma le_S_sym : forall n m : nat,
n >= S m -> n >= m.
Proof.
intros.
intuition.
Qed.

Lemma eq_to_ge : forall n m : nat,
n = m -> n >= m.
Proof.
intros.
lia.
Qed.

Lemma eq_to_le : forall n m : nat,
n = m -> n <= m.
Proof.
intros.
lia.
Qed.

Lemma eq_le_incl : forall n m, n = m -> n <= m.
Proof.
  intros; lia.
Qed.

Ltac solve_hyps_max H H0 :=
solve[apply matroid1_b_useful;simpl;repeat constructor
|apply rk_upper_dim
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S;apply H0
|apply le_S;apply le_S;apply H0
|apply le_S;apply le_S;apply le_S;apply H0
|lia
].

Ltac solve_hyps_min H H0:=
solve[apply matroid1_b_useful2;simpl;repeat constructor
|apply matroid1_a
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply le_S_sym;apply H0
|lia
].
 



(* dans la couche 0 *)
Lemma LP : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPM : rk(P ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPeq HPM1).
assert(HPm : rk(P ::  nil) >= 1) by (solve_hyps_min HPeq HPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQ : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQM : rk(Q ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQeq HQM1).
assert(HQm : rk(Q ::  nil) >= 1) by (solve_hyps_min HQeq HQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LR : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRM : rk(R ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HReq HRM1).
assert(HRm : rk(R ::  nil) >= 1) by (solve_hyps_min HReq HRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQR : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQRM : rk(P :: Q :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQReq HPQRM3).
assert(HPQRm : rk(P :: Q :: R ::  nil) >= 1) by (solve_hyps_min HPQReq HPQRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPpM : rk(Pp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPpeq HPpM1).
assert(HPpm : rk(Pp ::  nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQPpM : rk(P :: Q :: Pp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQPpeq HPQPpM3).
assert(HPQPpm : rk(P :: Q :: Pp ::  nil) >= 1) by (solve_hyps_min HPQPpeq HPQPpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPRPpM : rk(P :: R :: Pp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPRPpeq HPRPpM3).
assert(HPRPpm : rk(P :: R :: Pp ::  nil) >= 1) by (solve_hyps_min HPRPpeq HPRPpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQRPp *)
(* dans la couche 0 *)
Lemma LPQRPpQpRpOp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQRPpQpRpOpM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpOpm : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpOpeq HPQRPpQpRpOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPp requis par la preuve de (?)PQRPp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPp requis par la preuve de (?)PQRPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpm3 : rk(P :: Q :: R :: Pp :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpM3 : rk(P :: Q :: R :: Pp :: nil) <= 3).
{
	try assert(HPQRPpQpRpOpeq : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) = 3) by (apply LPQRPpQpRpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpM : rk(P :: Q :: R :: Pp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpm : rk(P :: Q :: R :: Pp ::  nil) >= 1) by (solve_hyps_min HPQRPpeq HPQRPpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQpM : rk(Qp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQpeq HQpM1).
assert(HQpm : rk(Qp ::  nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQQpM : rk(P :: Q :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQQpeq HPQQpM3).
assert(HPQQpm : rk(P :: Q :: Qp ::  nil) >= 1) by (solve_hyps_min HPQQpeq HPQQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQRQpM : rk(Q :: R :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQRQpeq HQRQpM3).
assert(HQRQpm : rk(Q :: R :: Qp ::  nil) >= 1) by (solve_hyps_min HQRQpeq HQRQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQp requis par la preuve de (?)PQRQp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQp requis par la preuve de (?)PQRQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpm3 : rk(P :: Q :: R :: Qp :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpM3 : rk(P :: Q :: R :: Qp :: nil) <= 3).
{
	try assert(HPQRPpQpRpOpeq : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) = 3) by (apply LPQRPpQpRpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpM : rk(P :: Q :: R :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpm : rk(P :: Q :: R :: Qp ::  nil) >= 1) by (solve_hyps_min HPQRQpeq HPQRQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPPpQpM : rk(P :: Pp :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPpQpeq HPPpQpM3).
assert(HPPpQpm : rk(P :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HPPpQpeq HPPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQPpQpM : rk(Q :: Pp :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQPpQpeq HQPpQpM3).
assert(HQPpQpm : rk(Q :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HQPpQpeq HQPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpQp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQp requis par la preuve de (?)PRPpQp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQp requis par la preuve de (?)PRPpQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpm3 : rk(P :: R :: Pp :: Qp :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpM3 : rk(P :: R :: Pp :: Qp :: nil) <= 3).
{
	try assert(HPQRPpQpRpOpeq : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) = 3) by (apply LPQRPpQpRpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: R :: Pp :: Qp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}


assert(HPRPpQpM : rk(P :: R :: Pp :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpm : rk(P :: R :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HPRPpQpeq HPRPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Rp ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRpM : rk(Rp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HRpeq HRpM1).
assert(HRpm : rk(Rp ::  nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRRpm3 : rk(P :: Q :: R :: Rp :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRRpM3 : rk(P :: Q :: R :: Rp :: nil) <= 3).
{
	try assert(HPQRPpQpRpOpeq : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) = 3) by (apply LPQRPpQpRpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}


assert(HPQRRpM : rk(P :: Q :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRRpm : rk(P :: Q :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HPQRRpeq HPQRRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPPpRpM : rk(P :: Pp :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPpRpeq HPPpRpM3).
assert(HPPpRpm : rk(P :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HPPpRpeq HPPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRp requis par la preuve de (?)PQPpRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRp requis par la preuve de (?)PQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpm3 : rk(P :: Q :: Pp :: Rp :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpM3 : rk(P :: Q :: Pp :: Rp :: nil) <= 3).
{
	try assert(HPQRPpQpRpOpeq : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) = 3) by (apply LPQRPpQpRpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpRpOpMtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) <= 3) by (solve_hyps_max HPQRPpQpRpOpeq HPQRPpQpRpOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: Pp :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Op :: nil) 3 3 HPQRPpQpRpOpMtmp Hcomp Hincl);apply HT.
}
try clear HPQRPpQpRpOpM1. try clear HPQRPpQpRpOpM2. try clear HPQRPpQpRpOpM3. try clear HPQRPpQpRpOpm4. try clear HPQRPpQpRpOpm3. try clear HPQRPpQpRpOpm2. try clear HPQRPpQpRpOpm1. 

assert(HPQPpRpM : rk(P :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpm : rk(P :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HPQPpRpeq HPQPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRPpRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Pp :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRPpRpM : rk(R :: Pp :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HRPpRpeq HRPpRpM3).
assert(HRPpRpm : rk(R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HRPpRpeq HRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQQpRpM : rk(Q :: Qp :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQQpRpeq HQQpRpM3).
assert(HQQpRpm : rk(Q :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HQQpRpeq HQQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPs : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPsM : rk(Ps ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPseq HPsM1).
assert(HPsm : rk(Ps ::  nil) >= 1) by (solve_hyps_min HPseq HPsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQs : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qs ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQsM : rk(Qs ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQseq HQsM1).
assert(HQsm : rk(Qs ::  nil) >= 1) by (solve_hyps_min HQseq HQsm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQs *)
(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPQPsQsOoalpha *)
(* dans constructLemma(), requis par LPQRPsQsOoalpha *)
(* dans la couche 0 *)
Lemma LPQROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQROoM : rk(P :: Q :: R :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQROom : rk(P :: Q :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HPQROoeq HPQROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalpha requis par la preuve de (?)PQRPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalpha requis par la preuve de (?)PQRPsQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalpham3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalpham4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsQsOoalphaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalpham : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPsQsOoalpha *)
(* dans constructLemma(), requis par LPalpha *)
(* dans la couche 0 *)
Lemma LPPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpalpham3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QRp requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpalpha requis par la preuve de (?)PPpRpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HPPpRpalphaM3 : rk(P :: Pp :: Rp :: alpha :: nil) <= 3).
{
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: alpha :: nil) ((P :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (Pp :: Rp :: alpha :: nil) (nil) 1 2 0 HPMtmp HPpRpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Rp :: alpha ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : Q :: Rp ::   de rang : 1 et 2 *)
assert(HPPpRpalpham2 : rk(P :: Pp :: Rp :: alpha :: nil) >= 2).
{
	assert(HQRpMtmp : rk(Q :: Rp :: nil) <= 2) by (solve_hyps_max HQRpeq HQRpM2).
	assert(HPQPpRpalphamtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpRpalphaeq HPQPpRpalpham3).
	try assert(HRpeq : rk(Rp :: nil) = 1) by (apply LRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (Q :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: alpha :: nil) (Q :: Rp :: P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Rp :: P :: Pp :: Rp :: alpha :: nil) ((Q :: Rp :: nil) ++ (P :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpalphamtmp;try rewrite HT2 in HPQPpRpalphamtmp.
	assert(HT := rule_4 (Q :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) (Rp :: nil) 3 1 2 HPQPpRpalphamtmp HRpmtmp HQRpMtmp Hincl); apply HT.
}
try clear HQRpM1. try clear HQRpM2. try clear HQRpM3. try clear HQRpm4. try clear HQRpm3. try clear HQRpm2. try clear HQRpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpalpham3 : rk(P :: Pp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


assert(HPPpRpalphaM : rk(P :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpalpham : rk(P :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpalphaeq HPPpRpalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPalpha *)
(* dans la couche 0 *)
Lemma Lalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(alpha ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HalphaM : rk(alpha ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Halphaeq HalphaM1).
assert(Halpham : rk(alpha ::  nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPalpha *)
(* dans la couche 0 *)
Lemma LPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPpRpalphaM : rk(Pp :: Rp :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM3).
assert(HPpRpalpham : rk(Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpalphaeq HPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Palpha requis par la preuve de (?)Palpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPalpham2 : rk(P :: alpha :: nil) >= 2).
{
	try assert(HPpRpalphaeq : rk(Pp :: Rp :: alpha :: nil) = 2) by (apply LPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	try assert(HPPpRpalphaeq : rk(P :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpalphamtmp : rk(P :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpalphaeq HPPpRpalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: alpha :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: alpha :: nil) (P :: alpha :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: alpha :: Pp :: Rp :: alpha :: nil) ((P :: alpha :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpalphamtmp;try rewrite HT2 in HPPpRpalphamtmp.
	assert(HT := rule_2 (P :: alpha :: nil) (Pp :: Rp :: alpha :: nil) (alpha :: nil) 3 1 2 HPPpRpalphamtmp Halphamtmp HPpRpalphaMtmp Hincl);apply HT.
}


assert(HPalphaM : rk(P :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPalphaeq HPalphaM2).
assert(HPalpham : rk(P :: alpha ::  nil) >= 1) by (solve_hyps_min HPalphaeq HPalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPsQsOoalpha *)
(* dans la couche 0 *)
Lemma LPRalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPRalphaM : rk(P :: R :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPRalphaeq HPRalphaM3).
assert(HPRalpham : rk(P :: R :: alpha ::  nil) >= 1) by (solve_hyps_min HPRalphaeq HPRalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PQOo requis par la preuve de (?)PQPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 1 pour Oo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ROo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ROo requis par la preuve de (?)ROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HROom2 : rk(R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: Q :: R :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (R :: Oo :: nil) (R :: nil) 4 1 3 HPQROomtmp HRmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PQ requis par la preuve de (?)PQOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPQOom2 : rk(P :: Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPQmtmp : rk(P :: Q :: nil) >= 1) by (solve_hyps_min HPQeq HPQm1).
	assert(Hincl : incl (P :: Q :: nil) (list_inter (P :: Q :: R :: nil) (P :: Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Q :: Oo :: nil) (P :: Q :: nil) 4 1 3 HPQROomtmp HPQmtmp HPQRMtmp Hincl); apply HT.
}
try clear HPQM1. try clear HPQM2. try clear HPQM3. try clear HPQm4. try clear HPQm3. try clear HPQm2. try clear HPQm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 5*)
assert(HPQOom3 : rk(P :: Q :: Oo :: nil) >= 3).
{
	assert(HROoMtmp : rk(R :: Oo :: nil) <= 2) by (solve_hyps_max HROoeq HROoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Q :: Oo :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: Oo :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Oo :: R :: Oo :: nil) ((P :: Q :: Oo :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_2 (P :: Q :: Oo :: nil) (R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HROoMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalpha requis par la preuve de (?)PQPpPsQsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalpham3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPpOp requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalpha requis par la preuve de (?)PQPsQsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalpham2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphaeq HPQPpPsQsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphaM1. try clear HPQPpPsQsOpOoalphaM2. try clear HPQPpPsQsOpOoalphaM3. try clear HPQPpPsQsOpOoalpham4. try clear HPQPpPsQsOpOoalpham3. try clear HPQPpPsQsOpOoalpham2. try clear HPQPpPsQsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPQPsQsOoalpham3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalpham4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphamtmp;try rewrite HT2 in HPQRPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsQsOoalphaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalpham : rk(P :: Q :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphaeq HPQPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPsOoalpha *)
(* dans constructLemma(), requis par LPpPsOoScalpha *)
(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpRpOo *)
(* dans constructLemma(), requis par LPQPpRpOoalpha *)
(* dans constructLemma(), requis par LPQPpOo *)
(* dans la couche 0 *)
Lemma LPQRPpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoalpha requis par la preuve de (?)PQRPpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoalpha requis par la preuve de (?)PQRPpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoalpham3 : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoalpham4 : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpOoalphaM : rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOoalpham : rk(P :: Q :: R :: Pp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpOo *)
(* dans constructLemma(), requis par LPQRPpalpha *)
(* dans la couche 0 *)
Lemma LPQRalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQRalpha requis par la preuve de (?)PQRalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalpha requis par la preuve de (?)PQRalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPQRalphaM3 : rk(P :: Q :: R :: alpha :: nil) <= 3).
{
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: nil) (Q :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: P :: R :: alpha :: nil) ((Q :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HQMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRalpham3 : rk(P :: Q :: R :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


assert(HPQRalphaM : rk(P :: Q :: R :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRalpham : rk(P :: Q :: R :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRalphaeq HPQRalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpalpham3 : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRPpalphaM3 : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3).
{
	try assert(HPQRPpeq : rk(P :: Q :: R :: Pp :: nil) = 3) by (apply LPQRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpMtmp : rk(P :: Q :: R :: Pp :: nil) <= 3) by (solve_hyps_max HPQRPpeq HPQRPpM3).
	try assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: R :: Pp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Pp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Pp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRPpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQRPpalphaM : rk(P :: Q :: R :: Pp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpalpham : rk(P :: Q :: R :: Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpalphaeq HPQRPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOo requis par la preuve de (?)PQPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOo requis par la preuve de (?)PQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpOom3 : rk(P :: Q :: Pp :: Oo :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQPpOom4 : rk(P :: Q :: Pp :: Oo :: nil) >= 4).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (list_inter (P :: Q :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (P :: Q :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: Pp :: nil) 4 3 3 HPQRPpOoalphamtmp HPQPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


assert(HPQPpOoM : rk(P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpOom : rk(P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpOoeq HPQPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpOoalpha requis par la preuve de (?)PQPpRpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpOoalpha requis par la preuve de (?)PQPpRpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpOoalpham3 : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpOoalpham4 : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}


assert(HPQPpRpOoalphaM : rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpOoalpham : rk(P :: Q :: Pp :: Rp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpOoalphaeq HPQPpRpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpRpOo *)
(* dans la couche 0 *)
Lemma LPQPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpalpha requis par la preuve de (?)PQPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpalpham3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQPpRpalphaM3 : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3).
{
	try assert(HPQPpRpeq : rk(P :: Q :: Pp :: Rp :: nil) = 3) by (apply LPQPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpMtmp : rk(P :: Q :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPQPpRpeq HPQPpRpM3).
	try assert(HPPpRpalphaeq : rk(P :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpalphaMtmp : rk(P :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPPpRpalphaeq HPPpRpalphaM3).
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Q :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Q :: Pp :: Rp :: P :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Rp :: P :: Pp :: Rp :: alpha :: nil) ((P :: Q :: Pp :: Rp :: nil) ++ (P :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: Pp :: Rp :: nil) (P :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 3 3 3 HPQPpRpMtmp HPPpRpalphaMtmp HPPpRpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQPpRpalphaM : rk(P :: Q :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpalpham : rk(P :: Q :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpalphaeq HPQPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpOo requis par la preuve de (?)PPpRpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpOo requis par la preuve de (?)PPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpOom3 : rk(P :: Pp :: Rp :: Oo :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Oo :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPPpRpOom4 : rk(P :: Pp :: Rp :: Oo :: nil) >= 4).
{
	try assert(HPQPpRpalphaeq : rk(P :: Q :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPQPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpalphaMtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQPpRpalphaeq HPQPpRpalphaM3).
	try assert(HPQPpRpOoalphaeq : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) = 4) by (apply LPQPpRpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpOoalphamtmp : rk(P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpRpOoalphaeq HPQPpRpOoalpham4).
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Oo :: alpha :: nil) (P :: Pp :: Rp :: Oo :: P :: Q :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: Oo :: P :: Q :: Pp :: Rp :: alpha :: nil) ((P :: Pp :: Rp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpOoalphamtmp;try rewrite HT2 in HPQPpRpOoalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 4 3 3 HPQPpRpOoalphamtmp HPPpRpmtmp HPQPpRpalphaMtmp Hincl);apply HT.
}


assert(HPPpRpOoM : rk(P :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpOom : rk(P :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPPpRpOoeq HPPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOoScalpha requis par la preuve de (?)PPpRpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOoScalpha requis par la preuve de (?)PPpRpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}


assert(HPPpRpPsOoScalphaM : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsOoScalpham : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPpOoSc *)
(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LPQPpQpQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpQsOoSc requis par la preuve de (?)PQRPpQpQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpQsOoSc requis par la preuve de (?)PQRPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpQsOoScm3 : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpQsOoScm4 : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpQpQsOoScM : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpQsOoScm : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpQpQsOoSceq HPQRPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpQpQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOo requis par la preuve de (?)PQRPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOo requis par la preuve de (?)PQRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOom3 : rk(P :: Q :: R :: Pp :: Oo :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOom4 : rk(P :: Q :: R :: Pp :: Oo :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpOoM : rk(P :: Q :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOom : rk(P :: Q :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpOoeq HPQRPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpQsOoSc requis par la preuve de (?)PQPpQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpQsOoSc requis par la preuve de (?)PQPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpQpQsOoScm3 : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpQsOoScm4 : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpQpQsOoSceq : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQRPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpQsOoScmtmp : rk(P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpQpQsOoSceq HPQRPpQpQsOoScm4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpQsOoScmtmp;try rewrite HT2 in HPQRPpQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpQsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpQpQsOoScM : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpQsOoScm : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpQpQsOoSceq HPQPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpOoalpha requis par la preuve de (?)PQRPpQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpOoalpha requis par la preuve de (?)PQRPpQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpOoalpham3 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpOoalpham4 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpQpOoalphaM : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpOoalpham : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpQpOoalphaeq HPQRPpQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpalpha requis par la preuve de (?)PQRPpQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpalpha requis par la preuve de (?)PQRPpQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpalpham3 : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRPpQpalphaM3 : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) <= 3).
{
	try assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRPpalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQRPpQpalphaM : rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpalpham : rk(P :: Q :: R :: Pp :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpQpalphaeq HPQRPpQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPpQpOom3 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	try assert(HQPpQpeq : rk(Q :: Pp :: Qp :: nil) = 3) by (apply LQPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Oo :: nil) 3 3 HQPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQPpQpOom4 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQRPpQpalphaeq : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPQRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpalphaMtmp : rk(P :: Q :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpQpalphaeq HPQRPpQpalphaM3).
	try assert(HPQRPpQpOoalphaeq : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpOoalphamtmp : rk(P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpQpOoalphaeq HPQRPpQpOoalpham4).
	try assert(HQPpQpeq : rk(Q :: Pp :: Qp :: nil) = 3) by (apply LQPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (list_inter (Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Oo :: alpha :: nil) (Q :: Pp :: Qp :: Oo :: P :: Q :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Qp :: Oo :: P :: Q :: R :: Pp :: Qp :: alpha :: nil) ((Q :: Pp :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpOoalphamtmp;try rewrite HT2 in HPQRPpQpOoalphamtmp.
	assert(HT := rule_2 (Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: alpha :: nil) (Q :: Pp :: Qp :: nil) 4 3 3 HPQRPpQpOoalphamtmp HQPpQpmtmp HPQRPpQpalphaMtmp Hincl);apply HT.
}


assert(HQPpQpOoM : rk(Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpOom : rk(Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpOoeq HQPpQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpQsOoSc *)
(* dans constructLemma(), requis par LPQPpQpOo *)
(* dans la couche 0 *)
Lemma LPQRPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpOo requis par la preuve de (?)PQRPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpOo requis par la preuve de (?)PQRPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpQpOoM : rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpOom : rk(P :: Q :: R :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpOoeq HPQRPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpOo requis par la preuve de (?)PQPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpOo requis par la preuve de (?)PQPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpQpOom3 : rk(P :: Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpOom4 : rk(P :: Q :: Pp :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpQpOoeq : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQRPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpOoeq HPQRPpQpOom4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Oo :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpOomtmp;try rewrite HT2 in HPQRPpQpOomtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpOomtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpQpOoM : rk(P :: Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpOom : rk(P :: Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpQpOoeq HPQPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpQsOoSc requis par la preuve de (?)QPpQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpQsOoSc requis par la preuve de (?)QPpQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPpQpQsOoScm3 : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HQPpQpeq : rk(Q :: Pp :: Qp :: nil) = 3) by (apply LQPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpQpmtmp : rk(Q :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HQPpQpeq HQPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Pp :: Qp :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HQPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HQPpQpQsOoScm4 : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQPpQpOoeq : rk(P :: Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpQpOoMtmp : rk(P :: Q :: Pp :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpQpOoeq HPQPpQpOoM4).
	try assert(HPQPpQpQsOoSceq : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpQpQsOoScmtmp : rk(P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpQpQsOoSceq HPQPpQpQsOoScm4).
	try assert(HQPpQpOoeq : rk(Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpQpOomtmp : rk(Q :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpOoeq HQPpQpOom4).
	assert(Hincl : incl (Q :: Pp :: Qp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Qp :: Oo :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Q :: Pp :: Qp :: Oo :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Qp :: Oo :: Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Qp :: Oo :: nil) ++ (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpQsOoScmtmp;try rewrite HT2 in HPQPpQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Qp :: Oo :: nil) (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (Q :: Pp :: Qp :: Oo :: nil) 4 4 4 HPQPpQpQsOoScmtmp HQPpQpOomtmp HPQPpQpOoMtmp Hincl); apply HT.
}


assert(HQPpQpQsOoScM : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpQsOoScm : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HQPpQpQsOoSceq HQPpQpQsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpOoSc *)
(* dans la couche 0 *)
Lemma LOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HOoScM : rk(Oo :: Sc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoSceq HOoScM2).
assert(HOoScm : rk(Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HOoSceq HOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpOoSc *)
(* dans constructLemma(), requis par LQQpQsOoSc *)
(* dans la couche 0 *)
Lemma LQQsOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQQsOoM : rk(Q :: Qs :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQQsOoeq HQQsOoM3).
assert(HQQsOom : rk(Q :: Qs :: Oo ::  nil) >= 1) by (solve_hyps_min HQQsOoeq HQQsOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpQsOoSc *)
(* dans la couche 0 *)
Lemma LQpQsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Qs :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQpQsScM : rk(Qp :: Qs :: Sc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQpQsSceq HQpQsScM3).
assert(HQpQsScm : rk(Qp :: Qs :: Sc ::  nil) >= 1) by (solve_hyps_min HQpQsSceq HQpQsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpPsQsOoScm3 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpPsQsOoScm4 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOoalpham3 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOoalpham4 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PQRQpalpha requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpalpham3 : rk(P :: Q :: R :: Qp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRQpalphaM3 : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3).
{
	try assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	try assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpOom3 : rk(P :: Q :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HPQQpOom4 : rk(P :: Q :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	assert(HPQRQpOoalphamtmp : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham4).
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (list_inter (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: alpha :: nil) (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOoalphamtmp;try rewrite HT2 in HPQRQpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: Qp :: nil) 4 3 3 HPQRQpOoalphamtmp HPQQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}
try clear HPQRQpOoalphaM1. try clear HPQRQpOoalphaM2. try clear HPQRQpOoalphaM3. try clear HPQRQpOoalpham4. try clear HPQRQpOoalpham3. try clear HPQRQpOoalpham2. try clear HPQRQpOoalpham1. 

(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOom4 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpPsQsOoScm3 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPQQpPsQsOoScm4 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	assert(HPQRQpOoMtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRQpOoeq HPQRQpOoM4).
	assert(HPQRQpPsQsOoScmtmp : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm4).
	assert(HPQQpOomtmp : rk(P :: Q :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQQpOoeq HPQQpOom4).
	assert(Hincl : incl (P :: Q :: Qp :: Oo :: nil) (list_inter (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Qp :: Oo :: nil) ++ (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpPsQsOoScmtmp;try rewrite HT2 in HPQRQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: Qp :: Oo :: nil) 4 4 4 HPQRQpPsQsOoScmtmp HPQQpOomtmp HPQRQpOoMtmp Hincl); apply HT.
}
try clear HPQRQpOoM1. try clear HPQRQpOoM2. try clear HPQRQpOoM3. try clear HPQRQpOom4. try clear HPQRQpOom3. try clear HPQRQpOom2. try clear HPQRQpOom1. try clear HPQQpOoM1. try clear HPQQpOoM2. try clear HPQQpOoM3. try clear HPQQpOom4. try clear HPQQpOom3. try clear HPQQpOom2. try clear HPQQpOom1. try clear HPQRQpPsQsOoScM1. try clear HPQRQpPsQsOoScM2. try clear HPQRQpPsQsOoScM3. try clear HPQRQpPsQsOoScm4. try clear HPQRQpPsQsOoScm3. try clear HPQRQpPsQsOoScm2. try clear HPQRQpPsQsOoScm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 1 pour Oo requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPsOo requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpQsOoSc requis par la preuve de (?)PQQpQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpQsOoScm3 : rk(P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpQsOoSc requis par la preuve de (?)QQpQsOoSc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : P :: Q :: Qp :: Qs :: Oo :: Sc ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Oo ::   de rang : 2 et 2 *)
assert(HQQpQsOoScm2 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOoMtmp : rk(P :: Oo :: nil) <= 2) by (solve_hyps_max HPOoeq HPOoM2).
	assert(HPQQpQsOoScmtmp : rk(P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPQQpQsOoSceq HPQQpQsOoScm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Qs :: Oo :: Sc :: nil) (P :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Oo :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpQsOoScmtmp;try rewrite HT2 in HPQQpQsOoScmtmp.
	assert(HT := rule_4 (P :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: nil) 3 1 2 HPQQpQsOoScmtmp HOomtmp HPOoMtmp Hincl); apply HT.
}
try clear HPQQpQsOoScM1. try clear HPQQpQsOoScM2. try clear HPQQpQsOoScM3. try clear HPQQpQsOoScm4. try clear HPQQpQsOoScm3. try clear HPQQpQsOoScm2. try clear HPQQpQsOoScm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HQQpQsOoScm3 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) >= 3).
{
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPQQpPsQsOoScmtmp : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQQpPsQsOoSceq HPQQpPsQsOoScm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Ps :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpPsQsOoScmtmp;try rewrite HT2 in HPQQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: nil) 4 1 2 HPQQpPsQsOoScmtmp HOomtmp HPPsOoMtmp Hincl); apply HT.
}
try clear HPQQpPsQsOoScM1. try clear HPQQpPsQsOoScM2. try clear HPQQpPsQsOoScM3. try clear HPQQpPsQsOoScm4. try clear HPQQpPsQsOoScm3. try clear HPQQpPsQsOoScm2. try clear HPQQpPsQsOoScm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HQQpQsOoScM3 : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) <= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	try assert(HQpQsSceq : rk(Qp :: Qs :: Sc :: nil) = 2) by (apply LQpQsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Qs :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Q :: Qs :: Oo :: Qp :: Qs :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Qs :: Sc :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Qs :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (Qp :: Qs :: Sc :: nil) (Qs :: nil) 2 2 1 HQQsOoMtmp HQpQsScMtmp HQsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HQQpQsOoScM : rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpQsOoScm : rk(Q :: Qp :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HQQpQsOoSceq HQQpQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpOoSc requis par la preuve de (?)PpOoSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoScm3 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoScm4 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpOoSc requis par la preuve de (?)PpOoSc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Pp :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPpOoScm2 : rk(Pp :: Oo :: Sc :: nil) >= 2).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpOoScmtmp : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpOoSceq HPQRPpOoScm4).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: Pp :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: Pp :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (Pp :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoScmtmp;try rewrite HT2 in HPQRPpOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Oo :: Sc :: nil) (Pp :: Oo :: nil) 4 2 4 HPQRPpOoScmtmp HPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}
try clear HPQRPpOoScM1. try clear HPQRPpOoScM2. try clear HPQRPpOoScM3. try clear HPQRPpOoScm4. try clear HPQRPpOoScm3. try clear HPQRPpOoScm2. try clear HPQRPpOoScm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPpOoScm3 : rk(Pp :: Oo :: Sc :: nil) >= 3).
{
	try assert(HQQpQsOoSceq : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) = 3) by (apply LQQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpQsOoScMtmp : rk(Q :: Qp :: Qs :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HQQpQsOoSceq HQQpQsOoScM3).
	try assert(HQPpQpQsOoSceq : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) = 4) by (apply LQPpQpQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpQpQsOoScmtmp : rk(Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HQPpQpQsOoSceq HQPpQpQsOoScm4).
	try assert(HOoSceq : rk(Oo :: Sc :: nil) = 2) by (apply LOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOoScmtmp : rk(Oo :: Sc :: nil) >= 2) by (solve_hyps_min HOoSceq HOoScm2).
	assert(Hincl : incl (Oo :: Sc :: nil) (list_inter (Pp :: Oo :: Sc :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Qs :: Oo :: Sc :: nil) (Pp :: Oo :: Sc :: Q :: Qp :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: Sc :: Q :: Qp :: Qs :: Oo :: Sc :: nil) ((Pp :: Oo :: Sc :: nil) ++ (Q :: Qp :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpQsOoScmtmp;try rewrite HT2 in HQPpQpQsOoScmtmp.
	assert(HT := rule_2 (Pp :: Oo :: Sc :: nil) (Q :: Qp :: Qs :: Oo :: Sc :: nil) (Oo :: Sc :: nil) 4 2 3 HQPpQpQsOoScmtmp HOoScmtmp HQQpQsOoScMtmp Hincl);apply HT.
}
try clear HOoScM1. try clear HOoScM2. try clear HOoScM3. try clear HOoScm4. try clear HOoScm3. try clear HOoScm2. try clear HOoScm1. 

assert(HPpOoScM : rk(Pp :: Oo :: Sc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpOoSceq HPpOoScM3).
assert(HPpOoScm : rk(Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPpOoSceq HPpOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpRpPsOoScalpha *)
(* dans constructLemma(), requis par LPPpOoSc *)
(* dans constructLemma(), requis par LPPpPsOoSc *)
(* dans constructLemma(), requis par LPQPpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoSc requis par la preuve de (?)PQRPpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoSc requis par la preuve de (?)PQRPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScm3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScm4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpPsOoScM : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpPsOoScm : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpPsOoSceq HPQRPpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoSc requis par la preuve de (?)PQPpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoSc requis par la preuve de (?)PQPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScm3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpPsOoScm4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpPsOoSceq : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpPsOoSceq HPQRPpPsOoScm4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpPsOoScmtmp;try rewrite HT2 in HPQRPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpPsOoScM : rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsOoScm : rk(P :: Q :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpPsOoSc *)
(* dans la couche 0 *)
Lemma LPPsOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPPsOoM : rk(P :: Ps :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPsOoeq HPPsOoM3).
assert(HPPsOom : rk(P :: Ps :: Oo ::  nil) >= 1) by (solve_hyps_min HPPsOoeq HPPsOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpPsOoSc *)
(* dans constructLemma(), requis par LPQPsOo *)
(* dans constructLemma(), requis par LPQOo *)
(* dans la couche 0 *)
Lemma LOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Oo ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQOo *)
(* dans la couche 0 *)
Lemma LROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ROo requis par la preuve de (?)ROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HROom2 : rk(R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: Q :: R :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (R :: Oo :: nil) (R :: nil) 4 1 3 HPQROomtmp HRmtmp HPQRMtmp Hincl); apply HT.
}


assert(HROoM : rk(R :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HROoeq HROoM2).
assert(HROom : rk(R :: Oo ::  nil) >= 1) by (solve_hyps_min HROoeq HROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PQ requis par la preuve de (?)PQOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQOo requis par la preuve de (?)PQOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPQOom2 : rk(P :: Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPQmtmp : rk(P :: Q :: nil) >= 1) by (solve_hyps_min HPQeq HPQm1).
	assert(Hincl : incl (P :: Q :: nil) (list_inter (P :: Q :: R :: nil) (P :: Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Q :: Oo :: nil) (P :: Q :: nil) 4 1 3 HPQROomtmp HPQmtmp HPQRMtmp Hincl); apply HT.
}
try clear HPQM1. try clear HPQM2. try clear HPQM3. try clear HPQm4. try clear HPQm3. try clear HPQm2. try clear HPQm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQOom3 : rk(P :: Q :: Oo :: nil) >= 3).
{
	try assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HROoMtmp : rk(R :: Oo :: nil) <= 2) by (solve_hyps_max HROoeq HROoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Q :: Oo :: nil) (R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: Oo :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Oo :: R :: Oo :: nil) ((P :: Q :: Oo :: nil) ++ (R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_2 (P :: Q :: Oo :: nil) (R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HROoMtmp Hincl);apply HT.
}


assert(HPQOoM : rk(P :: Q :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQOoeq HPQOoM3).
assert(HPQOom : rk(P :: Q :: Oo ::  nil) >= 1) by (solve_hyps_min HPQOoeq HPQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQPs requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOp requis par la preuve de (?)PQPs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOp requis par la preuve de (?)PQPpPsOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOpm3 : rk(P :: Q :: Pp :: Ps :: Op :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPpOp requis par la preuve de (?)PQPs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQPs requis par la preuve de (?)PQPs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HPQPsm2 : rk(P :: Q :: Ps :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpmtmp : rk(P :: Q :: Pp :: Ps :: Op :: nil) >= 3) by (solve_hyps_min HPQPpPsOpeq HPQPpPsOpm3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: Ps :: nil) (P :: Pp :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: nil) (P :: Q :: Ps :: P :: Pp :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: P :: Pp :: Op :: nil) ((P :: Q :: Ps :: nil) ++ (P :: Pp :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpmtmp;try rewrite HT2 in HPQPpPsOpmtmp.
	assert(HT := rule_2 (P :: Q :: Ps :: nil) (P :: Pp :: Op :: nil) (P :: nil) 3 1 2 HPQPpPsOpmtmp HPmtmp HPPpOpMtmp Hincl);apply HT.
}
try clear HPQPpPsOpM1. try clear HPQPpPsOpM2. try clear HPQPpPsOpM3. try clear HPQPpPsOpm4. try clear HPQPpPsOpm3. try clear HPQPpPsOpm2. try clear HPQPpPsOpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOo requis par la preuve de (?)PQPsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPQPsOoM3 : rk(P :: Q :: Ps :: Oo :: nil) <= 3).
{
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (P :: Ps :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: nil) (Q :: P :: Ps :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: P :: Ps :: Oo :: nil) ((Q :: nil) ++ (P :: Ps :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (P :: Ps :: Oo :: nil) (nil) 1 2 0 HQMtmp HPPsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPQPsOom2 : rk(P :: Q :: Ps :: Oo :: nil) >= 2).
{
	assert(HPQPsmtmp : rk(P :: Q :: Ps :: nil) >= 2) by (solve_hyps_min HPQPseq HPQPsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Ps :: nil) (P :: Q :: Ps :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Ps :: nil) (P :: Q :: Ps :: Oo :: nil) 2 2 HPQPsmtmp Hcomp Hincl);apply HT.
}
try clear HPQPsM1. try clear HPQPsM2. try clear HPQPsM3. try clear HPQPsm4. try clear HPQPsm3. try clear HPQPsm2. try clear HPQPsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOom3 : rk(P :: Q :: Ps :: Oo :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


assert(HPQPsOoM : rk(P :: Q :: Ps :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOom : rk(P :: Q :: Ps :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPsOoeq HPQPsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpPsSc requis par la preuve de (?)PPpPsOoSc pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpPsOoSc requis par la preuve de (?)PPpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPpPsOoScm2 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HPPpPsOoScM3 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) <= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: nil) (Ps :: nil) 2 2 1 HPPsOoMtmp HPpPsScMtmp HPsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Ps :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPPpPsOoScm3 : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	try assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOomtmp : rk(P :: Ps :: Oo :: nil) >= 2) by (solve_hyps_min HPPsOoeq HPPsOom2).
	assert(Hincl : incl (P :: Ps :: Oo :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Ps :: Oo :: P :: Pp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: P :: Pp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (P :: Pp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: nil) 4 2 3 HPQPpPsOoScmtmp HPPsOomtmp HPQPsOoMtmp Hincl); apply HT.
}


assert(HPPpPsOoScM : rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpPsOoScm : rk(P :: Pp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpPsOoSceq HPPpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Oo :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpOoSc requis par la preuve de (?)PPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPpOoScm2 : rk(P :: Pp :: Oo :: Sc :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPPpOoScm3 : rk(P :: Pp :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	try assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Ps :: Oo :: P :: Pp :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: P :: Pp :: Oo :: Sc :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (P :: Pp :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (P :: Pp :: Oo :: Sc :: nil) (P :: Oo :: nil) 4 2 3 HPQPpPsOoScmtmp HPOomtmp HPQPsOoMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpOoScM3 : rk(P :: Pp :: Oo :: Sc :: nil) <= 3).
{
	try assert(HPPpPsOoSceq : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) = 3) by (apply LPPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpPsOoScMtmp : rk(P :: Pp :: Ps :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HPPpPsOoSceq HPPpPsOoScM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Oo :: Sc :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Pp :: Oo :: Sc :: nil) (P :: Pp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpPsOoScMtmp Hcomp Hincl);apply HT.
}


assert(HPPpOoScM : rk(P :: Pp :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpOoScm : rk(P :: Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpOoSceq HPPpOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PsOo requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOpOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOpOoScalpha requis par la preuve de (?)PPpRpPsOpOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOpOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPpOp requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsOoScalpha requis par la preuve de (?)PpRpPsOoScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsOoScalpham2 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsOpOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsOpOoScalphaeq HPPpRpPsOpOoScalpham3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Op :: Oo :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOpOoScalphamtmp;try rewrite HT2 in HPPpRpPsOpOoScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsOpOoScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPPpRpPsOpOoScalphaM1. try clear HPPpRpPsOpOoScalphaM2. try clear HPPpRpPsOpOoScalphaM3. try clear HPPpRpPsOpOoScalpham4. try clear HPPpRpPsOpOoScalpham3. try clear HPPpRpPsOpOoScalpham2. try clear HPPpRpPsOpOoScalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps :: Oo ::  de rang :  1 et 2 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsOoScalpham3 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	assert(HPsOomtmp : rk(Ps :: Oo :: nil) >= 1) by (solve_hyps_min HPsOoeq HPsOom1).
	assert(Hincl : incl (Ps :: Oo :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Ps :: Oo :: nil) 4 1 2 HPPpRpPsOoScalphamtmp HPsOomtmp HPPsOoMtmp Hincl); apply HT.
}
try clear HPsOoM1. try clear HPsOoM2. try clear HPsOoM3. try clear HPsOom4. try clear HPsOom3. try clear HPsOom2. try clear HPsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: Oo :: Sc ::  de rang :  3 et 3 	 A : P :: Pp :: Oo :: Sc ::   de rang : 3 et 3 *)
assert(HPpRpPsOoScalpham4 : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPPpOoSceq : rk(P :: Pp :: Oo :: Sc :: nil) = 3) by (apply LPPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOoScMtmp : rk(P :: Pp :: Oo :: Sc :: nil) <= 3) by (solve_hyps_max HPPpOoSceq HPPpOoScM3).
	try assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	try assert(HPpOoSceq : rk(Pp :: Oo :: Sc :: nil) = 3) by (apply LPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpOoScmtmp : rk(Pp :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPpOoSceq HPpOoScm3).
	assert(Hincl : incl (Pp :: Oo :: Sc :: nil) (list_inter (P :: Pp :: Oo :: Sc :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Pp :: Oo :: Sc :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: Sc :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Pp :: Oo :: Sc :: nil) ++ (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: Sc :: nil) (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Oo :: Sc :: nil) 4 3 3 HPPpRpPsOoScalphamtmp HPpOoScmtmp HPPpOoScMtmp Hincl); apply HT.
}


assert(HPpRpPsOoScalphaM : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsOoScalpham : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsOoScalphaeq HPpRpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpPsOoScalpha *)
(* dans constructLemma(), requis par LPpalpha *)
(* dans la couche 0 *)
Lemma LPRPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpalpha requis par la preuve de (?)PQRPpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpalpham3 : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QPp requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpalpha requis par la preuve de (?)PRPpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPRPpalphaM3 : rk(P :: R :: Pp :: alpha :: nil) <= 3).
{
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpMtmp : rk(Pp :: nil) <= 1) by (solve_hyps_max HPpeq HPpM1).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: alpha :: nil) (Pp :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: P :: R :: alpha :: nil) ((Pp :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HPpMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : Q :: Pp ::   de rang : 1 et 2 *)
assert(HPRPpalpham2 : rk(P :: R :: Pp :: alpha :: nil) >= 2).
{
	assert(HQPpMtmp : rk(Q :: Pp :: nil) <= 2) by (solve_hyps_max HQPpeq HQPpM2).
	assert(HPQRPpalphamtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) >= 3) by (solve_hyps_min HPQRPpalphaeq HPQRPpalpham3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Q :: Pp :: nil) (P :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: alpha :: nil) (Q :: Pp :: P :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: P :: R :: Pp :: alpha :: nil) ((Q :: Pp :: nil) ++ (P :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpalphamtmp;try rewrite HT2 in HPQRPpalphamtmp.
	assert(HT := rule_4 (Q :: Pp :: nil) (P :: R :: Pp :: alpha :: nil) (Pp :: nil) 3 1 2 HPQRPpalphamtmp HPpmtmp HQPpMtmp Hincl); apply HT.
}
try clear HQPpM1. try clear HQPpM2. try clear HQPpM3. try clear HQPpm4. try clear HQPpm3. try clear HQPpm2. try clear HQPpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpalpham3 : rk(P :: R :: Pp :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


assert(HPRPpalphaM : rk(P :: R :: Pp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpalpham : rk(P :: R :: Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpalphaeq HPRPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ppalpha requis par la preuve de (?)Ppalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPpalpham2 : rk(Pp :: alpha :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRPpalphaeq : rk(P :: R :: Pp :: alpha :: nil) = 3) by (apply LPRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpalphamtmp : rk(P :: R :: Pp :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpalphaeq HPRPpalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: alpha :: nil) (P :: R :: alpha :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Pp :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpalphamtmp;try rewrite HT2 in HPRPpalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Pp :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPpalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPpalphaM : rk(Pp :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpalphaeq HPpalphaM2).
assert(HPpalpham : rk(Pp :: alpha ::  nil) >= 1) by (solve_hyps_min HPpalphaeq HPpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScalpham3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScalpham4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpOo requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpPsOoScalpha requis par la preuve de (?)PpPsOoScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: Oo ::  de rang :  2 et 2 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPpPsOoScalpham2 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 2).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	assert(HPQRPpPsOoScalphamtmp : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpPsOoScalphaeq HPQRPpPsOoScalpham4).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Q :: R :: Pp :: Oo :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpPsOoScalphamtmp;try rewrite HT2 in HPQRPpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Oo :: nil) 4 2 4 HPQRPpPsOoScalphamtmp HPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}
try clear HPQRPpPsOoScalphaM1. try clear HPQRPpPsOoScalphaM2. try clear HPQRPpPsOoScalphaM3. try clear HPQRPpPsOoScalpham4. try clear HPQRPpPsOoScalpham3. try clear HPQRPpPsOoScalpham2. try clear HPQRPpPsOoScalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPpPsOoScalpham3 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPpOoSceq : rk(Pp :: Oo :: Sc :: nil) = 3) by (apply LPpOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpOoScmtmp : rk(Pp :: Oo :: Sc :: nil) >= 3) by (solve_hyps_min HPpOoSceq HPpOoScm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Oo :: Sc :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Oo :: Sc :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPpOoScmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Pp :: alpha ::  de rang :  2 et 2 	 A : Pp :: Rp :: alpha ::   de rang : 2 et 2 *)
assert(HPpPsOoScalpham4 : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPpRpalphaeq : rk(Pp :: Rp :: alpha :: nil) = 2) by (apply LPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	try assert(HPpRpPsOoScalphaeq : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpPsOoScalphamtmp : rk(Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPpRpPsOoScalphaeq HPpRpPsOoScalpham4).
	try assert(HPpalphaeq : rk(Pp :: alpha :: nil) = 2) by (apply LPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpalphamtmp : rk(Pp :: alpha :: nil) >= 2) by (solve_hyps_min HPpalphaeq HPpalpham2).
	assert(Hincl : incl (Pp :: alpha :: nil) (list_inter (Pp :: Rp :: alpha :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: Rp :: alpha :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Rp :: alpha :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) ((Pp :: Rp :: alpha :: nil) ++ (Pp :: Ps :: Oo :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpRpPsOoScalphamtmp;try rewrite HT2 in HPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (Pp :: Rp :: alpha :: nil) (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Pp :: alpha :: nil) 4 2 2 HPpRpPsOoScalphamtmp HPpalphamtmp HPpRpalphaMtmp Hincl); apply HT.
}
try clear HPpalphaM1. try clear HPpalphaM2. try clear HPpalphaM3. try clear HPpalpham4. try clear HPpalpham3. try clear HPpalpham2. try clear HPpalpham1. 

assert(HPpPsOoScalphaM : rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpPsOoScalpham : rk(Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpPsOoScalphaeq HPpPsOoScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsOoalpha *)
(* dans constructLemma(), requis par LPsalpha *)
(* dans constructLemma(), requis par LPRPsalpha *)
(* dans constructLemma(), requis par LPRPpPsScalpha *)
(* dans constructLemma(), requis par LPRPpSc *)
(* dans constructLemma(), requis par LPQRPpScalpha *)
(* dans la couche 0 *)
Lemma LPQRSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQRScM : rk(P :: Q :: R :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRScm : rk(P :: Q :: R :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRSceq HPQRScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpScalpha requis par la preuve de (?)PQRPpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpScalpha requis par la preuve de (?)PQRPpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpScalpham3 : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpScalpham4 : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQRSceq : rk(P :: Q :: R :: Sc :: nil) = 4) by (apply LPQRSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Pp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpScalphaM : rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpScalpham : rk(P :: Q :: R :: Pp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpSc requis par la preuve de (?)PRPpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpSc requis par la preuve de (?)PRPpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpScm3 : rk(P :: R :: Pp :: Sc :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Sc :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPRPpScm4 : rk(P :: R :: Pp :: Sc :: nil) >= 4).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpScalphaeq : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) = 4) by (apply LPQRPpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpScalphamtmp : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham4).
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Sc :: alpha :: nil) (P :: R :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Sc :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpScalphamtmp;try rewrite HT2 in HPQRPpScalphamtmp.
	assert(HT := rule_2 (P :: R :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 4 3 3 HPQRPpScalphamtmp HPRPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


assert(HPRPpScM : rk(P :: R :: Pp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpScm : rk(P :: R :: Pp :: Sc ::  nil) >= 1) by (solve_hyps_min HPRPpSceq HPRPpScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsScalpha requis par la preuve de (?)PRPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsScalpha requis par la preuve de (?)PRPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsScalpham3 : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsScalpham4 : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPRPpPsScalphaM : rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpPsScalpham : rk(P :: R :: Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPRPsalpha *)
(* dans la couche 0 *)
Lemma LPpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Ps :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPpPsScM : rk(Pp :: Ps :: Sc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpPsSceq HPpPsScM3).
assert(HPpPsScm : rk(Pp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HPpPsSceq HPpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsalpha requis par la preuve de (?)PQRPsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsalpham3 : rk(P :: Q :: R :: Ps :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QPs requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsalpha requis par la preuve de (?)PRPsalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPRPsalphaM3 : rk(P :: R :: Ps :: alpha :: nil) <= 3).
{
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsMtmp : rk(Ps :: nil) <= 1) by (solve_hyps_max HPseq HPsM1).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ps :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (Ps :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: P :: R :: alpha :: nil) ((Ps :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HPsMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: alpha ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Q :: Ps ::   de rang : 1 et 2 *)
assert(HPRPsalpham2 : rk(P :: R :: Ps :: alpha :: nil) >= 2).
{
	assert(HQPsMtmp : rk(Q :: Ps :: nil) <= 2) by (solve_hyps_max HQPseq HQPsM2).
	assert(HPQRPsalphamtmp : rk(P :: Q :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPQRPsalphaeq HPQRPsalpham3).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Q :: Ps :: nil) (P :: R :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: alpha :: nil) (Q :: Ps :: P :: R :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Ps :: P :: R :: Ps :: alpha :: nil) ((Q :: Ps :: nil) ++ (P :: R :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsalphamtmp;try rewrite HT2 in HPQRPsalphamtmp.
	assert(HT := rule_4 (Q :: Ps :: nil) (P :: R :: Ps :: alpha :: nil) (Ps :: nil) 3 1 2 HPQRPsalphamtmp HPsmtmp HQPsMtmp Hincl); apply HT.
}
try clear HQPsM1. try clear HQPsM2. try clear HQPsM3. try clear HQPsm4. try clear HQPsm3. try clear HQPsm2. try clear HQPsm1. try clear HPQRPsalphaM1. try clear HPQRPsalphaM2. try clear HPQRPsalphaM3. try clear HPQRPsalpham4. try clear HPQRPsalpham3. try clear HPQRPsalpham2. try clear HPQRPsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsalpham3 : rk(P :: R :: Ps :: alpha :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPRPpPsScalphaeq : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) = 4) by (apply LPRPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpPsScalphamtmp : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsScalphamtmp;try rewrite HT2 in HPRPpPsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}


assert(HPRPsalphaM : rk(P :: R :: Ps :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsalpham : rk(P :: R :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsalphaeq HPRPsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Psalpha requis par la preuve de (?)Psalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsalpham2 : rk(Ps :: alpha :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRPsalphaeq : rk(P :: R :: Ps :: alpha :: nil) = 3) by (apply LPRPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPsalphamtmp : rk(P :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsalphaeq HPRPsalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (P :: R :: alpha :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsalphamtmp;try rewrite HT2 in HPRPsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPsalphaM : rk(Ps :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPsalphaeq HPsalphaM2).
assert(HPsalpham : rk(Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPsalphaeq HPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsOoalpha *)
(* dans la couche 0 *)
Lemma LPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Ps :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpPsScalpha requis par la preuve de (?)PpPsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Q :: Ps :: Oo ::   de rang : 3 et 3 *)
assert(HPpPsScalpham2 : rk(Pp :: Ps :: Sc :: alpha :: nil) >= 2).
{
	try assert(HPQPsOoeq : rk(P :: Q :: Ps :: Oo :: nil) = 3) by (apply LPQPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsOoMtmp : rk(P :: Q :: Ps :: Oo :: nil) <= 3) by (solve_hyps_max HPQPsOoeq HPQPsOoM3).
	assert(HPQPpPsOoScalphamtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsOoScalphaeq HPQPpPsOoScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Q :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Q :: Ps :: Oo :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: Oo :: Pp :: Ps :: Sc :: alpha :: nil) ((P :: Q :: Ps :: Oo :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScalphamtmp;try rewrite HT2 in HPQPpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Q :: Ps :: Oo :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (Ps :: nil) 4 1 3 HPQPpPsOoScalphamtmp HPsmtmp HPQPsOoMtmp Hincl); apply HT.
}
try clear HPQPpPsOoScalphaM1. try clear HPQPpPsOoScalphaM2. try clear HPQPpPsOoScalphaM3. try clear HPQPpPsOoScalpham4. try clear HPQPpPsOoScalpham3. try clear HPQPpPsOoScalpham2. try clear HPQPpPsOoScalpham1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPpPsScalphaM3 : rk(Pp :: Ps :: Sc :: alpha :: nil) <= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: Ps :: Sc :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (alpha :: nil) (nil) 2 1 0 HPpPsScMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPpPsScalpham3 : rk(Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRPpPsScalphaeq : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) = 4) by (apply LPRPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpPsScalphamtmp : rk(P :: R :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsScalphaeq HPRPpPsScalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Sc :: alpha :: nil) (P :: R :: alpha :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Pp :: Ps :: Sc :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsScalphamtmp;try rewrite HT2 in HPRPpPsScalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (alpha :: nil) 4 1 2 HPRPpPsScalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPpPsScalphaM : rk(Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpPsScalpham : rk(Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpPsScalphaeq HPpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PRPsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PROo requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}
try clear HPRM1. try clear HPRM2. try clear HPRM3. try clear HPRm4. try clear HPRm3. try clear HPRm2. try clear HPRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPpOp requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsOoalpham2 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsOpOoalphaeq HPRPpPsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsOpOoalphamtmp;try rewrite HT2 in HPRPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsOpOoalphaM1. try clear HPRPpPsOpOoalphaM2. try clear HPRPpPsOpOoalphaM3. try clear HPRPpPsOpOoalpham4. try clear HPRPpPsOpOoalpham3. try clear HPRPpPsOpOoalpham2. try clear HPRPpPsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPRPsOoalpham3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPRPsOoalphaM3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: R :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPRalphaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsOoalpha requis par la preuve de (?)PsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Oo :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsOoalpham2 : rk(Ps :: Oo :: alpha :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsOoalphamtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsOoalphamtmp;try rewrite HT2 in HPRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Oo :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPsOoalpham3 : rk(Ps :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPpPsScalphaeq : rk(Pp :: Ps :: Sc :: alpha :: nil) = 3) by (apply LPpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScalphaMtmp : rk(Pp :: Ps :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpPsScalphaeq HPpPsScalphaM3).
	try assert(HPpPsOoScalphaeq : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsOoScalphamtmp : rk(Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPpPsOoScalphaeq HPpPsOoScalpham4).
	try assert(HPsalphaeq : rk(Ps :: alpha :: nil) = 2) by (apply LPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsalphamtmp : rk(Ps :: alpha :: nil) >= 2) by (solve_hyps_min HPsalphaeq HPsalpham2).
	assert(Hincl : incl (Ps :: alpha :: nil) (list_inter (Ps :: Oo :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Ps :: Oo :: Sc :: alpha :: nil) (Ps :: Oo :: alpha :: Pp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Oo :: alpha :: Pp :: Ps :: Sc :: alpha :: nil) ((Ps :: Oo :: alpha :: nil) ++ (Pp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpPsOoScalphamtmp;try rewrite HT2 in HPpPsOoScalphamtmp.
	assert(HT := rule_2 (Ps :: Oo :: alpha :: nil) (Pp :: Ps :: Sc :: alpha :: nil) (Ps :: alpha :: nil) 4 2 3 HPpPsOoScalphamtmp HPsalphamtmp HPpPsScalphaMtmp Hincl);apply HT.
}
try clear HPsalphaM1. try clear HPsalphaM2. try clear HPsalphaM3. try clear HPsalpham4. try clear HPsalpham3. try clear HPsalpham2. try clear HPsalpham1. 

assert(HPsOoalphaM : rk(Ps :: Oo :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsOoalphaeq HPsOoalphaM3).
assert(HPsOoalpham : rk(Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPsOoalphaeq HPsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalpha *)
(* dans constructLemma(), requis par LPPsOoalpha *)
(* dans la couche 0 *)
Lemma LPRPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour PROo requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}
try clear HPRM1. try clear HPRM2. try clear HPRM3. try clear HPRm4. try clear HPRm3. try clear HPRm2. try clear HPRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsOpOoalpha requis par la preuve de (?)PRPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PPpOp requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsOoalpha requis par la preuve de (?)PRPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsOoalpham2 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsOpOoalphaeq HPRPpPsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsOpOoalphamtmp;try rewrite HT2 in HPRPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsOpOoalphaM1. try clear HPRPpPsOpOoalphaM2. try clear HPRPpPsOpOoalphaM3. try clear HPRPpPsOpOoalpham4. try clear HPRPpPsOpOoalpham3. try clear HPRPpPsOpOoalpham2. try clear HPRPpPsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPRPsOoalpham3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPRPsOoalphaM3 : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: R :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: R :: alpha :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPRalphaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPRPsOoalphaM : rk(P :: R :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsOoalpham : rk(P :: R :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour POo requis par la preuve de (?)PPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsOoalpha requis par la preuve de (?)PPsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HPPsOoalpham2 : rk(P :: Ps :: Oo :: alpha :: nil) >= 2).
{
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (P :: Oo :: nil) (P :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Oo :: nil) (P :: Ps :: Oo :: alpha :: nil) 2 2 HPOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPPsOoalphaM3 : rk(P :: Ps :: Oo :: alpha :: nil) <= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: Ps :: Oo :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Ps :: Oo :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (alpha :: nil) (nil) 2 1 0 HPPsOoMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Oo :: alpha ::  de rang :  3 et 3 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsOoalpham3 : rk(P :: Ps :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRPsOoalphaeq : rk(P :: R :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPsOoalphamtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsOoalphaeq HPRPsOoalpham3).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsOoalphamtmp;try rewrite HT2 in HPRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPPsOoalphaM : rk(P :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsOoalpham : rk(P :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsOoalphaeq HPPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)QPsQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalpha requis par la preuve de (?)QPsQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HQPsQsOoalpham2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalpham3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphaeq HPQRPsQsOoalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphamtmp;try rewrite HT2 in HPQRPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalpham4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsQsOoalphaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsOoalphamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphaeq HPQPsQsOoalpham4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphamtmp;try rewrite HT2 in HPQPsQsOoalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


assert(HQPsQsOoalphaM : rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalpham : rk(Q :: Ps :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphaeq HQPsQsOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQs *)
(* dans constructLemma(), requis par LQQsOoalpha *)
(* dans la couche 0 *)
Lemma LPQRQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQsOoalpha requis par la preuve de (?)PQRQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQsOoalpha requis par la preuve de (?)PQRQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQsOoalpham3 : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQsOoalpham4 : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qs :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRQsOoalphaM : rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQsOoalpham : rk(P :: Q :: R :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qs :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QOo requis par la preuve de (?)QQsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQsOoalpha requis par la preuve de (?)QQsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HQQsOoalpham2 : rk(Q :: Qs :: Oo :: alpha :: nil) >= 2).
{
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Qs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Qs :: Oo :: alpha :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HQQsOoalphaM3 : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: Qs :: Oo :: nil) (alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qs :: Oo :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: nil) ((Q :: Qs :: Oo :: nil) ++ (alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (alpha :: nil) (nil) 2 1 0 HQQsOoMtmp HalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQQsOoalpham3 : rk(Q :: Qs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRQsOoalphaeq : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQsOoalphamtmp : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: Oo :: alpha :: nil) (P :: R :: alpha :: Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Qs :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsOoalphamtmp;try rewrite HT2 in HPQRQsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Qs :: Oo :: alpha :: nil) (alpha :: nil) 4 1 2 HPQRQsOoalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HQQsOoalphaM : rk(Q :: Qs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQsOoalpham : rk(Q :: Qs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HQQsOoalphaeq HQQsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQs : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PsQs requis par la preuve de (?)PsQs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPsQsm2 : rk(Ps :: Qs :: nil) >= 2).
{
	try assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	try assert(HQPsQsOoalphaeq : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) = 4) by (apply LQPsQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPsQsOoalphamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphaeq HQPsQsOoalpham4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Ps :: Qs :: nil) (Q :: Qs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Q :: Qs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Qs :: Q :: Qs :: Oo :: alpha :: nil) ((Ps :: Qs :: nil) ++ (Q :: Qs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphamtmp;try rewrite HT2 in HQPsQsOoalphamtmp.
	assert(HT := rule_2 (Ps :: Qs :: nil) (Q :: Qs :: Oo :: alpha :: nil) (Qs :: nil) 4 1 3 HQPsQsOoalphamtmp HQsmtmp HQQsOoalphaMtmp Hincl);apply HT.
}


assert(HPsQsM : rk(Ps :: Qs ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPsQseq HPsQsM2).
assert(HPsQsm : rk(Ps :: Qs ::  nil) >= 1) by (solve_hyps_min HPsQseq HPsQsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRs : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Rs ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRsM : rk(Rs ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HRseq HRsM1).
assert(HRsm : rk(Rs ::  nil) >= 1) by (solve_hyps_min HRseq HRsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpOp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Op ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPPpOpM : rk(P :: Pp :: Op ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPpOpeq HPPpOpM3).
assert(HPPpOpm : rk(P :: Pp :: Op ::  nil) >= 1) by (solve_hyps_min HPPpOpeq HPPpOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpOp : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Op ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQQpOpM : rk(Q :: Qp :: Op ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQQpOpeq HQQpOpM3).
assert(HQQpOpm : rk(Q :: Qp :: Op ::  nil) >= 1) by (solve_hyps_min HQQpOpeq HQQpOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Q :: R :: nil) (P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: Oo :: nil) (P :: nil) 4 1 3 HPQROomtmp HPmtmp HPQRMtmp Hincl); apply HT.
}


assert(HPOoM : rk(P :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPOoeq HPOoM2).
assert(HPOom : rk(P :: Oo ::  nil) >= 1) by (solve_hyps_min HPOoeq HPOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QOo requis par la preuve de (?)QOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQOom2 : rk(Q :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (P :: Q :: R :: nil) (Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: Oo :: nil) (Q :: nil) 4 1 3 HPQROomtmp HQmtmp HPQRMtmp Hincl); apply HT.
}


assert(HQOoM : rk(Q :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQOoeq HQOoM2).
assert(HQOom : rk(Q :: Oo ::  nil) >= 1) by (solve_hyps_min HQOoeq HQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PR requis par la preuve de (?)PROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PROo requis par la preuve de (?)PROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : P :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HPROom2 : rk(P :: R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HPRmtmp : rk(P :: R :: nil) >= 1) by (solve_hyps_min HPReq HPRm1).
	assert(Hincl : incl (P :: R :: nil) (list_inter (P :: Q :: R :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: P :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (P :: R :: Oo :: nil) (P :: R :: nil) 4 1 3 HPQROomtmp HPRmtmp HPQRMtmp Hincl); apply HT.
}
try clear HPRM1. try clear HPRM2. try clear HPRM3. try clear HPRm4. try clear HPRm3. try clear HPRm2. try clear HPRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Oo ::   de rang : 2 et 2 *)
assert(HPROom3 : rk(P :: R :: Oo :: nil) >= 3).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOoMtmp : rk(Q :: Oo :: nil) <= 2) by (solve_hyps_max HQOoeq HQOoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Oo :: nil) (P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (Q :: Oo :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Oo :: P :: R :: Oo :: nil) ((Q :: Oo :: nil) ++ (P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (Q :: Oo :: nil) (P :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HQOoMtmp Hincl); apply HT.
}


assert(HPROoM : rk(P :: R :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPROoeq HPROoM3).
assert(HPROom : rk(P :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HPROoeq HPROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQROo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Oo ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QROo requis par la preuve de (?)QROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QR requis par la preuve de (?)QROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QROo requis par la preuve de (?)QROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Q :: R ::  de rang :  1 et 2 	 A : P :: Q :: R ::   de rang : 3 et 3 *)
assert(HQROom2 : rk(Q :: R :: Oo :: nil) >= 2).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRMtmp : rk(P :: Q :: R :: nil) <= 3) by (solve_hyps_max HPQReq HPQRM3).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(HQRmtmp : rk(Q :: R :: nil) >= 1) by (solve_hyps_min HQReq HQRm1).
	assert(Hincl : incl (Q :: R :: nil) (list_inter (P :: Q :: R :: nil) (Q :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Q :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Q :: R :: Oo :: nil) ((P :: Q :: R :: nil) ++ (Q :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Q :: R :: nil) (Q :: R :: Oo :: nil) (Q :: R :: nil) 4 1 3 HPQROomtmp HQRmtmp HPQRMtmp Hincl); apply HT.
}
try clear HQRM1. try clear HQRM2. try clear HQRM3. try clear HQRm4. try clear HQRm3. try clear HQRm2. try clear HQRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Oo ::   de rang : 2 et 2 *)
assert(HQROom3 : rk(Q :: R :: Oo :: nil) >= 3).
{
	try assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPOoMtmp : rk(P :: Oo :: nil) <= 2) by (solve_hyps_max HPOoeq HPOoM2).
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Oo :: nil) (Q :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Oo :: nil) (P :: Oo :: Q :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Oo :: Q :: R :: Oo :: nil) ((P :: Oo :: nil) ++ (Q :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQROomtmp;try rewrite HT2 in HPQROomtmp.
	assert(HT := rule_4 (P :: Oo :: nil) (Q :: R :: Oo :: nil) (Oo :: nil) 4 1 2 HPQROomtmp HOomtmp HPOoMtmp Hincl); apply HT.
}


assert(HQROoM : rk(Q :: R :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQROoeq HQROoM3).
assert(HQROom : rk(Q :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HQROoeq HQROom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (Pp :: nil) 4 1 3 HPQRPpOoalphamtmp HPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


assert(HPpOoM : rk(Pp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpOoeq HPpOoM2).
assert(HPpOom : rk(Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPpOoeq HPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpOo requis par la preuve de (?)PRPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpOo requis par la preuve de (?)PRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpOom3 : rk(P :: R :: Pp :: Oo :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Oo :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPRPpOom4 : rk(P :: R :: Pp :: Oo :: nil) >= 4).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpOoalphaeq : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) = 4) by (apply LPQRPpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoalphamtmp : rk(P :: Q :: R :: Pp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpOoalphaeq HPQRPpOoalpham4).
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Oo :: alpha :: nil) (P :: R :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Oo :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Oo :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpOoalphamtmp;try rewrite HT2 in HPQRPpOoalphamtmp.
	assert(HT := rule_2 (P :: R :: Pp :: Oo :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 4 3 3 HPQRPpOoalphamtmp HPRPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


assert(HPRPpOoM : rk(P :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpOom : rk(P :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPRPpOoeq HPRPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpOo *)
(* dans la couche 0 *)
Lemma LPQRQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOoalpha requis par la preuve de (?)PQRQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOoalpham3 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOoalpham4 : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpOoalphaM : rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpOoalpham : rk(P :: Q :: R :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpOo *)
(* dans la couche 0 *)
Lemma LPQRQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpalpha requis par la preuve de (?)PQRQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpalpham3 : rk(P :: Q :: R :: Qp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRQpalphaM3 : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3).
{
	try assert(HPQRQpeq : rk(P :: Q :: R :: Qp :: nil) = 3) by (apply LPQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpMtmp : rk(P :: Q :: R :: Qp :: nil) <= 3) by (solve_hyps_max HPQRQpeq HPQRQpM3).
	try assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRalphaMtmp : rk(P :: Q :: R :: alpha :: nil) <= 3) by (solve_hyps_max HPQRalphaeq HPQRalphaM3).
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: P :: Q :: R :: alpha :: nil) ((P :: Q :: R :: Qp :: nil) ++ (P :: Q :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Qp :: nil) (P :: Q :: R :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRQpMtmp HPQRalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQRQpalphaM : rk(P :: Q :: R :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpalpham : rk(P :: Q :: R :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpalphaeq HPQRQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpOo requis par la preuve de (?)PQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpOom3 : rk(P :: Q :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Oo :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQQpOom4 : rk(P :: Q :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	try assert(HPQRQpOoalphaeq : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPQRQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpOoalphamtmp : rk(P :: Q :: R :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpOoalphaeq HPQRQpOoalpham4).
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (list_inter (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: alpha :: nil) (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Qp :: Oo :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: Qp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOoalphamtmp;try rewrite HT2 in HPQRQpOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Qp :: Oo :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: Qp :: nil) 4 3 3 HPQRQpOoalphamtmp HPQQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}


assert(HPQQpOoM : rk(P :: Q :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQQpOom : rk(P :: Q :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQQpOoeq HPQQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpOom4 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpOoM : rk(P :: Q :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpOom : rk(P :: Q :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRQpOoeq HPQRQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpOo *)
(* dans la couche 0 *)
Lemma LPRPpQpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpOoalpha requis par la preuve de (?)PRPpQpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpOoalpha requis par la preuve de (?)PRPpQpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpOoalpham3 : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpOoalpham4 : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPRPpOoeq : rk(P :: R :: Pp :: Oo :: nil) = 4) by (apply LPRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpOomtmp : rk(P :: R :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPRPpOoeq HPRPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Oo :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Oo :: nil) (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) 4 4 HPRPpOomtmp Hcomp Hincl);apply HT.
}


assert(HPRPpQpOoalphaM : rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpOoalpham : rk(P :: R :: Pp :: Qp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpOoalphaeq HPRPpQpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpOo *)
(* dans la couche 0 *)
Lemma LPRPpQpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpalpha requis par la preuve de (?)PRPpQpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpalpha requis par la preuve de (?)PRPpQpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpalpham3 : rk(P :: R :: Pp :: Qp :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPRPpQpalphaM3 : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3).
{
	try assert(HPRPpQpeq : rk(P :: R :: Pp :: Qp :: nil) = 3) by (apply LPRPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpQpMtmp : rk(P :: R :: Pp :: Qp :: nil) <= 3) by (solve_hyps_max HPRPpQpeq HPRPpQpM3).
	try assert(HPRPpalphaeq : rk(P :: R :: Pp :: alpha :: nil) = 3) by (apply LPRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpalphaMtmp : rk(P :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpalphaeq HPRPpalphaM3).
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hincl : incl (P :: R :: Pp :: nil) (list_inter (P :: R :: Pp :: Qp :: nil) (P :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: alpha :: nil) (P :: R :: Pp :: Qp :: P :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Qp :: P :: R :: Pp :: alpha :: nil) ((P :: R :: Pp :: Qp :: nil) ++ (P :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: R :: Pp :: Qp :: nil) (P :: R :: Pp :: alpha :: nil) (P :: R :: Pp :: nil) 3 3 3 HPRPpQpMtmp HPRPpalphaMtmp HPRPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPRPpQpalphaM : rk(P :: R :: Pp :: Qp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpalpham : rk(P :: R :: Pp :: Qp :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpalphaeq HPRPpQpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpOom3 : rk(P :: Pp :: Qp :: Oo :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Oo :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPPpQpOom4 : rk(P :: Pp :: Qp :: Oo :: nil) >= 4).
{
	try assert(HPRPpQpalphaeq : rk(P :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpQpalphaMtmp : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpQpalphaeq HPRPpQpalphaM3).
	try assert(HPRPpQpOoalphaeq : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) = 4) by (apply LPRPpQpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpQpOoalphamtmp : rk(P :: R :: Pp :: Qp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpQpOoalphaeq HPRPpQpOoalpham4).
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (list_inter (P :: Pp :: Qp :: Oo :: nil) (P :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: Oo :: alpha :: nil) (P :: Pp :: Qp :: Oo :: P :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: Oo :: P :: R :: Pp :: Qp :: alpha :: nil) ((P :: Pp :: Qp :: Oo :: nil) ++ (P :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpQpOoalphamtmp;try rewrite HT2 in HPRPpQpOoalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Qp :: Oo :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) (P :: Pp :: Qp :: nil) 4 3 3 HPRPpQpOoalphamtmp HPPpQpmtmp HPRPpQpalphaMtmp Hincl);apply HT.
}


assert(HPPpQpOoM : rk(P :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpOom : rk(P :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPPpQpOoeq HPPpQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPpRpOo *)
(* dans la couche 0 *)
Lemma LPQRPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpOo requis par la preuve de (?)PQRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpOo requis par la preuve de (?)PQRPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpOom3 : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpOom4 : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Oo :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpRpOoM : rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpOom : rk(P :: Q :: R :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpRpOoeq HPQRPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpOo requis par la preuve de (?)PQPpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpOo requis par la preuve de (?)PQPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpOom3 : rk(P :: Q :: Pp :: Rp :: Oo :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpRpOom4 : rk(P :: Q :: Pp :: Rp :: Oo :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpRpOoeq : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPQRPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpRpOomtmp : rk(P :: Q :: R :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpRpOoeq HPQRPpRpOom4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Oo :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpOomtmp;try rewrite HT2 in HPQRPpRpOomtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpRpOomtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpRpOoM : rk(P :: Q :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpOom : rk(P :: Q :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQPpRpOoeq HPQPpRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpOo *)
(* dans la couche 0 *)
Lemma LPQRQpRpOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpOoalpha requis par la preuve de (?)PQRQpRpOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpOoalpha requis par la preuve de (?)PQRQpRpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpRpOoalpham3 : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpRpOoalpham4 : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpRpOoalphaM : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpOoalpham : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpOoalphaeq HPQRQpRpOoalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpOo *)
(* dans la couche 0 *)
Lemma LPQRQpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpalpha requis par la preuve de (?)PQRQpRpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpalpha requis par la preuve de (?)PQRQpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpRpalpham3 : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRQpRpalphaM3 : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3).
{
	try assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 3) by (apply LPQRRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRRpMtmp : rk(P :: Q :: R :: Rp :: nil) <= 3) by (solve_hyps_max HPQRRpeq HPQRRpM3).
	try assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (P :: Q :: R :: Rp :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Rp :: P :: Q :: R :: Qp :: alpha :: nil) ((P :: Q :: R :: Rp :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (P :: Q :: R :: nil) 3 3 3 HPQRRpMtmp HPQRQpalphaMtmp HPQRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQRQpRpalphaM : rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpalpham : rk(P :: Q :: R :: Qp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpalphaeq HPQRQpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpOo requis par la preuve de (?)QQpRpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpOo requis par la preuve de (?)QQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpOom3 : rk(Q :: Qp :: Rp :: Oo :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Oo :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQQpRpOom4 : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4).
{
	try assert(HPQRQpRpalphaeq : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) = 3) by (apply LPQRQpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpRpalphaMtmp : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpRpalphaeq HPQRQpRpalphaM3).
	try assert(HPQRQpRpOoalphaeq : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) = 4) by (apply LPQRQpRpOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpRpOoalphamtmp : rk(P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpRpOoalphaeq HPQRQpRpOoalpham4).
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (list_inter (Q :: Qp :: Rp :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: Oo :: alpha :: nil) (Q :: Qp :: Rp :: Oo :: P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: Oo :: P :: Q :: R :: Qp :: Rp :: alpha :: nil) ((Q :: Qp :: Rp :: Oo :: nil) ++ (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpRpOoalphamtmp;try rewrite HT2 in HPQRQpRpOoalphamtmp.
	assert(HT := rule_2 (Q :: Qp :: Rp :: Oo :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (Q :: Qp :: Rp :: nil) 4 3 3 HPQRQpRpOoalphamtmp HQQpRpmtmp HPQRQpRpalphaMtmp Hincl);apply HT.
}


assert(HQQpRpOoM : rk(Q :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpOom : rk(Q :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpOoeq HQQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRRsOo : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Rs :: Oo ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRRsOoM : rk(R :: Rs :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HRRsOoeq HRRsOoM3).
assert(HRRsOom : rk(R :: Rs :: Oo ::  nil) >= 1) by (solve_hyps_min HRRsOoeq HRRsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Sc ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HScM : rk(Sc ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HSceq HScM1).
assert(HScm : rk(Sc ::  nil) >= 1) by (solve_hyps_min HSceq HScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpSc requis par la preuve de (?)PQPpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpSc requis par la preuve de (?)PQPpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpScm3 : rk(P :: Q :: Pp :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQPpScm4 : rk(P :: Q :: Pp :: Sc :: nil) >= 4).
{
	try assert(HPQRPpalphaeq : rk(P :: Q :: R :: Pp :: alpha :: nil) = 3) by (apply LPQRPpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpalphaMtmp : rk(P :: Q :: R :: Pp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRPpalphaeq HPQRPpalphaM3).
	try assert(HPQRPpScalphaeq : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) = 4) by (apply LPQRPpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpScalphamtmp : rk(P :: Q :: R :: Pp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPpScalphaeq HPQRPpScalpham4).
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (list_inter (P :: Q :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Sc :: alpha :: nil) (P :: Q :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Sc :: P :: Q :: R :: Pp :: alpha :: nil) ((P :: Q :: Pp :: Sc :: nil) ++ (P :: Q :: R :: Pp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpScalphamtmp;try rewrite HT2 in HPQRPpScalphamtmp.
	assert(HT := rule_2 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: R :: Pp :: alpha :: nil) (P :: Q :: Pp :: nil) 4 3 3 HPQRPpScalphamtmp HPQPpmtmp HPQRPpalphaMtmp Hincl);apply HT.
}


assert(HPQPpScM : rk(P :: Q :: Pp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpScm : rk(P :: Q :: Pp :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpSceq HPQPpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpSc *)
(* dans constructLemma(), requis par LPpQpPsSc *)
(* dans constructLemma(), requis par LPPpQpPsOoSc *)
(* dans constructLemma(), requis par LPQPpQpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpPsOoSc requis par la preuve de (?)PQRPpQpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpPsOoSc requis par la preuve de (?)PQRPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpPsOoScm3 : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpPsOoScm4 : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpQpPsOoScM : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpPsOoScm : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpQpPsOoSceq HPQRPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpPsOoSc requis par la preuve de (?)PQPpQpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpPsOoSc requis par la preuve de (?)PQPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpQpPsOoScm3 : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpQpPsOoScm4 : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpQpPsOoSceq : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpQpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpQpPsOoSceq HPQRPpQpPsOoScm4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpPsOoScmtmp;try rewrite HT2 in HPQRPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpQpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpQpPsOoScM : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpQpPsOoScm : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpQpPsOoSceq HPQPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoSc requis par la preuve de (?)PPpQpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoSc requis par la preuve de (?)PPpQpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScm3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPPpQpPsOoScm4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQPpQpOoeq : rk(P :: Q :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPQPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpQpOoMtmp : rk(P :: Q :: Pp :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpQpOoeq HPQPpQpOoM4).
	try assert(HPQPpQpPsOoSceq : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpQpPsOoScmtmp : rk(P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpQpPsOoSceq HPQPpQpPsOoScm4).
	try assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Qp :: Oo :: P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Qp :: Oo :: P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Qp :: Oo :: nil) ++ (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpPsOoScmtmp;try rewrite HT2 in HPQPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Pp :: Qp :: Oo :: nil) 4 4 4 HPQPpQpPsOoScmtmp HPPpQpOomtmp HPQPpQpOoMtmp Hincl); apply HT.
}


assert(HPPpQpPsOoScM : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsOoScm : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpQpPsOoSceq HPPpQpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpQpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsSc requis par la preuve de (?)PPpQpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsScm3 : rk(P :: Pp :: Qp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsSc requis par la preuve de (?)PpQpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPpQpPsScM3 : rk(Pp :: Qp :: Ps :: Sc :: nil) <= 3).
{
	try assert(HQpeq : rk(Qp :: nil) = 1) by (apply LQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: nil) (Qp :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Pp :: Ps :: Sc :: nil) ((Qp :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HQpMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HPpQpPsScm2 : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPPpQpPsScmtmp : rk(P :: Pp :: Qp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPPpQpPsSceq HPPpQpPsScm3).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Pp :: Qp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Sc :: nil) (P :: Ps :: Pp :: Qp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Pp :: Qp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Pp :: Qp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsScmtmp;try rewrite HT2 in HPPpQpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Pp :: Qp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPPpQpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}
try clear HPPpQpPsScM1. try clear HPPpQpPsScM2. try clear HPPpQpPsScM3. try clear HPPpQpPsScm4. try clear HPPpQpPsScm3. try clear HPPpQpPsScm2. try clear HPPpQpPsScm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsScm3 : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPPpQpPsOoSceq : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPPpQpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpPsOoScmtmp : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPPpQpPsOoSceq HPPpQpPsOoScm4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOoScmtmp;try rewrite HT2 in HPPpQpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPPpQpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}


assert(HPpQpPsScM : rk(Pp :: Qp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsScm : rk(Pp :: Qp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HPpQpPsSceq HPpQpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QpSc requis par la preuve de (?)QpSc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQpScm2 : rk(Qp :: Sc :: nil) >= 2).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPpQpPsSceq : rk(Pp :: Qp :: Ps :: Sc :: nil) = 3) by (apply LPpQpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpQpPsScmtmp : rk(Pp :: Qp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPpQpPsSceq HPpQpPsScm3).
	try assert(HSceq : rk(Sc :: nil) = 1) by (apply LSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HScmtmp : rk(Sc :: nil) >= 1) by (solve_hyps_min HSceq HScm1).
	assert(Hincl : incl (Sc :: nil) (list_inter (Qp :: Sc :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: nil) (Qp :: Sc :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Sc :: Pp :: Ps :: Sc :: nil) ((Qp :: Sc :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpQpPsScmtmp;try rewrite HT2 in HPpQpPsScmtmp.
	assert(HT := rule_2 (Qp :: Sc :: nil) (Pp :: Ps :: Sc :: nil) (Sc :: nil) 3 1 2 HPpQpPsScmtmp HScmtmp HPpPsScMtmp Hincl);apply HT.
}


assert(HQpScM : rk(Qp :: Sc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQpSceq HQpScM2).
assert(HQpScm : rk(Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HQpSceq HQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQRQpSc *)
(* dans la couche 0 *)
Lemma LPQRQpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpScalpha requis par la preuve de (?)PQRQpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpScalpha requis par la preuve de (?)PQRQpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpScalpham3 : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpScalpham4 : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQRSceq : rk(P :: Q :: R :: Sc :: nil) = 4) by (apply LPQRSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpScalphaM : rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpScalpham : rk(P :: Q :: R :: Qp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpScalphaeq HPQRQpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpSc requis par la preuve de (?)QRQpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpSc requis par la preuve de (?)QRQpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpScm3 : rk(Q :: R :: Qp :: Sc :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Sc :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQRQpScm4 : rk(Q :: R :: Qp :: Sc :: nil) >= 4).
{
	try assert(HPQRQpalphaeq : rk(P :: Q :: R :: Qp :: alpha :: nil) = 3) by (apply LPQRQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpalphaMtmp : rk(P :: Q :: R :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpalphaeq HPQRQpalphaM3).
	try assert(HPQRQpScalphaeq : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) = 4) by (apply LPQRQpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpScalphamtmp : rk(P :: Q :: R :: Qp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpScalphaeq HPQRQpScalpham4).
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (list_inter (Q :: R :: Qp :: Sc :: nil) (P :: Q :: R :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Sc :: alpha :: nil) (Q :: R :: Qp :: Sc :: P :: Q :: R :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: Qp :: Sc :: P :: Q :: R :: Qp :: alpha :: nil) ((Q :: R :: Qp :: Sc :: nil) ++ (P :: Q :: R :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpScalphamtmp;try rewrite HT2 in HPQRQpScalphamtmp.
	assert(HT := rule_2 (Q :: R :: Qp :: Sc :: nil) (P :: Q :: R :: Qp :: alpha :: nil) (Q :: R :: Qp :: nil) 4 3 3 HPQRQpScalphamtmp HQRQpmtmp HPQRQpalphaMtmp Hincl);apply HT.
}


assert(HQRQpScM : rk(Q :: R :: Qp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpScm : rk(Q :: R :: Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HQRQpSceq HQRQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpQpSc *)
(* dans la couche 0 *)
Lemma LPRPpQpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpScalpha requis par la preuve de (?)PRPpQpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpScalpha requis par la preuve de (?)PRPpQpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpScalpham3 : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpQpScalpham4 : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPRPpQpScalphaM : rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpScalpham : rk(P :: R :: Pp :: Qp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpQpScalphaeq HPRPpQpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpSc requis par la preuve de (?)PPpQpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpSc requis par la preuve de (?)PPpQpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpScm3 : rk(P :: Pp :: Qp :: Sc :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Sc :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPPpQpScm4 : rk(P :: Pp :: Qp :: Sc :: nil) >= 4).
{
	try assert(HPRPpQpalphaeq : rk(P :: R :: Pp :: Qp :: alpha :: nil) = 3) by (apply LPRPpQpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpQpalphaMtmp : rk(P :: R :: Pp :: Qp :: alpha :: nil) <= 3) by (solve_hyps_max HPRPpQpalphaeq HPRPpQpalphaM3).
	try assert(HPRPpQpScalphaeq : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) = 4) by (apply LPRPpQpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpQpScalphamtmp : rk(P :: R :: Pp :: Qp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpQpScalphaeq HPRPpQpScalpham4).
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (list_inter (P :: Pp :: Qp :: Sc :: nil) (P :: R :: Pp :: Qp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: Sc :: alpha :: nil) (P :: Pp :: Qp :: Sc :: P :: R :: Pp :: Qp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: Sc :: P :: R :: Pp :: Qp :: alpha :: nil) ((P :: Pp :: Qp :: Sc :: nil) ++ (P :: R :: Pp :: Qp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpQpScalphamtmp;try rewrite HT2 in HPRPpQpScalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Qp :: Sc :: nil) (P :: R :: Pp :: Qp :: alpha :: nil) (P :: Pp :: Qp :: nil) 4 3 3 HPRPpQpScalphamtmp HPPpQpmtmp HPRPpQpalphaMtmp Hincl);apply HT.
}


assert(HPPpQpScM : rk(P :: Pp :: Qp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpScm : rk(P :: Pp :: Qp :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpQpSceq HPPpQpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpSc *)
(* dans constructLemma(), requis par LPpRpPsSc *)
(* dans constructLemma(), requis par LPPpRpPsOoSc *)
(* dans constructLemma(), requis par LPQPpRpPsOoSc *)
(* dans la couche 0 *)
Lemma LPQRPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpPsOoSc requis par la preuve de (?)PQRPpRpPsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpPsOoSc requis par la preuve de (?)PQRPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpPsOoScm3 : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpPsOoScm4 : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpRpPsOoScM : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpPsOoScm : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpRpPsOoSceq HPQRPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpPsOoSc requis par la preuve de (?)PQPpRpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpPsOoSc requis par la preuve de (?)PQPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpPsOoScm3 : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Pp :: Oo ::   de rang : 4 et 4 *)
assert(HPQPpRpPsOoScm4 : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQRPpOoeq : rk(P :: Q :: R :: Pp :: Oo :: nil) = 4) by (apply LPQRPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpOoMtmp : rk(P :: Q :: R :: Pp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRPpOoeq HPQRPpOoM4).
	try assert(HPQRPpRpPsOoSceq : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQRPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPpRpPsOoScmtmp : rk(P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRPpRpPsOoSceq HPQRPpRpPsOoScm4).
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (list_inter (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Pp :: Oo :: P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: R :: Pp :: Oo :: nil) ++ (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpPsOoScmtmp;try rewrite HT2 in HPQRPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Pp :: Oo :: nil) (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Oo :: nil) 4 4 4 HPQRPpRpPsOoScmtmp HPQPpOomtmp HPQRPpOoMtmp Hincl); apply HT.
}


assert(HPQPpRpPsOoScM : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpPsOoScm : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQPpRpPsOoSceq HPQPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOoSc requis par la preuve de (?)PPpRpPsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOoSc requis par la preuve de (?)PPpRpPsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOoScm3 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Pp :: Rp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: Pp :: Rp :: Oo ::   de rang : 4 et 4 *)
assert(HPPpRpPsOoScm4 : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQPpRpOoeq : rk(P :: Q :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPQPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpOoMtmp : rk(P :: Q :: Pp :: Rp :: Oo :: nil) <= 4) by (solve_hyps_max HPQPpRpOoeq HPQPpRpOoM4).
	try assert(HPQPpRpPsOoSceq : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpPsOoScmtmp : rk(P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpRpPsOoSceq HPQPpRpPsOoScm4).
	try assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (list_inter (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Q :: Pp :: Rp :: Oo :: P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Pp :: Rp :: Oo :: P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) ((P :: Q :: Pp :: Rp :: Oo :: nil) ++ (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpPsOoScmtmp;try rewrite HT2 in HPQPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Pp :: Rp :: Oo :: nil) 4 4 4 HPQPpRpPsOoScmtmp HPPpRpOomtmp HPQPpRpOoMtmp Hincl); apply HT.
}


assert(HPPpRpPsOoScM : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsOoScm : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpRpPsOoSceq HPPpRpPsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsSc requis par la preuve de (?)PPpRpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsScm3 : rk(P :: Pp :: Rp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsSc requis par la preuve de (?)PpRpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPpRpPsScM3 : rk(Pp :: Rp :: Ps :: Sc :: nil) <= 3).
{
	try assert(HRpeq : rk(Rp :: nil) = 1) by (apply LRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: nil) (Rp :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Pp :: Ps :: Sc :: nil) ((Rp :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HRpMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HPpRpPsScm2 : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPPpRpPsScmtmp : rk(P :: Pp :: Rp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPPpRpPsSceq HPPpRpPsScm3).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Pp :: Rp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Sc :: nil) (P :: Ps :: Pp :: Rp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Pp :: Rp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Pp :: Rp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsScmtmp;try rewrite HT2 in HPPpRpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Pp :: Rp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPPpRpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}
try clear HPPpRpPsScM1. try clear HPPpRpPsScM2. try clear HPPpRpPsScM3. try clear HPPpRpPsScm4. try clear HPPpRpPsScm3. try clear HPPpRpPsScm2. try clear HPPpRpPsScm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsScm3 : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPPpRpPsOoSceq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPPpRpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpPsOoScmtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoSceq HPPpRpPsOoScm4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScmtmp;try rewrite HT2 in HPPpRpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPPpRpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}


assert(HPpRpPsScM : rk(Pp :: Rp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsScm : rk(Pp :: Rp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HPpRpPsSceq HPpRpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Rp :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RpSc requis par la preuve de (?)RpSc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HRpScm2 : rk(Rp :: Sc :: nil) >= 2).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPpRpPsSceq : rk(Pp :: Rp :: Ps :: Sc :: nil) = 3) by (apply LPpRpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpPsScmtmp : rk(Pp :: Rp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPpRpPsSceq HPpRpPsScm3).
	try assert(HSceq : rk(Sc :: nil) = 1) by (apply LSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HScmtmp : rk(Sc :: nil) >= 1) by (solve_hyps_min HSceq HScm1).
	assert(Hincl : incl (Sc :: nil) (list_inter (Rp :: Sc :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: nil) (Rp :: Sc :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Sc :: Pp :: Ps :: Sc :: nil) ((Rp :: Sc :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPpRpPsScmtmp;try rewrite HT2 in HPpRpPsScmtmp.
	assert(HT := rule_2 (Rp :: Sc :: nil) (Pp :: Ps :: Sc :: nil) (Sc :: nil) 3 1 2 HPpRpPsScmtmp HScmtmp HPpPsScMtmp Hincl);apply HT.
}
try clear HScM1. try clear HScM2. try clear HScM3. try clear HScm4. try clear HScm3. try clear HScm2. try clear HScm1. 

assert(HRpScM : rk(Rp :: Sc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRpSceq HRpScM2).
assert(HRpScm : rk(Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HRpSceq HRpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPpRpSc *)
(* dans la couche 0 *)
Lemma LPQPpRpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpRpScalpha requis par la preuve de (?)PQPpRpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpRpScalpha requis par la preuve de (?)PQPpRpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpScalpham3 : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpRpScalpham4 : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPQPpRpScalphaM : rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpRpScalpham : rk(P :: Q :: Pp :: Rp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpRpScalphaeq HPQPpRpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpSc requis par la preuve de (?)PPpRpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpSc requis par la preuve de (?)PPpRpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpScm3 : rk(P :: Pp :: Rp :: Sc :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Sc :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPPpRpScm4 : rk(P :: Pp :: Rp :: Sc :: nil) >= 4).
{
	try assert(HPQPpRpalphaeq : rk(P :: Q :: Pp :: Rp :: alpha :: nil) = 3) by (apply LPQPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpalphaMtmp : rk(P :: Q :: Pp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQPpRpalphaeq HPQPpRpalphaM3).
	try assert(HPQPpRpScalphaeq : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) = 4) by (apply LPQPpRpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpRpScalphamtmp : rk(P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpRpScalphaeq HPQPpRpScalpham4).
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (P :: Pp :: Rp :: Sc :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Rp :: Sc :: alpha :: nil) (P :: Pp :: Rp :: Sc :: P :: Q :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: Sc :: P :: Q :: Pp :: Rp :: alpha :: nil) ((P :: Pp :: Rp :: Sc :: nil) ++ (P :: Q :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpRpScalphamtmp;try rewrite HT2 in HPQPpRpScalphamtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: Sc :: nil) (P :: Q :: Pp :: Rp :: alpha :: nil) (P :: Pp :: Rp :: nil) 4 3 3 HPQPpRpScalphamtmp HPPpRpmtmp HPQPpRpalphaMtmp Hincl);apply HT.
}


assert(HPPpRpScM : rk(P :: Pp :: Rp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpScm : rk(P :: Pp :: Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HPPpRpSceq HPPpRpScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpSc *)
(* dans la couche 0 *)
Lemma LPQRQpRpScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpRpScalpha requis par la preuve de (?)PQRQpRpScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpRpScalpha requis par la preuve de (?)PQRQpRpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpRpScalpham3 : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpRpScalpham4 : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQRSceq : rk(P :: Q :: R :: Sc :: nil) = 4) by (apply LPQRSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRScmtmp : rk(P :: Q :: R :: Sc :: nil) >= 4) by (solve_hyps_min HPQRSceq HPQRScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) 4 4 HPQRScmtmp Hcomp Hincl);apply HT.
}
try clear HPQRScM1. try clear HPQRScM2. try clear HPQRScM3. try clear HPQRScm4. try clear HPQRScm3. try clear HPQRScm2. try clear HPQRScm1. 

assert(HPQRQpRpScalphaM : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpRpScalpham : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRQpRpScalphaeq HPQRQpRpScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpSc requis par la preuve de (?)QQpRpSc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpSc requis par la preuve de (?)QQpRpSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpScm3 : rk(Q :: Qp :: Rp :: Sc :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Sc :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQQpRpScm4 : rk(Q :: Qp :: Rp :: Sc :: nil) >= 4).
{
	try assert(HPQRQpRpalphaeq : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) = 3) by (apply LPQRQpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpRpalphaMtmp : rk(P :: Q :: R :: Qp :: Rp :: alpha :: nil) <= 3) by (solve_hyps_max HPQRQpRpalphaeq HPQRQpRpalphaM3).
	try assert(HPQRQpRpScalphaeq : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) = 4) by (apply LPQRQpRpScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpRpScalphamtmp : rk(P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQpRpScalphaeq HPQRQpRpScalpham4).
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (list_inter (Q :: Qp :: Rp :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Rp :: Sc :: alpha :: nil) (Q :: Qp :: Rp :: Sc :: P :: Q :: R :: Qp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: Sc :: P :: Q :: R :: Qp :: Rp :: alpha :: nil) ((Q :: Qp :: Rp :: Sc :: nil) ++ (P :: Q :: R :: Qp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpRpScalphamtmp;try rewrite HT2 in HPQRQpRpScalphamtmp.
	assert(HT := rule_2 (Q :: Qp :: Rp :: Sc :: nil) (P :: Q :: R :: Qp :: Rp :: alpha :: nil) (Q :: Qp :: Rp :: nil) 4 3 3 HPQRQpRpScalphamtmp HQQpRpmtmp HPQRQpRpalphaMtmp Hincl);apply HT.
}


assert(HQQpRpScM : rk(Q :: Qp :: Rp :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpScm : rk(Q :: Qp :: Rp :: Sc ::  nil) >= 1) by (solve_hyps_min HQQpRpSceq HQQpRpScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpPsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Pp :: Ps :: Sc ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsSc requis par la preuve de (?)PQPpPsSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScm3 : rk(P :: Q :: Pp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PPs requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpPsSc requis par la preuve de (?)QPpPsSc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HQPpPsScM3 : rk(Q :: Pp :: Ps :: Sc :: nil) <= 3).
{
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Ps :: Sc :: nil) (Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Ps :: Sc :: nil) ((Q :: nil) ++ (Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (Pp :: Ps :: Sc :: nil) (nil) 1 2 0 HQMtmp HPpPsScMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc ::  de rang :  3 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps ::   de rang : 1 et 2 *)
assert(HQPpPsScm2 : rk(Q :: Pp :: Ps :: Sc :: nil) >= 2).
{
	assert(HPPsMtmp : rk(P :: Ps :: nil) <= 2) by (solve_hyps_max HPPseq HPPsM2).
	assert(HPQPpPsScmtmp : rk(P :: Q :: Pp :: Ps :: Sc :: nil) >= 3) by (solve_hyps_min HPQPpPsSceq HPQPpPsScm3).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: nil) (Q :: Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Q :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: nil) ++ (Q :: Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScmtmp;try rewrite HT2 in HPQPpPsScmtmp.
	assert(HT := rule_4 (P :: Ps :: nil) (Q :: Pp :: Ps :: Sc :: nil) (Ps :: nil) 3 1 2 HPQPpPsScmtmp HPsmtmp HPPsMtmp Hincl); apply HT.
}
try clear HPQPpPsScM1. try clear HPQPpPsScM2. try clear HPQPpPsScM3. try clear HPQPpPsScm4. try clear HPQPpPsScm3. try clear HPQPpPsScm2. try clear HPQPpPsScm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HQPpPsScm3 : rk(Q :: Pp :: Ps :: Sc :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPQPpPsOoSceq : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) = 4) by (apply LPQPpPsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpPsOoScmtmp : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpPsOoSceq HPQPpPsOoScm4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Q :: Pp :: Ps :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Oo :: Sc :: nil) (P :: Ps :: Oo :: Q :: Pp :: Ps :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Q :: Pp :: Ps :: Sc :: nil) ((P :: Ps :: Oo :: nil) ++ (Q :: Pp :: Ps :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOoScmtmp;try rewrite HT2 in HPQPpPsOoScmtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Q :: Pp :: Ps :: Sc :: nil) (Ps :: nil) 4 1 2 HPQPpPsOoScmtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}


assert(HQPpPsScM : rk(Q :: Pp :: Ps :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpPsScm : rk(Q :: Pp :: Ps :: Sc ::  nil) >= 1) by (solve_hyps_min HQPpPsSceq HQPpPsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpRsSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HRpRsScM : rk(Rp :: Rs :: Sc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HRpRsSceq HRpRsScM3).
assert(HRpRsScm : rk(Rp :: Rs :: Sc ::  nil) >= 1) by (solve_hyps_min HRpRsSceq HRpRsScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpOoSc requis par la preuve de (?)PQRPpOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoScm3 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpOoScm4 : rk(P :: Q :: R :: Pp :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpOoScM : rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpOoScm : rk(P :: Q :: R :: Pp :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRPpOoSceq HPQRPpOoScm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQQpPsQsOoSc *)
(* dans la couche 0 *)
Lemma LPQRQpPsQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpPsQsOoSc requis par la preuve de (?)PQRQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpPsQsOoScm3 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQpPsQsOoScm4 : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRQpPsQsOoScM : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpPsQsOoScm : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQQpPsQsOoSc : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpPsQsOoSc requis par la preuve de (?)PQQpPsQsOoSc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpPsQsOoScm3 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc ::  de rang :  4 et 4 	 AiB : P :: Q :: Qp :: Oo ::  de rang :  4 et 4 	 A : P :: Q :: R :: Qp :: Oo ::   de rang : 4 et 4 *)
assert(HPQQpPsQsOoScm4 : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4).
{
	try assert(HPQRQpOoeq : rk(P :: Q :: R :: Qp :: Oo :: nil) = 4) by (apply LPQRQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpOoMtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) <= 4) by (solve_hyps_max HPQRQpOoeq HPQRQpOoM4).
	try assert(HPQRQpPsQsOoSceq : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) = 4) by (apply LPQRQpPsQsOoSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQpPsQsOoScmtmp : rk(P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) >= 4) by (solve_hyps_min HPQRQpPsQsOoSceq HPQRQpPsQsOoScm4).
	try assert(HPQQpOoeq : rk(P :: Q :: Qp :: Oo :: nil) = 4) by (apply LPQQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpOomtmp : rk(P :: Q :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQQpOoeq HPQQpOom4).
	assert(Hincl : incl (P :: Q :: Qp :: Oo :: nil) (list_inter (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Qp :: Oo :: P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) ((P :: Q :: R :: Qp :: Oo :: nil) ++ (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpPsQsOoScmtmp;try rewrite HT2 in HPQRQpPsQsOoScmtmp.
	assert(HT := rule_4 (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc :: nil) (P :: Q :: Qp :: Oo :: nil) 4 4 4 HPQRQpPsQsOoScmtmp HPQQpOomtmp HPQRQpOoMtmp Hincl); apply HT.
}


assert(HPQQpPsQsOoScM : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQQpPsQsOoScm : rk(P :: Q :: Qp :: Ps :: Qs :: Oo :: Sc ::  nil) >= 1) by (solve_hyps_min HPQQpPsQsOoSceq HPQQpPsQsOoScm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQalpha requis par la preuve de (?)PQalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalpha requis par la preuve de (?)PQalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalpha requis par la preuve de (?)PQPpOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpOpalpham3 : rk(P :: Q :: Pp :: Op :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PQalpha requis par la preuve de (?)PQalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalpham2 : rk(P :: Q :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphamtmp : rk(P :: Q :: Pp :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpOpalphaeq HPQPpOpalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphamtmp;try rewrite HT2 in HPQPpOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: nil) (P :: nil) 3 1 2 HPQPpOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpOpalphaM1. try clear HPQPpOpalphaM2. try clear HPQPpOpalphaM3. try clear HPQPpOpalpham4. try clear HPQPpOpalpham3. try clear HPQPpOpalpham2. try clear HPQPpOpalpham1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQalpham3 : rk(P :: Q :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRalphaeq : rk(P :: Q :: R :: alpha :: nil) = 3) by (apply LPQRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRalphamtmp : rk(P :: Q :: R :: alpha :: nil) >= 3) by (solve_hyps_min HPQRalphaeq HPQRalpham3).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: Q :: alpha :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: nil) (P :: Q :: alpha :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: alpha :: P :: R :: alpha :: nil) ((P :: Q :: alpha :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRalphamtmp;try rewrite HT2 in HPQRalphamtmp.
	assert(HT := rule_2 (P :: Q :: alpha :: nil) (P :: R :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPQRalphamtmp HPalphamtmp HPRalphaMtmp Hincl);apply HT.
}


assert(HPQalphaM : rk(P :: Q :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQalphaeq HPQalphaM3).
assert(HPQalpham : rk(P :: Q :: alpha ::  nil) >= 1) by (solve_hyps_min HPQalphaeq HPQalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LRalpha *)
(* dans la couche 0 *)
Lemma LRPpRpalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: Pp :: Rp :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpRpalpha requis par la preuve de (?)PRPpRpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpRpalpham3 : rk(P :: R :: Pp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Rp :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PRp requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RPpRpalpha requis par la preuve de (?)RPpRpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HRPpRpalphaM3 : rk(R :: Pp :: Rp :: alpha :: nil) <= 3).
{
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	try assert(HPpRpalphaeq : rk(Pp :: Rp :: alpha :: nil) = 2) by (apply LPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (R :: Pp :: Rp :: alpha :: nil) (R :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Pp :: Rp :: alpha :: nil) ((R :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (Pp :: Rp :: alpha :: nil) (nil) 1 2 0 HRMtmp HPpRpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: R :: Pp :: Rp :: alpha ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: Rp ::   de rang : 1 et 2 *)
assert(HRPpRpalpham2 : rk(R :: Pp :: Rp :: alpha :: nil) >= 2).
{
	assert(HPRpMtmp : rk(P :: Rp :: nil) <= 2) by (solve_hyps_max HPRpeq HPRpM2).
	assert(HPRPpRpalphamtmp : rk(P :: R :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpRpalphaeq HPRPpRpalpham3).
	try assert(HRpeq : rk(Rp :: nil) = 1) by (apply LRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Rp :: alpha :: nil) (P :: Rp :: R :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Rp :: R :: Pp :: Rp :: alpha :: nil) ((P :: Rp :: nil) ++ (R :: Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpRpalphamtmp;try rewrite HT2 in HPRPpRpalphamtmp.
	assert(HT := rule_4 (P :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil) (Rp :: nil) 3 1 2 HPRPpRpalphamtmp HRpmtmp HPRpMtmp Hincl); apply HT.
}
try clear HPRPpRpalphaM1. try clear HPRPpRpalphaM2. try clear HPRPpRpalphaM3. try clear HPRPpRpalpham4. try clear HPRPpRpalpham3. try clear HPRPpRpalpham2. try clear HPRPpRpalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HRPpRpalpham3 : rk(R :: Pp :: Rp :: alpha :: nil) >= 3).
{
	try assert(HRPpRpeq : rk(R :: Pp :: Rp :: nil) = 3) by (apply LRPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRPpRpmtmp : rk(R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HRPpRpeq HRPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (R :: Pp :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (R :: Pp :: Rp :: nil) (R :: Pp :: Rp :: alpha :: nil) 3 3 HRPpRpmtmp Hcomp Hincl);apply HT.
}
try clear HRPpRpM1. try clear HRPpRpM2. try clear HRPpRpM3. try clear HRPpRpm4. try clear HRPpRpm3. try clear HRPpRpm2. try clear HRPpRpm1. 

assert(HRPpRpalphaM : rk(R :: Pp :: Rp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRPpRpalpham : rk(R :: Pp :: Rp :: alpha ::  nil) >= 1) by (solve_hyps_min HRPpRpalphaeq HRPpRpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(R :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ralpha requis par la preuve de (?)Ralpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HRalpham2 : rk(R :: alpha :: nil) >= 2).
{
	try assert(HPpRpalphaeq : rk(Pp :: Rp :: alpha :: nil) = 2) by (apply LPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	try assert(HRPpRpalphaeq : rk(R :: Pp :: Rp :: alpha :: nil) = 3) by (apply LRPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRPpRpalphamtmp : rk(R :: Pp :: Rp :: alpha :: nil) >= 3) by (solve_hyps_min HRPpRpalphaeq HRPpRpalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (R :: alpha :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (R :: Pp :: Rp :: alpha :: nil) (R :: alpha :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: alpha :: Pp :: Rp :: alpha :: nil) ((R :: alpha :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HRPpRpalphamtmp;try rewrite HT2 in HRPpRpalphamtmp.
	assert(HT := rule_2 (R :: alpha :: nil) (Pp :: Rp :: alpha :: nil) (alpha :: nil) 3 1 2 HRPpRpalphamtmp Halphamtmp HPpRpalphaMtmp Hincl);apply HT.
}


assert(HRalphaM : rk(R :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRalphaeq HRalphaM2).
assert(HRalpham : rk(R :: alpha ::  nil) >= 1) by (solve_hyps_min HRalphaeq HRalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPsalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPsalpha requis par la preuve de (?)PPsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Q :: Pp :: Ps :: Sc ::   de rang : 3 et 3 *)
assert(HPPsalpham2 : rk(P :: Ps :: alpha :: nil) >= 2).
{
	try assert(HQPpPsSceq : rk(Q :: Pp :: Ps :: Sc :: nil) = 3) by (apply LQPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQPpPsScMtmp : rk(Q :: Pp :: Ps :: Sc :: nil) <= 3) by (solve_hyps_max HQPpPsSceq HQPpPsScM3).
	assert(HPQPpPsScalphamtmp : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) (Q :: Pp :: Ps :: Sc :: P :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Ps :: Sc :: P :: Ps :: alpha :: nil) ((Q :: Pp :: Ps :: Sc :: nil) ++ (P :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScalphamtmp;try rewrite HT2 in HPQPpPsScalphamtmp.
	assert(HT := rule_4 (Q :: Pp :: Ps :: Sc :: nil) (P :: Ps :: alpha :: nil) (Ps :: nil) 4 1 3 HPQPpPsScalphamtmp HPsmtmp HQPpPsScMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: alpha ::  de rang :  3 et 3 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsalpham3 : rk(P :: Ps :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRPsalphaeq : rk(P :: R :: Ps :: alpha :: nil) = 3) by (apply LPRPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPsalphamtmp : rk(P :: R :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsalphaeq HPRPsalpham3).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsalphamtmp;try rewrite HT2 in HPRPsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPPsalphaM : rk(P :: Ps :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPPsalphaeq HPPsalphaM3).
assert(HPPsalpham : rk(P :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsalphaeq HPPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQPsalpha *)
(* dans constructLemma(), requis par LPQPsOoalpha *)
(* dans la couche 0 *)
Lemma LPQRPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsOoalpha requis par la preuve de (?)PQRPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsOoalpha requis par la preuve de (?)PQRPsOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsOoalpham3 : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsOoalpham4 : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Oo :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsOoalphaM : rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsOoalpham : rk(P :: Q :: R :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPsOoalphaeq HPQRPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpOoalpha requis par la preuve de (?)PQPpPsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOpOoalpham3 : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOoalpha requis par la preuve de (?)PQPsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsOoalpham2 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpOoalphamtmp : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsOpOoalphaeq HPQPpPsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpOoalphamtmp;try rewrite HT2 in HPQPpPsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsOpOoalphaM1. try clear HPQPpPsOpOoalphaM2. try clear HPQPpPsOpOoalphaM3. try clear HPQPpPsOpOoalpham4. try clear HPQPpPsOpOoalpham3. try clear HPQPpPsOpOoalpham2. try clear HPQPpPsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOoalpham3 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsOoalpham4 : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsOoalphaeq : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) = 4) by (apply LPQRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsOoalphamtmp : rk(P :: Q :: R :: Ps :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRPsOoalphaeq HPQRPsOoalpham4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Oo :: alpha :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Oo :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsOoalphamtmp;try rewrite HT2 in HPQRPsOoalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsOoalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsOoalphaM : rk(P :: Q :: Ps :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOoalpham : rk(P :: Q :: Ps :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsOoalphaeq HPQPsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpalpha requis par la preuve de (?)PQPpPsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOpalpham3 : rk(P :: Q :: Pp :: Ps :: Op :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsalpha requis par la preuve de (?)PQPsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsalpham2 : rk(P :: Q :: Ps :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpalphamtmp : rk(P :: Q :: Pp :: Ps :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPQPpPsOpalphaeq HPQPpPsOpalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpalphamtmp;try rewrite HT2 in HPQPpPsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: alpha :: nil) (P :: nil) 3 1 2 HPQPpPsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsOpalphaM1. try clear HPQPpPsOpalphaM2. try clear HPQPpPsOpalphaM3. try clear HPQPpPsOpalpham4. try clear HPQPpPsOpalpham3. try clear HPQPpPsOpalpham2. try clear HPQPpPsOpalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsalpham3 : rk(P :: Q :: Ps :: alpha :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsScalphamtmp : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsScalphamtmp;try rewrite HT2 in HPQPpPsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: alpha :: nil) (Ps :: nil) 4 1 2 HPQPpPsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPQPsalpham4 : rk(P :: Q :: Ps :: alpha :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsOoalphaeq : rk(P :: Q :: Ps :: Oo :: alpha :: nil) = 4) by (apply LPQPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsOoalphamtmp : rk(P :: Q :: Ps :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsOoalphaeq HPQPsOoalpham4).
	try assert(HPPsalphaeq : rk(P :: Ps :: alpha :: nil) = 3) by (apply LPPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsalphamtmp : rk(P :: Ps :: alpha :: nil) >= 3) by (solve_hyps_min HPPsalphaeq HPPsalpham3).
	assert(Hincl : incl (P :: Ps :: alpha :: nil) (list_inter (P :: Q :: Ps :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: alpha :: nil) (P :: Q :: Ps :: alpha :: P :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: Ps :: alpha :: P :: Ps :: Oo :: alpha :: nil) ((P :: Q :: Ps :: alpha :: nil) ++ (P :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsOoalphamtmp;try rewrite HT2 in HPQPsOoalphamtmp.
	assert(HT := rule_2 (P :: Q :: Ps :: alpha :: nil) (P :: Ps :: Oo :: alpha :: nil) (P :: Ps :: alpha :: nil) 4 3 3 HPQPsOoalphamtmp HPPsalphamtmp HPPsOoalphaMtmp Hincl);apply HT.
}


assert(HPQPsalphaM : rk(P :: Q :: Ps :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsalpham : rk(P :: Q :: Ps :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPsalphaeq HPQPsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsalpha *)
(* dans la couche 0 *)
Lemma LPRQsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Qs :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQsalpha requis par la preuve de (?)PQRQsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRQsalpham3 : rk(P :: Q :: R :: Qs :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qs :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QQs requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRQsalpha requis par la preuve de (?)PRQsalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPRQsalphaM3 : rk(P :: R :: Qs :: alpha :: nil) <= 3).
{
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsMtmp : rk(Qs :: nil) <= 1) by (solve_hyps_max HQseq HQsM1).
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qs :: nil) (P :: R :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Qs :: alpha :: nil) (Qs :: P :: R :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qs :: P :: R :: alpha :: nil) ((Qs :: nil) ++ (P :: R :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qs :: nil) (P :: R :: alpha :: nil) (nil) 1 2 0 HQsMtmp HPRalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: alpha ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs ::   de rang : 1 et 2 *)
assert(HPRQsalpham2 : rk(P :: R :: Qs :: alpha :: nil) >= 2).
{
	assert(HQQsMtmp : rk(Q :: Qs :: nil) <= 2) by (solve_hyps_max HQQseq HQQsM2).
	assert(HPQRQsalphamtmp : rk(P :: Q :: R :: Qs :: alpha :: nil) >= 3) by (solve_hyps_min HPQRQsalphaeq HPQRQsalpham3).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: nil) (P :: R :: Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: alpha :: nil) (Q :: Qs :: P :: R :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: P :: R :: Qs :: alpha :: nil) ((Q :: Qs :: nil) ++ (P :: R :: Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsalphamtmp;try rewrite HT2 in HPQRQsalphamtmp.
	assert(HT := rule_4 (Q :: Qs :: nil) (P :: R :: Qs :: alpha :: nil) (Qs :: nil) 3 1 2 HPQRQsalphamtmp HQsmtmp HQQsMtmp Hincl); apply HT.
}
try clear HQQsM1. try clear HQQsM2. try clear HQQsM3. try clear HQQsm4. try clear HQQsm3. try clear HQQsm2. try clear HQQsm1. try clear HPQRQsalphaM1. try clear HPQRQsalphaM2. try clear HPQRQsalphaM3. try clear HPQRQsalpham4. try clear HPQRQsalpham3. try clear HPQRQsalpham2. try clear HPQRQsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qs :: Oo :: alpha ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRQsalpham3 : rk(P :: R :: Qs :: alpha :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	try assert(HPQRQsOoalphaeq : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) = 4) by (apply LPQRQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRQsOoalphamtmp : rk(P :: Q :: R :: Qs :: Oo :: alpha :: nil) >= 4) by (solve_hyps_min HPQRQsOoalphaeq HPQRQsOoalpham4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qs :: Oo :: alpha :: nil) (Q :: Qs :: Oo :: P :: R :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Qs :: alpha :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQsOoalphamtmp;try rewrite HT2 in HPQRQsOoalphamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Qs :: alpha :: nil) (Qs :: nil) 4 1 2 HPQRQsOoalphamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}


assert(HPRQsalphaM : rk(P :: R :: Qs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRQsalpham : rk(P :: R :: Qs :: alpha ::  nil) >= 1) by (solve_hyps_min HPRQsalphaeq HPRQsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qs :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Qsalpha requis par la preuve de (?)Qsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: R :: Qs :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQsalpham2 : rk(Qs :: alpha :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPRQsalphaeq : rk(P :: R :: Qs :: alpha :: nil) = 3) by (apply LPRQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRQsalphamtmp : rk(P :: R :: Qs :: alpha :: nil) >= 3) by (solve_hyps_min HPRQsalphaeq HPRQsalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Qs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Qs :: alpha :: nil) (P :: R :: alpha :: Qs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Qs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Qs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRQsalphamtmp;try rewrite HT2 in HPRQsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Qs :: alpha :: nil) (alpha :: nil) 3 1 2 HPRQsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HQsalphaM : rk(Qs :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQsalphaeq HQsalphaM2).
assert(HQsalpham : rk(Qs :: alpha ::  nil) >= 1) by (solve_hyps_min HQsalphaeq HQsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans constructLemma(), requis par LPPsRsalpha *)
(* dans la couche 0 *)
Lemma LPRPsRsOoalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPpPsRsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsOoalpham2 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpOoalphaeq HPRPpPsRsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpOoalphamtmp;try rewrite HT2 in HPRPpPsRsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsRsOpOoalphaM1. try clear HPRPpPsRsOpOoalphaM2. try clear HPRPpPsRsOpOoalphaM3. try clear HPRPpPsRsOpOoalpham4. try clear HPRPpPsRsOpOoalpham3. try clear HPRPpPsRsOpOoalpham2. try clear HPRPpPsRsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPsRsOoalpham3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPROoeq : rk(P :: R :: Oo :: nil) = 3) by (apply LPROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPRPsRsOoalphaM3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) <= 3).
{
	try assert(HRRsOoeq : rk(R :: Rs :: Oo :: nil) = 2) by (apply LRRsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	try assert(HPRPsOoalphaeq : rk(P :: R :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPRPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPsOoalphaMtmp : rk(P :: R :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPRPsOoalphaeq HPRPsOoalphaM3).
	try assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HROomtmp : rk(R :: Oo :: nil) >= 2) by (solve_hyps_min HROoeq HROom2).
	assert(Hincl : incl (R :: Oo :: nil) (list_inter (R :: Rs :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (R :: Rs :: Oo :: P :: R :: Ps :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: P :: R :: Ps :: Oo :: alpha :: nil) ((R :: Rs :: Oo :: nil) ++ (P :: R :: Ps :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: Rs :: Oo :: nil) (P :: R :: Ps :: Oo :: alpha :: nil) (R :: Oo :: nil) 2 3 2 HRRsOoMtmp HPRPsOoalphaMtmp HROomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPRPsRsOoalphaM : rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPsRsOoalpham : rk(P :: R :: Ps :: Rs :: Oo :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPsRsOoalphaeq HPRPsRsOoalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsRsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Rs :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPpPsRsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsOpalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham2 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpalphaeq HPRPpPsRsOpalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpalphamtmp;try rewrite HT2 in HPRPpPsRsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsRsOpalphaM1. try clear HPRPpPsRsOpalphaM2. try clear HPRPpPsRsOpalphaM3. try clear HPRPpPsRsOpalpham4. try clear HPRPpPsRsOpalpham3. try clear HPRPpPsRsOpalpham2. try clear HPRPpPsRsOpalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham3 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPRPpPsRsScalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsScalphamtmp;try rewrite HT2 in HPRPpPsRsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsRsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}
try clear HPRPpPsRsScalphaM1. try clear HPRPpPsRsScalphaM2. try clear HPRPpPsRsScalphaM3. try clear HPRPpPsRsScalpham4. try clear HPRPpPsRsScalpham3. try clear HPRPpPsRsScalpham2. try clear HPRPpPsRsScalpham1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpOoalpha requis par la preuve de (?)PRPpPsRsOpOoalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsOpOoalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsOoalpha requis par la preuve de (?)PRPsRsOoalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsOoalpham2 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpOoalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpOoalphaeq HPRPpPsRsOpOoalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: Oo :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: Oo :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: Oo :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpOoalphamtmp;try rewrite HT2 in HPRPpPsRsOpOoalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpOoalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsRsOpOoalphaM1. try clear HPRPpPsRsOpOoalphaM2. try clear HPRPpPsRsOpOoalphaM3. try clear HPRPpPsRsOpOoalpham4. try clear HPRPpPsRsOpOoalpham3. try clear HPRPpPsRsOpOoalpham2. try clear HPRPpPsRsOpOoalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPsRsOoalpham3 : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3).
{
	try assert(HPROoeq : rk(P :: R :: Oo :: nil) = 3) by (apply LPROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPROomtmp : rk(P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HPROoeq HPROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Oo :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsRsalpha requis par la preuve de (?)PPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: Oo :: alpha ::  de rang :  3 et 4 	 AiB : Rs ::  de rang :  1 et 1 	 A : R :: Rs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsRsalpham2 : rk(P :: Ps :: Rs :: alpha :: nil) >= 2).
{
	try assert(HRRsOoeq : rk(R :: Rs :: Oo :: nil) = 2) by (apply LRRsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HPRPsRsOoalphamtmp : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsOoalphaeq HPRPsRsOoalpham3).
	try assert(HRseq : rk(Rs :: nil) = 1) by (apply LRs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (R :: Rs :: Oo :: nil) (P :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) (R :: Rs :: Oo :: P :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: P :: Ps :: Rs :: alpha :: nil) ((R :: Rs :: Oo :: nil) ++ (P :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsOoalphamtmp;try rewrite HT2 in HPRPsRsOoalphamtmp.
	assert(HT := rule_4 (R :: Rs :: Oo :: nil) (P :: Ps :: Rs :: alpha :: nil) (Rs :: nil) 3 1 2 HPRPsRsOoalphamtmp HRsmtmp HRRsOoMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: alpha ::  de rang :  3 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsRsalpham3 : rk(P :: Ps :: Rs :: alpha :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsRsalphamtmp : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsalphaeq HPRPsRsalpham3).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: alpha :: nil) (P :: R :: alpha :: P :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Rs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsalphamtmp;try rewrite HT2 in HPRPsRsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Rs :: alpha :: nil) (P :: alpha :: nil) 3 2 2 HPRPsRsalphamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPsRsalphaM3 : rk(P :: Ps :: Rs :: alpha :: nil) <= 3).
{
	try assert(HPRPsRsOoalphaeq : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) = 3) by (apply LPRPsRsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPsRsOoalphaMtmp : rk(P :: R :: Ps :: Rs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPRPsRsOoalphaeq HPRPsRsOoalphaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Ps :: Rs :: alpha :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Ps :: Rs :: alpha :: nil) (P :: R :: Ps :: Rs :: Oo :: alpha :: nil) 3 3 HPRPsRsOoalphaMtmp Hcomp Hincl);apply HT.
}
try clear HPRPsRsOoalphaM1. try clear HPRPsRsOoalphaM2. try clear HPRPsRsOoalphaM3. try clear HPRPsRsOoalpham4. try clear HPRPsRsOoalpham3. try clear HPRPsRsOoalpham2. try clear HPRPsRsOoalpham1. 

assert(HPPsRsalphaM : rk(P :: Ps :: Rs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsRsalpham : rk(P :: Ps :: Rs :: alpha ::  nil) >= 1) by (solve_hyps_min HPPsRsalphaeq HPPsRsalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans constructLemma(), requis par LPpRpPsRsScalpha *)
(* dans la couche 0 *)
Lemma LPpRpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsOpScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsOpScalpha requis par la preuve de (?)PPpRpPsOpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsOpScalpham3 : rk(P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsScalpha requis par la preuve de (?)PpRpPsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsScalpham2 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsOpScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsOpScalphaeq HPPpRpPsOpScalpham3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Op :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOpScalphamtmp;try rewrite HT2 in HPPpRpPsOpScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsOpScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPPpRpPsOpScalphaM1. try clear HPPpRpPsOpScalphaM2. try clear HPPpRpPsOpScalphaM3. try clear HPPpRpPsOpScalpham4. try clear HPPpRpPsOpScalpham3. try clear HPPpRpPsOpScalpham2. try clear HPPpRpPsOpScalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsScalpham3 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPPpRpPsOoScalphaeq : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsOoScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpPsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsOoScalphaeq HPPpRpPsOoScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsOoScalphamtmp;try rewrite HT2 in HPPpRpPsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Ps :: nil) 4 1 2 HPPpRpPsOoScalphamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPpRpPsScalphaM3 : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) <= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPpRpalphaeq : rk(Pp :: Rp :: alpha :: nil) = 2) by (apply LPpRpalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpalphaMtmp : rk(Pp :: Rp :: alpha :: nil) <= 2) by (solve_hyps_max HPpRpalphaeq HPpRpalphaM2).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (Pp :: Rp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: Pp :: Rp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: Pp :: Rp :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (Pp :: Rp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (Pp :: Rp :: alpha :: nil) (Pp :: nil) 2 2 1 HPpPsScMtmp HPpRpalphaMtmp HPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPpRpPsScalphaM : rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsScalpham : rk(Pp :: Rp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsScalphaeq HPpRpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpRpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOpScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOpScalpha requis par la preuve de (?)PPpRpPsRsOpScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOpScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpRpPsRsScalpha requis par la preuve de (?)PpRpPsRsScalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpRpPsRsScalpham2 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpRpPsRsOpScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) >= 3) by (solve_hyps_min HPPpRpPsRsOpScalphaeq HPPpRpPsRsOpScalpham3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Op :: Sc :: alpha :: nil) (P :: Pp :: Op :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsOpScalphamtmp;try rewrite HT2 in HPPpRpPsRsOpScalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: nil) 3 1 2 HPPpRpPsRsOpScalphamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPPpRpPsRsOpScalphaM1. try clear HPPpRpPsRsOpScalphaM2. try clear HPPpRpPsRsOpScalphaM3. try clear HPPpRpPsRsOpScalpham4. try clear HPPpRpPsRsOpScalpham3. try clear HPPpRpPsRsOpScalpham2. try clear HPPpRpPsRsOpScalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpRpPsRsScalpham3 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpRpPsRsOoScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsRsOoScalphaeq HPPpRpPsRsOoScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsOoScalphamtmp;try rewrite HT2 in HPPpRpPsRsOoScalphamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Ps :: nil) 4 1 2 HPPpRpPsRsOoScalphamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}
try clear HPPpRpPsRsOoScalphaM1. try clear HPPpRpPsRsOoScalphaM2. try clear HPPpRpPsRsOoScalphaM3. try clear HPPpRpPsRsOoScalpham4. try clear HPPpRpPsRsOoScalpham3. try clear HPPpRpPsRsOoScalpham2. try clear HPPpRpPsRsOoScalpham1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPpRpPsRsScalphaM3 : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) <= 3).
{
	try assert(HRpRsSceq : rk(Rp :: Rs :: Sc :: nil) = 2) by (apply LRpRsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpRsScMtmp : rk(Rp :: Rs :: Sc :: nil) <= 2) by (solve_hyps_max HRpRsSceq HRpRsScM2).
	try assert(HPpRpPsScalphaeq : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) = 3) by (apply LPpRpPsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpPsScalphaMtmp : rk(Pp :: Rp :: Ps :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpRpPsScalphaeq HPpRpPsScalphaM3).
	try assert(HRpSceq : rk(Rp :: Sc :: nil) = 2) by (apply LRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpScmtmp : rk(Rp :: Sc :: nil) >= 2) by (solve_hyps_min HRpSceq HRpScm2).
	assert(Hincl : incl (Rp :: Sc :: nil) (list_inter (Rp :: Rs :: Sc :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Rp :: Rs :: Sc :: Pp :: Rp :: Ps :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Rs :: Sc :: Pp :: Rp :: Ps :: Sc :: alpha :: nil) ((Rp :: Rs :: Sc :: nil) ++ (Pp :: Rp :: Ps :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Rs :: Sc :: nil) (Pp :: Rp :: Ps :: Sc :: alpha :: nil) (Rp :: Sc :: nil) 2 3 2 HRpRsScMtmp HPpRpPsScalphaMtmp HRpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPpRpPsRsScalphaM : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpRpPsRsScalpham : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPpRpPsRsScalphaeq HPpRpPsRsScalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsRsalpha *)
(* dans la couche 0 *)
Lemma LPPpRpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsScalpha requis par la preuve de (?)PPpRpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsScalpha requis par la preuve de (?)PPpRpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPPpRpSceq : rk(P :: Pp :: Rp :: Sc :: nil) = 4) by (apply LPPpRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpScmtmp : rk(P :: Pp :: Rp :: Sc :: nil) >= 4) by (solve_hyps_min HPPpRpSceq HPPpRpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Sc :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Sc :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPPpRpScmtmp Hcomp Hincl);apply HT.
}


assert(HPPpRpPsRsScalphaM : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsRsScalpham : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsRsScalphaeq HPPpRpPsRsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsRsalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Rs :: alpha ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsOpalpha requis par la preuve de (?)PRPpPsRsOpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsOpalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsRsalpha requis par la preuve de (?)PRPsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Op :: alpha ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham2 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsRsOpalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) >= 3) by (solve_hyps_min HPRPpPsRsOpalphaeq HPRPpPsRsOpalpham3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Op :: alpha :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Rs :: alpha :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsOpalphamtmp;try rewrite HT2 in HPRPpPsRsOpalphamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (P :: nil) 3 1 2 HPRPpPsRsOpalphamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsRsOpalphaM1. try clear HPRPpPsRsOpalphaM2. try clear HPRPpPsRsOpalphaM3. try clear HPRPpPsRsOpalpham4. try clear HPRPpPsRsOpalpham3. try clear HPRPpPsRsOpalpham2. try clear HPRPpPsRsOpalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPRPsRsalpham3 : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPRPpPsRsScalphamtmp : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: R :: Ps :: Rs :: alpha :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: R :: Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsRsScalphamtmp;try rewrite HT2 in HPRPpPsRsScalphamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: R :: Ps :: Rs :: alpha :: nil) (Ps :: nil) 4 1 2 HPRPpPsRsScalphamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}
try clear HPRPpPsRsScalphaM1. try clear HPRPpPsRsScalphaM2. try clear HPRPpPsRsScalphaM3. try clear HPRPpPsRsScalpham4. try clear HPRPpPsRsScalpham3. try clear HPRPpPsRsScalpham2. try clear HPRPpPsRsScalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsRsalpha requis par la preuve de (?)PsRsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Rs :: alpha ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsRsalpham2 : rk(Ps :: Rs :: alpha :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsRsalphamtmp : rk(P :: R :: Ps :: Rs :: alpha :: nil) >= 3) by (solve_hyps_min HPRPsRsalphaeq HPRPsRsalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Rs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Rs :: alpha :: nil) (P :: R :: alpha :: Ps :: Rs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Rs :: alpha :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Rs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsRsalphamtmp;try rewrite HT2 in HPRPsRsalphamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Rs :: alpha :: nil) (alpha :: nil) 3 1 2 HPRPsRsalphamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HPsRsalphaM2 : rk(Ps :: Rs :: alpha :: nil) <= 2).
{
	try assert(HPPsRsalphaeq : rk(P :: Ps :: Rs :: alpha :: nil) = 3) by (apply LPPsRsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsRsalphaMtmp : rk(P :: Ps :: Rs :: alpha :: nil) <= 3) by (solve_hyps_max HPPsRsalphaeq HPPsRsalphaM3).
	try assert(HPpRpPsRsScalphaeq : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) = 3) by (apply LPpRpPsRsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpRpPsRsScalphaMtmp : rk(Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) <= 3) by (solve_hyps_max HPpRpPsRsScalphaeq HPpRpPsRsScalphaM3).
	try assert(HPPpRpPsRsScalphaeq : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) = 4) by (apply LPPpRpPsRsScalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpPsRsScalphamtmp : rk(P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4) by (solve_hyps_min HPPpRpPsRsScalphaeq HPPpRpPsRsScalpham4).
	assert(Hincl : incl (Ps :: Rs :: alpha :: nil) (list_inter (P :: Ps :: Rs :: alpha :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (P :: Ps :: Rs :: alpha :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Rs :: alpha :: Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) ((P :: Ps :: Rs :: alpha :: nil) ++ (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpRpPsRsScalphamtmp;try rewrite HT2 in HPPpRpPsRsScalphamtmp.
	assert(HT := rule_3 (P :: Ps :: Rs :: alpha :: nil) (Pp :: Rp :: Ps :: Rs :: Sc :: alpha :: nil) (Ps :: Rs :: alpha :: nil) 3 3 4 HPPsRsalphaMtmp HPpRpPsRsScalphaMtmp HPPpRpPsRsScalphamtmp Hincl);apply HT.
}


assert(HPsRsalphaM : rk(Ps :: Rs :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsRsalphaeq HPsRsalphaM3).
assert(HPsRsalpham : rk(Ps :: Rs :: alpha ::  nil) >= 1) by (solve_hyps_min HPsRsalphaeq HPsRsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsScalpha requis par la preuve de (?)PQPpPsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham3 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsScalpham4 : rk(P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Sc :: alpha :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPQPpPsScalphaM : rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsScalpham : rk(P :: Q :: Pp :: Ps :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpPsScalphaeq HPQPpPsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpPsRsScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsRsScalpha requis par la preuve de (?)PRPpPsRsScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham3 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsRsScalpham4 : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPRPpSceq : rk(P :: R :: Pp :: Sc :: nil) = 4) by (apply LPRPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpScmtmp : rk(P :: R :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPRPpSceq HPRPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: Sc :: nil) (P :: R :: Pp :: Ps :: Rs :: Sc :: alpha :: nil) 4 4 HPRPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPRPpPsRsScalphaM : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpPsRsScalpham : rk(P :: R :: Pp :: Ps :: Rs :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPRPpPsRsScalphaeq HPRPpPsRsScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOoScalpha requis par la preuve de (?)PQPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham3 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOoScalpham4 : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQPpOoeq : rk(P :: Q :: Pp :: Oo :: nil) = 4) by (apply LPQPpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpOomtmp : rk(P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HPQPpOoeq HPQPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Oo :: nil) (P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQPpOomtmp Hcomp Hincl);apply HT.
}


assert(HPQPpPsOoScalphaM : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsOoScalpham : rk(P :: Q :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQPpPsOoScalphaeq HPQPpPsOoScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpPsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpPsOoScalpha requis par la preuve de (?)PQRPpPsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScalpham3 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpPsOoScalpham4 : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPpPsOoScalphaM : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpPsOoScalpham : rk(P :: Q :: R :: Pp :: Ps :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPQRPpPsOoScalphaeq HPQRPpPsOoScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpRpPsRsOoScalpha : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpRpPsRsOoScalpha requis par la preuve de (?)PPpRpPsRsOoScalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham3 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 3).
{
	try assert(HPPpRpeq : rk(P :: Pp :: Rp :: nil) = 3) by (apply LPPpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPPpRpeq HPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 3 3 HPPpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpRpPsRsOoScalpham4 : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) >= 4).
{
	try assert(HPPpRpOoeq : rk(P :: Pp :: Rp :: Oo :: nil) = 4) by (apply LPPpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpRpOomtmp : rk(P :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpRpOoeq HPPpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Rp :: Oo :: nil) (P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha :: nil) 4 4 HPPpRpOomtmp Hcomp Hincl);apply HT.
}


assert(HPPpRpPsRsOoScalphaM : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpRpPsRsOoScalpham : rk(P :: Pp :: Rp :: Ps :: Rs :: Oo :: Sc :: alpha ::  nil) >= 1) by (solve_hyps_min HPPpRpPsRsOoScalphaeq HPPpRpPsRsOoScalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(beta ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HbetaM : rk(beta ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hbetaeq HbetaM1).
assert(Hbetam : rk(beta ::  nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQbeta *)
(* dans la couche 0 *)
Lemma LQQpRpbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQQpRpbeta requis par la preuve de (?)PQQpRpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQQpRpbetam3 : rk(P :: Q :: Qp :: Rp :: beta :: nil) >= 3).
{
	try assert(HPQQpeq : rk(P :: Q :: Qp :: nil) = 3) by (apply LPQQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQQpmtmp : rk(P :: Q :: Qp :: nil) >= 3) by (solve_hyps_min HPQQpeq HPQQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Rp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Qp :: nil) (P :: Q :: Qp :: Rp :: beta :: nil) 3 3 HPQQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PRp requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour QpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpbeta requis par la preuve de (?)QQpRpbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HQQpRpbetaM3 : rk(Q :: Qp :: Rp :: beta :: nil) <= 3).
{
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: beta :: nil) (Q :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Rp :: beta :: nil) ((Q :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (Qp :: Rp :: beta :: nil) (nil) 1 2 0 HQMtmp HQpRpbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: Qp :: Rp :: beta ::  de rang :  3 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: Rp ::   de rang : 1 et 2 *)
assert(HQQpRpbetam2 : rk(Q :: Qp :: Rp :: beta :: nil) >= 2).
{
	assert(HPRpMtmp : rk(P :: Rp :: nil) <= 2) by (solve_hyps_max HPRpeq HPRpM2).
	assert(HPQQpRpbetamtmp : rk(P :: Q :: Qp :: Rp :: beta :: nil) >= 3) by (solve_hyps_min HPQQpRpbetaeq HPQQpRpbetam3).
	try assert(HRpeq : rk(Rp :: nil) = 1) by (apply LRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Qp :: Rp :: beta :: nil) (P :: Rp :: Q :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Rp :: Q :: Qp :: Rp :: beta :: nil) ((P :: Rp :: nil) ++ (Q :: Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQQpRpbetamtmp;try rewrite HT2 in HPQQpRpbetamtmp.
	assert(HT := rule_4 (P :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil) (Rp :: nil) 3 1 2 HPQQpRpbetamtmp HRpmtmp HPRpMtmp Hincl); apply HT.
}
try clear HPQQpRpbetaM1. try clear HPQQpRpbetaM2. try clear HPQQpRpbetaM3. try clear HPQQpRpbetam4. try clear HPQQpRpbetam3. try clear HPQQpRpbetam2. try clear HPQQpRpbetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpbetam3 : rk(Q :: Qp :: Rp :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


assert(HQQpRpbetaM : rk(Q :: Qp :: Rp :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpbetam : rk(Q :: Qp :: Rp :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpbetaeq HQQpRpbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQbeta *)
(* dans la couche 0 *)
Lemma LQpRpbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQpRpbetaM : rk(Qp :: Rp :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM3).
assert(HQpRpbetam : rk(Qp :: Rp :: beta ::  nil) >= 1) by (solve_hyps_min HQpRpbetaeq HQpRpbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Qbeta requis par la preuve de (?)Qbeta pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQbetam2 : rk(Q :: beta :: nil) >= 2).
{
	try assert(HQpRpbetaeq : rk(Qp :: Rp :: beta :: nil) = 2) by (apply LQpRpbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	try assert(HQQpRpbetaeq : rk(Q :: Qp :: Rp :: beta :: nil) = 3) by (apply LQQpRpbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpbetamtmp : rk(Q :: Qp :: Rp :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpbetaeq HQQpRpbetam3).
	try assert(Hbetaeq : rk(beta :: nil) = 1) by (apply Lbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: beta :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: beta :: nil) (Q :: beta :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: beta :: Qp :: Rp :: beta :: nil) ((Q :: beta :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpbetamtmp;try rewrite HT2 in HQQpRpbetamtmp.
	assert(HT := rule_2 (Q :: beta :: nil) (Qp :: Rp :: beta :: nil) (beta :: nil) 3 1 2 HQQpRpbetamtmp Hbetamtmp HQpRpbetaMtmp Hincl);apply HT.
}


assert(HQbetaM : rk(Q :: beta ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQbetaeq HQbetaM2).
assert(HQbetam : rk(Q :: beta ::  nil) >= 1) by (solve_hyps_min HQbetaeq HQbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HQRbetaM : rk(Q :: R :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQRbetaeq HQRbetaM3).
assert(HQRbetam : rk(Q :: R :: beta ::  nil) >= 1) by (solve_hyps_min HQRbetaeq HQRbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans constructLemma(), requis par LQQsRsbeta *)
(* dans constructLemma(), requis par LQRQsRsOobeta *)
(* dans la couche 0 *)
Lemma LQRQsOobeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qs :: Oo :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsOpOobeta requis par la preuve de (?)QRQsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsOpOobeta requis par la preuve de (?)QRQpQsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsOobeta requis par la preuve de (?)QRQsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsOobetam2 : rk(Q :: R :: Qs :: Oo :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsOpOobetaeq HQRQpQsOpOobetam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsOpOobetamtmp;try rewrite HT2 in HQRQpQsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpQsOpOobetaM1. try clear HQRQpQsOpOobetaM2. try clear HQRQpQsOpOobetaM3. try clear HQRQpQsOpOobetam4. try clear HQRQpQsOpOobetam3. try clear HQRQpQsOpOobetam2. try clear HQRQpQsOpOobetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsOobetam3 : rk(Q :: R :: Qs :: Oo :: beta :: nil) >= 3).
{
	try assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HQRQsOobetaM3 : rk(Q :: R :: Qs :: Oo :: beta :: nil) <= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	try assert(HQRbetaeq : rk(Q :: R :: beta :: nil) = 2) by (apply LQRbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Q :: R :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Oo :: beta :: nil) (Q :: Qs :: Oo :: Q :: R :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Q :: R :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Q :: R :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (Q :: R :: beta :: nil) (Q :: nil) 2 2 1 HQQsOoMtmp HQRbetaMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HQRQsOobetaM : rk(Q :: R :: Qs :: Oo :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQsOobetam : rk(Q :: R :: Qs :: Oo :: beta ::  nil) >= 1) by (solve_hyps_min HQRQsOobetaeq HQRQsOobetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQsRsOobeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQpQsRsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsOobetam2 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpOobetaeq HQRQpQsRsOpOobetam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpOobetamtmp;try rewrite HT2 in HQRQpQsRsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpQsRsOpOobetaM1. try clear HQRQpQsRsOpOobetaM2. try clear HQRQpQsRsOpOobetaM3. try clear HQRQpQsRsOpOobetam4. try clear HQRQpQsRsOpOobetam3. try clear HQRQpQsRsOpOobetam2. try clear HQRQpQsRsOpOobetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsRsOobetam3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3).
{
	try assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HQRQsRsOobetaM3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) <= 3).
{
	try assert(HRRsOoeq : rk(R :: Rs :: Oo :: nil) = 2) by (apply LRRsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	try assert(HQRQsOobetaeq : rk(Q :: R :: Qs :: Oo :: beta :: nil) = 3) by (apply LQRQsOobeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQsOobetaMtmp : rk(Q :: R :: Qs :: Oo :: beta :: nil) <= 3) by (solve_hyps_max HQRQsOobetaeq HQRQsOobetaM3).
	try assert(HROoeq : rk(R :: Oo :: nil) = 2) by (apply LROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HROomtmp : rk(R :: Oo :: nil) >= 2) by (solve_hyps_min HROoeq HROom2).
	assert(Hincl : incl (R :: Oo :: nil) (list_inter (R :: Rs :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (R :: Rs :: Oo :: Q :: R :: Qs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: Q :: R :: Qs :: Oo :: beta :: nil) ((R :: Rs :: Oo :: nil) ++ (Q :: R :: Qs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: Rs :: Oo :: nil) (Q :: R :: Qs :: Oo :: beta :: nil) (R :: Oo :: nil) 2 3 2 HRRsOoMtmp HQRQsOobetaMtmp HROomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HROoM1. try clear HROoM2. try clear HROoM3. try clear HROom4. try clear HROom3. try clear HROom2. try clear HROom1. 

assert(HQRQsRsOobetaM : rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQsRsOobetam : rk(Q :: R :: Qs :: Rs :: Oo :: beta ::  nil) >= 1) by (solve_hyps_min HQRQsRsOobetaeq HQRQsRsOobetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQsRsbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qs :: Rs :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	try assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQpQsRsOpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsOpbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam2 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpbetaeq HQRQpQsRsOpbetam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpbetamtmp;try rewrite HT2 in HQRQpQsRsOpbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpbetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpQsRsOpbetaM1. try clear HQRQpQsRsOpbetaM2. try clear HQRQpQsRsOpbetaM3. try clear HQRQpQsRsOpbetam4. try clear HQRQpQsRsOpbetam3. try clear HQRQpQsRsOpbetam2. try clear HQRQpQsRsOpbetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Qp :: Qs :: Sc ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam3 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3).
{
	try assert(HQpQsSceq : rk(Qp :: Qs :: Sc :: nil) = 2) by (apply LQpQsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQRQpQsRsScbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsScbetamtmp;try rewrite HT2 in HQRQpQsRsScbetamtmp.
	assert(HT := rule_4 (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Qs :: nil) 4 1 2 HQRQpQsRsScbetamtmp HQsmtmp HQpQsScMtmp Hincl); apply HT.
}
try clear HQRQpQsRsScbetaM1. try clear HQRQpQsRsScbetaM2. try clear HQRQpQsRsScbetaM3. try clear HQRQpQsRsScbetam4. try clear HQRQpQsRsScbetam3. try clear HQRQpQsRsScbetam2. try clear HQRQpQsRsScbetam1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpOobeta requis par la preuve de (?)QRQpQsRsOpOobeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsOpOobetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsOobeta requis par la preuve de (?)QRQsRsOobeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsOobetam2 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpOobetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpOobetaeq HQRQpQsRsOpOobetam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: Oo :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: Oo :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: Oo :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpOobetamtmp;try rewrite HT2 in HQRQpQsRsOpOobetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpOobetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpQsRsOpOobetaM1. try clear HQRQpQsRsOpOobetaM2. try clear HQRQpQsRsOpOobetaM3. try clear HQRQpQsRsOpOobetam4. try clear HQRQpQsRsOpOobetam3. try clear HQRQpQsRsOpOobetam2. try clear HQRQpQsRsOpOobetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQsRsOobetam3 : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3).
{
	try assert(HQROoeq : rk(Q :: R :: Oo :: nil) = 3) by (apply LQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQROomtmp : rk(Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HQROoeq HQROom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Oo :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQsRsbeta requis par la preuve de (?)QQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: Oo :: beta ::  de rang :  3 et 4 	 AiB : Rs ::  de rang :  1 et 1 	 A : R :: Rs :: Oo ::   de rang : 2 et 2 *)
assert(HQQsRsbetam2 : rk(Q :: Qs :: Rs :: beta :: nil) >= 2).
{
	try assert(HRRsOoeq : rk(R :: Rs :: Oo :: nil) = 2) by (apply LRRsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRRsOoMtmp : rk(R :: Rs :: Oo :: nil) <= 2) by (solve_hyps_max HRRsOoeq HRRsOoM2).
	assert(HQRQsRsOobetamtmp : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsOobetaeq HQRQsRsOobetam3).
	try assert(HRseq : rk(Rs :: nil) = 1) by (apply LRs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (R :: Rs :: Oo :: nil) (Q :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) (R :: Rs :: Oo :: Q :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Rs :: Oo :: Q :: Qs :: Rs :: beta :: nil) ((R :: Rs :: Oo :: nil) ++ (Q :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsOobetamtmp;try rewrite HT2 in HQRQsRsOobetamtmp.
	assert(HT := rule_4 (R :: Rs :: Oo :: nil) (Q :: Qs :: Rs :: beta :: nil) (Rs :: nil) 3 1 2 HQRQsRsOobetamtmp HRsmtmp HRRsOoMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: beta ::  de rang :  3 et 4 	 AiB : Q :: beta ::  de rang :  2 et 2 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(HQQsRsbetam3 : rk(Q :: Qs :: Rs :: beta :: nil) >= 3).
{
	try assert(HQRbetaeq : rk(Q :: R :: beta :: nil) = 2) by (apply LQRbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRQsRsbetamtmp : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsbetaeq HQRQsRsbetam3).
	try assert(HQbetaeq : rk(Q :: beta :: nil) = 2) by (apply LQbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQbetamtmp : rk(Q :: beta :: nil) >= 2) by (solve_hyps_min HQbetaeq HQbetam2).
	assert(Hincl : incl (Q :: beta :: nil) (list_inter (Q :: R :: beta :: nil) (Q :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: R :: beta :: Q :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: Q :: Qs :: Rs :: beta :: nil) ((Q :: R :: beta :: nil) ++ (Q :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsbetamtmp;try rewrite HT2 in HQRQsRsbetamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (Q :: Qs :: Rs :: beta :: nil) (Q :: beta :: nil) 3 2 2 HQRQsRsbetamtmp HQbetamtmp HQRbetaMtmp Hincl); apply HT.
}
try clear HQbetaM1. try clear HQbetaM2. try clear HQbetaM3. try clear HQbetam4. try clear HQbetam3. try clear HQbetam2. try clear HQbetam1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQsRsbetaM3 : rk(Q :: Qs :: Rs :: beta :: nil) <= 3).
{
	try assert(HQRQsRsOobetaeq : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) = 3) by (apply LQRQsRsOobeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQsRsOobetaMtmp : rk(Q :: R :: Qs :: Rs :: Oo :: beta :: nil) <= 3) by (solve_hyps_max HQRQsRsOobetaeq HQRQsRsOobetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qs :: Rs :: beta :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Q :: Qs :: Rs :: beta :: nil) (Q :: R :: Qs :: Rs :: Oo :: beta :: nil) 3 3 HQRQsRsOobetaMtmp Hcomp Hincl);apply HT.
}
try clear HQRQsRsOobetaM1. try clear HQRQsRsOobetaM2. try clear HQRQsRsOobetaM3. try clear HQRQsRsOobetam4. try clear HQRQsRsOobetam3. try clear HQRQsRsOobetam2. try clear HQRQsRsOobetam1. 

assert(HQQsRsbetaM : rk(Q :: Qs :: Rs :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQsRsbetam : rk(Q :: Qs :: Rs :: beta ::  nil) >= 1) by (solve_hyps_min HQQsRsbetaeq HQQsRsbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans constructLemma(), requis par LQpRpQsRsScbeta *)
(* dans la couche 0 *)
Lemma LQpRpQsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4).
{
	try assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOpScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOpScbeta requis par la preuve de (?)QQpRpQsOpScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOpScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QpRpQsScbeta requis par la preuve de (?)QpRpQsScbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQpRpQsScbetam2 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQQpRpQsOpScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpQsOpScbetaeq HQQpRpQsOpScbetam3).
	try assert(HQpeq : rk(Qp :: nil) = 1) by (apply LQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Op :: Sc :: beta :: nil) (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsOpScbetamtmp;try rewrite HT2 in HQQpRpQsOpScbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qp :: nil) 3 1 2 HQQpRpQsOpScbetamtmp HQpmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQQpRpQsOpScbetaM1. try clear HQQpRpQsOpScbetaM2. try clear HQQpRpQsOpScbetaM3. try clear HQQpRpQsOpScbetam4. try clear HQQpRpQsOpScbetam3. try clear HQQpRpQsOpScbetam2. try clear HQQpRpQsOpScbetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HQpRpQsScbetam3 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQQpRpQsOoScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsOoScbetaeq HQQpRpQsOoScbetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsOoScbetamtmp;try rewrite HT2 in HQQpRpQsOoScbetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qs :: nil) 4 1 2 HQQpRpQsOoScbetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}
try clear HQQpRpQsOoScbetaM1. try clear HQQpRpQsOoScbetaM2. try clear HQQpRpQsOoScbetaM3. try clear HQQpRpQsOoScbetam4. try clear HQQpRpQsOoScbetam3. try clear HQQpRpQsOoScbetam2. try clear HQQpRpQsOoScbetam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HQpRpQsScbetaM3 : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) <= 3).
{
	try assert(HQpQsSceq : rk(Qp :: Qs :: Sc :: nil) = 2) by (apply LQpQsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	try assert(HQpRpbetaeq : rk(Qp :: Rp :: beta :: nil) = 2) by (apply LQpRpbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpRpbetaMtmp : rk(Qp :: Rp :: beta :: nil) <= 2) by (solve_hyps_max HQpRpbetaeq HQpRpbetaM2).
	try assert(HQpeq : rk(Qp :: nil) = 1) by (apply LQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Qp :: Rp :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Qp :: Rp :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Qp :: Rp :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Qp :: Rp :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: Qs :: Sc :: nil) (Qp :: Rp :: beta :: nil) (Qp :: nil) 2 2 1 HQpQsScMtmp HQpRpbetaMtmp HQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HQpRpQsScbetaM : rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQpRpQsScbetam : rk(Qp :: Rp :: Qs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQpRpQsScbetaeq HQpRpQsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpRpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4).
{
	try assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOpScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOpScbeta requis par la preuve de (?)QQpRpQsRsOpScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOpScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QpRpQsRsScbeta requis par la preuve de (?)QpRpQsRsScbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQpRpQsRsScbetam2 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQQpRpQsRsOpScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) >= 3) by (solve_hyps_min HQQpRpQsRsOpScbetaeq HQQpRpQsRsOpScbetam3).
	try assert(HQpeq : rk(Qp :: nil) = 1) by (apply LQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Op :: Sc :: beta :: nil) (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsOpScbetamtmp;try rewrite HT2 in HQQpRpQsRsOpScbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: nil) 3 1 2 HQQpRpQsRsOpScbetamtmp HQpmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQQpRpQsRsOpScbetaM1. try clear HQQpRpQsRsOpScbetaM2. try clear HQQpRpQsRsOpScbetaM3. try clear HQQpRpQsRsOpScbetam4. try clear HQQpRpQsRsOpScbetam3. try clear HQQpRpQsRsOpScbetam2. try clear HQQpRpQsRsOpScbetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HQpRpQsRsScbetam3 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HQQpRpQsRsOoScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsRsOoScbetaeq HQQpRpQsRsOoScbetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsOoScbetamtmp;try rewrite HT2 in HQQpRpQsRsOoScbetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qs :: nil) 4 1 2 HQQpRpQsRsOoScbetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}
try clear HQQpRpQsRsOoScbetaM1. try clear HQQpRpQsRsOoScbetaM2. try clear HQQpRpQsRsOoScbetaM3. try clear HQQpRpQsRsOoScbetam4. try clear HQQpRpQsRsOoScbetam3. try clear HQQpRpQsRsOoScbetam2. try clear HQQpRpQsRsOoScbetam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HQpRpQsRsScbetaM3 : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) <= 3).
{
	try assert(HRpRsSceq : rk(Rp :: Rs :: Sc :: nil) = 2) by (apply LRpRsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpRsScMtmp : rk(Rp :: Rs :: Sc :: nil) <= 2) by (solve_hyps_max HRpRsSceq HRpRsScM2).
	try assert(HQpRpQsScbetaeq : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) = 3) by (apply LQpRpQsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpRpQsScbetaMtmp : rk(Qp :: Rp :: Qs :: Sc :: beta :: nil) <= 3) by (solve_hyps_max HQpRpQsScbetaeq HQpRpQsScbetaM3).
	try assert(HRpSceq : rk(Rp :: Sc :: nil) = 2) by (apply LRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRpScmtmp : rk(Rp :: Sc :: nil) >= 2) by (solve_hyps_min HRpSceq HRpScm2).
	assert(Hincl : incl (Rp :: Sc :: nil) (list_inter (Rp :: Rs :: Sc :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Rp :: Rs :: Sc :: Qp :: Rp :: Qs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Rs :: Sc :: Qp :: Rp :: Qs :: Sc :: beta :: nil) ((Rp :: Rs :: Sc :: nil) ++ (Qp :: Rp :: Qs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Rs :: Sc :: nil) (Qp :: Rp :: Qs :: Sc :: beta :: nil) (Rp :: Sc :: nil) 2 3 2 HRpRsScMtmp HQpRpQsScbetaMtmp HRpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HRpRsScM1. try clear HRpRsScM2. try clear HRpRsScM3. try clear HRpRsScm4. try clear HRpRsScm3. try clear HRpRsScm2. try clear HRpRsScm1. try clear HRpScM1. try clear HRpScM2. try clear HRpScM3. try clear HRpScm4. try clear HRpScm3. try clear HRpScm2. try clear HRpScm1. 

assert(HQpRpQsRsScbetaM : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQpRpQsRsScbetam : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQpRpQsRsScbetaeq HQpRpQsRsScbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQsRsbeta *)
(* dans la couche 0 *)
Lemma LQQpRpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsScbeta requis par la preuve de (?)QQpRpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsScbeta requis par la preuve de (?)QQpRpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	try assert(HQQpRpSceq : rk(Q :: Qp :: Rp :: Sc :: nil) = 4) by (apply LQQpRpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpScmtmp : rk(Q :: Qp :: Rp :: Sc :: nil) >= 4) by (solve_hyps_min HQQpRpSceq HQQpRpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Sc :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Sc :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQQpRpScmtmp Hcomp Hincl);apply HT.
}


assert(HQQpRpQsRsScbetaM : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsRsScbetam : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsRsScbetaeq HQQpRpQsRsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQsRsbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Qs :: Rs :: beta ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	try assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsOpbeta requis par la preuve de (?)QRQpQsRsOpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsOpbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQsRsbeta requis par la preuve de (?)QRQsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Op :: beta ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam2 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpQsRsOpbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) >= 3) by (solve_hyps_min HQRQpQsRsOpbetaeq HQRQpQsRsOpbetam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Op :: beta :: nil) (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: Qs :: Rs :: beta :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsOpbetamtmp;try rewrite HT2 in HQRQpQsRsOpbetamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: nil) 3 1 2 HQRQpQsRsOpbetamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpQsRsOpbetaM1. try clear HQRQpQsRsOpbetaM2. try clear HQRQpQsRsOpbetaM3. try clear HQRQpQsRsOpbetam4. try clear HQRQpQsRsOpbetam3. try clear HQRQpQsRsOpbetam2. try clear HQRQpQsRsOpbetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Qp :: Qs :: Sc ::   de rang : 2 et 2 *)
assert(HQRQsRsbetam3 : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3).
{
	try assert(HQpQsSceq : rk(Qp :: Qs :: Sc :: nil) = 2) by (apply LQpQsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	assert(HQRQpQsRsScbetamtmp : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Q :: R :: Qs :: Rs :: beta :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Q :: R :: Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpQsRsScbetamtmp;try rewrite HT2 in HQRQpQsRsScbetamtmp.
	assert(HT := rule_4 (Qp :: Qs :: Sc :: nil) (Q :: R :: Qs :: Rs :: beta :: nil) (Qs :: nil) 4 1 2 HQRQpQsRsScbetamtmp HQsmtmp HQpQsScMtmp Hincl); apply HT.
}
try clear HQRQpQsRsScbetaM1. try clear HQRQpQsRsScbetaM2. try clear HQRQpQsRsScbetaM3. try clear HQRQpQsRsScbetam4. try clear HQRQpQsRsScbetam3. try clear HQRQpQsRsScbetam2. try clear HQRQpQsRsScbetam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QsRsbeta requis par la preuve de (?)QsRsbeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qs :: Rs :: beta ::  de rang :  3 et 4 	 AiB : beta ::  de rang :  1 et 1 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(HQsRsbetam2 : rk(Qs :: Rs :: beta :: nil) >= 2).
{
	try assert(HQRbetaeq : rk(Q :: R :: beta :: nil) = 2) by (apply LQRbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRQsRsbetamtmp : rk(Q :: R :: Qs :: Rs :: beta :: nil) >= 3) by (solve_hyps_min HQRQsRsbetaeq HQRQsRsbetam3).
	try assert(Hbetaeq : rk(beta :: nil) = 1) by (apply Lbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: R :: beta :: nil) (Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qs :: Rs :: beta :: nil) (Q :: R :: beta :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: Qs :: Rs :: beta :: nil) ((Q :: R :: beta :: nil) ++ (Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQsRsbetamtmp;try rewrite HT2 in HQRQsRsbetamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (Qs :: Rs :: beta :: nil) (beta :: nil) 3 1 2 HQRQsRsbetamtmp Hbetamtmp HQRbetaMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HQsRsbetaM2 : rk(Qs :: Rs :: beta :: nil) <= 2).
{
	try assert(HQQsRsbetaeq : rk(Q :: Qs :: Rs :: beta :: nil) = 3) by (apply LQQsRsbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsRsbetaMtmp : rk(Q :: Qs :: Rs :: beta :: nil) <= 3) by (solve_hyps_max HQQsRsbetaeq HQQsRsbetaM3).
	try assert(HQpRpQsRsScbetaeq : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) = 3) by (apply LQpRpQsRsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpRpQsRsScbetaMtmp : rk(Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) <= 3) by (solve_hyps_max HQpRpQsRsScbetaeq HQpRpQsRsScbetaM3).
	try assert(HQQpRpQsRsScbetaeq : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) = 4) by (apply LQQpRpQsRsScbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpQsRsScbetamtmp : rk(Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) >= 4) by (solve_hyps_min HQQpRpQsRsScbetaeq HQQpRpQsRsScbetam4).
	assert(Hincl : incl (Qs :: Rs :: beta :: nil) (list_inter (Q :: Qs :: Rs :: beta :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Q :: Qs :: Rs :: beta :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Rs :: beta :: Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) ((Q :: Qs :: Rs :: beta :: nil) ++ (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpQsRsScbetamtmp;try rewrite HT2 in HQQpRpQsRsScbetamtmp.
	assert(HT := rule_3 (Q :: Qs :: Rs :: beta :: nil) (Qp :: Rp :: Qs :: Rs :: Sc :: beta :: nil) (Qs :: Rs :: beta :: nil) 3 3 4 HQQsRsbetaMtmp HQpRpQsRsScbetaMtmp HQQpRpQsRsScbetamtmp Hincl);apply HT.
}


assert(HQsRsbetaM : rk(Qs :: Rs :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQsRsbetaeq HQsRsbetaM3).
assert(HQsRsbetam : rk(Qs :: Rs :: beta ::  nil) >= 1) by (solve_hyps_min HQsRsbetaeq HQsRsbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpQsRsScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpQsRsScbeta requis par la preuve de (?)QRQpQsRsScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam3 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpQsRsScbetam4 : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) >= 4).
{
	try assert(HQRQpSceq : rk(Q :: R :: Qp :: Sc :: nil) = 4) by (apply LQRQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpScmtmp : rk(Q :: R :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HQRQpSceq HQRQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: Sc :: nil) (Q :: R :: Qp :: Qs :: Rs :: Sc :: beta :: nil) 4 4 HQRQpScmtmp Hcomp Hincl);apply HT.
}


assert(HQRQpQsRsScbetaM : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpQsRsScbetam : rk(Q :: R :: Qp :: Qs :: Rs :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQRQpQsRsScbetaeq HQRQpQsRsScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpQsOoScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsOoScbeta requis par la preuve de (?)QQpRpQsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) >= 4).
{
	try assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}


assert(HQQpRpQsOoScbetaM : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsOoScbetam : rk(Q :: Qp :: Rp :: Qs :: Oo :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsOoScbetaeq HQQpRpQsOoScbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpQsRsOoScbeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpQsRsOoScbeta requis par la preuve de (?)QQpRpQsRsOoScbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam3 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 3).
{
	try assert(HQQpRpeq : rk(Q :: Qp :: Rp :: nil) = 3) by (apply LQQpRp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpmtmp : rk(Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HQQpRpeq HQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 3 3 HQQpRpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpRpQsRsOoScbetam4 : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) >= 4).
{
	try assert(HQQpRpOoeq : rk(Q :: Qp :: Rp :: Oo :: nil) = 4) by (apply LQQpRpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpRpOomtmp : rk(Q :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpOoeq HQQpRpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Qp :: Rp :: Oo :: nil) (Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta :: nil) 4 4 HQQpRpOomtmp Hcomp Hincl);apply HT.
}


assert(HQQpRpQsRsOoScbetaM : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpQsRsOoScbetam : rk(Q :: Qp :: Rp :: Qs :: Rs :: Oo :: Sc :: beta ::  nil) >= 1) by (solve_hyps_min HQQpRpQsRsOoScbetaeq HQQpRpQsRsOoScbetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQalphabeta *)
(* dans la couche 0 *)
Lemma LPQRalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRalphabeta requis par la preuve de (?)PQRalphabeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalphabeta requis par la preuve de (?)PQRalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRalphabetam3 : rk(P :: Q :: R :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQRalphabetaM3 : rk(P :: Q :: R :: alpha :: beta :: nil) <= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HQRbetaeq : rk(Q :: R :: beta :: nil) = 2) by (apply LQRbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: R :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: R :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: R :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: R :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: R :: alpha :: nil) (Q :: R :: beta :: nil) (R :: nil) 2 2 1 HPRalphaMtmp HQRbetaMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQRalphabetaM : rk(P :: Q :: R :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRalphabetam : rk(P :: Q :: R :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRalphabetaeq HPQRalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphabeta requis par la preuve de (?)PQalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphabeta requis par la preuve de (?)PQPpOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpOpalphabetam3 : rk(P :: Q :: Pp :: Op :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphabeta requis par la preuve de (?)PQalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphabetam2 : rk(P :: Q :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphabetamtmp : rk(P :: Q :: Pp :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpOpalphabetaeq HPQPpOpalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphabetamtmp;try rewrite HT2 in HPQPpOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpOpalphabetaM1. try clear HPQPpOpalphabetaM2. try clear HPQPpOpalphabetaM3. try clear HPQPpOpalphabetam4. try clear HPQPpOpalphabetam3. try clear HPQPpOpalphabetam2. try clear HPQPpOpalphabetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetam3 : rk(P :: Q :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetaM3 : rk(P :: Q :: alpha :: beta :: nil) <= 3).
{
	try assert(HPQRalphabetaeq : rk(P :: Q :: R :: alpha :: beta :: nil) = 3) by (apply LPQRalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRalphabetaMtmp : rk(P :: Q :: R :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPQRalphabetaeq HPQRalphabetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: beta :: nil) (P :: Q :: R :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: alpha :: beta :: nil) (P :: Q :: R :: alpha :: beta :: nil) 3 3 HPQRalphabetaMtmp Hcomp Hincl);apply HT.
}


assert(HPQalphabetaM : rk(P :: Q :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphabetam : rk(P :: Q :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQalphabetaeq HPQalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsalphabeta *)
(* dans la couche 0 *)
Lemma LPsQsRsalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsRsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsRsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPpPsQsRsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsRsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsRsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsRsOpOoalphabetaeq HPQPpPsQsRsOpOoalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsRsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsRsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsRsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsRsOpOoalphabetaM1. try clear HPQPpPsQsRsOpOoalphabetaM2. try clear HPQPpPsQsRsOpOoalphabetaM3. try clear HPQPpPsQsRsOpOoalphabetam4. try clear HPQPpPsQsRsOpOoalphabetam3. try clear HPQPpPsQsRsOpOoalphabetam2. try clear HPQPpPsQsRsOpOoalphabetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsRsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsRsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsRsOoalphabetam2 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsRsOoalphabetam3 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsRsOoalphabetam4 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsRsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsRsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}
try clear HPQPsQsRsOoalphabetaM1. try clear HPQPsQsRsOoalphabetaM2. try clear HPQPsQsRsOoalphabetaM3. try clear HPQPsQsRsOoalphabetam4. try clear HPQPsQsRsOoalphabetam3. try clear HPQPsQsRsOoalphabetam2. try clear HPQPsQsRsOoalphabetam1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsRsOpalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsRsOpalphabeta requis par la preuve de (?)PRPpPsQsRsOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsQsRsOpalphabetam3 : rk(P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsRsalphabeta requis par la preuve de (?)PRPsQsRsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsRsalphabetam2 : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsRsOpalphabetamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPpPsQsRsOpalphabetaeq HPRPpPsQsRsOpalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Rs :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsRsOpalphabetamtmp;try rewrite HT2 in HPRPpPsQsRsOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPRPpPsQsRsOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsQsRsOpalphabetaM1. try clear HPRPpPsQsRsOpalphabetaM2. try clear HPRPpPsQsRsOpalphabetaM3. try clear HPRPpPsQsRsOpalphabetam4. try clear HPRPpPsQsRsOpalphabetam3. try clear HPRPpPsQsRsOpalphabetam2. try clear HPRPpPsQsRsOpalphabetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsRsalphabetam3 : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (Qs :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}
try clear HPQRPsQsRsOoalphabetaM1. try clear HPQRPsQsRsOoalphabetaM2. try clear HPQRPsQsRsOoalphabetaM3. try clear HPQRPsQsRsOoalphabetam4. try clear HPQRPsQsRsOoalphabetam3. try clear HPQRPsQsRsOoalphabetam2. try clear HPQRPsQsRsOoalphabetam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsRsalphabeta requis par la preuve de (?)PsQsRsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: Rs :: alpha :: beta ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsRsalphabetam2 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsRsalphabetamtmp : rk(P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPsQsRsalphabetaeq HPRPsQsRsalphabetam3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: Rs :: alpha :: beta :: nil) (P :: R :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsRsalphabetamtmp;try rewrite HT2 in HPRPsQsRsalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) (alpha :: nil) 3 1 2 HPRPsQsRsalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}
try clear HPRPsQsRsalphabetaM1. try clear HPRPsQsRsalphabetaM2. try clear HPRPsQsRsalphabetaM3. try clear HPRPsQsRsalphabetam4. try clear HPRPsQsRsalphabetam3. try clear HPRPsQsRsalphabetam2. try clear HPRPsQsRsalphabetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsRsalphabetam3 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) >= 3).
{
	try assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsRsOoalphabetamtmp : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HQPsQsRsOoalphabetaeq HQPsQsRsOoalphabetam4).
	try assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: Rs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: Rs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsRsOoalphabetamtmp;try rewrite HT2 in HQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsRsOoalphabetamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}
try clear HQPsQsRsOoalphabetaM1. try clear HQPsQsRsOoalphabetaM2. try clear HQPsQsRsOoalphabetaM3. try clear HQPsQsRsOoalphabetam4. try clear HQPsQsRsOoalphabetam3. try clear HQPsQsRsOoalphabetam2. try clear HQPsQsRsOoalphabetam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPsQsRsalphabetaM3 : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) <= 3).
{
	try assert(HPsRsalphaeq : rk(Ps :: Rs :: alpha :: nil) = 2) by (apply LPsRsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsRsalphaMtmp : rk(Ps :: Rs :: alpha :: nil) <= 2) by (solve_hyps_max HPsRsalphaeq HPsRsalphaM2).
	try assert(HQsRsbetaeq : rk(Qs :: Rs :: beta :: nil) = 2) by (apply LQsRsbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsRsbetaMtmp : rk(Qs :: Rs :: beta :: nil) <= 2) by (solve_hyps_max HQsRsbetaeq HQsRsbetaM2).
	try assert(HRseq : rk(Rs :: nil) = 1) by (apply LRs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRsmtmp : rk(Rs :: nil) >= 1) by (solve_hyps_min HRseq HRsm1).
	assert(Hincl : incl (Rs :: nil) (list_inter (Ps :: Rs :: alpha :: nil) (Qs :: Rs :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ps :: Qs :: Rs :: alpha :: beta :: nil) (Ps :: Rs :: alpha :: Qs :: Rs :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Rs :: alpha :: Qs :: Rs :: beta :: nil) ((Ps :: Rs :: alpha :: nil) ++ (Qs :: Rs :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: Rs :: alpha :: nil) (Qs :: Rs :: beta :: nil) (Rs :: nil) 2 2 1 HPsRsalphaMtmp HQsRsbetaMtmp HRsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPsQsRsalphabetaM : rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsRsalphabetam : rk(Ps :: Qs :: Rs :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPsQsRsalphabetaeq HPsQsRsalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: alpha :: beta ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPpPsQsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetaeq HPQPpPsQsOpOoalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphabetaM1. try clear HPQPpPsQsOpOoalphabetaM2. try clear HPQPpPsQsOpOoalphabetaM3. try clear HPQPpPsQsOpOoalphabetam4. try clear HPQPpPsQsOpOoalphabetam3. try clear HPQPpPsQsOpOoalphabetam2. try clear HPQPpPsQsOpOoalphabetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetamtmp;try rewrite HT2 in HPQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}
try clear HPQPsQsOoalphabetaM1. try clear HPQPsQsOoalphabetaM2. try clear HPQPsQsOoalphabetaM3. try clear HPQPsQsOoalphabetam4. try clear HPQPsQsOoalphabetam3. try clear HPQPsQsOoalphabetam2. try clear HPQPsQsOoalphabetam1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabeta requis par la preuve de (?)PRPpPsQsOpalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsQsOpalphabetam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabeta requis par la preuve de (?)PRPsQsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetaeq HPRPpPsQsOpalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsQsOpalphabetaM1. try clear HPRPpPsQsOpalphabetaM2. try clear HPRPpPsQsOpalphabetaM3. try clear HPRPpPsQsOpalphabetam4. try clear HPRPpPsQsOpalphabetam3. try clear HPRPpPsQsOpalphabetam2. try clear HPRPpPsQsOpalphabetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}
try clear HPQRPsQsOoalphabetaM1. try clear HPQRPsQsOoalphabetaM2. try clear HPQRPsQsOoalphabetaM3. try clear HPQRPsQsOoalphabetam4. try clear HPQRPsQsOoalphabetam3. try clear HPQRPsQsOoalphabetam2. try clear HPQRPsQsOoalphabetam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsalphabeta requis par la preuve de (?)PsQsalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsalphabetam2 : rk(Ps :: Qs :: alpha :: beta :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetaeq HPRPsQsalphabetam3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: nil) (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetamtmp;try rewrite HT2 in HPRPsQsalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil) (alpha :: nil) 3 1 2 HPRPsQsalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}
try clear HPRPsQsalphabetaM1. try clear HPRPsQsalphabetaM2. try clear HPRPsQsalphabetaM3. try clear HPRPsQsalphabetam4. try clear HPRPsQsalphabetam3. try clear HPRPsQsalphabetam2. try clear HPRPsQsalphabetam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsalphabetam3 : rk(Ps :: Qs :: alpha :: beta :: nil) >= 3).
{
	try assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphabetamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphabetaeq HQPsQsOoalphabetam4).
	try assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphabetamtmp;try rewrite HT2 in HQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsOoalphabetamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}
try clear HQPsQsOoalphabetaM1. try clear HQPsQsOoalphabetaM2. try clear HQPsQsOoalphabetaM3. try clear HQPsQsOoalphabetam4. try clear HQPsQsOoalphabetam3. try clear HQPsQsOoalphabetam2. try clear HQPsQsOoalphabetam1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPsQsalphabetaM3 : rk(Ps :: Qs :: alpha :: beta :: nil) <= 3).
{
	try assert(HPsQsRsalphabetaeq : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) = 3) by (apply LPsQsRsalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsQsRsalphabetaMtmp : rk(Ps :: Qs :: Rs :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPsQsRsalphabetaeq HPsQsRsalphabetaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: Rs :: alpha :: beta :: nil) 3 3 HPsQsRsalphabetaMtmp Hcomp Hincl);apply HT.
}


assert(HPsQsalphabetaM : rk(Ps :: Qs :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsalphabetam : rk(Ps :: Qs :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPsQsalphabetaeq HPsQsalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphabeta *)
(* dans constructLemma(), requis par LPQPsQsOoalphabeta *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabeta requis par la preuve de (?)PQRPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsQsOoalphabetaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphabetam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabeta requis par la preuve de (?)PQPpPsQsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabeta requis par la preuve de (?)PQPsQsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetaeq HPQPpPsQsOpOoalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphabetaM1. try clear HPQPpPsQsOpOoalphabetaM2. try clear HPQPpPsQsOpOoalphabetaM3. try clear HPQPpPsQsOpOoalphabetam4. try clear HPQPpPsQsOpOoalphabetam3. try clear HPQPpPsQsOpOoalphabetam2. try clear HPQPpPsQsOpOoalphabetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsQsOoalphabetaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphabetam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabeta requis par la preuve de (?)QPsQsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetaeq HPQRPsQsOoalphabetam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsQsOoalphabetaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQPsQsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetaeq HPQPsQsOoalphabetam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetamtmp;try rewrite HT2 in HPQPsQsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


assert(HQPsQsOoalphabetaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphabetam : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphabetaeq HQPsQsOoalphabetam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsRsOoalphabeta *)
(* dans constructLemma(), requis par LPQPsQsRsOoalphabeta *)
(* dans la couche 0 *)
Lemma LPQRPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsRsOoalphabeta requis par la preuve de (?)PQRPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsRsOoalphabetam3 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsRsOoalphabetam4 : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsQsRsOoalphabetaM : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsRsOoalphabetam : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsRsOpOoalphabeta requis par la preuve de (?)PQPpPsQsRsOpOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsRsOpOoalphabetam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsRsOoalphabeta requis par la preuve de (?)PQPsQsRsOoalphabeta pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam2 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsRsOpOoalphabetamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) >= 3) by (solve_hyps_min HPQPpPsQsRsOpOoalphabetaeq HPQPpPsQsRsOpOoalphabetam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Rs :: Op :: Oo :: alpha :: beta :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsRsOpOoalphabetamtmp;try rewrite HT2 in HPQPpPsQsRsOpOoalphabetamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: nil) 3 1 2 HPQPpPsQsRsOpOoalphabetamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsRsOpOoalphabetaM1. try clear HPQPpPsQsRsOpOoalphabetaM2. try clear HPQPpPsQsRsOpOoalphabetaM3. try clear HPQPpPsQsRsOpOoalphabetam4. try clear HPQPpPsQsRsOpOoalphabetam3. try clear HPQPpPsQsRsOpOoalphabetam2. try clear HPQPpPsQsRsOpOoalphabetam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsRsOoalphabetam3 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsRsOoalphabetam4 : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsRsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsRsOoalphabetamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsQsRsOoalphabetaM : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsRsOoalphabetam : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsRsOoalphabeta : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsRsOoalphabeta requis par la preuve de (?)QPsQsRsOoalphabeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsRsOoalphabetam2 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsRsOoalphabetam3 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsRsOoalphabetaeq : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQRPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsRsOoalphabetamtmp : rk(P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQRPsQsRsOoalphabetaeq HPQRPsQsRsOoalphabetam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQRPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (alpha :: nil) 4 1 2 HPQRPsQsRsOoalphabetamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsRsOoalphabetam4 : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsQsRsOoalphabetaeq : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) = 4) by (apply LPQPsQsRsOoalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsRsOoalphabetamtmp : rk(P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) >= 4) by (solve_hyps_min HPQPsQsRsOoalphabetaeq HPQPsQsRsOoalphabetam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsRsOoalphabetamtmp;try rewrite HT2 in HPQPsQsRsOoalphabetamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsRsOoalphabetamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


assert(HQPsQsRsOoalphabetaM : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsRsOoalphabetam : rk(Q :: Ps :: Qs :: Rs :: Oo :: alpha :: beta ::  nil) >= 1) by (solve_hyps_min HQPsQsRsOoalphabetaeq HQPsQsRsOoalphabetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(gamma ::  nil) = 1.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HgammaM : rk(gamma ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hgammaeq HgammaM1).
assert(Hgammam : rk(gamma ::  nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPgamma *)
(* dans la couche 0 *)
Lemma LPPpQpgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpQpgamma requis par la preuve de (?)PQPpQpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpQpgammam3 : rk(P :: Q :: Pp :: Qp :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Qp :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QQp requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour PpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpgamma requis par la preuve de (?)PPpQpgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HPPpQpgammaM3 : rk(P :: Pp :: Qp :: gamma :: nil) <= 3).
{
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: gamma :: nil) (P :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Qp :: gamma :: nil) ((P :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (Pp :: Qp :: gamma :: nil) (nil) 1 2 0 HPMtmp HPpQpgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : P :: Q :: Pp :: Qp :: gamma ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Q :: Qp ::   de rang : 1 et 2 *)
assert(HPPpQpgammam2 : rk(P :: Pp :: Qp :: gamma :: nil) >= 2).
{
	assert(HQQpMtmp : rk(Q :: Qp :: nil) <= 2) by (solve_hyps_max HQQpeq HQQpM2).
	assert(HPQPpQpgammamtmp : rk(P :: Q :: Pp :: Qp :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpQpgammaeq HPQPpQpgammam3).
	try assert(HQpeq : rk(Qp :: nil) = 1) by (apply LQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Q :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Qp :: gamma :: nil) (Q :: Qp :: P :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: P :: Pp :: Qp :: gamma :: nil) ((Q :: Qp :: nil) ++ (P :: Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpQpgammamtmp;try rewrite HT2 in HPQPpQpgammamtmp.
	assert(HT := rule_4 (Q :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil) (Qp :: nil) 3 1 2 HPQPpQpgammamtmp HQpmtmp HQQpMtmp Hincl); apply HT.
}
try clear HQQpM1. try clear HQQpM2. try clear HQQpM3. try clear HQQpm4. try clear HQQpm3. try clear HQQpm2. try clear HQQpm1. try clear HPQPpQpgammaM1. try clear HPQPpQpgammaM2. try clear HPQPpQpgammaM3. try clear HPQPpQpgammam4. try clear HPQPpQpgammam3. try clear HPQPpQpgammam2. try clear HPQPpQpgammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpgammam3 : rk(P :: Pp :: Qp :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


assert(HPPpQpgammaM : rk(P :: Pp :: Qp :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpgammam : rk(P :: Pp :: Qp :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpgammaeq HPPpQpgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPgamma *)
(* dans la couche 0 *)
Lemma LPpQpgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPpQpgammaM : rk(Pp :: Qp :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM3).
assert(HPpQpgammam : rk(Pp :: Qp :: gamma ::  nil) >= 1) by (solve_hyps_min HPpQpgammaeq HPpQpgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Pgamma requis par la preuve de (?)Pgamma pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPgammam2 : rk(P :: gamma :: nil) >= 2).
{
	try assert(HPpQpgammaeq : rk(Pp :: Qp :: gamma :: nil) = 2) by (apply LPpQpgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	try assert(HPPpQpgammaeq : rk(P :: Pp :: Qp :: gamma :: nil) = 3) by (apply LPPpQpgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpgammamtmp : rk(P :: Pp :: Qp :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpgammaeq HPPpQpgammam3).
	try assert(Hgammaeq : rk(gamma :: nil) = 1) by (apply Lgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Hgammamtmp : rk(gamma :: nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
	assert(Hincl : incl (gamma :: nil) (list_inter (P :: gamma :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: gamma :: nil) (P :: gamma :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: gamma :: Pp :: Qp :: gamma :: nil) ((P :: gamma :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpgammamtmp;try rewrite HT2 in HPPpQpgammamtmp.
	assert(HT := rule_2 (P :: gamma :: nil) (Pp :: Qp :: gamma :: nil) (gamma :: nil) 3 1 2 HPPpQpgammamtmp Hgammamtmp HPpQpgammaMtmp Hincl);apply HT.
}
try clear HgammaM1. try clear HgammaM2. try clear HgammaM3. try clear Hgammam4. try clear Hgammam3. try clear Hgammam2. try clear Hgammam1. 

assert(HPgammaM : rk(P :: gamma ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPgammaeq HPgammaM2).
assert(HPgammam : rk(P :: gamma ::  nil) >= 1) by (solve_hyps_min HPgammaeq HPgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

assert(HPQgammaM : rk(P :: Q :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPQgammaeq HPQgammaM3).
assert(HPQgammam : rk(P :: Q :: gamma ::  nil) >= 1) by (solve_hyps_min HPQgammaeq HPQgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans constructLemma(), requis par LPPsQsgamma *)
(* dans constructLemma(), requis par LPQPsQsOogamma *)
(* dans la couche 0 *)
Lemma LPQPsOogamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Oo :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsOpOogamma requis par la preuve de (?)PQPsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsOpOogamma requis par la preuve de (?)PQPpPsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsOogamma requis par la preuve de (?)PQPsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsOogammam2 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsOpOogammaeq HPQPpPsOpOogammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsOpOogammamtmp;try rewrite HT2 in HPQPpPsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsOpOogammaM1. try clear HPQPpPsOpOogammaM2. try clear HPQPpPsOpOogammaM3. try clear HPQPpPsOpOogammam4. try clear HPQPpPsOpOogammam3. try clear HPQPpPsOpOogammam2. try clear HPQPpPsOpOogammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsOogammam3 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQPsOogammaM3 : rk(P :: Q :: Ps :: Oo :: gamma :: nil) <= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	try assert(HPQgammaeq : rk(P :: Q :: gamma :: nil) = 2) by (apply LPQgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Ps :: Oo :: nil) (P :: Q :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Oo :: gamma :: nil) (P :: Ps :: Oo :: P :: Q :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: P :: Q :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (P :: Q :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Ps :: Oo :: nil) (P :: Q :: gamma :: nil) (P :: nil) 2 2 1 HPPsOoMtmp HPQgammaMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQPsOogammaM : rk(P :: Q :: Ps :: Oo :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsOogammam : rk(P :: Q :: Ps :: Oo :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsOogammaeq HPQPsOogammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOogamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPpPsQsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOogammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOogammaeq HPQPpPsQsOpOogammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOogammamtmp;try rewrite HT2 in HPQPpPsQsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOogammaM1. try clear HPQPpPsQsOpOogammaM2. try clear HPQPpPsQsOpOogammaM3. try clear HPQPpPsQsOpOogammam4. try clear HPQPpPsQsOpOogammam3. try clear HPQPpPsQsOpOogammam2. try clear HPQPpPsQsOpOogammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOogammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQPsQsOogammaM3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) <= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	try assert(HPQPsOogammaeq : rk(P :: Q :: Ps :: Oo :: gamma :: nil) = 3) by (apply LPQPsOogamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsOogammaMtmp : rk(P :: Q :: Ps :: Oo :: gamma :: nil) <= 3) by (solve_hyps_max HPQPsOogammaeq HPQPsOogammaM3).
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hincl : incl (Q :: Oo :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (Q :: Qs :: Oo :: P :: Q :: Ps :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Q :: Ps :: Oo :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Q :: Ps :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: Qs :: Oo :: nil) (P :: Q :: Ps :: Oo :: gamma :: nil) (Q :: Oo :: nil) 2 3 2 HQQsOoMtmp HPQPsOogammaMtmp HQOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQPsQsOogammaM : rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOogammam : rk(P :: Q :: Ps :: Qs :: Oo :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOogammaeq HPQPsQsOogammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsQsgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Qs :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpgamma requis par la preuve de (?)PQPpPsQsOpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsgamma requis par la preuve de (?)PQPsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsgammam2 : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpgammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpgammaeq HPQPpPsQsOpgammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpgammamtmp;try rewrite HT2 in HPQPpPsQsOpgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpgammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpgammaM1. try clear HPQPpPsQsOpgammaM2. try clear HPQPpPsQsOpgammaM3. try clear HPQPpPsQsOpgammam4. try clear HPQPpPsQsOpgammam3. try clear HPQPpPsQsOpgammam2. try clear HPQPpPsQsOpgammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsQsgammam3 : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsQsScgammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPQPpPsQsScgammaeq HPQPpPsQsScgammam4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsScgammamtmp;try rewrite HT2 in HPQPpPsQsScgammamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: gamma :: nil) (Ps :: nil) 4 1 2 HPQPpPsQsScgammamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}
try clear HPQPpPsQsScgammaM1. try clear HPQPpPsQsScgammaM2. try clear HPQPpPsQsScgammaM3. try clear HPQPpPsQsScgammam4. try clear HPQPpPsQsScgammam3. try clear HPQPpPsQsScgammam2. try clear HPQPpPsQsScgammam1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOogamma requis par la preuve de (?)PQPpPsQsOpOogamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOogammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOogamma requis par la preuve de (?)PQPsQsOogamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOogammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOogammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOogammaeq HPQPpPsQsOpOogammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOogammamtmp;try rewrite HT2 in HPQPpPsQsOpOogammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOogammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOogammaM1. try clear HPQPpPsQsOpOogammaM2. try clear HPQPpPsQsOpOogammaM3. try clear HPQPpPsQsOpOogammam4. try clear HPQPpPsQsOpOogammam3. try clear HPQPpPsQsOpOogammam2. try clear HPQPpPsQsOpOogammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOogammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsQsgamma requis par la preuve de (?)PPsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: gamma ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsQsgammam2 : rk(P :: Ps :: Qs :: gamma :: nil) >= 2).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQPsQsOogammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsOogammaeq HPQPsQsOogammam3).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) (Q :: Qs :: Oo :: P :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Ps :: Qs :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOogammamtmp;try rewrite HT2 in HPQPsQsOogammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: gamma :: nil) (Qs :: nil) 3 1 2 HPQPsQsOogammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: gamma ::  de rang :  3 et 4 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPPsQsgammam3 : rk(P :: Ps :: Qs :: gamma :: nil) >= 3).
{
	try assert(HPQgammaeq : rk(P :: Q :: gamma :: nil) = 2) by (apply LPQgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(HPQPsQsgammamtmp : rk(P :: Q :: Ps :: Qs :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsgammaeq HPQPsQsgammam3).
	try assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: gamma :: nil) (P :: Q :: gamma :: P :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: Ps :: Qs :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsgammamtmp;try rewrite HT2 in HPQPsQsgammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: gamma :: nil) (P :: gamma :: nil) 3 2 2 HPQPsQsgammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}
try clear HPQPsQsgammaM1. try clear HPQPsQsgammaM2. try clear HPQPsQsgammaM3. try clear HPQPsQsgammam4. try clear HPQPsQsgammam3. try clear HPQPsQsgammam2. try clear HPQPsQsgammam1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPsQsgammaM3 : rk(P :: Ps :: Qs :: gamma :: nil) <= 3).
{
	try assert(HPQPsQsOogammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) = 3) by (apply LPQPsQsOogamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsOogammaMtmp : rk(P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) <= 3) by (solve_hyps_max HPQPsQsOogammaeq HPQPsQsOogammaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Ps :: Qs :: gamma :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Ps :: Qs :: gamma :: nil) (P :: Q :: Ps :: Qs :: Oo :: gamma :: nil) 3 3 HPQPsQsOogammaMtmp Hcomp Hincl);apply HT.
}
try clear HPQPsQsOogammaM1. try clear HPQPsQsOogammaM2. try clear HPQPsQsOogammaM3. try clear HPQPsQsOogammam4. try clear HPQPsQsOogammam3. try clear HPQPsQsOogammam2. try clear HPQPsQsOogammam1. 

assert(HPPsQsgammaM : rk(P :: Ps :: Qs :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsQsgammam : rk(P :: Ps :: Qs :: gamma ::  nil) >= 1) by (solve_hyps_min HPPsQsgammaeq HPPsQsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans constructLemma(), requis par LPpQpPsQsScgamma *)
(* dans la couche 0 *)
Lemma LPpQpPsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOpScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOpScgamma requis par la preuve de (?)PPpQpPsOpScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOpScgammam3 : rk(P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsScgamma requis par la preuve de (?)PpQpPsScgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpQpPsScgammam2 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpQpPsOpScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpPsOpScgammaeq HPPpQpPsOpScgammam3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Op :: Sc :: gamma :: nil) (P :: Pp :: Op :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOpScgammamtmp;try rewrite HT2 in HPPpQpPsOpScgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Pp :: nil) 3 1 2 HPPpQpPsOpScgammamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPPpQpPsOpScgammaM1. try clear HPPpQpPsOpScgammaM2. try clear HPPpQpPsOpScgammaM3. try clear HPPpQpPsOpScgammam4. try clear HPPpQpPsOpScgammam3. try clear HPPpQpPsOpScgammam2. try clear HPPpQpPsOpScgammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsScgammam3 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpQpPsOoScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsOoScgammaeq HPPpQpPsOoScgammam4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsOoScgammamtmp;try rewrite HT2 in HPPpQpPsOoScgammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Ps :: nil) 4 1 2 HPPpQpPsOoScgammamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}
try clear HPPpQpPsOoScgammaM1. try clear HPPpQpPsOoScgammaM2. try clear HPPpQpPsOoScgammaM3. try clear HPPpQpPsOoScgammam4. try clear HPPpQpPsOoScgammam3. try clear HPPpQpPsOoScgammam2. try clear HPPpQpPsOoScgammam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPpQpPsScgammaM3 : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) <= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	try assert(HPpQpgammaeq : rk(Pp :: Qp :: gamma :: nil) = 2) by (apply LPpQpgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpQpgammaMtmp : rk(Pp :: Qp :: gamma :: nil) <= 2) by (solve_hyps_max HPpQpgammaeq HPpQpgammaM2).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (Pp :: Qp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Pp :: Ps :: Sc :: Pp :: Qp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: Pp :: Qp :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (Pp :: Qp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: Ps :: Sc :: nil) (Pp :: Qp :: gamma :: nil) (Pp :: nil) 2 2 1 HPpPsScMtmp HPpQpgammaMtmp HPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPpQpPsScgammaM : rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsScgammam : rk(Pp :: Qp :: Ps :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPpQpPsScgammaeq HPpQpPsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpQpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOpScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOpScgamma requis par la preuve de (?)PPpQpPsQsOpScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOpScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PpQpPsQsScgamma requis par la preuve de (?)PpQpPsQsScgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPpQpPsQsScgammam2 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPPpQpPsQsOpScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) >= 3) by (solve_hyps_min HPPpQpPsQsOpScgammaeq HPPpQpPsQsOpScgammam3).
	try assert(HPpeq : rk(Pp :: nil) = 1) by (apply LPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Op :: Sc :: gamma :: nil) (P :: Pp :: Op :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsOpScgammamtmp;try rewrite HT2 in HPPpQpPsQsOpScgammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Pp :: nil) 3 1 2 HPPpQpPsQsOpScgammamtmp HPpmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPPpQpPsQsOpScgammaM1. try clear HPPpQpPsQsOpScgammaM2. try clear HPPpQpPsQsOpScgammaM3. try clear HPPpQpPsQsOpScgammam4. try clear HPPpQpPsQsOpScgammam3. try clear HPPpQpPsQsOpScgammam2. try clear HPPpQpPsQsOpScgammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : P :: Ps :: Oo ::   de rang : 2 et 2 *)
assert(HPpQpPsQsScgammam3 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPsOoeq : rk(P :: Ps :: Oo :: nil) = 2) by (apply LPPsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoMtmp : rk(P :: Ps :: Oo :: nil) <= 2) by (solve_hyps_max HPPsOoeq HPPsOoM2).
	assert(HPPpQpPsQsOoScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsQsOoScgammaeq HPPpQpPsQsOoScgammam4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Ps :: Oo :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsOoScgammamtmp;try rewrite HT2 in HPPpQpPsQsOoScgammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Ps :: nil) 4 1 2 HPPpQpPsQsOoScgammamtmp HPsmtmp HPPsOoMtmp Hincl); apply HT.
}
try clear HPPpQpPsQsOoScgammaM1. try clear HPPpQpPsQsOoScgammaM2. try clear HPPpQpPsQsOoScgammaM3. try clear HPPpQpPsQsOoScgammam4. try clear HPPpQpPsQsOoScgammam3. try clear HPPpQpPsQsOoScgammam2. try clear HPPpQpPsQsOoScgammam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPpQpPsQsScgammaM3 : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) <= 3).
{
	try assert(HQpQsSceq : rk(Qp :: Qs :: Sc :: nil) = 2) by (apply LQpQsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpQsScMtmp : rk(Qp :: Qs :: Sc :: nil) <= 2) by (solve_hyps_max HQpQsSceq HQpQsScM2).
	try assert(HPpQpPsScgammaeq : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) = 3) by (apply LPpQpPsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpQpPsScgammaMtmp : rk(Pp :: Qp :: Ps :: Sc :: gamma :: nil) <= 3) by (solve_hyps_max HPpQpPsScgammaeq HPpQpPsScgammaM3).
	try assert(HQpSceq : rk(Qp :: Sc :: nil) = 2) by (apply LQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQpScmtmp : rk(Qp :: Sc :: nil) >= 2) by (solve_hyps_min HQpSceq HQpScm2).
	assert(Hincl : incl (Qp :: Sc :: nil) (list_inter (Qp :: Qs :: Sc :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Qp :: Qs :: Sc :: Pp :: Qp :: Ps :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Qs :: Sc :: Pp :: Qp :: Ps :: Sc :: gamma :: nil) ((Qp :: Qs :: Sc :: nil) ++ (Pp :: Qp :: Ps :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: Qs :: Sc :: nil) (Pp :: Qp :: Ps :: Sc :: gamma :: nil) (Qp :: Sc :: nil) 2 3 2 HQpQsScMtmp HPpQpPsScgammaMtmp HQpScmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HQpScM1. try clear HQpScM2. try clear HQpScM3. try clear HQpScm4. try clear HQpScm3. try clear HQpScm2. try clear HQpScm1. 

assert(HPpQpPsQsScgammaM : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPpQpPsQsScgammam : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPpQpPsQsScgammaeq HPpQpPsQsScgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPsQsgamma *)
(* dans la couche 0 *)
Lemma LPPpQpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsScgamma requis par la preuve de (?)PPpQpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsScgamma requis par la preuve de (?)PPpQpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPPpQpSceq : rk(P :: Pp :: Qp :: Sc :: nil) = 4) by (apply LPPpQpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpScmtmp : rk(P :: Pp :: Qp :: Sc :: nil) >= 4) by (solve_hyps_min HPPpQpSceq HPPpQpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Sc :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Sc :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPPpQpScmtmp Hcomp Hincl);apply HT.
}


assert(HPPpQpPsQsScgammaM : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsQsScgammam : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsQsScgammaeq HPPpQpPsQsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PsQsgamma requis par la preuve de (?)PsQsgamma pour la règle 3  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)PsQsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPpPsQsOpOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphagammaeq HPQPpPsQsOpOoalphagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphagammaM1. try clear HPQPpPsQsOpOoalphagammaM2. try clear HPQPpPsQsOpOoalphagammaM3. try clear HPQPpPsQsOpOoalphagammam4. try clear HPQPpPsQsOpOoalphagammam3. try clear HPQPpPsQsOpOoalphagammam2. try clear HPQPpPsQsOpOoalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}
try clear HPQRPsQsOoalphagammaM1. try clear HPQRPsQsOoalphagammaM2. try clear HPQRPsQsOoalphagammaM3. try clear HPQRPsQsOoalphagammam4. try clear HPQRPsQsOoalphagammam3. try clear HPQRPsQsOoalphagammam2. try clear HPQRPsQsOoalphagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphagammamtmp;try rewrite HT2 in HPQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}
try clear HPQPsQsOoalphagammaM1. try clear HPQPsQsOoalphagammaM2. try clear HPQPsQsOoalphagammaM3. try clear HPQPsQsOoalphagammam4. try clear HPQPsQsOoalphagammam3. try clear HPQPsQsOoalphagammam2. try clear HPQPsQsOoalphagammam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PsQsgamma requis par la preuve de (?)PsQsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsgammam2 : rk(Ps :: Qs :: gamma :: nil) >= 2).
{
	try assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphagammamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphagammaeq HQPsQsOoalphagammam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: gamma :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphagammamtmp;try rewrite HT2 in HQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: gamma :: nil) (Qs :: nil) 4 1 3 HQPsQsOoalphagammamtmp HQsmtmp HQQsOoalphaMtmp Hincl); apply HT.
}
try clear HQPsQsOoalphagammaM1. try clear HQPsQsOoalphagammaM2. try clear HQPsQsOoalphagammaM3. try clear HQPsQsOoalphagammam4. try clear HQPsQsOoalphagammam3. try clear HQPsQsOoalphagammam2. try clear HQPsQsOoalphagammam1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HPsQsgammaM2 : rk(Ps :: Qs :: gamma :: nil) <= 2).
{
	try assert(HPPsQsgammaeq : rk(P :: Ps :: Qs :: gamma :: nil) = 3) by (apply LPPsQsgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsQsgammaMtmp : rk(P :: Ps :: Qs :: gamma :: nil) <= 3) by (solve_hyps_max HPPsQsgammaeq HPPsQsgammaM3).
	try assert(HPpQpPsQsScgammaeq : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) = 3) by (apply LPpQpPsQsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpQpPsQsScgammaMtmp : rk(Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) <= 3) by (solve_hyps_max HPpQpPsQsScgammaeq HPpQpPsQsScgammaM3).
	try assert(HPPpQpPsQsScgammaeq : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) = 4) by (apply LPPpQpPsQsScgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpPsQsScgammamtmp : rk(P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4) by (solve_hyps_min HPPpQpPsQsScgammaeq HPPpQpPsQsScgammam4).
	assert(Hincl : incl (Ps :: Qs :: gamma :: nil) (list_inter (P :: Ps :: Qs :: gamma :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (P :: Ps :: Qs :: gamma :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Qs :: gamma :: Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) ((P :: Ps :: Qs :: gamma :: nil) ++ (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpPsQsScgammamtmp;try rewrite HT2 in HPPpQpPsQsScgammamtmp.
	assert(HT := rule_3 (P :: Ps :: Qs :: gamma :: nil) (Pp :: Qp :: Ps :: Qs :: Sc :: gamma :: nil) (Ps :: Qs :: gamma :: nil) 3 3 4 HPPsQsgammaMtmp HPpQpPsQsScgammaMtmp HPPpQpPsQsScgammamtmp Hincl);apply HT.
}


assert(HPsQsgammaM : rk(Ps :: Qs :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPsQsgammaeq HPsQsgammaM3).
assert(HPsQsgammam : rk(Ps :: Qs :: gamma ::  nil) >= 1) by (solve_hyps_min HPsQsgammaeq HPsQsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsQsScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScgamma requis par la preuve de (?)PQPpPsQsScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScgammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPQPpPsQsScgammaM : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsQsScgammam : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPpPsQsScgammaeq HPQPpPsQsScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsOoScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsOoScgamma requis par la preuve de (?)PPpQpPsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}


assert(HPPpQpPsOoScgammaM : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsOoScgammam : rk(P :: Pp :: Qp :: Ps :: Oo :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsOoScgammaeq HPPpQpPsOoScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpPsQsOoScgamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpPsQsOoScgamma requis par la preuve de (?)PPpQpPsQsOoScgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam3 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 3).
{
	try assert(HPPpQpeq : rk(P :: Pp :: Qp :: nil) = 3) by (apply LPPpQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpmtmp : rk(P :: Pp :: Qp :: nil) >= 3) by (solve_hyps_min HPPpQpeq HPPpQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 3 3 HPPpQpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPPpQpPsQsOoScgammam4 : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) >= 4).
{
	try assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LPPpQpOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPPpQpOoeq HPPpQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma :: nil) 4 4 HPPpQpOomtmp Hcomp Hincl);apply HT.
}


assert(HPPpQpPsQsOoScgammaM : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpPsQsOoScgammam : rk(P :: Pp :: Qp :: Ps :: Qs :: Oo :: Sc :: gamma ::  nil) >= 1) by (solve_hyps_min HPPpQpPsQsOoScgammaeq HPPpQpPsQsOoScgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphagamma requis par la preuve de (?)PQalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphagamma requis par la preuve de (?)PQPpOpalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpOpalphagammam3 : rk(P :: Q :: Pp :: Op :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphagamma requis par la preuve de (?)PQalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphagammam2 : rk(P :: Q :: alpha :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphagammamtmp : rk(P :: Q :: Pp :: Op :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpOpalphagammaeq HPQPpOpalphagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphagammamtmp;try rewrite HT2 in HPQPpOpalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpOpalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpOpalphagammaM1. try clear HPQPpOpalphagammaM2. try clear HPQPpOpalphagammaM3. try clear HPQPpOpalphagammam4. try clear HPQPpOpalphagammam3. try clear HPQPpOpalphagammam2. try clear HPQPpOpalphagammam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HPQalphagammaM3 : rk(P :: Q :: alpha :: gamma :: nil) <= 3).
{
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HalphaMtmp : rk(alpha :: nil) <= 1) by (solve_hyps_max Halphaeq HalphaM1).
	try assert(HPQgammaeq : rk(P :: Q :: gamma :: nil) = 2) by (apply LPQgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (alpha :: nil) (P :: Q :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: gamma :: nil) (alpha :: P :: Q :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (alpha :: P :: Q :: gamma :: nil) ((alpha :: nil) ++ (P :: Q :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (alpha :: nil) (P :: Q :: gamma :: nil) (nil) 1 2 0 HalphaMtmp HPQgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphagammam3 : rk(P :: Q :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: gamma :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}


assert(HPQalphagammaM : rk(P :: Q :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphagammam : rk(P :: Q :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQalphagammaeq HPQalphagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphagamma *)
(* dans constructLemma(), requis par LPQPsQsOoalphagamma *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphagamma requis par la preuve de (?)PQRPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsQsOoalphagammaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphagammam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphagamma requis par la preuve de (?)PQPpPsQsOpOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphagamma requis par la preuve de (?)PQPsQsOoalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphagammaeq HPQPpPsQsOpOoalphagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphagammaM1. try clear HPQPpPsQsOpOoalphagammaM2. try clear HPQPpPsQsOpOoalphagammaM3. try clear HPQPpPsQsOpOoalphagammam4. try clear HPQPpPsQsOpOoalphagammam3. try clear HPQPpPsQsOpOoalphagammam2. try clear HPQPpPsQsOpOoalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsQsOoalphagammaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphagammam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphagamma requis par la preuve de (?)QPsQsOoalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphagammaeq HPQRPsQsOoalphagammam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphagammamtmp;try rewrite HT2 in HPQRPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsQsOoalphagammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) = 4) by (apply LPQPsQsOoalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsOoalphagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphagammaeq HPQPsQsOoalphagammam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphagammamtmp;try rewrite HT2 in HPQPsQsOoalphagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


assert(HQPsQsOoalphagammaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphagammam : rk(Q :: Ps :: Qs :: Oo :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphagammaeq HQPsQsOoalphagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpOpalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpOpalphabetagamma requis par la preuve de (?)PQPpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpOpalphabetagammam3 : rk(P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQalphabetagamma requis par la preuve de (?)PQalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQalphabetagammam2 : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpOpalphabetagammamtmp : rk(P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpOpalphabetagammaeq HPQPpOpalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpOpalphabetagammamtmp;try rewrite HT2 in HPQPpOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpOpalphabetagammaM1. try clear HPQPpOpalphabetagammaM2. try clear HPQPpOpalphabetagammaM3. try clear HPQPpOpalphabetagammam4. try clear HPQPpOpalphabetagammam3. try clear HPQPpOpalphabetagammam2. try clear HPQPpOpalphabetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQalphabetagammam3 : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: alpha :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) 3 3 HPQalphamtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPQalphabetagammaM3 : rk(P :: Q :: alpha :: beta :: gamma :: nil) <= 3).
{
	try assert(HPQalphabetaeq : rk(P :: Q :: alpha :: beta :: nil) = 3) by (apply LPQalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphabetaMtmp : rk(P :: Q :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPQalphabetaeq HPQalphabetaM3).
	try assert(HPQalphagammaeq : rk(P :: Q :: alpha :: gamma :: nil) = 3) by (apply LPQalphagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphagammaMtmp : rk(P :: Q :: alpha :: gamma :: nil) <= 3) by (solve_hyps_max HPQalphagammaeq HPQalphagammaM3).
	try assert(HPQalphaeq : rk(P :: Q :: alpha :: nil) = 3) by (apply LPQalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphamtmp : rk(P :: Q :: alpha :: nil) >= 3) by (solve_hyps_min HPQalphaeq HPQalpham3).
	assert(Hincl : incl (P :: Q :: alpha :: nil) (list_inter (P :: Q :: alpha :: beta :: nil) (P :: Q :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: P :: Q :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: alpha :: beta :: P :: Q :: alpha :: gamma :: nil) ((P :: Q :: alpha :: beta :: nil) ++ (P :: Q :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: Q :: alpha :: beta :: nil) (P :: Q :: alpha :: gamma :: nil) (P :: Q :: alpha :: nil) 3 3 3 HPQalphabetaMtmp HPQalphagammaMtmp HPQalphamtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HPQalphabetagammaM : rk(P :: Q :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQalphabetagammam : rk(P :: Q :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQalphabetagammaeq HPQalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRalphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpOpalphabetagamma requis par la preuve de (?)PRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpOpalphabetagamma requis par la preuve de (?)PRPpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpOpalphabetagammam3 : rk(P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRalphabetagamma requis par la preuve de (?)PRalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRalphabetagammam2 : rk(P :: R :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpOpalphabetagammamtmp : rk(P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpOpalphabetagammaeq HPRPpOpalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpOpalphabetagammamtmp;try rewrite HT2 in HPRPpOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpOpalphabetagammaM1. try clear HPRPpOpalphabetagammaM2. try clear HPRPpOpalphabetagammaM3. try clear HPRPpOpalphabetagammam4. try clear HPRPpOpalphabetagammam3. try clear HPRPpOpalphabetagammam2. try clear HPRPpOpalphabetagammam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Palphabetagamma requis par la preuve de (?)Palphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: alpha :: beta :: gamma ::  de rang :  2 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPalphabetagammam2 : rk(P :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRalphabetagammamtmp : rk(P :: R :: alpha :: beta :: gamma :: nil) >= 2) by (solve_hyps_min HPRalphabetagammaeq HPRalphabetagammam2).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRalphabetagammamtmp;try rewrite HT2 in HPRalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 2 2 2 HPRalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}
try clear HPRalphabetagammaM1. try clear HPRalphabetagammaM2. try clear HPRalphabetagammaM3. try clear HPRalphabetagammam4. try clear HPRalphabetagammam3. try clear HPRalphabetagammam2. try clear HPRalphabetagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: alpha :: beta :: gamma ::  de rang :  3 et 3 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPalphabetagammam3 : rk(P :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQgammaeq : rk(P :: Q :: gamma :: nil) = 2) by (apply LPQgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	try assert(HPQalphabetagammaeq : rk(P :: Q :: alpha :: beta :: gamma :: nil) = 3) by (apply LPQalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphabetagammamtmp : rk(P :: Q :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQalphabetagammaeq HPQalphabetagammam3).
	try assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: alpha :: beta :: gamma :: nil) (P :: Q :: gamma :: P :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: alpha :: beta :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQalphabetagammamtmp;try rewrite HT2 in HPQalphabetagammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: alpha :: beta :: gamma :: nil) (P :: gamma :: nil) 3 2 2 HPQalphabetagammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPalphabetagammaM3 : rk(P :: alpha :: beta :: gamma :: nil) <= 3).
{
	try assert(HPQalphabetagammaeq : rk(P :: Q :: alpha :: beta :: gamma :: nil) = 3) by (apply LPQalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQalphabetagammaMtmp : rk(P :: Q :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPQalphabetagammaeq HPQalphabetagammaM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: alpha :: beta :: gamma :: nil) (P :: Q :: alpha :: beta :: gamma :: nil) 3 3 HPQalphabetagammaMtmp Hcomp Hincl);apply HT.
}


assert(HPalphabetagammaM : rk(P :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPalphabetagammam : rk(P :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPalphabetagammaeq HPalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 3.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphabetagammaM1. try clear HPQPpPsQsOpOoalphabetagammaM2. try clear HPQPpPsQsOpOoalphabetagammaM3. try clear HPQPpPsQsOpOoalphabetagammam4. try clear HPQPpPsQsOpOoalphabetagammam3. try clear HPQPpPsQsOpOoalphabetagammam2. try clear HPQPpPsQsOpOoalphabetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsQsOpalphabetagammam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetagammamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetagammaeq HPRPpPsQsOpalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsQsOpalphabetagammaM1. try clear HPRPpPsQsOpalphabetagammaM2. try clear HPRPpPsQsOpalphabetagammaM3. try clear HPRPpPsQsOpalphabetagammam4. try clear HPRPpPsQsOpalphabetagammam3. try clear HPRPpPsQsOpalphabetagammam2. try clear HPRPpPsQsOpalphabetagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}
try clear HPQRPsQsOoalphabetagammaM1. try clear HPQRPsQsOoalphabetagammaM2. try clear HPQRPsQsOoalphabetagammaM3. try clear HPQRPsQsOoalphabetagammam4. try clear HPQRPsQsOoalphabetagammam3. try clear HPQRPsQsOoalphabetagammam2. try clear HPQRPsQsOoalphabetagammam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PsQsalphabetagamma requis par la preuve de (?)PsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPsQsalphabetagammam2 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetagammamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetagammaeq HPRPsQsalphabetagammam3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetagammamtmp;try rewrite HT2 in HPRPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (alpha :: nil) 3 1 2 HPRPsQsalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs :: alpha ::  de rang :  2 et 2 	 A : Q :: Qs :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HPsQsalphabetagammam3 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HQQsOoalphaeq : rk(Q :: Qs :: Oo :: alpha :: nil) = 3) by (apply LQQsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoalphaMtmp : rk(Q :: Qs :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HQQsOoalphaeq HQQsOoalphaM3).
	assert(HQPsQsOoalphabetagammamtmp : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HQPsQsOoalphabetagammaeq HQPsQsOoalphabetagammam4).
	try assert(HQsalphaeq : rk(Qs :: alpha :: nil) = 2) by (apply LQsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsalphamtmp : rk(Qs :: alpha :: nil) >= 2) by (solve_hyps_min HQsalphaeq HQsalpham2).
	assert(Hincl : incl (Qs :: alpha :: nil) (list_inter (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: alpha :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: alpha :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPsQsOoalphabetagammamtmp;try rewrite HT2 in HQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: alpha :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: alpha :: nil) 4 2 3 HQPsQsOoalphabetagammamtmp HQsalphamtmp HQQsOoalphaMtmp Hincl); apply HT.
}
try clear HQPsQsOoalphabetagammaM1. try clear HQPsQsOoalphabetagammaM2. try clear HQPsQsOoalphabetagammaM3. try clear HQPsQsOoalphabetagammam4. try clear HQPsQsOoalphabetagammam3. try clear HQPsQsOoalphabetagammam2. try clear HQPsQsOoalphabetagammam1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HPsQsalphabetagammaM3 : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) <= 3).
{
	try assert(HPsQsalphabetaeq : rk(Ps :: Qs :: alpha :: beta :: nil) = 3) by (apply LPsQsalphabeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsQsalphabetaMtmp : rk(Ps :: Qs :: alpha :: beta :: nil) <= 3) by (solve_hyps_max HPsQsalphabetaeq HPsQsalphabetaM3).
	try assert(HPsQsgammaeq : rk(Ps :: Qs :: gamma :: nil) = 2) by (apply LPsQsgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsQsgammaMtmp : rk(Ps :: Qs :: gamma :: nil) <= 2) by (solve_hyps_max HPsQsgammaeq HPsQsgammaM2).
	try assert(HPsQseq : rk(Ps :: Qs :: nil) = 2) by (apply LPsQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsQsmtmp : rk(Ps :: Qs :: nil) >= 2) by (solve_hyps_min HPsQseq HPsQsm2).
	assert(Hincl : incl (Ps :: Qs :: nil) (list_inter (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ps :: Qs :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: Ps :: Qs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ps :: Qs :: alpha :: beta :: Ps :: Qs :: gamma :: nil) ((Ps :: Qs :: alpha :: beta :: nil) ++ (Ps :: Qs :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ps :: Qs :: alpha :: beta :: nil) (Ps :: Qs :: gamma :: nil) (Ps :: Qs :: nil) 3 2 2 HPsQsalphabetaMtmp HPsQsgammaMtmp HPsQsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HPsQsM1. try clear HPsQsM2. try clear HPsQsM3. try clear HPsQsm4. try clear HPsQsm3. try clear HPsQsm2. try clear HPsQsm1. 

assert(HPsQsalphabetagammaM : rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPsQsalphabetagammam : rk(Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPsQsalphabetagammaeq HPsQsalphabetagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LPPsQsalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpalphabetagamma requis par la preuve de (?)PQPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsalphabetagamma requis par la preuve de (?)PQPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpalphabetagammaeq HPQPpPsQsOpalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpalphabetagammaM1. try clear HPQPpPsQsOpalphabetagammaM2. try clear HPQPpPsQsOpalphabetagammaM3. try clear HPQPpPsQsOpalphabetagammam4. try clear HPQPpPsQsOpalphabetagammam3. try clear HPQPpPsQsOpalphabetagammam2. try clear HPQPpPsQsOpalphabetagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps ::  de rang :  1 et 1 	 A : Pp :: Ps :: Sc ::   de rang : 2 et 2 *)
assert(HPQPsQsalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPpPsSceq : rk(Pp :: Ps :: Sc :: nil) = 2) by (apply LPpPsSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPpPsScMtmp : rk(Pp :: Ps :: Sc :: nil) <= 2) by (solve_hyps_max HPpPsSceq HPpPsScM2).
	assert(HPQPpPsQsScalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPpPsQsScalphabetagammaeq HPQPpPsQsScalphabetagammam4).
	try assert(HPseq : rk(Ps :: nil) = 1) by (apply LPs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsmtmp : rk(Ps :: nil) >= 1) by (solve_hyps_min HPseq HPsm1).
	assert(Hincl : incl (Ps :: nil) (list_inter (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Ps :: Sc :: P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Pp :: Ps :: Sc :: nil) ++ (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsScalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsScalphabetagammamtmp.
	assert(HT := rule_4 (Pp :: Ps :: Sc :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Ps :: nil) 4 1 2 HPQPpPsQsScalphabetagammamtmp HPsmtmp HPpPsScMtmp Hincl); apply HT.
}
try clear HPQPpPsQsScalphabetagammaM1. try clear HPQPpPsQsScalphabetagammaM2. try clear HPQPpPsQsScalphabetagammaM3. try clear HPQPpPsQsScalphabetagammam4. try clear HPQPpPsQsScalphabetagammam3. try clear HPQPpPsQsScalphabetagammam2. try clear HPQPpPsQsScalphabetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQPsalphaeq : rk(P :: Q :: Ps :: alpha :: nil) = 4) by (apply LPQPsalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsalphamtmp : rk(P :: Q :: Ps :: alpha :: nil) >= 4) by (solve_hyps_min HPQPsalphaeq HPQPsalpham4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Ps :: alpha :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Ps :: alpha :: nil) (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) 4 4 HPQPsalphamtmp Hcomp Hincl);apply HT.
}


assert(HPQPsQsalphabetagammaM : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsalphabetagammam : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsalphabetagammaeq HPQPsQsalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPsQsalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpPsQsOpalphabetagamma requis par la preuve de (?)PRPpPsQsOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpPsQsOpalphabetagammam3 : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRPpeq : rk(P :: R :: Pp :: nil) = 3) by (apply LPRPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRPpmtmp : rk(P :: R :: Pp :: nil) >= 3) by (solve_hyps_min HPRPpeq HPRPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: R :: Pp :: nil) (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) 3 3 HPRPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPsQsalphabetagamma requis par la preuve de (?)PRPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam2 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPRPpPsQsOpalphabetagammamtmp : rk(P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPpPsQsOpalphabetagammaeq HPRPpPsQsOpalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Ps :: Qs :: Op :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpPsQsOpalphabetagammamtmp;try rewrite HT2 in HPRPpPsQsOpalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPRPpPsQsOpalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPRPpPsQsOpalphabetagammaM1. try clear HPRPpPsQsOpalphabetagammaM2. try clear HPRPpPsQsOpalphabetagammaM3. try clear HPRPpPsQsOpalphabetagammam4. try clear HPRPpPsQsOpalphabetagammam3. try clear HPRPpPsQsOpalphabetagammam2. try clear HPRPpPsQsOpalphabetagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPRPsQsalphabetagammam3 : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphabetagammaM1. try clear HPQPpPsQsOpOoalphabetagammaM2. try clear HPQPpPsQsOpOoalphabetagammaM3. try clear HPQPpPsQsOpOoalphabetagammam4. try clear HPQPpPsQsOpOoalphabetagammam3. try clear HPQPpPsQsOpOoalphabetagammam2. try clear HPQPpPsQsOpOoalphabetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPsQsalphabetagamma requis par la preuve de (?)PPsQsalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : Qs ::  de rang :  1 et 1 	 A : Q :: Qs :: Oo ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam2 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HQQsOoeq : rk(Q :: Qs :: Oo :: nil) = 2) by (apply LQQsOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQsOoMtmp : rk(Q :: Qs :: Oo :: nil) <= 2) by (solve_hyps_max HQQsOoeq HQQsOoM2).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam3).
	try assert(HQseq : rk(Qs :: nil) = 1) by (apply LQs with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQsmtmp : rk(Qs :: nil) >= 1) by (solve_hyps_min HQseq HQsm1).
	assert(Hincl : incl (Qs :: nil) (list_inter (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Q :: Qs :: Oo :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qs :: Oo :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((Q :: Qs :: Oo :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qs :: Oo :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (Qs :: nil) 3 1 2 HPQPsQsOoalphabetagammamtmp HQsmtmp HQQsOoMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: R :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam3 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPRPsQsalphabetagammamtmp : rk(P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPRPsQsalphabetagammaeq HPRPsQsalphabetagammam3).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPsQsalphabetagammamtmp;try rewrite HT2 in HPRPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 3 2 2 HPRPsQsalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: gamma ::  de rang :  2 et 2 	 A : P :: Q :: gamma ::   de rang : 2 et 2 *)
assert(HPPsQsalphabetagammam4 : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQgammaeq : rk(P :: Q :: gamma :: nil) = 2) by (apply LPQgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQgammaMtmp : rk(P :: Q :: gamma :: nil) <= 2) by (solve_hyps_max HPQgammaeq HPQgammaM2).
	try assert(HPQPsQsalphabetagammaeq : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsalphabetagammaeq HPQPsQsalphabetagammam4).
	try assert(HPgammaeq : rk(P :: gamma :: nil) = 2) by (apply LPgamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPgammamtmp : rk(P :: gamma :: nil) >= 2) by (solve_hyps_min HPgammaeq HPgammam2).
	assert(Hincl : incl (P :: gamma :: nil) (list_inter (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: Q :: gamma :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: gamma :: P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: Q :: gamma :: nil) ++ (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsalphabetagammamtmp;try rewrite HT2 in HPQPsQsalphabetagammamtmp.
	assert(HT := rule_4 (P :: Q :: gamma :: nil) (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: gamma :: nil) 4 2 2 HPQPsQsalphabetagammamtmp HPgammamtmp HPQgammaMtmp Hincl); apply HT.
}


assert(HPPsQsalphabetagammaM : rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPsQsalphabetagammam : rk(P :: Ps :: Qs :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPPsQsalphabetagammaeq HPPsQsalphabetagammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPsQsOoalphabetagamma *)
(* dans constructLemma(), requis par LPQPsQsOoalphabetagamma *)
(* dans la couche 0 *)
Lemma LPQRPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPsQsOoalphabetagamma requis par la preuve de (?)PQRPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam3 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPsQsOoalphabetagammam4 : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQROoeq : rk(P :: Q :: R :: Oo :: nil) = 4) by (apply LPQROo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQROomtmp : rk(P :: Q :: R :: Oo :: nil) >= 4) by (solve_hyps_min HPQROoeq HPQROom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Oo :: nil) (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 4 4 HPQROomtmp Hcomp Hincl);apply HT.
}


assert(HPQRPsQsOoalphabetagammaM : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPsQsOoalphabetagammam : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsOpOoalphabetagamma requis par la preuve de (?)PQPpPsQsOpOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsOpOoalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPsQsOoalphabetagamma requis par la preuve de (?)PQPsQsOoalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: Pp :: Op ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam2 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HPPpOpeq : rk(P :: Pp :: Op :: nil) = 2) by (apply LPPpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPpOpMtmp : rk(P :: Pp :: Op :: nil) <= 2) by (solve_hyps_max HPPpOpeq HPPpOpM2).
	assert(HPQPpPsQsOpOoalphabetagammamtmp : rk(P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQPpPsQsOpOoalphabetagammaeq HPQPpPsQsOpOoalphabetagammam3).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Pp :: Ps :: Qs :: Op :: Oo :: alpha :: beta :: gamma :: nil) (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Op :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Pp :: Op :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPpPsQsOpOoalphabetagammamtmp;try rewrite HT2 in HPQPpPsQsOpOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Pp :: Op :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: nil) 3 1 2 HPQPpPsQsOpOoalphabetagammamtmp HPmtmp HPPpOpMtmp Hincl); apply HT.
}
try clear HPQPpPsQsOpOoalphabetagammaM1. try clear HPQPpPsQsOpOoalphabetagammaM2. try clear HPQPpPsQsOpOoalphabetagammaM3. try clear HPQPpPsQsOpOoalphabetagammam4. try clear HPQPpPsQsOpOoalphabetagammam3. try clear HPQPpPsQsOpOoalphabetagammam2. try clear HPQPpPsQsOpOoalphabetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPsQsOoalphabetagammam3 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQOoeq : rk(P :: Q :: Oo :: nil) = 3) by (apply LPQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQOomtmp : rk(P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HPQOoeq HPQOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Oo :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 3 3 HPQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : P :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HPQPsQsOoalphabetagammam4 : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphabetagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(HPalphaeq : rk(P :: alpha :: nil) = 2) by (apply LPalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphamtmp : rk(P :: alpha :: nil) >= 2) by (solve_hyps_min HPalphaeq HPalpham2).
	assert(Hincl : incl (P :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: alpha :: nil) 4 2 2 HPQRPsQsOoalphabetagammamtmp HPalphamtmp HPRalphaMtmp Hincl); apply HT.
}


assert(HPQPsQsOoalphabetagammaM : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPsQsOoalphabetagammam : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPsQsOoalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPsQsOoalphabetagamma requis par la preuve de (?)QPsQsOoalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPsQsOoalphabetagammam2 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HQOoeq : rk(Q :: Oo :: nil) = 2) by (apply LQOo with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQOomtmp : rk(Q :: Oo :: nil) >= 2) by (solve_hyps_min HQOoeq HQOom2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: Oo :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) 2 2 HQOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQPsQsOoalphabetagammam3 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	try assert(HPQRPsQsOoalphabetagammaeq : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQRPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRPsQsOoalphabetagammamtmp : rk(P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQRPsQsOoalphabetagammaeq HPQRPsQsOoalphabetagammam4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQRPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (alpha :: nil) 4 1 2 HPQRPsQsOoalphabetagammamtmp Halphamtmp HPRalphaMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  de rang :  4 et 4 	 AiB : Ps :: Oo :: alpha ::  de rang :  3 et 3 	 A : P :: Ps :: Oo :: alpha ::   de rang : 3 et 3 *)
assert(HQPsQsOoalphabetagammam4 : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPPsOoalphaeq : rk(P :: Ps :: Oo :: alpha :: nil) = 3) by (apply LPPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsOoalphaMtmp : rk(P :: Ps :: Oo :: alpha :: nil) <= 3) by (solve_hyps_max HPPsOoalphaeq HPPsOoalphaM3).
	try assert(HPQPsQsOoalphabetagammaeq : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) = 4) by (apply LPQPsQsOoalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPsQsOoalphabetagammamtmp : rk(P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPQPsQsOoalphabetagammaeq HPQPsQsOoalphabetagammam4).
	try assert(HPsOoalphaeq : rk(Ps :: Oo :: alpha :: nil) = 3) by (apply LPsOoalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsOoalphamtmp : rk(Ps :: Oo :: alpha :: nil) >= 3) by (solve_hyps_min HPsOoalphaeq HPsOoalpham3).
	assert(Hincl : incl (Ps :: Oo :: alpha :: nil) (list_inter (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Ps :: Oo :: alpha :: Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) ((P :: Ps :: Oo :: alpha :: nil) ++ (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQPsQsOoalphabetagammamtmp;try rewrite HT2 in HPQPsQsOoalphabetagammamtmp.
	assert(HT := rule_4 (P :: Ps :: Oo :: alpha :: nil) (Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma :: nil) (Ps :: Oo :: alpha :: nil) 4 3 3 HPQPsQsOoalphabetagammamtmp HPsOoalphamtmp HPPsOoalphaMtmp Hincl); apply HT.
}


assert(HQPsQsOoalphabetagammaM : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPsQsOoalphabetagammam : rk(Q :: Ps :: Qs :: Oo :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HQPsQsOoalphabetagammaeq HQPsQsOoalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQPpPsQsScalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) = 4.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQPpPsQsScalphabetagamma requis par la preuve de (?)PQPpPsQsScalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam3 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQPpeq : rk(P :: Q :: Pp :: nil) = 3) by (apply LPQPp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpmtmp : rk(P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HPQPpeq HPQPpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 3 3 HPQPpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQPpPsQsScalphabetagammam4 : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) >= 4).
{
	try assert(HPQPpSceq : rk(P :: Q :: Pp :: Sc :: nil) = 4) by (apply LPQPpSc with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQPpScmtmp : rk(P :: Q :: Pp :: Sc :: nil) >= 4) by (solve_hyps_min HPQPpSceq HPQPpScm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: Pp :: Sc :: nil) (P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma :: nil) 4 4 HPQPpScmtmp Hcomp Hincl);apply HT.
}


assert(HPQPpPsQsScalphabetagammaM : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQPpPsQsScalphabetagammam : rk(P :: Q :: Pp :: Ps :: Qs :: Sc :: alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HPQPpPsQsScalphabetagammaeq HPQPpPsQsScalphabetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lalphabetagamma : forall P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma ,
rk(P :: Q :: R ::  nil) = 3 -> rk(P :: Q :: Pp ::  nil) = 3 -> rk(P :: R :: Pp ::  nil) = 3 ->
rk(Q :: R :: Pp ::  nil) = 3 -> rk(P :: Q :: Qp ::  nil) = 3 -> rk(P :: R :: Qp ::  nil) = 3 ->
rk(Q :: R :: Qp ::  nil) = 3 -> rk(P :: Pp :: Qp ::  nil) = 3 -> rk(Q :: Pp :: Qp ::  nil) = 3 ->
rk(R :: Pp :: Qp ::  nil) = 3 -> rk(P :: Q :: Rp ::  nil) = 3 -> rk(P :: R :: Rp ::  nil) = 3 ->
rk(Q :: R :: Rp ::  nil) = 3 -> rk(P :: Pp :: Rp ::  nil) = 3 -> rk(Q :: Pp :: Rp ::  nil) = 3 ->
rk(R :: Pp :: Rp ::  nil) = 3 -> rk(P :: Qp :: Rp ::  nil) = 3 -> rk(Q :: Qp :: Rp ::  nil) = 3 ->
rk(R :: Qp :: Rp ::  nil) = 3 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(P :: Q :: Op ::  nil) = 3 ->
rk(P :: R :: Op ::  nil) = 3 -> rk(Q :: R :: Op ::  nil) = 3 -> rk(P :: Pp :: Op ::  nil) = 2 ->
rk(Q :: Pp :: Op ::  nil) = 3 -> rk(R :: Pp :: Op ::  nil) = 3 -> rk(P :: Qp :: Op ::  nil) = 3 ->
rk(Q :: Qp :: Op ::  nil) = 2 -> rk(R :: Qp :: Op ::  nil) = 3 -> rk(Pp :: Qp :: Op ::  nil) = 3 ->
rk(P :: Rp :: Op ::  nil) = 3 -> rk(Q :: Rp :: Op ::  nil) = 3 -> rk(R :: Rp :: Op ::  nil) = 2 ->
rk(Pp :: Rp :: Op ::  nil) = 3 -> rk(Qp :: Rp :: Op ::  nil) = 3 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Op ::  nil) = 3 ->
rk(P :: Q :: R :: Oo ::  nil) = 4 -> rk(P :: Ps :: Oo ::  nil) = 2 -> rk(Q :: Qs :: Oo ::  nil) = 2 ->
rk(R :: Rs :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Sc ::  nil) = 4 -> rk(Pp :: Ps :: Sc ::  nil) = 2 ->
rk(Qp :: Qs :: Sc ::  nil) = 2 -> rk(Rp :: Rs :: Sc ::  nil) = 2 -> rk(Oo :: Sc ::  nil) = 2 ->
rk(Op :: Oo :: Sc ::  nil) = 2 -> rk(P :: R :: alpha ::  nil) = 2 -> rk(Pp :: Rp :: alpha ::  nil) = 2 ->
rk(Q :: R :: beta ::  nil) = 2 -> rk(Qp :: Rp :: beta ::  nil) = 2 -> rk(P :: Q :: gamma ::  nil) = 2 ->
rk(Pp :: Qp :: gamma ::  nil) = 2 -> rk(alpha :: beta :: gamma ::  nil) = 2.
Proof.

intros P Q R Pp Qp Rp Ps Qs Rs Op Oo Sc alpha beta gamma 
HPQReq HPQPpeq HPRPpeq HQRPpeq HPQQpeq HPRQpeq HQRQpeq HPPpQpeq HQPpQpeq HRPpQpeq
HPQRpeq HPRRpeq HQRRpeq HPPpRpeq HQPpRpeq HRPpRpeq HPQpRpeq HQQpRpeq HRQpRpeq HPpQpRpeq
HPQOpeq HPROpeq HQROpeq HPPpOpeq HQPpOpeq HRPpOpeq HPQpOpeq HQQpOpeq HRQpOpeq HPpQpOpeq
HPRpOpeq HQRpOpeq HRRpOpeq HPpRpOpeq HQpRpOpeq HPQRPpQpRpOpeq HPQROoeq HPPsOoeq HQQsOoeq HRRsOoeq
HPQRSceq HPpPsSceq HQpQsSceq HRpRsSceq HOoSceq HOpOoSceq HPRalphaeq HPpRpalphaeq HQRbetaeq HQpRpbetaeq
HPQgammaeq HPpQpgammaeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour alphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRalphabetagamma requis par la preuve de (?)PQRalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRalphabetagammam3 : rk(P :: Q :: R :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPQReq : rk(P :: Q :: R :: nil) = 3) by (apply LPQR with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: alpha :: beta :: gamma :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpOpalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpOpalphabetagamma requis par la preuve de (?)QRQpOpalphabetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQRQpOpalphabetagammam3 : rk(Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HQRQpeq : rk(Q :: R :: Qp :: nil) = 3) by (apply LQRQp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRQpmtmp : rk(Q :: R :: Qp :: nil) >= 3) by (solve_hyps_min HQRQpeq HQRQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Q :: R :: Qp :: nil) (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) 3 3 HQRQpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRalphabetagamma requis par la preuve de (?)QRalphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: Op :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : Q ::  de rang :  1 et 1 	 A : Q :: Qp :: Op ::   de rang : 2 et 2 *)
assert(HQRalphabetagammam2 : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HQQpOpeq : rk(Q :: Qp :: Op :: nil) = 2) by (apply LQQpOp with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQQpOpMtmp : rk(Q :: Qp :: Op :: nil) <= 2) by (solve_hyps_max HQQpOpeq HQQpOpM2).
	assert(HQRQpOpalphabetagammamtmp : rk(Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HQRQpOpalphabetagammaeq HQRQpOpalphabetagammam3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Q :: Qp :: Op :: nil) (Q :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Op :: alpha :: beta :: gamma :: nil) (Q :: Qp :: Op :: Q :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Op :: Q :: R :: alpha :: beta :: gamma :: nil) ((Q :: Qp :: Op :: nil) ++ (Q :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpOpalphabetagammamtmp;try rewrite HT2 in HQRQpOpalphabetagammamtmp.
	assert(HT := rule_4 (Q :: Qp :: Op :: nil) (Q :: R :: alpha :: beta :: gamma :: nil) (Q :: nil) 3 1 2 HQRQpOpalphabetagammamtmp HQmtmp HQQpOpMtmp Hincl); apply HT.
}
try clear HQRQpOpalphabetagammaM1. try clear HQRQpOpalphabetagammaM2. try clear HQRQpOpalphabetagammaM3. try clear HQRQpOpalphabetagammam4. try clear HQRQpOpalphabetagammam3. try clear HQRQpOpalphabetagammam2. try clear HQRQpOpalphabetagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : R :: alpha ::  de rang :  2 et 2 	 A : P :: R :: alpha ::   de rang : 2 et 2 *)
assert(HQRalphabetagammam3 : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 3).
{
	try assert(HPRalphaeq : rk(P :: R :: alpha :: nil) = 2) by (apply LPRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPRalphaMtmp : rk(P :: R :: alpha :: nil) <= 2) by (solve_hyps_max HPRalphaeq HPRalphaM2).
	assert(HPQRalphabetagammamtmp : rk(P :: Q :: R :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HPQRalphabetagammaeq HPQRalphabetagammam3).
	try assert(HRalphaeq : rk(R :: alpha :: nil) = 2) by (apply LRalpha with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HRalphamtmp : rk(R :: alpha :: nil) >= 2) by (solve_hyps_min HRalphaeq HRalpham2).
	assert(Hincl : incl (R :: alpha :: nil) (list_inter (P :: R :: alpha :: nil) (Q :: R :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: alpha :: beta :: gamma :: nil) (P :: R :: alpha :: Q :: R :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: alpha :: Q :: R :: alpha :: beta :: gamma :: nil) ((P :: R :: alpha :: nil) ++ (Q :: R :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRalphabetagammamtmp;try rewrite HT2 in HPQRalphabetagammamtmp.
	assert(HT := rule_4 (P :: R :: alpha :: nil) (Q :: R :: alpha :: beta :: gamma :: nil) (R :: alpha :: nil) 3 2 2 HPQRalphabetagammamtmp HRalphamtmp HPRalphaMtmp Hincl); apply HT.
}
try clear HRalphaM1. try clear HRalphaM2. try clear HRalphaM3. try clear HRalpham4. try clear HRalpham3. try clear HRalpham2. try clear HRalpham1. try clear HPQRalphabetagammaM1. try clear HPQRalphabetagammaM2. try clear HPQRalphabetagammaM3. try clear HPQRalphabetagammam4. try clear HPQRalphabetagammam3. try clear HPQRalphabetagammam2. try clear HPQRalphabetagammam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour alphabetagamma requis par la preuve de (?)alphabetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: R :: alpha :: beta :: gamma ::  de rang :  3 et 4 	 AiB : beta ::  de rang :  1 et 1 	 A : Q :: R :: beta ::   de rang : 2 et 2 *)
assert(Halphabetagammam2 : rk(alpha :: beta :: gamma :: nil) >= 2).
{
	try assert(HQRbetaeq : rk(Q :: R :: beta :: nil) = 2) by (apply LQRbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HQRbetaMtmp : rk(Q :: R :: beta :: nil) <= 2) by (solve_hyps_max HQRbetaeq HQRbetaM2).
	assert(HQRalphabetagammamtmp : rk(Q :: R :: alpha :: beta :: gamma :: nil) >= 3) by (solve_hyps_min HQRalphabetagammaeq HQRalphabetagammam3).
	try assert(Hbetaeq : rk(beta :: nil) = 1) by (apply Lbeta with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(Hbetamtmp : rk(beta :: nil) >= 1) by (solve_hyps_min Hbetaeq Hbetam1).
	assert(Hincl : incl (beta :: nil) (list_inter (Q :: R :: beta :: nil) (alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: alpha :: beta :: gamma :: nil) (Q :: R :: beta :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: R :: beta :: alpha :: beta :: gamma :: nil) ((Q :: R :: beta :: nil) ++ (alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRalphabetagammamtmp;try rewrite HT2 in HQRalphabetagammamtmp.
	assert(HT := rule_4 (Q :: R :: beta :: nil) (alpha :: beta :: gamma :: nil) (beta :: nil) 3 1 2 HQRalphabetagammamtmp Hbetamtmp HQRbetaMtmp Hincl); apply HT.
}
try clear HQRalphabetagammaM1. try clear HQRalphabetagammaM2. try clear HQRalphabetagammaM3. try clear HQRalphabetagammam4. try clear HQRalphabetagammam3. try clear HQRalphabetagammam2. try clear HQRalphabetagammam1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HalphabetagammaM2 : rk(alpha :: beta :: gamma :: nil) <= 2).
{
	try assert(HPalphabetagammaeq : rk(P :: alpha :: beta :: gamma :: nil) = 3) by (apply LPalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPalphabetagammaMtmp : rk(P :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPalphabetagammaeq HPalphabetagammaM3).
	try assert(HPsQsalphabetagammaeq : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) = 3) by (apply LPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPsQsalphabetagammaMtmp : rk(Ps :: Qs :: alpha :: beta :: gamma :: nil) <= 3) by (solve_hyps_max HPsQsalphabetagammaeq HPsQsalphabetagammaM3).
	try assert(HPPsQsalphabetagammaeq : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) = 4) by (apply LPPsQsalphabetagamma with (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (Ps := Ps) (Qs := Qs) (Rs := Rs) (Op := Op) (Oo := Oo) (Sc := Sc) (alpha := alpha) (beta := beta) (gamma := gamma) ;try assumption).
	assert(HPPsQsalphabetagammamtmp : rk(P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HPPsQsalphabetagammaeq HPPsQsalphabetagammam4).
	assert(Hincl : incl (alpha :: beta :: gamma :: nil) (list_inter (P :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Ps :: Qs :: alpha :: beta :: gamma :: nil) (P :: alpha :: beta :: gamma :: Ps :: Qs :: alpha :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: alpha :: beta :: gamma :: Ps :: Qs :: alpha :: beta :: gamma :: nil) ((P :: alpha :: beta :: gamma :: nil) ++ (Ps :: Qs :: alpha :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPsQsalphabetagammamtmp;try rewrite HT2 in HPPsQsalphabetagammamtmp.
	assert(HT := rule_3 (P :: alpha :: beta :: gamma :: nil) (Ps :: Qs :: alpha :: beta :: gamma :: nil) (alpha :: beta :: gamma :: nil) 3 3 4 HPalphabetagammaMtmp HPsQsalphabetagammaMtmp HPPsQsalphabetagammamtmp Hincl);apply HT.
}


assert(HalphabetagammaM : rk(alpha :: beta :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Halphabetagammaeq HalphabetagammaM3).
assert(Halphabetagammam : rk(alpha :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min Halphabetagammaeq Halphabetagammam1).
intuition.
Qed.

