Load "preamble3D.v".


(* dans la couche 0 *)
Lemma LAQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AQ requis par la preuve de (?)AQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HAQm2 : rk(A :: Q :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: nil) (A :: B :: A :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: Q :: nil) ((A :: B :: nil) ++ (A :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQmtmp;try rewrite HT2 in HABQmtmp.
	assert(HT := rule_4 (A :: B :: nil) (A :: Q :: nil) (A :: nil) 3 1 2 HABQmtmp HAmtmp HABMtmp Hincl); apply HT.
}

assert(HAQM : rk(A :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAQeq HAQM2).
assert(HAQm : rk(A :: Q ::  nil) >= 1) by (solve_hyps_min HAQeq HAQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BQ requis par la preuve de (?)BQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HBQm2 : rk(B :: Q :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (B :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: nil) (A :: B :: B :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: B :: Q :: nil) ((A :: B :: nil) ++ (B :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQmtmp;try rewrite HT2 in HABQmtmp.
	assert(HT := rule_4 (A :: B :: nil) (B :: Q :: nil) (B :: nil) 3 1 2 HABQmtmp HBmtmp HABMtmp Hincl); apply HT.
}

assert(HBQM : rk(B :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBQeq HBQM2).
assert(HBQm : rk(B :: Q ::  nil) >= 1) by (solve_hyps_min HBQeq HBQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCQ *)
(* dans la couche 0 *)
Lemma LABCQDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQDDp requis par la preuve de (?)ABCQDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQDDp requis par la preuve de (?)ABCQDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQDDp requis par la preuve de (?)ABCQDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQDDpm2 : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCQDDpM3 : rk(A :: B :: C :: Q :: D :: Dp :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: D :: Dp :: nil) (Q :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: A :: B :: C :: D :: Dp :: nil) ((Q :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (A :: B :: C :: D :: Dp :: nil) (nil) 1 2 0 HQMtmp HABCDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQDDpm3 : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: D :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABCQDDpM : rk(A :: B :: C :: Q :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQDDpm : rk(A :: B :: C :: Q :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCQDDpeq HABCQDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CQ requis par la preuve de (?)CQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCQm2 : rk(C :: Q :: nil) >= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQDDpeq : rk(A :: B :: C :: Q :: D :: Dp :: nil) = 3) by (apply LABCQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQDDpmtmp : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQDDpeq HABCQDDpm3).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: D :: Dp :: nil) (C :: Q :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Q :: A :: B :: C :: D :: Dp :: nil) ((C :: Q :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQDDpmtmp;try rewrite HT2 in HABCQDDpmtmp.
	assert(HT := rule_2 (C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil) (C :: nil) 3 1 2 HABCQDDpmtmp HCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HCQM : rk(C :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCQeq HCQM2).
assert(HCQm : rk(C :: Q ::  nil) >= 1) by (solve_hyps_min HCQeq HCQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACQ requis par la preuve de (?)ACQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACQ requis par la preuve de (?)ACQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQm2 : rk(A :: C :: Q :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HACQm3 : rk(A :: C :: Q :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQDDpeq : rk(A :: B :: C :: Q :: D :: Dp :: nil) = 3) by (apply LABCQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQDDpmtmp : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQDDpeq HABCQDDpm3).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: D :: Dp :: nil) (A :: C :: Q :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Q :: A :: B :: C :: D :: Dp :: nil) ((A :: C :: Q :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQDDpmtmp;try rewrite HT2 in HABCQDDpmtmp.
	assert(HT := rule_2 (A :: C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil) (A :: C :: nil) 3 2 2 HABCQDDpmtmp HACmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HACQM : rk(A :: C :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACQeq HACQM3).
assert(HACQm : rk(A :: C :: Q ::  nil) >= 1) by (solve_hyps_min HACQeq HACQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCQ requis par la preuve de (?)BCQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCQ requis par la preuve de (?)BCQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQm2 : rk(B :: C :: Q :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HBCQm3 : rk(B :: C :: Q :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQDDpeq : rk(A :: B :: C :: Q :: D :: Dp :: nil) = 3) by (apply LABCQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQDDpmtmp : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQDDpeq HABCQDDpm3).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (B :: C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: D :: Dp :: nil) (B :: C :: Q :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Q :: A :: B :: C :: D :: Dp :: nil) ((B :: C :: Q :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQDDpmtmp;try rewrite HT2 in HABCQDDpmtmp.
	assert(HT := rule_2 (B :: C :: Q :: nil) (A :: B :: C :: D :: Dp :: nil) (B :: C :: nil) 3 2 2 HABCQDDpmtmp HBCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HBCQM : rk(B :: C :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCQeq HBCQM3).
assert(HBCQm : rk(B :: C :: Q ::  nil) >= 1) by (solve_hyps_min HBCQeq HBCQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQ requis par la preuve de (?)ABCQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQ requis par la preuve de (?)ABCQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQ requis par la preuve de (?)ABCQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQm2 : rk(A :: B :: C :: Q :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABCQM3 : rk(A :: B :: C :: Q :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: C :: nil) (Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: nil) (A :: B :: C :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: nil) ((A :: B :: C :: nil) ++ (Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (Q :: nil) (nil) 2 1 0 HABCMtmp HQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQm3 : rk(A :: B :: C :: Q :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABCQM : rk(A :: B :: C :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQm : rk(A :: B :: C :: Q ::  nil) >= 1) by (solve_hyps_min HABCQeq HABCQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPQ *)
(* dans la couche 0 *)
Lemma LABCPQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: Q ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCPQ requis par la preuve de (?)ABCPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQ requis par la preuve de (?)ABCPQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQ requis par la preuve de (?)ABCPQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQm2 : rk(A :: B :: C :: P :: Q :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCPQM3 : rk(A :: B :: C :: P :: Q :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: B :: C :: nil) (C :: P :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: nil) (A :: B :: C :: C :: P :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: C :: P :: Q :: nil) ((A :: B :: C :: nil) ++ (C :: P :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (C :: P :: Q :: nil) (C :: nil) 2 2 1 HABCMtmp HCPQMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQm3 : rk(A :: B :: C :: P :: Q :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABCPQM : rk(A :: B :: C :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPQm : rk(A :: B :: C :: P :: Q ::  nil) >= 1) by (solve_hyps_min HABCPQeq HABCPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQ : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQ requis par la preuve de (?)ABPQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQ requis par la preuve de (?)ABPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQ requis par la preuve de (?)ABPQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQm2 : rk(A :: B :: P :: Q :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQm3 : rk(A :: B :: P :: Q :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQM3 : rk(A :: B :: P :: Q :: nil) <= 3).
{
	assert(HABCPQeq : rk(A :: B :: C :: P :: Q :: nil) = 3) by (apply LABCPQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPQMtmp : rk(A :: B :: C :: P :: Q :: nil) <= 3) by (solve_hyps_max HABCPQeq HABCPQM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: P :: Q :: nil) (A :: B :: C :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: P :: Q :: nil) (A :: B :: C :: P :: Q :: nil) 3 3 HABCPQMtmp Hcomp Hincl);apply HT.
}

assert(HABPQM : rk(A :: B :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQm : rk(A :: B :: P :: Q ::  nil) >= 1) by (solve_hyps_min HABPQeq HABPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AR requis par la preuve de (?)AR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HARm2 : rk(A :: R :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: nil) (A :: B :: A :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: R :: nil) ((A :: B :: nil) ++ (A :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRmtmp;try rewrite HT2 in HABRmtmp.
	assert(HT := rule_4 (A :: B :: nil) (A :: R :: nil) (A :: nil) 3 1 2 HABRmtmp HAmtmp HABMtmp Hincl); apply HT.
}

assert(HARM : rk(A :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAReq HARM2).
assert(HARm : rk(A :: R ::  nil) >= 1) by (solve_hyps_min HAReq HARm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BR requis par la preuve de (?)BR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HBRm2 : rk(B :: R :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (B :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: nil) (A :: B :: B :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: B :: R :: nil) ((A :: B :: nil) ++ (B :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRmtmp;try rewrite HT2 in HABRmtmp.
	assert(HT := rule_4 (A :: B :: nil) (B :: R :: nil) (B :: nil) 3 1 2 HABRmtmp HBmtmp HABMtmp Hincl); apply HT.
}

assert(HBRM : rk(B :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBReq HBRM2).
assert(HBRm : rk(B :: R ::  nil) >= 1) by (solve_hyps_min HBReq HBRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCR *)
(* dans la couche 0 *)
Lemma LABCRDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: R :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCRDDp requis par la preuve de (?)ABCRDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRDDp requis par la preuve de (?)ABCRDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRDDp requis par la preuve de (?)ABCRDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRDDpm2 : rk(A :: B :: C :: R :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCRDDpM3 : rk(A :: B :: C :: R :: D :: Dp :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: D :: Dp :: nil) (R :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: A :: B :: C :: D :: Dp :: nil) ((R :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (A :: B :: C :: D :: Dp :: nil) (nil) 1 2 0 HRMtmp HABCDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRDDpm3 : rk(A :: B :: C :: R :: D :: Dp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: D :: Dp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

assert(HABCRDDpM : rk(A :: B :: C :: R :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCRDDpm : rk(A :: B :: C :: R :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCRDDpeq HABCRDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCR requis par la preuve de (?)BCR pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCR requis par la preuve de (?)BCR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRm2 : rk(B :: C :: R :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HBCRm3 : rk(B :: C :: R :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCRDDpeq : rk(A :: B :: C :: R :: D :: Dp :: nil) = 3) by (apply LABCRDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRDDpmtmp : rk(A :: B :: C :: R :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCRDDpeq HABCRDDpm3).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (B :: C :: R :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: D :: Dp :: nil) (B :: C :: R :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: R :: A :: B :: C :: D :: Dp :: nil) ((B :: C :: R :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRDDpmtmp;try rewrite HT2 in HABCRDDpmtmp.
	assert(HT := rule_2 (B :: C :: R :: nil) (A :: B :: C :: D :: Dp :: nil) (B :: C :: nil) 3 2 2 HABCRDDpmtmp HBCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HBCRM : rk(B :: C :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCReq HBCRM3).
assert(HBCRm : rk(B :: C :: R ::  nil) >= 1) by (solve_hyps_min HBCReq HBCRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCR requis par la preuve de (?)ABCR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCR requis par la preuve de (?)ABCR pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCR requis par la preuve de (?)ABCR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRm2 : rk(A :: B :: C :: R :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABCRM3 : rk(A :: B :: C :: R :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: C :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: nil) (A :: B :: C :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: nil) ((A :: B :: C :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (R :: nil) (nil) 2 1 0 HABCMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRm3 : rk(A :: B :: C :: R :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

assert(HABCRM : rk(A :: B :: C :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCRm : rk(A :: B :: C :: R ::  nil) >= 1) by (solve_hyps_min HABCReq HABCRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABPR requis par la preuve de (?)ABPR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABPR requis par la preuve de (?)ABPR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPR requis par la preuve de (?)ABPR pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABPRM3 : rk(A :: B :: P :: R :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: P :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: nil) (A :: B :: P :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: R :: nil) ((A :: nil) ++ (B :: P :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: P :: R :: nil) (nil) 1 2 0 HAMtmp HBPRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRm2 : rk(A :: B :: P :: R :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRm3 : rk(A :: B :: P :: R :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

assert(HABPRM : rk(A :: B :: P :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRm : rk(A :: B :: P :: R ::  nil) >= 1) by (solve_hyps_min HABPReq HABPRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCPR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCPR requis par la preuve de (?)ABCPR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPR requis par la preuve de (?)ABCPR pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPR requis par la preuve de (?)ABCPR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRm2 : rk(A :: B :: C :: P :: R :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCPRM3 : rk(A :: B :: C :: P :: R :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: C :: nil) (B :: P :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: R :: nil) (A :: B :: C :: B :: P :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: B :: P :: R :: nil) ((A :: B :: C :: nil) ++ (B :: P :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (B :: P :: R :: nil) (B :: nil) 2 2 1 HABCMtmp HBPRMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRm3 : rk(A :: B :: C :: P :: R :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: P :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: P :: R :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

assert(HABCPRM : rk(A :: B :: C :: P :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPRm : rk(A :: B :: C :: P :: R ::  nil) >= 1) by (solve_hyps_min HABCPReq HABCPRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCQR *)
(* dans la couche 0 *)
Lemma LABCQR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQR requis par la preuve de (?)ABCQR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQR requis par la preuve de (?)ABCQR pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQR requis par la preuve de (?)ABCQR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRm2 : rk(A :: B :: C :: Q :: R :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCQRM3 : rk(A :: B :: C :: Q :: R :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: Q :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: nil) (A :: B :: C :: A :: Q :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: Q :: R :: nil) ((A :: B :: C :: nil) ++ (A :: Q :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (A :: Q :: R :: nil) (A :: nil) 2 2 1 HABCMtmp HAQRMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRm3 : rk(A :: B :: C :: Q :: R :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABCQRM : rk(A :: B :: C :: Q :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQRm : rk(A :: B :: C :: Q :: R ::  nil) >= 1) by (solve_hyps_min HABCQReq HABCQRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQR : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: R ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQR requis par la preuve de (?)BCQR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQR requis par la preuve de (?)BCQR pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQR requis par la preuve de (?)BCQR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQRm2 : rk(B :: C :: Q :: R :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: R :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R ::  de rang :  3 et 3 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQRm3 : rk(B :: C :: Q :: R :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQReq : rk(A :: B :: C :: Q :: R :: nil) = 3) by (apply LABCQR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQRmtmp : rk(A :: B :: C :: Q :: R :: nil) >= 3) by (solve_hyps_min HABCQReq HABCQRm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: nil) (A :: B :: C :: Q :: B :: C :: Q :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: R :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRmtmp;try rewrite HT2 in HABCQRmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQRmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQRM3 : rk(B :: C :: Q :: R :: nil) <= 3).
{
	assert(HABCQReq : rk(A :: B :: C :: Q :: R :: nil) = 3) by (apply LABCQR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQRMtmp : rk(A :: B :: C :: Q :: R :: nil) <= 3) by (solve_hyps_max HABCQReq HABCQRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: R :: nil) (A :: B :: C :: Q :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: Q :: R :: nil) (A :: B :: C :: Q :: R :: nil) 3 3 HABCQRMtmp Hcomp Hincl);apply HT.
}

assert(HBCQRM : rk(B :: C :: Q :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQRm : rk(B :: C :: Q :: R ::  nil) >= 1) by (solve_hyps_min HBCQReq HBCQRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Qp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AQp requis par la preuve de (?)AQp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Qp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HAQpm2 : rk(A :: Qp :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: Qp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Qp :: nil) (A :: B :: A :: Qp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: Qp :: nil) ((A :: B :: nil) ++ (A :: Qp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQpmtmp;try rewrite HT2 in HABQpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (A :: Qp :: nil) (A :: nil) 3 1 2 HABQpmtmp HAmtmp HABMtmp Hincl); apply HT.
}

assert(HAQpM : rk(A :: Qp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAQpeq HAQpM2).
assert(HAQpm : rk(A :: Qp ::  nil) >= 1) by (solve_hyps_min HAQpeq HAQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BQp requis par la preuve de (?)BQp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Qp ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HBQpm2 : rk(B :: Qp :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (B :: Qp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Qp :: nil) (A :: B :: B :: Qp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: B :: Qp :: nil) ((A :: B :: nil) ++ (B :: Qp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQpmtmp;try rewrite HT2 in HABQpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (B :: Qp :: nil) (B :: nil) 3 1 2 HABQpmtmp HBmtmp HABMtmp Hincl); apply HT.
}

assert(HBQpM : rk(B :: Qp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBQpeq HBQpM2).
assert(HBQpm : rk(B :: Qp ::  nil) >= 1) by (solve_hyps_min HBQpeq HBQpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCQp *)
(* dans la couche 0 *)
Lemma LABCQpDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Qp :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQpDDp requis par la preuve de (?)ABCQpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQpDDp requis par la preuve de (?)ABCQpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQpDDp requis par la preuve de (?)ABCQpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpDDpm2 : rk(A :: B :: C :: Qp :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Qp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Qp :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCQpDDpM3 : rk(A :: B :: C :: Qp :: D :: Dp :: nil) <= 3).
{
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: D :: Dp :: nil) (Qp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: A :: B :: C :: D :: Dp :: nil) ((Qp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (A :: B :: C :: D :: Dp :: nil) (nil) 1 2 0 HQpMtmp HABCDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpDDpm3 : rk(A :: B :: C :: Qp :: D :: Dp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: D :: Dp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQpDDpM : rk(A :: B :: C :: Qp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQpDDpm : rk(A :: B :: C :: Qp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCQpDDpeq HABCQpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Qp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CQp requis par la preuve de (?)CQp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCQpm2 : rk(C :: Qp :: nil) >= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQpDDpeq : rk(A :: B :: C :: Qp :: D :: Dp :: nil) = 3) by (apply LABCQpDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpDDpmtmp : rk(A :: B :: C :: Qp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQpDDpeq HABCQpDDpm3).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: D :: Dp :: nil) (C :: Qp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Qp :: A :: B :: C :: D :: Dp :: nil) ((C :: Qp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQpDDpmtmp;try rewrite HT2 in HABCQpDDpmtmp.
	assert(HT := rule_2 (C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil) (C :: nil) 3 1 2 HABCQpDDpmtmp HCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HCQpM : rk(C :: Qp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCQpeq HCQpM2).
assert(HCQpm : rk(C :: Qp ::  nil) >= 1) by (solve_hyps_min HCQpeq HCQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Qp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACQp requis par la preuve de (?)ACQp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACQp requis par la preuve de (?)ACQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQpm2 : rk(A :: C :: Qp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Qp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HACQpm3 : rk(A :: C :: Qp :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQpDDpeq : rk(A :: B :: C :: Qp :: D :: Dp :: nil) = 3) by (apply LABCQpDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpDDpmtmp : rk(A :: B :: C :: Qp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQpDDpeq HABCQpDDpm3).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: D :: Dp :: nil) (A :: C :: Qp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Qp :: A :: B :: C :: D :: Dp :: nil) ((A :: C :: Qp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQpDDpmtmp;try rewrite HT2 in HABCQpDDpmtmp.
	assert(HT := rule_2 (A :: C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil) (A :: C :: nil) 3 2 2 HABCQpDDpmtmp HACmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HACQpM : rk(A :: C :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACQpeq HACQpM3).
assert(HACQpm : rk(A :: C :: Qp ::  nil) >= 1) by (solve_hyps_min HACQpeq HACQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Qp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCQp requis par la preuve de (?)BCQp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCQp requis par la preuve de (?)BCQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQpm2 : rk(B :: C :: Qp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Qp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HBCQpm3 : rk(B :: C :: Qp :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQpDDpeq : rk(A :: B :: C :: Qp :: D :: Dp :: nil) = 3) by (apply LABCQpDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpDDpmtmp : rk(A :: B :: C :: Qp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQpDDpeq HABCQpDDpm3).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (B :: C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: D :: Dp :: nil) (B :: C :: Qp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: A :: B :: C :: D :: Dp :: nil) ((B :: C :: Qp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQpDDpmtmp;try rewrite HT2 in HABCQpDDpmtmp.
	assert(HT := rule_2 (B :: C :: Qp :: nil) (A :: B :: C :: D :: Dp :: nil) (B :: C :: nil) 3 2 2 HABCQpDDpmtmp HBCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HBCQpM : rk(B :: C :: Qp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCQpeq HBCQpM3).
assert(HBCQpm : rk(B :: C :: Qp ::  nil) >= 1) by (solve_hyps_min HBCQpeq HBCQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Qp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQp requis par la preuve de (?)ABCQp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQp requis par la preuve de (?)ABCQp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQp requis par la preuve de (?)ABCQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpm2 : rk(A :: B :: C :: Qp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Qp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABCQpM3 : rk(A :: B :: C :: Qp :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: C :: nil) (Qp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: nil) (A :: B :: C :: Qp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: nil) ((A :: B :: C :: nil) ++ (Qp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (Qp :: nil) (nil) 2 1 0 HABCMtmp HQpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpm3 : rk(A :: B :: C :: Qp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQpM : rk(A :: B :: C :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQpm : rk(A :: B :: C :: Qp ::  nil) >= 1) by (solve_hyps_min HABCQpeq HABCQpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPpQp *)
(* dans la couche 0 *)
Lemma LABCPpQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Pp :: Qp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCPpQp requis par la preuve de (?)ABCPpQp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpQp requis par la preuve de (?)ABCPpQp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpQp requis par la preuve de (?)ABCPpQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpm2 : rk(A :: B :: C :: Pp :: Qp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCPpQpM3 : rk(A :: B :: C :: Pp :: Qp :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: B :: C :: nil) (C :: Pp :: Qp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Qp :: nil) (A :: B :: C :: C :: Pp :: Qp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: C :: Pp :: Qp :: nil) ((A :: B :: C :: nil) ++ (C :: Pp :: Qp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (C :: Pp :: Qp :: nil) (C :: nil) 2 2 1 HABCMtmp HCPpQpMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpm3 : rk(A :: B :: C :: Pp :: Qp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

assert(HABCPpQpM : rk(A :: B :: C :: Pp :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPpQpm : rk(A :: B :: C :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HABCPpQpeq HABCPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPpQp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Pp :: Qp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpQp requis par la preuve de (?)ABPpQp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpQp requis par la preuve de (?)ABPpQp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpQp requis par la preuve de (?)ABPpQp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpQpm2 : rk(A :: B :: Pp :: Qp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: Qp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpQpm3 : rk(A :: B :: Pp :: Qp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: Pp :: Qp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPpQpM3 : rk(A :: B :: Pp :: Qp :: nil) <= 3).
{
	assert(HABCPpQpeq : rk(A :: B :: C :: Pp :: Qp :: nil) = 3) by (apply LABCPpQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPpQpMtmp : rk(A :: B :: C :: Pp :: Qp :: nil) <= 3) by (solve_hyps_max HABCPpQpeq HABCPpQpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Pp :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Pp :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: nil) 3 3 HABCPpQpMtmp Hcomp Hincl);apply HT.
}

assert(HABPpQpM : rk(A :: B :: Pp :: Qp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPpQpm : rk(A :: B :: Pp :: Qp ::  nil) >= 1) by (solve_hyps_min HABPpQpeq HABPpQpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Rp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ARp requis par la preuve de (?)ARp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Rp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HARpm2 : rk(A :: Rp :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Rp :: nil) (A :: B :: A :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: Rp :: nil) ((A :: B :: nil) ++ (A :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRpmtmp;try rewrite HT2 in HABRpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (A :: Rp :: nil) (A :: nil) 3 1 2 HABRpmtmp HAmtmp HABMtmp Hincl); apply HT.
}

assert(HARpM : rk(A :: Rp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HARpeq HARpM2).
assert(HARpm : rk(A :: Rp ::  nil) >= 1) by (solve_hyps_min HARpeq HARpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Rp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BRp requis par la preuve de (?)BRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Rp ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HBRpm2 : rk(B :: Rp :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (B :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Rp :: nil) (A :: B :: B :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: B :: Rp :: nil) ((A :: B :: nil) ++ (B :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRpmtmp;try rewrite HT2 in HABRpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (B :: Rp :: nil) (B :: nil) 3 1 2 HABRpmtmp HBmtmp HABMtmp Hincl); apply HT.
}

assert(HBRpM : rk(B :: Rp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBRpeq HBRpM2).
assert(HBRpm : rk(B :: Rp ::  nil) >= 1) by (solve_hyps_min HBRpeq HBRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCRp *)
(* dans la couche 0 *)
Lemma LABCRpDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Rp :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCRpDDp requis par la preuve de (?)ABCRpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRpDDp requis par la preuve de (?)ABCRpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRpDDp requis par la preuve de (?)ABCRpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRpDDpm2 : rk(A :: B :: C :: Rp :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Rp :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCRpDDpM3 : rk(A :: B :: C :: Rp :: D :: Dp :: nil) <= 3).
{
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Rp :: D :: Dp :: nil) (Rp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: A :: B :: C :: D :: Dp :: nil) ((Rp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: nil) (A :: B :: C :: D :: Dp :: nil) (nil) 1 2 0 HRpMtmp HABCDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRpDDpm3 : rk(A :: B :: C :: Rp :: D :: Dp :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: C :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: C :: Rp :: D :: Dp :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCRpDDpM : rk(A :: B :: C :: Rp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCRpDDpm : rk(A :: B :: C :: Rp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCRpDDpeq HABCRpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCRp requis par la preuve de (?)BCRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCRp requis par la preuve de (?)BCRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRpm2 : rk(B :: C :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HBCRpm3 : rk(B :: C :: Rp :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCRpDDpeq : rk(A :: B :: C :: Rp :: D :: Dp :: nil) = 3) by (apply LABCRpDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRpDDpmtmp : rk(A :: B :: C :: Rp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCRpDDpeq HABCRpDDpm3).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (B :: C :: Rp :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Rp :: D :: Dp :: nil) (B :: C :: Rp :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Rp :: A :: B :: C :: D :: Dp :: nil) ((B :: C :: Rp :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRpDDpmtmp;try rewrite HT2 in HABCRpDDpmtmp.
	assert(HT := rule_2 (B :: C :: Rp :: nil) (A :: B :: C :: D :: Dp :: nil) (B :: C :: nil) 3 2 2 HABCRpDDpmtmp HBCmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HBCRpM : rk(B :: C :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCRpeq HBCRpM3).
assert(HBCRpm : rk(B :: C :: Rp ::  nil) >= 1) by (solve_hyps_min HBCRpeq HBCRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCRp requis par la preuve de (?)ABCRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRp requis par la preuve de (?)ABCRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRp requis par la preuve de (?)ABCRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRpm2 : rk(A :: B :: C :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABCRpM3 : rk(A :: B :: C :: Rp :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: C :: nil) (Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Rp :: nil) (A :: B :: C :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Rp :: nil) ((A :: B :: C :: nil) ++ (Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (Rp :: nil) (nil) 2 1 0 HABCMtmp HRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRpm3 : rk(A :: B :: C :: Rp :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: C :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: C :: Rp :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCRpM : rk(A :: B :: C :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCRpm : rk(A :: B :: C :: Rp ::  nil) >= 1) by (solve_hyps_min HABCRpeq HABCRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(R :: Rp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RRp requis par la preuve de (?)RRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Rp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HRRpm2 : rk(R :: Rp :: nil) >= 2).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: nil) (R :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Rp :: nil) (A :: B :: R :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: R :: Rp :: nil) ((A :: B :: nil) ++ (R :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRRpmtmp;try rewrite HT2 in HABRRpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (R :: Rp :: nil) (nil) 4 0 2 HABRRpmtmp Hmtmp HABMtmp Hincl); apply HT.
}

assert(HRRpM : rk(R :: Rp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRRpeq HRRpM2).
assert(HRRpm : rk(R :: Rp ::  nil) >= 1) by (solve_hyps_min HRRpeq HRRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARRp requis par la preuve de (?)ARRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Rp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HARRpm3 : rk(A :: R :: Rp :: nil) >= 3).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: R :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Rp :: nil) (A :: B :: A :: R :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: R :: Rp :: nil) ((A :: B :: nil) ++ (A :: R :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRRpmtmp;try rewrite HT2 in HABRRpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (A :: R :: Rp :: nil) (A :: nil) 4 1 2 HABRRpmtmp HAmtmp HABMtmp Hincl); apply HT.
}

assert(HARRpM : rk(A :: R :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HARRpeq HARRpM3).
assert(HARRpm : rk(A :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HARRpeq HARRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BRRp requis par la preuve de (?)BRRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Rp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HBRRpm3 : rk(B :: R :: Rp :: nil) >= 3).
{
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (B :: R :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Rp :: nil) (A :: B :: B :: R :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: B :: R :: Rp :: nil) ((A :: B :: nil) ++ (B :: R :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRRpmtmp;try rewrite HT2 in HABRRpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (B :: R :: Rp :: nil) (B :: nil) 4 1 2 HABRRpmtmp HBmtmp HABMtmp Hincl); apply HT.
}

assert(HBRRpM : rk(B :: R :: Rp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBRRpeq HBRRpM3).
assert(HBRRpm : rk(B :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HBRRpeq HBRRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCRRp *)
(* dans la couche 0 *)
Lemma LABCRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRPpRp requis par la preuve de (?)ABCRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRPpRp requis par la preuve de (?)ABCRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRPpRp requis par la preuve de (?)ABCRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpRpm2 : rk(A :: B :: C :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpRpm3 : rk(A :: B :: C :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpRpm4 : rk(A :: B :: C :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: C :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCRPpRpM : rk(A :: B :: C :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCRPpRpm : rk(A :: B :: C :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCRPpRpeq HABCRPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCRRp *)
(* dans la couche 0 *)
Lemma LABCPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Pp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCPpRp requis par la preuve de (?)ABCPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpRp requis par la preuve de (?)ABCPpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpRp requis par la preuve de (?)ABCPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpRpm2 : rk(A :: B :: C :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCPpRpM3 : rk(A :: B :: C :: Pp :: Rp :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: C :: nil) (B :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Rp :: nil) (A :: B :: C :: B :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: B :: Pp :: Rp :: nil) ((A :: B :: C :: nil) ++ (B :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (B :: Pp :: Rp :: nil) (B :: nil) 2 2 1 HABCMtmp HBPpRpMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpRpm3 : rk(A :: B :: C :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCPpRpM : rk(A :: B :: C :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPpRpm : rk(A :: B :: C :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCPpRpeq HABCPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRRp requis par la preuve de (?)BCRRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRRp requis par la preuve de (?)BCRRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRRp requis par la preuve de (?)ABCRRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRRp requis par la preuve de (?)ABCRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRRpm2 : rk(A :: B :: C :: R :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRRpm3 : rk(A :: B :: C :: R :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRRp requis par la preuve de (?)BCRRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRRp requis par la preuve de (?)BCRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRRpm2 : rk(B :: C :: R :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRRpm3 : rk(B :: C :: R :: Rp :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRRpmtmp : rk(A :: B :: C :: R :: Rp :: nil) >= 3) by (solve_hyps_min HABCRRpeq HABCRRpm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: Rp :: nil) (A :: B :: C :: R :: B :: C :: R :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: Rp :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRRpmtmp;try rewrite HT2 in HABCRRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: Rp :: nil) (B :: C :: R :: nil) 3 3 3 HABCRRpmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCRRpm4 : rk(B :: C :: R :: Rp :: nil) >= 4).
{
	assert(HABCPpRpeq : rk(A :: B :: C :: Pp :: Rp :: nil) = 3) by (apply LABCPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPpRpMtmp : rk(A :: B :: C :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HABCPpRpeq HABCPpRpM3).
	assert(HABCRPpRpeq : rk(A :: B :: C :: R :: Pp :: Rp :: nil) = 4) by (apply LABCRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRPpRpmtmp : rk(A :: B :: C :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABCRPpRpeq HABCRPpRpm4).
	assert(HBCRpeq : rk(B :: C :: Rp :: nil) = 3) by (apply LBCRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRpmtmp : rk(B :: C :: Rp :: nil) >= 3) by (solve_hyps_min HBCRpeq HBCRpm3).
	assert(Hincl : incl (B :: C :: Rp :: nil) (list_inter (B :: C :: R :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: Pp :: Rp :: nil) (B :: C :: R :: Rp :: A :: B :: C :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: R :: Rp :: A :: B :: C :: Pp :: Rp :: nil) ((B :: C :: R :: Rp :: nil) ++ (A :: B :: C :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRPpRpmtmp;try rewrite HT2 in HABCRPpRpmtmp.
	assert(HT := rule_2 (B :: C :: R :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: nil) (B :: C :: Rp :: nil) 4 3 3 HABCRPpRpmtmp HBCRpmtmp HABCPpRpMtmp Hincl);apply HT.
}

assert(HBCRRpM : rk(B :: C :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRRpm : rk(B :: C :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HBCRRpeq HBCRRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQRRp *)
(* dans la couche 0 *)
Lemma LABPQRRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: R :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQRRpU requis par la preuve de (?)ABPQRRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQRRpU requis par la preuve de (?)ABPQRRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQRRpU requis par la preuve de (?)ABPQRRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpUm2 : rk(A :: B :: P :: Q :: R :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpUm3 : rk(A :: B :: P :: Q :: R :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpUm4 : rk(A :: B :: P :: Q :: R :: Rp :: U :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Rp :: U :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPQRRpUM : rk(A :: B :: P :: Q :: R :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQRRpUm : rk(A :: B :: P :: Q :: R :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABPQRRpUeq HABPQRRpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQRRp *)
(* dans constructLemma(), requis par LABPQRU *)
(* dans la couche 0 *)
Lemma LABPQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQU requis par la preuve de (?)ABPQU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQU requis par la preuve de (?)ABPQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQU requis par la preuve de (?)ABPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQUm2 : rk(A :: B :: P :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQUm3 : rk(A :: B :: P :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HABPQUM3 : rk(A :: B :: P :: Q :: U :: nil) <= 3).
{
	assert(HABPQeq : rk(A :: B :: P :: Q :: nil) = 3) by (apply LABPQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQMtmp : rk(A :: B :: P :: Q :: nil) <= 3) by (solve_hyps_max HABPQeq HABPQM3).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hincl : incl (B :: Q :: nil) (list_inter (A :: B :: P :: Q :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: U :: nil) (A :: B :: P :: Q :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: B :: Q :: U :: nil) ((A :: B :: P :: Q :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: P :: Q :: nil) (B :: Q :: U :: nil) (B :: Q :: nil) 3 2 2 HABPQMtmp HBQUMtmp HBQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABPQUM : rk(A :: B :: P :: Q :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQUm : rk(A :: B :: P :: Q :: U ::  nil) >= 1) by (solve_hyps_min HABPQUeq HABPQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQRU requis par la preuve de (?)ABPQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQRU requis par la preuve de (?)ABPQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQRU requis par la preuve de (?)ABPQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRUm2 : rk(A :: B :: P :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRUm3 : rk(A :: B :: P :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABPQRUM3 : rk(A :: B :: P :: Q :: R :: U :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HABPQUeq : rk(A :: B :: P :: Q :: U :: nil) = 3) by (apply LABPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQUMtmp : rk(A :: B :: P :: Q :: U :: nil) <= 3) by (solve_hyps_max HABPQUeq HABPQUM3).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: nil) (A :: B :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: R :: U :: nil) (A :: Q :: R :: A :: B :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: A :: B :: P :: Q :: U :: nil) ((A :: Q :: R :: nil) ++ (A :: B :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (A :: B :: P :: Q :: U :: nil) (A :: Q :: nil) 2 3 2 HAQRMtmp HABPQUMtmp HAQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABPQRUM : rk(A :: B :: P :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQRUm : rk(A :: B :: P :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HABPQRUeq HABPQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRRp requis par la preuve de (?)PQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRRpm3 : rk(P :: Q :: R :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HPQRRpm4 : rk(P :: Q :: R :: Rp :: nil) >= 4).
{
	assert(HABPQRUeq : rk(A :: B :: P :: Q :: R :: U :: nil) = 3) by (apply LABPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQRUMtmp : rk(A :: B :: P :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABPQRUeq HABPQRUM3).
	assert(HABPQRRpUeq : rk(A :: B :: P :: Q :: R :: Rp :: U :: nil) = 4) by (apply LABPQRRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQRRpUmtmp : rk(A :: B :: P :: Q :: R :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABPQRRpUeq HABPQRRpUm4).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: R :: Rp :: U :: nil) (P :: Q :: R :: Rp :: A :: B :: P :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: Rp :: A :: B :: P :: Q :: R :: U :: nil) ((P :: Q :: R :: Rp :: nil) ++ (A :: B :: P :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQRRpUmtmp;try rewrite HT2 in HABPQRRpUmtmp.
	assert(HT := rule_2 (P :: Q :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: U :: nil) (P :: Q :: R :: nil) 4 3 3 HABPQRRpUmtmp HPQRmtmp HABPQRUMtmp Hincl);apply HT.
}

assert(HPQRRpM : rk(P :: Q :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRRpm : rk(P :: Q :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HPQRRpeq HPQRRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPQRRp *)
(* dans la couche 0 *)
Lemma LABPQRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: R :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQRRp requis par la preuve de (?)ABPQRRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQRRp requis par la preuve de (?)ABPQRRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQRRp requis par la preuve de (?)ABPQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpm2 : rk(A :: B :: P :: Q :: R :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: R :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpm3 : rk(A :: B :: P :: Q :: R :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRRpm4 : rk(A :: B :: P :: Q :: R :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPQRRpM : rk(A :: B :: P :: Q :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQRRpm : rk(A :: B :: P :: Q :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HABPQRRpeq HABPQRRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPQRRp *)
(* dans la couche 0 *)
Lemma LAPQRRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRRp requis par la preuve de (?)APQRRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRRp requis par la preuve de (?)BPQRRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRRp requis par la preuve de (?)BPQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRRpm2 : rk(B :: P :: Q :: R :: Rp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Rp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRRpm3 : rk(B :: P :: Q :: R :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRRp requis par la preuve de (?)APQRRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRRp requis par la preuve de (?)APQRRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRRp requis par la preuve de (?)APQRRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRRpm2 : rk(A :: P :: Q :: R :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRRpm3 : rk(A :: P :: Q :: R :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAPQRRpm4 : rk(A :: P :: Q :: R :: Rp :: nil) >= 4).
{
	assert(HBPQRRpMtmp : rk(B :: P :: Q :: R :: Rp :: nil) <= 4) by (solve_hyps_max HBPQRRpeq HBPQRRpM4).
	assert(HABPQRRpeq : rk(A :: B :: P :: Q :: R :: Rp :: nil) = 4) by (apply LABPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQRRpmtmp : rk(A :: B :: P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABPQRRpeq HABPQRRpm4).
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (list_inter (A :: P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Rp :: B :: P :: Q :: R :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: R :: Rp :: B :: P :: Q :: R :: Rp :: nil) ((A :: P :: Q :: R :: Rp :: nil) ++ (B :: P :: Q :: R :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQRRpmtmp;try rewrite HT2 in HABPQRRpmtmp.
	assert(HT := rule_2 (A :: P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Rp :: nil) 4 4 4 HABPQRRpmtmp HPQRRpmtmp HBPQRRpMtmp Hincl);apply HT.
}

assert(HAPQRRpM : rk(A :: P :: Q :: R :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRRpm : rk(A :: P :: Q :: R :: Rp ::  nil) >= 1) by (solve_hyps_min HAPQRRpeq HAPQRRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQPpRp *)
(* dans constructLemma(), requis par LBPQRPpRp *)
(* dans la couche 0 *)
Lemma LABPQRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQRPpRp requis par la preuve de (?)ABPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQRPpRp requis par la preuve de (?)ABPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQRPpRp requis par la preuve de (?)ABPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRPpRpm2 : rk(A :: B :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRPpRpm3 : rk(A :: B :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQRPpRpm4 : rk(A :: B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: Q :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPQRPpRpM : rk(A :: B :: P :: Q :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQRPpRpm : rk(A :: B :: P :: Q :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABPQRPpRpeq HABPQRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPQRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Q :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRp requis par la preuve de (?)BPQRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRp requis par la preuve de (?)BPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRp requis par la preuve de (?)BPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: R :: Pp :: Rp ::  de rang :  4 et 4 	 AiB : P :: Q :: R :: Rp ::  de rang :  4 et 4 	 A : A :: P :: Q :: R :: Rp ::   de rang : 4 et 4 *)
assert(HBPQRPpRpm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HAPQRRpeq : rk(A :: P :: Q :: R :: Rp :: nil) = 4) by (apply LAPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRRpMtmp : rk(A :: P :: Q :: R :: Rp :: nil) <= 4) by (solve_hyps_max HAPQRRpeq HAPQRRpM4).
	assert(HABPQRPpRpeq : rk(A :: B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LABPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQRPpRpmtmp : rk(A :: B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABPQRPpRpeq HABPQRPpRpm4).
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (list_inter (A :: P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: R :: Pp :: Rp :: nil) (A :: P :: Q :: R :: Rp :: B :: P :: Q :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: R :: Rp :: B :: P :: Q :: R :: Pp :: Rp :: nil) ((A :: P :: Q :: R :: Rp :: nil) ++ (B :: P :: Q :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQRPpRpmtmp;try rewrite HT2 in HABPQRPpRpmtmp.
	assert(HT := rule_4 (A :: P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: nil) (P :: Q :: R :: Rp :: nil) 4 4 4 HABPQRPpRpmtmp HPQRRpmtmp HAPQRRpMtmp Hincl); apply HT.
}

assert(HBPQRPpRpM : rk(B :: P :: Q :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPQRPpRpm : rk(B :: P :: Q :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQPpRp *)
(* dans la couche 0 *)
Lemma LBPRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPRPpRp requis par la preuve de (?)BPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpRp requis par la preuve de (?)BPRPpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpRp requis par la preuve de (?)BPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)BCPQRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm2 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm3 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpRp requis par la preuve de (?)BCPQRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpRp requis par la preuve de (?)BCPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpRpm2 : rk(B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQRPpRpm3 : rk(B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRPpRpmtmp : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPQRPpRpeq HABCPQRPpRpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRPpRpmtmp;try rewrite HT2 in HABCPQRPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Rp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQRPpRpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpRp requis par la preuve de (?)BPRPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpRpm2 : rk(B :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpRpmtmp : rk(B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBCPQRPpRpeq HBCPQRPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Rp :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Rp :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpRpmtmp;try rewrite HT2 in HBCPQRPpRpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HBCPQRPpRpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBPRPpRpM3 : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: P :: R :: nil) (B :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Rp :: nil) (B :: P :: R :: B :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: B :: Pp :: Rp :: nil) ((B :: P :: R :: nil) ++ (B :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (B :: Pp :: Rp :: nil) (B :: nil) 2 2 1 HBPRMtmp HBPpRpMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPRPpRpm3 : rk(B :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HBRRpeq : rk(B :: R :: Rp :: nil) = 3) by (apply LBRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpmtmp : rk(B :: R :: Rp :: nil) >= 3) by (solve_hyps_min HBRRpeq HBRRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) 3 3 HBRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPRPpRpM : rk(B :: P :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpRpm : rk(B :: P :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HBPRPpRpeq HBPRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQPpRp requis par la preuve de (?)BQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BQPpRp requis par la preuve de (?)BQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpRp requis par la preuve de (?)BQPpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBQPpRpM3 : rk(B :: Q :: Pp :: Rp :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (B :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Rp :: nil) (Q :: B :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: B :: Pp :: Rp :: nil) ((Q :: nil) ++ (B :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (B :: Pp :: Rp :: nil) (nil) 1 2 0 HQMtmp HBPpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpRpm2 : rk(B :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Rp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HBQPpRpm3 : rk(B :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HBPpRpmtmp : rk(B :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HBPpRpeq HBPpRpm2).
	assert(Hincl : incl (B :: Pp :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (B :: Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((B :: Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (B :: Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (B :: Pp :: Rp :: nil) 4 2 3 HBPQRPpRpmtmp HBPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

assert(HBQPpRpM : rk(B :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpRpm : rk(B :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HBQPpRpeq HBQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABQPpRp *)
(* dans la couche 0 *)
Lemma LABQRPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRpU requis par la preuve de (?)ABQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRpU requis par la preuve de (?)ABQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRpU requis par la preuve de (?)ABQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQRPpRpUM : rk(A :: B :: Q :: R :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRPpRpUm : rk(A :: B :: Q :: R :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABQPpRp *)
(* dans la couche 0 *)
Lemma LABQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRU requis par la preuve de (?)ABQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRU requis par la preuve de (?)ABQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRU requis par la preuve de (?)ABQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRUm2 : rk(A :: B :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRUm3 : rk(A :: B :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABQRUM3 : rk(A :: B :: Q :: R :: U :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (A :: Q :: R :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: U :: nil) (A :: Q :: R :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: B :: Q :: U :: nil) ((A :: Q :: R :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (B :: Q :: U :: nil) (Q :: nil) 2 2 1 HAQRMtmp HBQUMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABQRUM : rk(A :: B :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRUm : rk(A :: B :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HABQRUeq HABQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpRp requis par la preuve de (?)ABQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpRp requis par la preuve de (?)ABQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpRp requis par la preuve de (?)ABQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpRpm2 : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpRpm3 : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABQPpRpm4 : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hincl : incl (A :: B :: Q :: nil) (list_inter (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: B :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: B :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: B :: Q :: nil) 4 3 3 HABQRPpRpUmtmp HABQmtmp HABQRUMtmp Hincl);apply HT.
}

assert(HABQPpRpM : rk(A :: B :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpRpm : rk(A :: B :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABQPpRpeq HABQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACQPpRp *)
(* dans la couche 0 *)
Lemma LABCQPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)ABCQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)ABCQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)ABCQPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpUm2 : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpUm3 : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpRpUm4 : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpRpUM : rk(A :: B :: C :: Q :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpRpUm : rk(A :: B :: C :: Q :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABCQPpRpUeq HABCQPpRpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACQPpRp *)
(* dans la couche 0 *)
Lemma LABCQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQU requis par la preuve de (?)ABCQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQU requis par la preuve de (?)ABCQU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQU requis par la preuve de (?)ABCQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUm2 : rk(A :: B :: C :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCQUM3 : rk(A :: B :: C :: Q :: U :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: C :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: nil) (A :: B :: C :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: B :: Q :: U :: nil) ((A :: B :: C :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (B :: Q :: U :: nil) (B :: nil) 2 2 1 HABCMtmp HBQUMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUm3 : rk(A :: B :: C :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABCQUM : rk(A :: B :: C :: Q :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQUm : rk(A :: B :: C :: Q :: U ::  nil) >= 1) by (solve_hyps_min HABCQUeq HABCQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpRp requis par la preuve de (?)ACQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ACQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm2 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm3 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpRp requis par la preuve de (?)ACQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpRp requis par la preuve de (?)ACQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpRpm2 : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Rp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQPpRpm3 : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpRpmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCQPpRpeq HABCQPpRpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpmtmp;try rewrite HT2 in HABCQPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQPpRpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACQPpRpm4 : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4).
{
	assert(HABCQUeq : rk(A :: B :: C :: Q :: U :: nil) = 3) by (apply LABCQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQUMtmp : rk(A :: B :: C :: Q :: U :: nil) <= 3) by (solve_hyps_max HABCQUeq HABCQUM3).
	assert(HABCQPpRpUeq : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LABCQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABCQPpRpUeq HABCQPpRpUm4).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) (A :: C :: Q :: Pp :: Rp :: A :: B :: C :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Q :: Pp :: Rp :: A :: B :: C :: Q :: U :: nil) ((A :: C :: Q :: Pp :: Rp :: nil) ++ (A :: B :: C :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpUmtmp;try rewrite HT2 in HABCQPpRpUmtmp.
	assert(HT := rule_2 (A :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: U :: nil) (A :: C :: Q :: nil) 4 3 3 HABCQPpRpUmtmp HACQmtmp HABCQUMtmp Hincl);apply HT.
}

assert(HACQPpRpM : rk(A :: C :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpRpm : rk(A :: C :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HACQPpRpeq HACQPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpRp requis par la preuve de (?)BCQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)BCQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm2 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm3 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpRp requis par la preuve de (?)BCQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpRp requis par la preuve de (?)BCQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpRpm2 : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpRpm3 : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpRpmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCQPpRpeq HABCQPpRpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpmtmp;try rewrite HT2 in HABCQPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpRpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCQPpRpm4 : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 4).
{
	assert(HABCQUeq : rk(A :: B :: C :: Q :: U :: nil) = 3) by (apply LABCQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQUMtmp : rk(A :: B :: C :: Q :: U :: nil) <= 3) by (solve_hyps_max HABCQUeq HABCQUM3).
	assert(HABCQPpRpUeq : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LABCQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABCQPpRpUeq HABCQPpRpUm4).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) (B :: C :: Q :: Pp :: Rp :: A :: B :: C :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Q :: Pp :: Rp :: A :: B :: C :: Q :: U :: nil) ((B :: C :: Q :: Pp :: Rp :: nil) ++ (A :: B :: C :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpUmtmp;try rewrite HT2 in HABCQPpRpUmtmp.
	assert(HT := rule_2 (B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: U :: nil) (B :: C :: Q :: nil) 4 3 3 HABCQPpRpUmtmp HBCQmtmp HABCQUMtmp Hincl);apply HT.
}

assert(HBCQPpRpM : rk(B :: C :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpRpm : rk(B :: C :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HBCQPpRpeq HBCQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCQPpRp *)
(* dans la couche 0 *)
Lemma LABCQRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRPpRp requis par la preuve de (?)ABCQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRPpRp requis par la preuve de (?)ABCQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRPpRp requis par la preuve de (?)ABCQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRPpRpm2 : rk(A :: B :: C :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRPpRpm3 : rk(A :: B :: C :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRPpRpm4 : rk(A :: B :: C :: Q :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: C :: Q :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQRPpRpM : rk(A :: B :: C :: Q :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQRPpRpm : rk(A :: B :: C :: Q :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCQRPpRpeq HABCQRPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCQPpRp *)
(* dans la couche 0 *)
Lemma LABQRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRp requis par la preuve de (?)ABQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRp requis par la preuve de (?)ABQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRp requis par la preuve de (?)ABQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQRPpRpM : rk(A :: B :: Q :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRPpRpm : rk(A :: B :: Q :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABQRPpRpeq HABQRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpRp requis par la preuve de (?)ABCQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm2 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpm3 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCQPpRpm4 : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 4).
{
	assert(HABQRPpRpeq : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LABQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpMtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABQRPpRpeq HABQRPpRpM4).
	assert(HABCQRPpRpeq : rk(A :: B :: C :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LABCQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQRPpRpmtmp : rk(A :: B :: C :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABCQRPpRpeq HABCQRPpRpm4).
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Rp :: A :: B :: Q :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: A :: B :: Q :: R :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRPpRpmtmp;try rewrite HT2 in HABCQRPpRpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Rp :: nil) 4 4 4 HABCQRPpRpmtmp HABQPpRpmtmp HABQRPpRpMtmp Hincl);apply HT.
}

assert(HABCQPpRpM : rk(A :: B :: C :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpRpm : rk(A :: B :: C :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCQPpRpeq HABCQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCPQPpRp *)
(* dans la couche 0 *)
Lemma LABCPQRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm2 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm3 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm4 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCPQRPpRpM : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPQRPpRpm : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCPQRPpRpeq HABCPQRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCPQPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: Q :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm2 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm3 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCPQPpRpm4 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 4).
{
	assert(HABQRPpRpeq : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LABQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpMtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABQRPpRpeq HABQRPpRpM4).
	assert(HABCPQRPpRpeq : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LABCPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPQRPpRpmtmp : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABCPQRPpRpeq HABCPQRPpRpm4).
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: A :: B :: Q :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: P :: Q :: Pp :: Rp :: A :: B :: Q :: R :: Pp :: Rp :: nil) ((A :: B :: C :: P :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRPpRpmtmp;try rewrite HT2 in HABCPQRPpRpmtmp.
	assert(HT := rule_2 (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Rp :: nil) 4 4 4 HABCPQRPpRpmtmp HABQPpRpmtmp HABQRPpRpMtmp Hincl);apply HT.
}

assert(HABCPQPpRpM : rk(A :: B :: C :: P :: Q :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPQPpRpm : rk(A :: B :: C :: P :: Q :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCPQPpRpeq HABCPQPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPRPpRp *)
(* dans la couche 0 *)
Lemma LAPQRPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Pp :: Qp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRp requis par la preuve de (?)APQRPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRp requis par la preuve de (?)APQRPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRp requis par la preuve de (?)APQRPpQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpm2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpm3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpm4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4).
{
	assert(HAPQRRpeq : rk(A :: P :: Q :: R :: Rp :: nil) = 4) by (apply LAPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRRpmtmp : rk(A :: P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRRpeq HAPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) 4 4 HAPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRPpQpRpM : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRPpQpRpm : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPRPpRp *)
(* dans la couche 0 *)
Lemma LAQRQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRQpRp requis par la preuve de (?)AQRQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpRp requis par la preuve de (?)AQRQpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpRp requis par la preuve de (?)AQRQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpm2 : rk(A :: Q :: R :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQRQpRpM3 : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Q :: R :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Rp :: nil) (A :: Q :: R :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: A :: Qp :: Rp :: nil) ((A :: Q :: R :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (A :: Qp :: Rp :: nil) (A :: nil) 2 2 1 HAQRMtmp HAQpRpMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpm3 : rk(A :: Q :: R :: Qp :: Rp :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

assert(HAQRQpRpM : rk(A :: Q :: R :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRQpRpm : rk(A :: Q :: R :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAQRQpRpeq HAQRQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: R :: Pp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PRPpRp requis par la preuve de (?)PRPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPpRp requis par la preuve de (?)PRPpRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpRp requis par la preuve de (?)PRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpRpm2 : rk(P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HRRpeq : rk(R :: Rp :: nil) = 2) by (apply LRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpmtmp : rk(R :: Rp :: nil) >= 2) by (solve_hyps_min HRRpeq HRRpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (R :: Rp :: nil) (P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (R :: Rp :: nil) (P :: R :: Pp :: Rp :: nil) 2 2 HRRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRPpRpM3 : rk(P :: R :: Pp :: Rp :: nil) <= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: R :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) 3 3 HBPRPpRpMtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPRPpRpm3 : rk(P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpeq : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) = 4) by (apply LAPQRPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRPpQpRpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm4).
	assert(HRRpeq : rk(R :: Rp :: nil) = 2) by (apply LRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpmtmp : rk(R :: Rp :: nil) >= 2) by (solve_hyps_min HRRpeq HRRpm2).
	assert(Hincl : incl (R :: Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) (P :: R :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpmtmp;try rewrite HT2 in HAPQRPpQpRpmtmp.
	assert(HT := rule_2 (P :: R :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (R :: Rp :: nil) 4 2 3 HAPQRPpQpRpmtmp HRRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

assert(HPRPpRpM : rk(P :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpRpm : rk(P :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HPRPpRpeq HPRPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPRPpRp *)
(* dans la couche 0 *)
Lemma LABPRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRp requis par la preuve de (?)ABPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRp requis par la preuve de (?)ABPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRp requis par la preuve de (?)ABPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpm2 : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpm3 : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpm4 : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpRpM : rk(A :: B :: P :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpRpm : rk(A :: B :: P :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HABPRPpRpeq HABPRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRPpRp requis par la preuve de (?)APRPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRPpRp requis par la preuve de (?)APRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRPpRp requis par la preuve de (?)APRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ACPQRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRPpRp requis par la preuve de (?)ABCPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm2 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRPpRpm3 : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRPpRp requis par la preuve de (?)ACPQRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRPpRp requis par la preuve de (?)ACPQRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRPpRpm2 : rk(A :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Rp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQRPpRpm3 : rk(A :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRPpRpmtmp : rk(A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPQRPpRpeq HABCPQRPpRpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: Pp :: Rp :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRPpRpmtmp;try rewrite HT2 in HABCPQRPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Rp :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQRPpRpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRPpRp requis par la preuve de (?)APRPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRPpRpm2 : rk(A :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRPpRpmtmp : rk(A :: C :: P :: Q :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HACPQRPpRpeq HACPQRPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Pp :: Rp :: nil) (C :: P :: Q :: A :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Pp :: Rp :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRPpRpmtmp;try rewrite HT2 in HACPQRPpRpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HACPQRPpRpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRPpRpm3 : rk(A :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Rp :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAPRPpRpm4 : rk(A :: P :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpeq : rk(A :: B :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LABPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpRpmtmp : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABPRPpRpeq HABPRPpRpm4).
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpmtmp : rk(P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HPRPpRpeq HPRPpRpm3).
	assert(Hincl : incl (P :: R :: Pp :: Rp :: nil) (list_inter (A :: P :: R :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: R :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((A :: P :: R :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpmtmp;try rewrite HT2 in HABPRPpRpmtmp.
	assert(HT := rule_2 (A :: P :: R :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: R :: Pp :: Rp :: nil) 4 3 3 HABPRPpRpmtmp HPRPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

assert(HAPRPpRpM : rk(A :: P :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRPpRpm : rk(A :: P :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPRPpRpeq HAPRPpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCPRPpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm2 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm3 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpRpm2 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCPRPpRpm3 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCPRPpRpmtmp : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPRPpRpeq HABCPRPpRpm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: R :: Pp :: Rp :: nil) (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPRPpRpmtmp;try rewrite HT2 in HABCPRPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) (B :: C :: R :: nil) 3 3 3 HABCPRPpRpmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpRpm4 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCPRPpRpM : rk(B :: C :: P :: R :: Pp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpRpm : rk(B :: C :: P :: R :: Pp :: Rp ::  nil) >= 1) by (solve_hyps_min HBCPRPpRpeq HBCPRPpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCQpRp *)
(* dans la couche 0 *)
Lemma LABCQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCQpRp requis par la preuve de (?)ABCQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQpRp requis par la preuve de (?)ABCQpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQpRp requis par la preuve de (?)ABCQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpRpm2 : rk(A :: B :: C :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCQpRpM3 : rk(A :: B :: C :: Qp :: Rp :: nil) <= 3).
{
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: Rp :: nil) (A :: B :: C :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: Qp :: Rp :: nil) ((A :: B :: C :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (A :: Qp :: Rp :: nil) (A :: nil) 2 2 1 HABCMtmp HAQpRpMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQpRpm3 : rk(A :: B :: C :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Qp :: Rp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQpRpM : rk(A :: B :: C :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQpRpm : rk(A :: B :: C :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCQpRpeq HABCQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQpRp requis par la preuve de (?)BCQpRp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQpRp requis par la preuve de (?)BCQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQpRp requis par la preuve de (?)BCQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQpRpm2 : rk(B :: C :: Qp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Qp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Qp :: Rp ::  de rang :  3 et 3 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : A :: B :: C :: Qp ::   de rang : 3 et 3 *)
assert(HBCQpRpm3 : rk(B :: C :: Qp :: Rp :: nil) >= 3).
{
	assert(HABCQpeq : rk(A :: B :: C :: Qp :: nil) = 3) by (apply LABCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpMtmp : rk(A :: B :: C :: Qp :: nil) <= 3) by (solve_hyps_max HABCQpeq HABCQpM3).
	assert(HABCQpRpeq : rk(A :: B :: C :: Qp :: Rp :: nil) = 3) by (apply LABCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpRpmtmp : rk(A :: B :: C :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HABCQpRpeq HABCQpRpm3).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (A :: B :: C :: Qp :: nil) (B :: C :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Qp :: Rp :: nil) (A :: B :: C :: Qp :: B :: C :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: B :: C :: Qp :: Rp :: nil) ((A :: B :: C :: Qp :: nil) ++ (B :: C :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQpRpmtmp;try rewrite HT2 in HABCQpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Qp :: nil) (B :: C :: Qp :: Rp :: nil) (B :: C :: Qp :: nil) 3 3 3 HABCQpRpmtmp HBCQpmtmp HABCQpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQpRpM3 : rk(B :: C :: Qp :: Rp :: nil) <= 3).
{
	assert(HABCQpRpeq : rk(A :: B :: C :: Qp :: Rp :: nil) = 3) by (apply LABCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpRpMtmp : rk(A :: B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABCQpRpeq HABCQpRpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Qp :: Rp :: nil) (A :: B :: C :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: Qp :: Rp :: nil) (A :: B :: C :: Qp :: Rp :: nil) 3 3 HABCQpRpMtmp Hcomp Hincl);apply HT.
}

assert(HBCQpRpM : rk(B :: C :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQpRpm : rk(B :: C :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HBCQpRpeq HBCQpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPQpRp *)
(* dans la couche 0 *)
Lemma LAPQRQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRp requis par la preuve de (?)APQRQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRp requis par la preuve de (?)APQRQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRp requis par la preuve de (?)APQRQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 4).
{
	assert(HAPQRRpeq : rk(A :: P :: Q :: R :: Rp :: nil) = 4) by (apply LAPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRRpmtmp : rk(A :: P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRRpeq HAPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: nil) 4 4 HAPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpM : rk(A :: P :: Q :: R :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpm : rk(A :: P :: Q :: R :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpeq HAPQRQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APQpRp requis par la preuve de (?)APQpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQQpRp requis par la preuve de (?)APQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQQpRp requis par la preuve de (?)ACPQQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQQpRp requis par la preuve de (?)ABCPQQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQQpRp requis par la preuve de (?)ABCPQQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpRpm2 : rk(A :: B :: C :: P :: Q :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpRpm3 : rk(A :: B :: C :: P :: Q :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQQpRp requis par la preuve de (?)ACPQQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQQpRp requis par la preuve de (?)ACPQQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQQpRpm2 : rk(A :: C :: P :: Q :: Qp :: Rp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Qp :: Rp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Qp :: Rp ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQQpRpm3 : rk(A :: C :: P :: Q :: Qp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQQpRpmtmp : rk(A :: B :: C :: P :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPQQpRpeq HABCPQQpRpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Qp :: Rp :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Qp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQQpRpmtmp;try rewrite HT2 in HABCPQQpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Qp :: Rp :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQQpRpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APQpRp requis par la preuve de (?)APQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQpRp requis par la preuve de (?)APQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPQpRpM3 : rk(A :: P :: Qp :: Rp :: nil) <= 3).
{
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Qp :: Rp :: nil) (P :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: A :: Qp :: Rp :: nil) ((P :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (A :: Qp :: Rp :: nil) (nil) 1 2 0 HPMtmp HAQpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Qp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPQpRpm2 : rk(A :: P :: Qp :: Rp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQQpRpmtmp : rk(A :: C :: P :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HACPQQpRpeq HACPQQpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Qp :: Rp :: nil) (C :: P :: Q :: A :: P :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Qp :: Rp :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQQpRpmtmp;try rewrite HT2 in HACPQQpRpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Qp :: Rp :: nil) (P :: nil) 3 1 2 HACPQQpRpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HAPQpRpm3 : rk(A :: P :: Qp :: Rp :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpeq : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) = 4) by (apply LAPQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpeq HAPQRQpRpm4).
	assert(HAQpRpmtmp : rk(A :: Qp :: Rp :: nil) >= 2) by (solve_hyps_min HAQpRpeq HAQpRpm2).
	assert(Hincl : incl (A :: Qp :: Rp :: nil) (list_inter (A :: P :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Qp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Qp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((A :: P :: Qp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpmtmp;try rewrite HT2 in HAPQRQpRpmtmp.
	assert(HT := rule_2 (A :: P :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (A :: Qp :: Rp :: nil) 4 2 3 HAPQRQpRpmtmp HAQpRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

assert(HAPQpRpM : rk(A :: P :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQpRpm : rk(A :: P :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPQpRpeq HAPQpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQQpRp *)
(* dans constructLemma(), requis par LABQPpQpRp *)
(* dans la couche 0 *)
Lemma LABCPQPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpQpRp requis par la preuve de (?)ABCPQPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpQpRp requis par la preuve de (?)ABCPQPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpQpRp requis par la preuve de (?)ABCPQPpQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpm2 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpm3 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCPQPpQpRpm4 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) >= 4).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABCQPpRpeq HABCQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Q :: Pp :: Rp :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) 4 4 HABCQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCPQPpQpRpM : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPQPpQpRpm : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HABCPQPpQpRpeq HABCPQPpQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRp requis par la preuve de (?)ABQPpQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRp requis par la preuve de (?)ABQPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRp requis par la preuve de (?)ABQPpQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Qp :: Rp ::  de rang :  4 et 4 	 AiB : A :: B :: Q :: Pp :: Rp ::  de rang :  4 et 4 	 A : A :: B :: C :: P :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HABQPpQpRpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: nil) >= 4).
{
	assert(HABCPQPpRpeq : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCPQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPQPpRpMtmp : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCPQPpRpeq HABCPQPpRpM4).
	assert(HABCPQPpQpRpeq : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) = 4) by (apply LABCPQPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPQPpQpRpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HABCPQPpQpRpeq HABCPQPpQpRpm4).
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: A :: B :: Q :: Pp :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: P :: Q :: Pp :: Rp :: A :: B :: Q :: Pp :: Qp :: Rp :: nil) ((A :: B :: C :: P :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: Pp :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpQpRpmtmp;try rewrite HT2 in HABCPQPpQpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Pp :: Rp :: nil) 4 4 4 HABCPQPpQpRpmtmp HABQPpRpmtmp HABCPQPpRpMtmp Hincl); apply HT.
}

assert(HABQPpQpRpM : rk(A :: B :: Q :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpm : rk(A :: B :: Q :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpeq HABQPpQpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQQpRp *)
(* dans la couche 0 *)
Lemma LABPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Pp :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpQpRp requis par la preuve de (?)ABPpQpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpQpRp requis par la preuve de (?)ABPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpQpRp requis par la preuve de (?)ABPpQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpQpRpm2 : rk(A :: B :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpQpRpm3 : rk(A :: B :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: Pp :: Qp :: Rp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HABPpQpRpM3 : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3).
{
	assert(HABPpQpeq : rk(A :: B :: Pp :: Qp :: nil) = 3) by (apply LABPpQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpMtmp : rk(A :: B :: Pp :: Qp :: nil) <= 3) by (solve_hyps_max HABPpQpeq HABPpQpM3).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Pp :: Qp :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: A :: Qp :: Rp :: nil) ((A :: B :: Pp :: Qp :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: Pp :: Qp :: nil) (A :: Qp :: Rp :: nil) (A :: Qp :: nil) 3 2 2 HABPpQpMtmp HAQpRpMtmp HAQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABPpQpRpM : rk(A :: B :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPpQpRpm : rk(A :: B :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HABPpQpRpeq HABPpQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQQpRp requis par la preuve de (?)AQQpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQQpRp requis par la preuve de (?)AQQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRp requis par la preuve de (?)AQQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAQQpRpM3 : rk(A :: Q :: Qp :: Rp :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: nil) (Q :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: A :: Qp :: Rp :: nil) ((Q :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (A :: Qp :: Rp :: nil) (nil) 1 2 0 HQMtmp HAQpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpm2 : rk(A :: Q :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HAQQpRpm3 : rk(A :: Q :: Qp :: Rp :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: nil) = 4) by (apply LABQPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpQpRpeq HABQPpQpRpm4).
	assert(HAQpRpmtmp : rk(A :: Qp :: Rp :: nil) >= 2) by (solve_hyps_min HAQpRpeq HAQpRpm2).
	assert(Hincl : incl (A :: Qp :: Rp :: nil) (list_inter (A :: Q :: Qp :: Rp :: nil) (A :: B :: Pp :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: A :: B :: Pp :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Qp :: Rp :: A :: B :: Pp :: Qp :: Rp :: nil) ((A :: Q :: Qp :: Rp :: nil) ++ (A :: B :: Pp :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpmtmp;try rewrite HT2 in HABQPpQpRpmtmp.
	assert(HT := rule_2 (A :: Q :: Qp :: Rp :: nil) (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Qp :: Rp :: nil) 4 2 3 HABQPpQpRpmtmp HAQpRpmtmp HABPpQpRpMtmp Hincl);apply HT.
}

assert(HAQQpRpM : rk(A :: Q :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpm : rk(A :: Q :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAQQpRpeq HAQQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Qp :: Rp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRp requis par la preuve de (?)APQQpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ARQpRp requis par la preuve de (?)APQQpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HARQpRpM3 : rk(A :: R :: Qp :: Rp :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: Qp :: Rp :: nil) (R :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: A :: Qp :: Rp :: nil) ((R :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (A :: Qp :: Rp :: nil) (nil) 1 2 0 HRMtmp HAQpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpm2 : rk(A :: R :: Qp :: Rp :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Qp :: Rp :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpm3 : rk(A :: R :: Qp :: Rp :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRp requis par la preuve de (?)APQQpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRp requis par la preuve de (?)APQQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpm2 : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 5*)
assert(HAPQQpRpm3 : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 3).
{
	assert(HARQpRpMtmp : rk(A :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HARQpRpeq HARQpRpM3).
	assert(HAPQRQpRpeq : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) = 4) by (apply LAPQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpeq HAPQRQpRpm4).
	assert(HAQpRpmtmp : rk(A :: Qp :: Rp :: nil) >= 2) by (solve_hyps_min HAQpRpeq HAQpRpm2).
	assert(Hincl : incl (A :: Qp :: Rp :: nil) (list_inter (A :: P :: Q :: Qp :: Rp :: nil) (A :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: A :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: Qp :: Rp :: A :: R :: Qp :: Rp :: nil) ((A :: P :: Q :: Qp :: Rp :: nil) ++ (A :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpmtmp;try rewrite HT2 in HAPQRQpRpmtmp.
	assert(HT := rule_2 (A :: P :: Q :: Qp :: Rp :: nil) (A :: R :: Qp :: Rp :: nil) (A :: Qp :: Rp :: nil) 4 2 3 HAPQRQpRpmtmp HAQpRpmtmp HARQpRpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAPQQpRpm4 : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpeq : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) = 4) by (apply LAPQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpeq HAPQRQpRpm4).
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (list_inter (A :: P :: Q :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: Qp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((A :: P :: Q :: Qp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpmtmp;try rewrite HT2 in HAPQRQpRpmtmp.
	assert(HT := rule_2 (A :: P :: Q :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: nil) 4 3 3 HAPQRQpRpmtmp HAQQpRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

assert(HAPQQpRpM : rk(A :: P :: Q :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQQpRpm : rk(A :: P :: Q :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARQpRp requis par la preuve de (?)ARQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HARQpRpM3 : rk(A :: R :: Qp :: Rp :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: Qp :: Rp :: nil) (R :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: A :: Qp :: Rp :: nil) ((R :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (A :: Qp :: Rp :: nil) (nil) 1 2 0 HRMtmp HAQpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpm2 : rk(A :: R :: Qp :: Rp :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Qp :: Rp :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpm3 : rk(A :: R :: Qp :: Rp :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

assert(HARQpRpM : rk(A :: R :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARQpRpm : rk(A :: R :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HARQpRpeq HARQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpQpRp requis par la preuve de (?)APpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APpQpRp requis par la preuve de (?)APpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpQpRp requis par la preuve de (?)APpQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPpQpRpM3 : rk(A :: Pp :: Qp :: Rp :: nil) <= 3).
{
	assert(HPpMtmp : rk(Pp :: nil) <= 1) by (solve_hyps_max HPpeq HPpM1).
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: nil) (A :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: Qp :: Rp :: nil) (Pp :: A :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: A :: Qp :: Rp :: nil) ((Pp :: nil) ++ (A :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: nil) (A :: Qp :: Rp :: nil) (nil) 1 2 0 HPpMtmp HAQpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpQpRpm2 : rk(A :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: nil) (A :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: nil) (A :: Pp :: Qp :: Rp :: nil) 2 2 HAQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPpQpRpm3 : rk(A :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (A :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (A :: Pp :: Qp :: Rp :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPpQpRpM : rk(A :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpQpRpm : rk(A :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HAPpQpRpeq HAPpQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Pp :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPpQpRp requis par la preuve de (?)BPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPpQpRp requis par la preuve de (?)BPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPpQpRp requis par la preuve de (?)BPpQpRp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBPpQpRpM3 : rk(B :: Pp :: Qp :: Rp :: nil) <= 3).
{
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (B :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Pp :: Qp :: Rp :: nil) (Qp :: B :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: B :: Pp :: Rp :: nil) ((Qp :: nil) ++ (B :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (B :: Pp :: Rp :: nil) (nil) 1 2 0 HQpMtmp HBPpRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPpQpRpm2 : rk(B :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Pp :: Qp :: Rp :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPpQpRpm3 : rk(B :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (B :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (B :: Pp :: Qp :: Rp :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPpQpRpM : rk(B :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPpQpRpm : rk(B :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HBPpQpRpeq HBPpQpRpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPpQpRp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Pp :: Qp :: Rp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPpQpRp requis par la preuve de (?)CPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPpQpRp requis par la preuve de (?)CPpQpRp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPpQpRp requis par la preuve de (?)CPpQpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpQpRp requis par la preuve de (?)ABCPpQpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpQpRp requis par la preuve de (?)ABCPpQpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpRpm2 : rk(A :: B :: C :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpRpm3 : rk(A :: B :: C :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: Rp :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPpQpRp requis par la preuve de (?)CPpQpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Pp :: Qp :: Rp ::  de rang :  3 et 4 	 AiB : C :: Qp ::  de rang :  2 et 2 	 A : A :: B :: C :: Qp ::   de rang : 3 et 3 *)
assert(HCPpQpRpm2 : rk(C :: Pp :: Qp :: Rp :: nil) >= 2).
{
	assert(HABCQpeq : rk(A :: B :: C :: Qp :: nil) = 3) by (apply LABCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpMtmp : rk(A :: B :: C :: Qp :: nil) <= 3) by (solve_hyps_max HABCQpeq HABCQpM3).
	assert(HABCPpQpRpmtmp : rk(A :: B :: C :: Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPpQpRpeq HABCPpQpRpm3).
	assert(HCQpeq : rk(C :: Qp :: nil) = 2) by (apply LCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQpmtmp : rk(C :: Qp :: nil) >= 2) by (solve_hyps_min HCQpeq HCQpm2).
	assert(Hincl : incl (C :: Qp :: nil) (list_inter (A :: B :: C :: Qp :: nil) (C :: Pp :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Qp :: Rp :: nil) (A :: B :: C :: Qp :: C :: Pp :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: C :: Pp :: Qp :: Rp :: nil) ((A :: B :: C :: Qp :: nil) ++ (C :: Pp :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPpQpRpmtmp;try rewrite HT2 in HABCPpQpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Qp :: nil) (C :: Pp :: Qp :: Rp :: nil) (C :: Qp :: nil) 3 2 3 HABCPpQpRpmtmp HCQpmtmp HABCQpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HCPpQpRpM3 : rk(C :: Pp :: Qp :: Rp :: nil) <= 3).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Pp :: Qp :: nil) (Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Pp :: Qp :: Rp :: nil) (C :: Pp :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: Rp :: nil) ((C :: Pp :: Qp :: nil) ++ (Rp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Pp :: Qp :: nil) (Rp :: nil) (nil) 2 1 0 HCPpQpMtmp HRpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCPpQpRpm3 : rk(C :: Pp :: Qp :: Rp :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (C :: Pp :: Qp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (C :: Pp :: Qp :: Rp :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HCPpQpRpM : rk(C :: Pp :: Qp :: Rp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPpQpRpm : rk(C :: Pp :: Qp :: Rp ::  nil) >= 1) by (solve_hyps_min HCPpQpRpeq HCPpQpRpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAU *)
(* dans la couche 0 *)
Lemma LABQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABQU requis par la preuve de (?)ABQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABQU requis par la preuve de (?)ABQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQU requis par la preuve de (?)ABQU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABQUM3 : rk(A :: B :: Q :: U :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: U :: nil) (A :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Q :: U :: nil) ((A :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: Q :: U :: nil) (nil) 1 2 0 HAMtmp HBQUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQUm2 : rk(A :: B :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQUm3 : rk(A :: B :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

assert(HABQUM : rk(A :: B :: Q :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQUm : rk(A :: B :: Q :: U ::  nil) >= 1) by (solve_hyps_min HABQUeq HABQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: U ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AU requis par la preuve de (?)AU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAUm2 : rk(A :: U :: nil) >= 2).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HABQUeq : rk(A :: B :: Q :: U :: nil) = 3) by (apply LABQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQUmtmp : rk(A :: B :: Q :: U :: nil) >= 3) by (solve_hyps_min HABQUeq HABQUm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: U :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: U :: nil) (A :: U :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: U :: B :: Q :: U :: nil) ((A :: U :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQUmtmp;try rewrite HT2 in HABQUmtmp.
	assert(HT := rule_2 (A :: U :: nil) (B :: Q :: U :: nil) (U :: nil) 3 1 2 HABQUmtmp HUmtmp HBQUMtmp Hincl);apply HT.
}

assert(HAUM : rk(A :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAUeq HAUM2).
assert(HAUm : rk(A :: U ::  nil) >= 1) by (solve_hyps_min HAUeq HAUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQU *)
(* dans constructLemma(), requis par LAPQU *)
(* dans la couche 0 *)
Lemma LAPQRQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpU requis par la preuve de (?)APQRQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpU requis par la preuve de (?)APQRQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpU requis par la preuve de (?)APQRQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUM : rk(A :: P :: Q :: R :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUm : rk(A :: P :: Q :: R :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUeq HAPQRQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APQU requis par la preuve de (?)APQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APQU requis par la preuve de (?)APQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQU requis par la preuve de (?)APQU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPQUM3 : rk(A :: P :: Q :: U :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (A :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: nil) (Q :: A :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: A :: P :: U :: nil) ((Q :: nil) ++ (A :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (A :: P :: U :: nil) (nil) 1 2 0 HQMtmp HAPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUm2 : rk(A :: P :: Q :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQUm3 : rk(A :: P :: Q :: U :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) = 4) by (apply LAPQRQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUeq HAPQRQpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUmtmp;try rewrite HT2 in HAPQRQpRpUmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpUmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

assert(HAPQUM : rk(A :: P :: Q :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQUm : rk(A :: P :: Q :: U ::  nil) >= 1) by (solve_hyps_min HAPQUeq HAPQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: U ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QU requis par la preuve de (?)QU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: U ::  de rang :  3 et 3 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQUm2 : rk(Q :: U :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQUeq : rk(A :: P :: Q :: U :: nil) = 3) by (apply LAPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQUmtmp : rk(A :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HAPQUeq HAPQUm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: nil) (A :: P :: U :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: U :: nil) ((A :: P :: U :: nil) ++ (Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQUmtmp;try rewrite HT2 in HAPQUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: U :: nil) (U :: nil) 3 1 2 HAPQUmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HQUM : rk(Q :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQUeq HQUM2).
assert(HQUm : rk(Q :: U ::  nil) >= 1) by (solve_hyps_min HQUeq HQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQU requis par la preuve de (?)AQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQU requis par la preuve de (?)AQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQUm2 : rk(A :: Q :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: U ::  de rang :  3 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQUm3 : rk(A :: Q :: U :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQUeq : rk(A :: P :: Q :: U :: nil) = 3) by (apply LAPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQUmtmp : rk(A :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HAPQUeq HAPQUm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: nil) (A :: P :: U :: A :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: U :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQUmtmp;try rewrite HT2 in HAPQUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: U :: nil) (A :: U :: nil) 3 2 2 HAPQUmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HAQUM : rk(A :: Q :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAQUeq HAQUM3).
assert(HAQUm : rk(A :: Q :: U ::  nil) >= 1) by (solve_hyps_min HAQUeq HAQUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQU requis par la preuve de (?)ACQU pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQU requis par la preuve de (?)ACQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQU requis par la preuve de (?)ACQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQUm2 : rk(A :: C :: Q :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: U ::  de rang :  3 et 3 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQUm3 : rk(A :: C :: Q :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQUeq : rk(A :: B :: C :: Q :: U :: nil) = 3) by (apply LABCQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQUmtmp : rk(A :: B :: C :: Q :: U :: nil) >= 3) by (solve_hyps_min HABCQUeq HABCQUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: nil) (A :: B :: C :: Q :: A :: C :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQUmtmp;try rewrite HT2 in HABCQUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQUM3 : rk(A :: C :: Q :: U :: nil) <= 3).
{
	assert(HABCQUeq : rk(A :: B :: C :: Q :: U :: nil) = 3) by (apply LABCQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQUMtmp : rk(A :: B :: C :: Q :: U :: nil) <= 3) by (solve_hyps_max HABCQUeq HABCQUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: U :: nil) (A :: B :: C :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Q :: U :: nil) (A :: B :: C :: Q :: U :: nil) 3 3 HABCQUMtmp Hcomp Hincl);apply HT.
}

assert(HACQUM : rk(A :: C :: Q :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQUm : rk(A :: C :: Q :: U ::  nil) >= 1) by (solve_hyps_min HACQUeq HACQUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LRU *)
(* dans la couche 0 *)
Lemma LAPRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APRU requis par la preuve de (?)APRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRU requis par la preuve de (?)APRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRU requis par la preuve de (?)APRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRU requis par la preuve de (?)ACPQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRU requis par la preuve de (?)ABCPQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRU requis par la preuve de (?)ABCPQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRUm2 : rk(A :: B :: C :: P :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRUm3 : rk(A :: B :: C :: P :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRU requis par la preuve de (?)ACPQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRU requis par la preuve de (?)ACPQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRUm2 : rk(A :: C :: P :: Q :: R :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQRUm3 : rk(A :: C :: P :: Q :: R :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRUmtmp : rk(A :: B :: C :: P :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HABCPQRUeq HABCPQRUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: U :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRUmtmp;try rewrite HT2 in HABCPQRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQRUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRU requis par la preuve de (?)APRU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRUm2 : rk(A :: P :: R :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRUmtmp : rk(A :: C :: P :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HACPQRUeq HACPQRUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: U :: nil) (C :: P :: Q :: A :: P :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: U :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRUmtmp;try rewrite HT2 in HACPQRUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: U :: nil) (P :: nil) 3 1 2 HACPQRUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPRUM3 : rk(A :: P :: R :: U :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (A :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: U :: nil) (R :: A :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: A :: P :: U :: nil) ((R :: nil) ++ (A :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (A :: P :: U :: nil) (nil) 1 2 0 HRMtmp HAPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : A :: R ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRUm3 : rk(A :: P :: R :: U :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) = 4) by (apply LAPQRQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUeq HAPQRQpRpUm4).
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hincl : incl (A :: R :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: U :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUmtmp;try rewrite HT2 in HAPQRQpRpUmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: U :: nil) (A :: R :: nil) 4 2 3 HAPQRQpRpUmtmp HARmtmp HAQRQpRpMtmp Hincl); apply HT.
}

assert(HAPRUM : rk(A :: P :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRUm : rk(A :: P :: R :: U ::  nil) >= 1) by (solve_hyps_min HAPRUeq HAPRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(R :: U ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RU requis par la preuve de (?)RU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: P :: R :: U ::  de rang :  3 et 3 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HRUm2 : rk(R :: U :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRUeq : rk(A :: P :: R :: U :: nil) = 3) by (apply LAPRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRUmtmp : rk(A :: P :: R :: U :: nil) >= 3) by (solve_hyps_min HAPRUeq HAPRUm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: U :: nil) (A :: P :: U :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: R :: U :: nil) ((A :: P :: U :: nil) ++ (R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRUmtmp;try rewrite HT2 in HAPRUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (R :: U :: nil) (U :: nil) 3 1 2 HAPRUmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HRUM : rk(R :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRUeq HRUM2).
assert(HRUm : rk(R :: U ::  nil) >= 1) by (solve_hyps_min HRUeq HRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARU requis par la preuve de (?)ARU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARU requis par la preuve de (?)ARU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARUm2 : rk(A :: R :: U :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: U :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: U ::  de rang :  3 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HARUm3 : rk(A :: R :: U :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRUeq : rk(A :: P :: R :: U :: nil) = 3) by (apply LAPRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRUmtmp : rk(A :: P :: R :: U :: nil) >= 3) by (solve_hyps_min HAPRUeq HAPRUm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: U :: nil) (A :: P :: U :: A :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: R :: U :: nil) ((A :: P :: U :: nil) ++ (A :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRUmtmp;try rewrite HT2 in HAPRUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: R :: U :: nil) (A :: U :: nil) 3 2 2 HAPRUmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HARUM : rk(A :: R :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HARUeq HARUM3).
assert(HARUm : rk(A :: R :: U ::  nil) >= 1) by (solve_hyps_min HARUeq HARUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABRU *)
(* dans la couche 0 *)
Lemma LABPRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRU requis par la preuve de (?)ABPRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRU requis par la preuve de (?)ABPRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRU requis par la preuve de (?)ABPRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRUm2 : rk(A :: B :: P :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRUm3 : rk(A :: B :: P :: R :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABPRUM3 : rk(A :: B :: P :: R :: U :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (A :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: U :: nil) (B :: P :: R :: A :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: A :: P :: U :: nil) ((B :: P :: R :: nil) ++ (A :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (A :: P :: U :: nil) (P :: nil) 2 2 1 HBPRMtmp HAPUMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABPRUM : rk(A :: B :: P :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRUm : rk(A :: B :: P :: R :: U ::  nil) >= 1) by (solve_hyps_min HABPRUeq HABPRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRU requis par la preuve de (?)ABRU pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRU requis par la preuve de (?)ABRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRU requis par la preuve de (?)ABRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRUm2 : rk(A :: B :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRUm3 : rk(A :: B :: R :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABRUM3 : rk(A :: B :: R :: U :: nil) <= 3).
{
	assert(HABPRUeq : rk(A :: B :: P :: R :: U :: nil) = 3) by (apply LABPRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRUMtmp : rk(A :: B :: P :: R :: U :: nil) <= 3) by (solve_hyps_max HABPRUeq HABPRUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: U :: nil) (A :: B :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: R :: U :: nil) (A :: B :: P :: R :: U :: nil) 3 3 HABPRUMtmp Hcomp Hincl);apply HT.
}

assert(HABRUM : rk(A :: B :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRUm : rk(A :: B :: R :: U ::  nil) >= 1) by (solve_hyps_min HABRUeq HABRUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCRU *)
(* dans la couche 0 *)
Lemma LABCPRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPRU requis par la preuve de (?)ABCPRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPRU requis par la preuve de (?)ABCPRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPRU requis par la preuve de (?)ABCPRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRUm2 : rk(A :: B :: C :: P :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRUm3 : rk(A :: B :: C :: P :: R :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: P :: R :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABCPRUM3 : rk(A :: B :: C :: P :: R :: U :: nil) <= 3).
{
	assert(HABCPReq : rk(A :: B :: C :: P :: R :: nil) = 3) by (apply LABCPR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPRMtmp : rk(A :: B :: C :: P :: R :: nil) <= 3) by (solve_hyps_max HABCPReq HABCPRM3).
	assert(HABPRUeq : rk(A :: B :: P :: R :: U :: nil) = 3) by (apply LABPRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRUMtmp : rk(A :: B :: P :: R :: U :: nil) <= 3) by (solve_hyps_max HABPRUeq HABPRUM3).
	assert(HABPReq : rk(A :: B :: P :: R :: nil) = 3) by (apply LABPR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRmtmp : rk(A :: B :: P :: R :: nil) >= 3) by (solve_hyps_min HABPReq HABPRm3).
	assert(Hincl : incl (A :: B :: P :: R :: nil) (list_inter (A :: B :: C :: P :: R :: nil) (A :: B :: P :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: R :: U :: nil) (A :: B :: C :: P :: R :: A :: B :: P :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: P :: R :: A :: B :: P :: R :: U :: nil) ((A :: B :: C :: P :: R :: nil) ++ (A :: B :: P :: R :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: P :: R :: nil) (A :: B :: P :: R :: U :: nil) (A :: B :: P :: R :: nil) 3 3 3 HABCPRMtmp HABPRUMtmp HABPRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCPRUM : rk(A :: B :: C :: P :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPRUm : rk(A :: B :: C :: P :: R :: U ::  nil) >= 1) by (solve_hyps_min HABCPRUeq HABCPRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRU requis par la preuve de (?)BCRU pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRU requis par la preuve de (?)BCRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRU requis par la preuve de (?)ABCRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRU requis par la preuve de (?)ABCRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRUm2 : rk(A :: B :: C :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRUm3 : rk(A :: B :: C :: R :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRU requis par la preuve de (?)BCRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRU requis par la preuve de (?)BCRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRUm2 : rk(B :: C :: R :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: U ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRUm3 : rk(B :: C :: R :: U :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRUmtmp : rk(A :: B :: C :: R :: U :: nil) >= 3) by (solve_hyps_min HABCRUeq HABCRUm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: U :: nil) (A :: B :: C :: R :: B :: C :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: U :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRUmtmp;try rewrite HT2 in HABCRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: U :: nil) (B :: C :: R :: nil) 3 3 3 HABCRUmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCRUM3 : rk(B :: C :: R :: U :: nil) <= 3).
{
	assert(HABCPRUeq : rk(A :: B :: C :: P :: R :: U :: nil) = 3) by (apply LABCPRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPRUMtmp : rk(A :: B :: C :: P :: R :: U :: nil) <= 3) by (solve_hyps_max HABCPRUeq HABCPRUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: U :: nil) (A :: B :: C :: P :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: R :: U :: nil) (A :: B :: C :: P :: R :: U :: nil) 3 3 HABCPRUMtmp Hcomp Hincl);apply HT.
}

assert(HBCRUM : rk(B :: C :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRUm : rk(B :: C :: R :: U ::  nil) >= 1) by (solve_hyps_min HBCRUeq HBCRUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQRU *)
(* dans constructLemma(), requis par LBQRU *)
(* dans la couche 0 *)
Lemma LBPQRPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Q :: R :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpU requis par la preuve de (?)BPQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpU requis par la preuve de (?)BPQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpU requis par la preuve de (?)BPQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPQRPpRpUM : rk(B :: P :: Q :: R :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPQRPpRpUm : rk(B :: P :: Q :: R :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBPQRPpRpUeq HBPQRPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQRU requis par la preuve de (?)BQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQRU requis par la preuve de (?)BQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQRU requis par la preuve de (?)BQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQRUm2 : rk(B :: Q :: R :: U :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: R :: U :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBQRUM3 : rk(B :: Q :: R :: U :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: R :: U :: nil) (R :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: B :: Q :: U :: nil) ((R :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (B :: Q :: U :: nil) (nil) 1 2 0 HRMtmp HBQUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: Q :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : B :: R ::  de rang :  2 et 2 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HBQRUm3 : rk(B :: Q :: R :: U :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpUeq : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LBPQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpUmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBPQRPpRpUeq HBPQRPpRpUm4).
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hincl : incl (B :: R :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: U :: nil) (B :: P :: R :: Pp :: Rp :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: B :: Q :: R :: U :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpUmtmp;try rewrite HT2 in HBPQRPpRpUmtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: R :: U :: nil) (B :: R :: nil) 4 2 3 HBPQRPpRpUmtmp HBRmtmp HBPRPpRpMtmp Hincl); apply HT.
}

assert(HBQRUM : rk(B :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQRUm : rk(B :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HBQRUeq HBQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QRU requis par la preuve de (?)QRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)QRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QRU requis par la preuve de (?)QRU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQRUm2 : rk(Q :: R :: U :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpRpUmtmp : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HPQRPpRpUeq HPQRPpRpUm4).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: U :: nil) (P :: R :: Pp :: Rp :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: R :: U :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpUmtmp;try rewrite HT2 in HPQRPpRpUmtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: R :: U :: nil) (R :: nil) 4 1 3 HPQRPpRpUmtmp HRmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Q :: R :: U ::  de rang :  3 et 3 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HQRUm3 : rk(Q :: R :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQRUeq : rk(B :: Q :: R :: U :: nil) = 3) by (apply LBQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQRUmtmp : rk(B :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HBQRUeq HBQRUm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: R :: U :: nil) (B :: Q :: U :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: R :: U :: nil) ((B :: Q :: U :: nil) ++ (Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQRUmtmp;try rewrite HT2 in HBQRUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (Q :: R :: U :: nil) (Q :: U :: nil) 3 2 2 HBQRUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HQRUM : rk(Q :: R :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQRUeq HQRUM3).
assert(HQRUm : rk(Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HQRUeq HQRUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQRU *)
(* dans la couche 0 *)
Lemma LAPQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APQRU requis par la preuve de (?)APQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRU requis par la preuve de (?)APQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRU requis par la preuve de (?)APQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRUm2 : rk(A :: P :: Q :: R :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAPQRUM3 : rk(A :: P :: Q :: R :: U :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Q :: R :: nil) (A :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: U :: nil) (A :: Q :: R :: A :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: A :: P :: U :: nil) ((A :: Q :: R :: nil) ++ (A :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (A :: P :: U :: nil) (A :: nil) 2 2 1 HAQRMtmp HAPUMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRUm3 : rk(A :: P :: Q :: R :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRUM : rk(A :: P :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRUm : rk(A :: P :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HAPQRUeq HAPQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRU requis par la preuve de (?)AQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRU requis par la preuve de (?)AQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRU requis par la preuve de (?)AQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRUm2 : rk(A :: Q :: R :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAQRUM3 : rk(A :: Q :: R :: U :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HUMtmp : rk(U :: nil) <= 1) by (solve_hyps_max HUeq HUM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Q :: R :: nil) (U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: U :: nil) (A :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: U :: nil) ((A :: Q :: R :: nil) ++ (U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (U :: nil) (nil) 2 1 0 HAQRMtmp HUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: U ::  de rang :  3 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQRUm3 : rk(A :: Q :: R :: U :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQRUeq : rk(A :: P :: Q :: R :: U :: nil) = 3) by (apply LAPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRUmtmp : rk(A :: P :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HAPQRUeq HAPQRUm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: U :: nil) (A :: P :: U :: A :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: R :: U :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRUmtmp;try rewrite HT2 in HAPQRUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: R :: U :: nil) (A :: U :: nil) 3 2 2 HAPQRUmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HAQRUM : rk(A :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRUm : rk(A :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HAQRUeq HAQRUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCQRU *)
(* dans la couche 0 *)
Lemma LACQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQRU requis par la preuve de (?)ACQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ACQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm2 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm3 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQRU requis par la preuve de (?)ACQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQRU requis par la preuve de (?)ACQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQRUm2 : rk(A :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: R :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQRUm3 : rk(A :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUmtmp : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HABCQRUeq HABCQRUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: nil) (A :: B :: C :: Q :: A :: C :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: R :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUmtmp;try rewrite HT2 in HABCQRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: R :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQRUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACQRUM3 : rk(A :: C :: Q :: R :: U :: nil) <= 3).
{
	assert(HACQUeq : rk(A :: C :: Q :: U :: nil) = 3) by (apply LACQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQUMtmp : rk(A :: C :: Q :: U :: nil) <= 3) by (solve_hyps_max HACQUeq HACQUM3).
	assert(HAQRUeq : rk(A :: Q :: R :: U :: nil) = 3) by (apply LAQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUMtmp : rk(A :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAQRUeq HAQRUM3).
	assert(HAQUeq : rk(A :: Q :: U :: nil) = 3) by (apply LAQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQUmtmp : rk(A :: Q :: U :: nil) >= 3) by (solve_hyps_min HAQUeq HAQUm3).
	assert(Hincl : incl (A :: Q :: U :: nil) (list_inter (A :: C :: Q :: U :: nil) (A :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: R :: U :: nil) (A :: C :: Q :: U :: A :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Q :: U :: A :: Q :: R :: U :: nil) ((A :: C :: Q :: U :: nil) ++ (A :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: Q :: U :: nil) (A :: Q :: R :: U :: nil) (A :: Q :: U :: nil) 3 3 3 HACQUMtmp HAQRUMtmp HAQUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACQRUM : rk(A :: C :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQRUm : rk(A :: C :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HACQRUeq HACQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQRU requis par la preuve de (?)CQRU pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCQRU requis par la preuve de (?)CQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRU requis par la preuve de (?)BCQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm2 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm3 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQRUm2 : rk(B :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: R :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQRUm3 : rk(B :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUmtmp : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HABCQRUeq HABCQRUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUmtmp;try rewrite HT2 in HABCQRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQRUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBCQRUM3 : rk(B :: C :: Q :: R :: U :: nil) <= 3).
{
	assert(HBCQReq : rk(B :: C :: Q :: R :: nil) = 3) by (apply LBCQR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQRMtmp : rk(B :: C :: Q :: R :: nil) <= 3) by (solve_hyps_max HBCQReq HBCQRM3).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hincl : incl (B :: Q :: nil) (list_inter (B :: C :: Q :: R :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: R :: U :: nil) (B :: C :: Q :: R :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Q :: R :: B :: Q :: U :: nil) ((B :: C :: Q :: R :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: Q :: R :: nil) (B :: Q :: U :: nil) (B :: Q :: nil) 3 2 2 HBCQRMtmp HBQUMtmp HBQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQRU requis par la preuve de (?)CQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQRU requis par la preuve de (?)CQRU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQRUm2 : rk(C :: Q :: R :: U :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUmtmp : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HABCQRUeq HABCQRUm3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: nil) (A :: B :: C :: Q :: C :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: R :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUmtmp;try rewrite HT2 in HABCQRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: R :: U :: nil) (C :: Q :: nil) 3 2 3 HABCQRUmtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: R :: U ::  de rang :  3 et 3 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQRUm3 : rk(C :: Q :: R :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQRUmtmp : rk(B :: C :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HBCQRUeq HBCQRUm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: R :: U :: nil) (B :: Q :: U :: C :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: R :: U :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQRUmtmp;try rewrite HT2 in HBCQRUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: R :: U :: nil) (Q :: U :: nil) 3 2 2 HBCQRUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCQRUM3 : rk(C :: Q :: R :: U :: nil) <= 3).
{
	assert(HACQRUeq : rk(A :: C :: Q :: R :: U :: nil) = 3) by (apply LACQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQRUMtmp : rk(A :: C :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HACQRUeq HACQRUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Q :: R :: U :: nil) (A :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Q :: R :: U :: nil) (A :: C :: Q :: R :: U :: nil) 3 3 HACQRUMtmp Hcomp Hincl);apply HT.
}

assert(HCQRUM : rk(C :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQRUm : rk(C :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HCQRUeq HCQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRU requis par la preuve de (?)BCQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRU requis par la preuve de (?)ABCQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm2 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUm3 : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQRU requis par la preuve de (?)BCQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQRUm2 : rk(B :: C :: Q :: R :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: R :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQRUm3 : rk(B :: C :: Q :: R :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUmtmp : rk(A :: B :: C :: Q :: R :: U :: nil) >= 3) by (solve_hyps_min HABCQRUeq HABCQRUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUmtmp;try rewrite HT2 in HABCQRUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQRUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBCQRUM3 : rk(B :: C :: Q :: R :: U :: nil) <= 3).
{
	assert(HBCQReq : rk(B :: C :: Q :: R :: nil) = 3) by (apply LBCQR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQRMtmp : rk(B :: C :: Q :: R :: nil) <= 3) by (solve_hyps_max HBCQReq HBCQRM3).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hincl : incl (B :: Q :: nil) (list_inter (B :: C :: Q :: R :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: R :: U :: nil) (B :: C :: Q :: R :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Q :: R :: B :: Q :: U :: nil) ((B :: C :: Q :: R :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: Q :: R :: nil) (B :: Q :: U :: nil) (B :: Q :: nil) 3 2 2 HBCQRMtmp HBQUMtmp HBQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCQRUM : rk(B :: C :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQRUm : rk(B :: C :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HBCQRUeq HBCQRUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRU requis par la preuve de (?)PQRU pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRU requis par la preuve de (?)PQRU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRUm3 : rk(P :: Q :: R :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRUM3 : rk(P :: Q :: R :: U :: nil) <= 3).
{
	assert(HAPQRUeq : rk(A :: P :: Q :: R :: U :: nil) = 3) by (apply LAPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRUMtmp : rk(A :: P :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAPQRUeq HAPQRUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: U :: nil) (A :: P :: Q :: R :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: Q :: R :: U :: nil) (A :: P :: Q :: R :: U :: nil) 3 3 HAPQRUMtmp Hcomp Hincl);apply HT.
}

assert(HPQRUM : rk(P :: Q :: R :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRUm : rk(P :: Q :: R :: U ::  nil) >= 1) by (solve_hyps_min HPQRUeq HPQRUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpU *)
(* dans constructLemma(), requis par LCQPpQpUOo *)
(* dans constructLemma(), requis par LBCQPpQpUOo *)
(* dans la couche 0 *)
Lemma LBCQPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpRpUOo requis par la preuve de (?)BCQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpRpUOo requis par la preuve de (?)BCQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpRpUOo requis par la preuve de (?)BCQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpRpUOom2 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpQpRpUOom3 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpQpRpUOom4 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HBCQPpRpeq : rk(B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LBCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpRpmtmp : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCQPpRpeq HBCQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HBCQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCQPpQpRpUOoM : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpRpUOom : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBCQPpQpRpUOoeq HBCQPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpUOo requis par la preuve de (?)BCQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpUOo requis par la preuve de (?)BCQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpUOo requis par la preuve de (?)BCQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpUOom2 : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpQpUOom3 : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCQPpQpUOom4 : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCQPpQpRpUOoeq : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LBCQPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpRpUOomtmp : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCQPpQpRpUOoeq HBCQPpQpRpUOom4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpRpUOomtmp;try rewrite HT2 in HBCQPpQpRpUOomtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCQPpQpRpUOomtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCQPpQpUOoM : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpUOom : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBCQPpQpUOoeq HBCQPpQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQPpQpUOo requis par la preuve de (?)CQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)CQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpUOom2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUOom3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUOom4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQPpQpUOo requis par la preuve de (?)CQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpUOo requis par la preuve de (?)CQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpUOo requis par la preuve de (?)ABCQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpUOo requis par la preuve de (?)ABCQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQPpQpUOo requis par la preuve de (?)CQPpQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQPpQpUOom2 : rk(C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpUOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HABCQPpQpUOoeq HABCQPpQpUOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpUOomtmp;try rewrite HT2 in HABCQPpQpUOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCQPpQpUOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HCQPpQpUOom3 : rk(C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HACQPpQpRpUOomtmp : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HACQPpQpRpUOoeq HACQPpQpRpUOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpRpUOomtmp;try rewrite HT2 in HACQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil) (Qp :: nil) 4 1 2 HACQPpQpRpUOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQPpQpUOom4 : rk(C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQPpQpUOoeq : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) = 4) by (apply LBCQPpQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpUOomtmp : rk(B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCQPpQpUOoeq HBCQPpQpUOom4).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) (B :: Q :: U :: C :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: Pp :: Qp :: U :: Oo :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpUOomtmp;try rewrite HT2 in HBCQPpQpUOomtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: Pp :: Qp :: U :: Oo :: nil) (Q :: U :: nil) 4 2 2 HBCQPpQpUOomtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HCQPpQpUOoM : rk(C :: Q :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQPpQpUOom : rk(C :: Q :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HCQPpQpUOoeq HCQPpQpUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpU *)
(* dans constructLemma(), requis par LCQPpQpOo *)
(* dans la couche 0 *)
Lemma LACQPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpOo requis par la preuve de (?)ACQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpOo requis par la preuve de (?)ACQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpOo requis par la preuve de (?)ACQPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpOom2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpOom3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpOom4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HACQPpQpRpOoM : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpQpRpOom : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HACQPpQpRpOoeq HACQPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQPpQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: Pp :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CQPpQpOo requis par la preuve de (?)CQPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQPpQpOo requis par la preuve de (?)CQPpQpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpOo requis par la preuve de (?)CQPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpOo requis par la preuve de (?)ABCQPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpOo requis par la preuve de (?)ABCQPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQPpQpOo requis par la preuve de (?)CQPpQpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQPpQpOom2 : rk(C :: Q :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HABCQPpQpOoeq HABCQPpQpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Oo :: nil) (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpOomtmp;try rewrite HT2 in HABCQPpQpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCQPpQpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HCQPpQpOoM3 : rk(C :: Q :: Pp :: Qp :: Oo :: nil) <= 3).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (C :: Pp :: Qp :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: Pp :: Qp :: Oo :: nil) (C :: Pp :: Qp :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: Q :: Qp :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Pp :: Qp :: nil) (Q :: Qp :: Oo :: nil) (Qp :: nil) 2 2 1 HCPpQpMtmp HQQpOoMtmp HQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HCQPpQpOom3 : rk(C :: Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HACQPpQpRpOoeq : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LACQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpQpRpOomtmp : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HACQPpQpRpOoeq HACQPpQpRpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (C :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpRpOomtmp;try rewrite HT2 in HACQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil) (Qp :: nil) 4 1 2 HACQPpQpRpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HCQPpQpOoM : rk(C :: Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQPpQpOom : rk(C :: Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HCQPpQpOoeq HCQPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Pp :: U ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpU requis par la preuve de (?)PpU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPpUm2 : rk(Pp :: U :: nil) >= 2).
{
	assert(HCQPpQpOoeq : rk(C :: Q :: Pp :: Qp :: Oo :: nil) = 3) by (apply LCQPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpOoMtmp : rk(C :: Q :: Pp :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HCQPpQpOoeq HCQPpQpOoM3).
	assert(HCQPpQpUOoeq : rk(C :: Q :: Pp :: Qp :: U :: Oo :: nil) = 4) by (apply LCQPpQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpUOomtmp : rk(C :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HCQPpQpUOoeq HCQPpQpUOom4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (Pp :: U :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: Pp :: Qp :: U :: Oo :: nil) (Pp :: U :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: U :: C :: Q :: Pp :: Qp :: Oo :: nil) ((Pp :: U :: nil) ++ (C :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCQPpQpUOomtmp;try rewrite HT2 in HCQPpQpUOomtmp.
	assert(HT := rule_2 (Pp :: U :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil) (Pp :: nil) 4 1 3 HCQPpQpUOomtmp HPpmtmp HCQPpQpOoMtmp Hincl);apply HT.
}

assert(HPpUM : rk(Pp :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpUeq HPpUM2).
assert(HPpUm : rk(Pp :: U ::  nil) >= 1) by (solve_hyps_min HPpUeq HPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPpU *)
(* dans la couche 0 *)
Lemma LABQPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpRpU requis par la preuve de (?)ABQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpRpU requis par la preuve de (?)ABQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpRpU requis par la preuve de (?)ABQPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpRpUm2 : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpRpUm3 : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpRpUm4 : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Rp :: U :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpRpUM : rk(A :: B :: Q :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpRpUm : rk(A :: B :: Q :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABQPpRpUeq HABQPpRpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPpU *)
(* dans la couche 0 *)
Lemma LBQPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Rp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQPpRpU requis par la preuve de (?)BQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpRpU requis par la preuve de (?)BQPpRpU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpRpU requis par la preuve de (?)BQPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpRpUm2 : rk(B :: Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Rp :: U :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBQPpRpUM3 : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Pp :: Rp :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Rp :: U :: nil) (B :: Pp :: Rp :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: B :: Q :: U :: nil) ((B :: Pp :: Rp :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Pp :: Rp :: nil) (B :: Q :: U :: nil) (B :: nil) 2 2 1 HBPpRpMtmp HBQUMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpRpUm3 : rk(B :: Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Rp :: U :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBQPpRpUM : rk(B :: Q :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpRpUm : rk(B :: Q :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBQPpRpUeq HBQPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpU requis par la preuve de (?)APpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpU requis par la preuve de (?)APpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)ACPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)ABCPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)ABCPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUm2 : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUm3 : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpU requis par la preuve de (?)ACPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpU requis par la preuve de (?)ACPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUm2 : rk(A :: C :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Qp ::  de rang :  3 et 3 	 A : A :: B :: C :: Qp ::   de rang : 3 et 3 *)
assert(HACPpQpUm3 : rk(A :: C :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABCQpeq : rk(A :: B :: C :: Qp :: nil) = 3) by (apply LABCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpMtmp : rk(A :: B :: C :: Qp :: nil) <= 3) by (solve_hyps_max HABCQpeq HABCQpM3).
	assert(HABCPpQpUmtmp : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCPpQpUeq HABCPpQpUm3).
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hincl : incl (A :: C :: Qp :: nil) (list_inter (A :: B :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Qp :: U :: nil) (A :: B :: C :: Qp :: A :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: A :: C :: Pp :: Qp :: U :: nil) ((A :: B :: C :: Qp :: nil) ++ (A :: C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPpQpUmtmp;try rewrite HT2 in HABCPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: nil) (A :: C :: Qp :: nil) 3 3 3 HABCPpQpUmtmp HACQpmtmp HABCQpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APpU requis par la preuve de (?)APpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUm2 : rk(A :: Pp :: U :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUmtmp : rk(A :: C :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HACPpQpUeq HACPpQpUm3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUmtmp;try rewrite HT2 in HACPpQpUmtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: nil) (Pp :: nil) 3 1 2 HACPpQpUmtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAPpUm3 : rk(A :: Pp :: U :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HABQPpRpUeq : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LABQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpUmtmp : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQPpRpUeq HABQPpRpUm4).
	assert(HPpUeq : rk(Pp :: U :: nil) = 2) by (apply LPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUmtmp : rk(Pp :: U :: nil) >= 2) by (solve_hyps_min HPpUeq HPpUm2).
	assert(Hincl : incl (Pp :: U :: nil) (list_inter (A :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Rp :: U :: nil) (A :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil) ((A :: Pp :: U :: nil) ++ (B :: Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpRpUmtmp;try rewrite HT2 in HABQPpRpUmtmp.
	assert(HT := rule_2 (A :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil) (Pp :: U :: nil) 4 2 3 HABQPpRpUmtmp HPpUmtmp HBQPpRpUMtmp Hincl);apply HT.
}

assert(HAPpUM : rk(A :: Pp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAPpUeq HAPpUM3).
assert(HAPpUm : rk(A :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HAPpUeq HAPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCPpU *)
(* dans la couche 0 *)
Lemma LBCQPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpRpU requis par la preuve de (?)BCQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)BCQPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)ABCQPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpRpU requis par la preuve de (?)ABCQPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpUm2 : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpRpUm3 : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpRpU requis par la preuve de (?)BCQPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpRpU requis par la preuve de (?)BCQPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpRpUm2 : rk(B :: C :: Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Rp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpRpUm3 : rk(B :: C :: Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpRpUeq HABCQPpRpUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Rp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpUmtmp;try rewrite HT2 in HABCQPpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpRpUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpRpUm4 : rk(B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HBCQPpRpeq : rk(B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LBCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpRpmtmp : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCQPpRpeq HBCQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Rp :: U :: nil) 4 4 HBCQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCQPpRpUM : rk(B :: C :: Q :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpRpUm : rk(B :: C :: Q :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBCQPpRpUeq HBCQPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Pp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPpU requis par la preuve de (?)CPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPpRpU requis par la preuve de (?)CPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPpRpU requis par la preuve de (?)BCPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpRpU requis par la preuve de (?)ABCPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpRpU requis par la preuve de (?)ABCPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpRpUm2 : rk(A :: B :: C :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpRpUm3 : rk(A :: B :: C :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: C :: Pp :: Rp :: U :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPpRpU requis par la preuve de (?)BCPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPpRpU requis par la preuve de (?)BCPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPpRpUm2 : rk(B :: C :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Pp :: Rp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Pp :: Rp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Rp ::  de rang :  3 et 3 	 A : A :: B :: C :: Rp ::   de rang : 3 et 3 *)
assert(HBCPpRpUm3 : rk(B :: C :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABCRpeq : rk(A :: B :: C :: Rp :: nil) = 3) by (apply LABCRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRpMtmp : rk(A :: B :: C :: Rp :: nil) <= 3) by (solve_hyps_max HABCRpeq HABCRpM3).
	assert(HABCPpRpUmtmp : rk(A :: B :: C :: Pp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCPpRpUeq HABCPpRpUm3).
	assert(HBCRpeq : rk(B :: C :: Rp :: nil) = 3) by (apply LBCRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRpmtmp : rk(B :: C :: Rp :: nil) >= 3) by (solve_hyps_min HBCRpeq HBCRpm3).
	assert(Hincl : incl (B :: C :: Rp :: nil) (list_inter (A :: B :: C :: Rp :: nil) (B :: C :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Rp :: U :: nil) (A :: B :: C :: Rp :: B :: C :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Rp :: B :: C :: Pp :: Rp :: U :: nil) ((A :: B :: C :: Rp :: nil) ++ (B :: C :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPpRpUmtmp;try rewrite HT2 in HABCPpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Rp :: nil) (B :: C :: Pp :: Rp :: U :: nil) (B :: C :: Rp :: nil) 3 3 3 HABCPpRpUmtmp HBCRpmtmp HABCRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CPpU requis par la preuve de (?)CPpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Pp :: Rp :: U ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HCPpUm2 : rk(C :: Pp :: U :: nil) >= 2).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBCPpRpUmtmp : rk(B :: C :: Pp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HBCPpRpUeq HBCPpRpUm3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (C :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Pp :: Rp :: U :: nil) (B :: Pp :: Rp :: C :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: C :: Pp :: U :: nil) ((B :: Pp :: Rp :: nil) ++ (C :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPpRpUmtmp;try rewrite HT2 in HBCPpRpUmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (C :: Pp :: U :: nil) (Pp :: nil) 3 1 2 HBCPpRpUmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCPpUm3 : rk(C :: Pp :: U :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBCQPpRpUeq : rk(B :: C :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LBCQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpRpUmtmp : rk(B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBCQPpRpUeq HBCQPpRpUm4).
	assert(HPpUeq : rk(Pp :: U :: nil) = 2) by (apply LPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUmtmp : rk(Pp :: U :: nil) >= 2) by (solve_hyps_min HPpUeq HPpUm2).
	assert(Hincl : incl (Pp :: U :: nil) (list_inter (C :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Rp :: U :: nil) (C :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil) ((C :: Pp :: U :: nil) ++ (B :: Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpRpUmtmp;try rewrite HT2 in HBCQPpRpUmtmp.
	assert(HT := rule_2 (C :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil) (Pp :: U :: nil) 4 2 3 HBCQPpRpUmtmp HPpUmtmp HBQPpRpUMtmp Hincl);apply HT.
}

assert(HCPpUM : rk(C :: Pp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCPpUeq HCPpUM3).
assert(HCPpUm : rk(C :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HCPpUeq HCPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpU *)
(* dans constructLemma(), requis par LCQPpQpU *)
(* dans constructLemma(), requis par LBCQPpQpU *)
(* dans la couche 0 *)
Lemma LBCQPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpRpU requis par la preuve de (?)BCQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)BCQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpRpU requis par la preuve de (?)BCQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpRpU requis par la preuve de (?)BCQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpRpUm2 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpQpRpUm3 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpQpRpUeq HABCQPpQpRpUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUmtmp;try rewrite HT2 in HABCQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpQpRpUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpQpRpUm4 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HBCQPpRpeq : rk(B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LBCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpRpmtmp : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCQPpRpeq HBCQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 4 4 HBCQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCQPpQpRpUM : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpRpUm : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBCQPpQpRpUeq HBCQPpQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQPpQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpU requis par la preuve de (?)BCQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)BCQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)ABCQPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)ABCQPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpU requis par la preuve de (?)BCQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpU requis par la preuve de (?)BCQPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpUm2 : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpQpUm3 : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpUmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpQpUeq HABCQPpQpUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpUmtmp;try rewrite HT2 in HABCQPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpQpUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCQPpQpUm4 : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCQPpQpRpUeq : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) = 4) by (apply LBCQPpQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpRpUmtmp : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBCQPpQpRpUeq HBCQPpQpRpUm4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpRpUmtmp;try rewrite HT2 in HBCQPpQpRpUmtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCQPpQpRpUmtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCQPpQpUM : rk(B :: C :: Q :: Pp :: Qp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpUm : rk(B :: C :: Q :: Pp :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HBCQPpQpUeq HBCQPpQpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQPpQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: Pp :: Qp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQPpQpU requis par la preuve de (?)CQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)CQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpUm2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQPpQpRpUm3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpQpRpUeq HABCQPpQpRpUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUmtmp;try rewrite HT2 in HABCQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQPpQpRpUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUm4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQPpQpU requis par la preuve de (?)CQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)CQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)ABCQPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpU requis par la preuve de (?)ABCQPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQPpQpU requis par la preuve de (?)CQPpQpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQPpQpUm2 : rk(C :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpUmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpQpUeq HABCQPpQpUm3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: U :: nil) (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpUmtmp;try rewrite HT2 in HABCQPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: U :: nil) (C :: Q :: nil) 3 2 3 HABCQPpQpUmtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HCQPpQpUm3 : rk(C :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HACQPpQpRpUmtmp : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HACQPpQpRpUeq HACQPpQpRpUm4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: U :: nil) ((A :: Qp :: Rp :: nil) ++ (C :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpRpUmtmp;try rewrite HT2 in HACQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: U :: nil) (Qp :: nil) 4 1 2 HACQPpQpRpUmtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: U ::  de rang :  4 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQPpQpUm4 : rk(C :: Q :: Pp :: Qp :: U :: nil) >= 4).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQPpQpUeq : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) = 4) by (apply LBCQPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpUmtmp : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) >= 4) by (solve_hyps_min HBCQPpQpUeq HBCQPpQpUm4).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: U :: nil) (B :: Q :: U :: C :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: Pp :: Qp :: U :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpUmtmp;try rewrite HT2 in HBCQPpQpUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: Pp :: Qp :: U :: nil) (Q :: U :: nil) 4 2 2 HBCQPpQpUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HCQPpQpUM : rk(C :: Q :: Pp :: Qp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQPpQpUm : rk(C :: Q :: Pp :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HCQPpQpUeq HCQPpQpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpU *)
(* dans la couche 0 *)
Lemma LCPpQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Pp :: Qp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPpQpU requis par la preuve de (?)CPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPpQpU requis par la preuve de (?)CPpQpU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)CPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)ABCPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpQpU requis par la preuve de (?)ABCPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUm2 : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUm3 : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPpQpU requis par la preuve de (?)CPpQpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : C :: Qp ::  de rang :  2 et 2 	 A : A :: B :: C :: Qp ::   de rang : 3 et 3 *)
assert(HCPpQpUm2 : rk(C :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABCQpeq : rk(A :: B :: C :: Qp :: nil) = 3) by (apply LABCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpMtmp : rk(A :: B :: C :: Qp :: nil) <= 3) by (solve_hyps_max HABCQpeq HABCQpM3).
	assert(HABCPpQpUmtmp : rk(A :: B :: C :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCPpQpUeq HABCPpQpUm3).
	assert(HCQpeq : rk(C :: Qp :: nil) = 2) by (apply LCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQpmtmp : rk(C :: Qp :: nil) >= 2) by (solve_hyps_min HCQpeq HCQpm2).
	assert(Hincl : incl (C :: Qp :: nil) (list_inter (A :: B :: C :: Qp :: nil) (C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Qp :: U :: nil) (A :: B :: C :: Qp :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: C :: Pp :: Qp :: U :: nil) ((A :: B :: C :: Qp :: nil) ++ (C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPpQpUmtmp;try rewrite HT2 in HABCPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Qp :: nil) (C :: Pp :: Qp :: U :: nil) (C :: Qp :: nil) 3 2 3 HABCPpQpUmtmp HCQpmtmp HABCQpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HCPpQpUM3 : rk(C :: Pp :: Qp :: U :: nil) <= 3).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HUMtmp : rk(U :: nil) <= 1) by (solve_hyps_max HUeq HUM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Pp :: Qp :: nil) (U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Pp :: Qp :: U :: nil) (C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: nil) ((C :: Pp :: Qp :: nil) ++ (U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Pp :: Qp :: nil) (U :: nil) (nil) 2 1 0 HCPpQpMtmp HUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: U ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCPpQpUm3 : rk(C :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQPpQpUeq : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) = 4) by (apply LBCQPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpUmtmp : rk(B :: C :: Q :: Pp :: Qp :: U :: nil) >= 4) by (solve_hyps_min HBCQPpQpUeq HBCQPpQpUm4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: U :: nil) (B :: Q :: U :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Pp :: Qp :: U :: nil) ((B :: Q :: U :: nil) ++ (C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpUmtmp;try rewrite HT2 in HBCQPpQpUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Pp :: Qp :: U :: nil) (U :: nil) 4 1 2 HBCQPpQpUmtmp HUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HCPpQpUM : rk(C :: Pp :: Qp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPpQpUm : rk(C :: Pp :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HCPpQpUeq HCPpQpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpU requis par la preuve de (?)QPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)QPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpU requis par la preuve de (?)QPpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpUm2 : rk(Q :: Pp :: U :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpRpUmtmp : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HPQRPpRpUeq HPQRPpRpUm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: U :: nil) (P :: R :: Pp :: Rp :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Pp :: U :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpUmtmp;try rewrite HT2 in HPQRPpRpUmtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Pp :: U :: nil) (Pp :: nil) 4 1 3 HPQRPpRpUmtmp HPpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HQPpUm3 : rk(Q :: Pp :: U :: nil) >= 3).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HCQPpQpUeq : rk(C :: Q :: Pp :: Qp :: U :: nil) = 4) by (apply LCQPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpUmtmp : rk(C :: Q :: Pp :: Qp :: U :: nil) >= 4) by (solve_hyps_min HCQPpQpUeq HCQPpQpUm4).
	assert(HPpUeq : rk(Pp :: U :: nil) = 2) by (apply LPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUmtmp : rk(Pp :: U :: nil) >= 2) by (solve_hyps_min HPpUeq HPpUm2).
	assert(Hincl : incl (Pp :: U :: nil) (list_inter (Q :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: Pp :: Qp :: U :: nil) (Q :: Pp :: U :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: U :: C :: Pp :: Qp :: U :: nil) ((Q :: Pp :: U :: nil) ++ (C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCQPpQpUmtmp;try rewrite HT2 in HCQPpQpUmtmp.
	assert(HT := rule_2 (Q :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil) (Pp :: U :: nil) 4 2 3 HCQPpQpUmtmp HPpUmtmp HCPpQpUMtmp Hincl);apply HT.
}

assert(HQPpUM : rk(Q :: Pp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQPpUeq HQPpUM3).
assert(HQPpUm : rk(Q :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HQPpUeq HQPpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpU requis par la preuve de (?)AQPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpU requis par la preuve de (?)AQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUm2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUm3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUm4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpU requis par la preuve de (?)APQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpU requis par la preuve de (?)APQPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUm2 : rk(A :: P :: Q :: Pp :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpUm3 : rk(A :: P :: Q :: Pp :: U :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpUmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpUeq HAPQRPpQpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpUmtmp;try rewrite HT2 in HAPQRPpQpRpUmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpUmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpU requis par la preuve de (?)AQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpU requis par la preuve de (?)AQPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpUm2 : rk(A :: Q :: Pp :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Pp :: U ::  de rang :  3 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQPpUm3 : rk(A :: Q :: Pp :: U :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQPpUmtmp : rk(A :: P :: Q :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPQPpUeq HAPQPpUm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Pp :: U :: nil) (A :: P :: U :: A :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: Pp :: U :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQPpUmtmp;try rewrite HT2 in HAPQPpUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: Pp :: U :: nil) (A :: U :: nil) 3 2 2 HAPQPpUmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpUm4 : rk(A :: Q :: Pp :: U :: nil) >= 4).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HABQPpRpUeq : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LABQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpUmtmp : rk(A :: B :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQPpRpUeq HABQPpRpUm4).
	assert(HQPpUeq : rk(Q :: Pp :: U :: nil) = 3) by (apply LQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpUmtmp : rk(Q :: Pp :: U :: nil) >= 3) by (solve_hyps_min HQPpUeq HQPpUm3).
	assert(Hincl : incl (Q :: Pp :: U :: nil) (list_inter (A :: Q :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: U :: B :: Q :: Pp :: Rp :: U :: nil) ((A :: Q :: Pp :: U :: nil) ++ (B :: Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpRpUmtmp;try rewrite HT2 in HABQPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil) (Q :: Pp :: U :: nil) 4 3 3 HABQPpRpUmtmp HQPpUmtmp HBQPpRpUMtmp Hincl);apply HT.
}

assert(HAQPpUM : rk(A :: Q :: Pp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpUm : rk(A :: Q :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HAQPpUeq HAQPpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: Pp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQPpU requis par la preuve de (?)CQPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpU requis par la preuve de (?)CQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpU requis par la preuve de (?)BCQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpU requis par la preuve de (?)ABCQPpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpU requis par la preuve de (?)ABCQPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpUm2 : rk(A :: B :: C :: Q :: Pp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpUm3 : rk(A :: B :: C :: Q :: Pp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpU requis par la preuve de (?)BCQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpU requis par la preuve de (?)BCQPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpUm2 : rk(B :: C :: Q :: Pp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpUm3 : rk(B :: C :: Q :: Pp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpUmtmp : rk(A :: B :: C :: Q :: Pp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpUeq HABCQPpUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: U :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpUmtmp;try rewrite HT2 in HABCQPpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQPpU requis par la preuve de (?)CQPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQPpU requis par la preuve de (?)CQPpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: U ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQPpUm2 : rk(C :: Q :: Pp :: U :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpUmtmp : rk(A :: B :: C :: Q :: Pp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpUeq HABCQPpUm3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: U :: nil) (A :: B :: C :: Q :: C :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: Pp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpUmtmp;try rewrite HT2 in HABCQPpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: U :: nil) (C :: Q :: nil) 3 2 3 HABCQPpUmtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: U ::  de rang :  3 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQPpUm3 : rk(C :: Q :: Pp :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQPpUmtmp : rk(B :: C :: Q :: Pp :: U :: nil) >= 3) by (solve_hyps_min HBCQPpUeq HBCQPpUm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: U :: nil) (B :: Q :: U :: C :: Q :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: Pp :: U :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpUmtmp;try rewrite HT2 in HBCQPpUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: Pp :: U :: nil) (Q :: U :: nil) 3 2 2 HBCQPpUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCQPpUm4 : rk(C :: Q :: Pp :: U :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HCQPpQpUeq : rk(C :: Q :: Pp :: Qp :: U :: nil) = 4) by (apply LCQPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpUmtmp : rk(C :: Q :: Pp :: Qp :: U :: nil) >= 4) by (solve_hyps_min HCQPpQpUeq HCQPpQpUm4).
	assert(HCPpUeq : rk(C :: Pp :: U :: nil) = 3) by (apply LCPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpUmtmp : rk(C :: Pp :: U :: nil) >= 3) by (solve_hyps_min HCPpUeq HCPpUm3).
	assert(Hincl : incl (C :: Pp :: U :: nil) (list_inter (C :: Q :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: Pp :: Qp :: U :: nil) (C :: Q :: Pp :: U :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Q :: Pp :: U :: C :: Pp :: Qp :: U :: nil) ((C :: Q :: Pp :: U :: nil) ++ (C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCQPpQpUmtmp;try rewrite HT2 in HCQPpQpUmtmp.
	assert(HT := rule_2 (C :: Q :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil) (C :: Pp :: U :: nil) 4 3 3 HCQPpQpUmtmp HCPpUmtmp HCPpQpUMtmp Hincl);apply HT.
}

assert(HCQPpUM : rk(C :: Q :: Pp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQPpUm : rk(C :: Q :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HCQPpUeq HCQPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LARPpU *)
(* dans la couche 0 *)
Lemma LAQRPpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: Pp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRPpUD requis par la preuve de (?)AQRPpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)AQRPpUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRPpUD requis par la preuve de (?)AQRPpUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRPpUD requis par la preuve de (?)AQRPpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRPpUDm2 : rk(A :: Q :: R :: Pp :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Pp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Pp :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: R :: Pp :: Rp :: U :: D ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HAQRPpUDm3 : rk(A :: Q :: R :: Pp :: U :: D :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABQRPpRpUDmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4) by (solve_hyps_min HABQRPpRpUDeq HABQRPpRpUDm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: Q :: R :: Pp :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) (B :: Pp :: Rp :: A :: Q :: R :: Pp :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: Q :: R :: Pp :: U :: D :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Pp :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUDmtmp;try rewrite HT2 in HABQRPpRpUDmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: Q :: R :: Pp :: U :: D :: nil) (Pp :: nil) 4 1 2 HABQRPpRpUDmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRPpUDm4 : rk(A :: Q :: R :: Pp :: U :: D :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: Q :: R :: Pp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: Q :: R :: Pp :: U :: D :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HAQRPpUDM : rk(A :: Q :: R :: Pp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRPpUDm : rk(A :: Q :: R :: Pp :: U :: D ::  nil) >= 1) by (solve_hyps_min HAQRPpUDeq HAQRPpUDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LARPpU *)
(* dans constructLemma(), requis par LAQRUD *)
(* dans constructLemma(), requis par LAPQRUD *)
(* dans la couche 0 *)
Lemma LAPQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRUD requis par la preuve de (?)APQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRUD requis par la preuve de (?)AQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRUD requis par la preuve de (?)AQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRUDm2 : rk(A :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQRUDM3 : rk(A :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (A :: Q :: R :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: U :: D :: nil) (A :: Q :: R :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: R :: U :: D :: nil) ((A :: Q :: R :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (R :: U :: D :: nil) (R :: nil) 2 2 1 HAQRMtmp HRUDMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRUD requis par la preuve de (?)APQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRUD requis par la preuve de (?)APQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRUD requis par la preuve de (?)APQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRUDm2 : rk(A :: P :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRUDm3 : rk(A :: P :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 4*)
assert(HAPQRUDM3 : rk(A :: P :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAQRUDMtmp : rk(A :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAQRUDeq HAQRUDM3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: U :: D :: nil) (A :: P :: U :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: R :: U :: D :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: P :: U :: nil) (A :: Q :: R :: U :: D :: nil) (A :: U :: nil) 2 3 2 HAPUMtmp HAQRUDMtmp HAUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAPQRUDM : rk(A :: P :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRUDm : rk(A :: P :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HAPQRUDeq HAPQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRUD requis par la preuve de (?)AQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRUD requis par la preuve de (?)AQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRUD requis par la preuve de (?)AQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRUDm2 : rk(A :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQRUDM3 : rk(A :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (A :: Q :: R :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: U :: D :: nil) (A :: Q :: R :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: R :: U :: D :: nil) ((A :: Q :: R :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (R :: U :: D :: nil) (R :: nil) 2 2 1 HAQRMtmp HRUDMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: U :: D ::  de rang :  3 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQRUDm3 : rk(A :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQRUDeq : rk(A :: P :: Q :: R :: U :: D :: nil) = 3) by (apply LAPQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRUDmtmp : rk(A :: P :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HAPQRUDeq HAPQRUDm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: U :: D :: nil) (A :: P :: U :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: R :: U :: D :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRUDmtmp;try rewrite HT2 in HAPQRUDmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: R :: U :: D :: nil) (A :: U :: nil) 3 2 2 HAPQRUDmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HAQRUDM : rk(A :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRUDm : rk(A :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HAQRUDeq HAQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Pp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARPpU requis par la preuve de (?)ARPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ARPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm2 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm3 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm4 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARPpU requis par la preuve de (?)ARPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARPpU requis par la preuve de (?)ARPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARPpUm2 : rk(A :: R :: Pp :: U :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Pp :: U :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HARPpUm3 : rk(A :: R :: Pp :: U :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABRPpRpUmtmp : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABRPpRpUeq HABRPpRpUm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: R :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Rp :: U :: nil) (B :: Pp :: Rp :: A :: R :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: R :: Pp :: U :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: R :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpRpUmtmp;try rewrite HT2 in HABRPpRpUmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: R :: Pp :: U :: nil) (Pp :: nil) 4 1 2 HABRPpRpUmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HARPpUm4 : rk(A :: R :: Pp :: U :: nil) >= 4).
{
	assert(HAQRUDeq : rk(A :: Q :: R :: U :: D :: nil) = 3) by (apply LAQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUDMtmp : rk(A :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAQRUDeq HAQRUDM3).
	assert(HAQRPpUDeq : rk(A :: Q :: R :: Pp :: U :: D :: nil) = 4) by (apply LAQRPpUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRPpUDmtmp : rk(A :: Q :: R :: Pp :: U :: D :: nil) >= 4) by (solve_hyps_min HAQRPpUDeq HAQRPpUDm4).
	assert(HARUeq : rk(A :: R :: U :: nil) = 3) by (apply LARU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARUmtmp : rk(A :: R :: U :: nil) >= 3) by (solve_hyps_min HARUeq HARUm3).
	assert(Hincl : incl (A :: R :: U :: nil) (list_inter (A :: R :: Pp :: U :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Pp :: U :: D :: nil) (A :: R :: Pp :: U :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: R :: Pp :: U :: A :: Q :: R :: U :: D :: nil) ((A :: R :: Pp :: U :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRPpUDmtmp;try rewrite HT2 in HAQRPpUDmtmp.
	assert(HT := rule_2 (A :: R :: Pp :: U :: nil) (A :: Q :: R :: U :: D :: nil) (A :: R :: U :: nil) 4 3 3 HAQRPpUDmtmp HARUmtmp HAQRUDMtmp Hincl);apply HT.
}

assert(HARPpUM : rk(A :: R :: Pp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARPpUm : rk(A :: R :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HARPpUeq HARPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCRPpU *)
(* dans constructLemma(), requis par LBCRPpQpU *)
(* dans la couche 0 *)
Lemma LBCRPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRPpQpRpU requis par la preuve de (?)BCRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRPpQpRpU requis par la preuve de (?)BCRPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRPpQpRpU requis par la preuve de (?)ABCRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRPpQpRpU requis par la preuve de (?)ABCRPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpQpRpUm2 : rk(A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpQpRpUm3 : rk(A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRPpQpRpU requis par la preuve de (?)BCRPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRPpQpRpU requis par la preuve de (?)BCRPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRPpQpRpUm2 : rk(B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRPpQpRpUm3 : rk(B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRPpQpRpUmtmp : rk(A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCRPpQpRpUeq HABCRPpQpRpUm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) (A :: B :: C :: R :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRPpQpRpUmtmp;try rewrite HT2 in HABCRPpQpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) (B :: C :: R :: nil) 3 3 3 HABCRPpQpRpUmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCRPpQpRpUm4 : rk(B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCRPpQpRpUM : rk(B :: C :: R :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRPpQpRpUm : rk(B :: C :: R :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBCRPpQpRpUeq HBCRPpQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRPpQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: Pp :: Qp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRPpQpU requis par la preuve de (?)BCRPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRPpQpU requis par la preuve de (?)BCRPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRPpQpU requis par la preuve de (?)ABCRPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRPpQpU requis par la preuve de (?)ABCRPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpQpUm2 : rk(A :: B :: C :: R :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpQpUm3 : rk(A :: B :: C :: R :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: Qp :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRPpQpU requis par la preuve de (?)BCRPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRPpQpU requis par la preuve de (?)BCRPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRPpQpUm2 : rk(B :: C :: R :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRPpQpUm3 : rk(B :: C :: R :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRPpQpUmtmp : rk(A :: B :: C :: R :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCRPpQpUeq HABCRPpQpUm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: Pp :: Qp :: U :: nil) (A :: B :: C :: R :: B :: C :: R :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: Pp :: Qp :: U :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRPpQpUmtmp;try rewrite HT2 in HABCRPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil) (B :: C :: R :: nil) 3 3 3 HABCRPpQpUmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: R :: Pp :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCRPpQpUm4 : rk(B :: C :: R :: Pp :: Qp :: U :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCRPpQpRpUeq : rk(B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) = 4) by (apply LBCRPpQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRPpQpRpUmtmp : rk(B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBCRPpQpRpUeq HBCRPpQpRpUm4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: R :: Pp :: Qp :: Rp :: U :: nil) (B :: C :: Qp :: Rp :: B :: C :: R :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: R :: Pp :: Qp :: U :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: R :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCRPpQpRpUmtmp;try rewrite HT2 in HBCRPpQpRpUmtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: R :: Pp :: Qp :: U :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCRPpQpRpUmtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCRPpQpUM : rk(B :: C :: R :: Pp :: Qp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRPpQpUm : rk(B :: C :: R :: Pp :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HBCRPpQpUeq HBCRPpQpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRPpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: Pp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRPpU requis par la preuve de (?)BCRPpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRPpU requis par la preuve de (?)BCRPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRPpU requis par la preuve de (?)ABCRPpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRPpU requis par la preuve de (?)ABCRPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpUm2 : rk(A :: B :: C :: R :: Pp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: Pp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRPpUm3 : rk(A :: B :: C :: R :: Pp :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: Pp :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRPpU requis par la preuve de (?)BCRPpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRPpU requis par la preuve de (?)BCRPpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRPpUm2 : rk(B :: C :: R :: Pp :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: Pp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: Pp :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: Pp :: U ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRPpUm3 : rk(B :: C :: R :: Pp :: U :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRPpUmtmp : rk(A :: B :: C :: R :: Pp :: U :: nil) >= 3) by (solve_hyps_min HABCRPpUeq HABCRPpUm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: Pp :: U :: nil) (A :: B :: C :: R :: B :: C :: R :: Pp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: Pp :: U :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: Pp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRPpUmtmp;try rewrite HT2 in HABCRPpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: Pp :: U :: nil) (B :: C :: R :: nil) 3 3 3 HABCRPpUmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCRPpUm4 : rk(B :: C :: R :: Pp :: U :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCRPpQpUeq : rk(B :: C :: R :: Pp :: Qp :: U :: nil) = 4) by (apply LBCRPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRPpQpUmtmp : rk(B :: C :: R :: Pp :: Qp :: U :: nil) >= 4) by (solve_hyps_min HBCRPpQpUeq HBCRPpQpUm4).
	assert(HCPpUeq : rk(C :: Pp :: U :: nil) = 3) by (apply LCPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpUmtmp : rk(C :: Pp :: U :: nil) >= 3) by (solve_hyps_min HCPpUeq HCPpUm3).
	assert(Hincl : incl (C :: Pp :: U :: nil) (list_inter (B :: C :: R :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: R :: Pp :: Qp :: U :: nil) (B :: C :: R :: Pp :: U :: C :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: R :: Pp :: U :: C :: Pp :: Qp :: U :: nil) ((B :: C :: R :: Pp :: U :: nil) ++ (C :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCRPpQpUmtmp;try rewrite HT2 in HBCRPpQpUmtmp.
	assert(HT := rule_2 (B :: C :: R :: Pp :: U :: nil) (C :: Pp :: Qp :: U :: nil) (C :: Pp :: U :: nil) 4 3 3 HBCRPpQpUmtmp HCPpUmtmp HCPpQpUMtmp Hincl);apply HT.
}

assert(HBCRPpUM : rk(B :: C :: R :: Pp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRPpUm : rk(B :: C :: R :: Pp :: U ::  nil) >= 1) by (solve_hyps_min HBCRPpUeq HBCRPpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpU *)
(* dans la couche 0 *)
Lemma LAPQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Qp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APQpU requis par la preuve de (?)APQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQpU requis par la preuve de (?)APQpU pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQQpU requis par la preuve de (?)APQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQQpU requis par la preuve de (?)ACPQQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQQpU requis par la preuve de (?)ABCPQQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQQpU requis par la preuve de (?)ABCPQQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpUm2 : rk(A :: B :: C :: P :: Q :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpUm3 : rk(A :: B :: C :: P :: Q :: Qp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQQpU requis par la preuve de (?)ACPQQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQQpU requis par la preuve de (?)ACPQQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQQpUm2 : rk(A :: C :: P :: Q :: Qp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Qp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Qp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQQpUm3 : rk(A :: C :: P :: Q :: Qp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQQpUmtmp : rk(A :: B :: C :: P :: Q :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCPQQpUeq HABCPQQpUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Qp :: U :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Qp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQQpUmtmp;try rewrite HT2 in HABCPQQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Qp :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQQpUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQpU requis par la preuve de (?)APQpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Qp :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPQpUm2 : rk(A :: P :: Qp :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQQpUmtmp : rk(A :: C :: P :: Q :: Qp :: U :: nil) >= 3) by (solve_hyps_min HACPQQpUeq HACPQQpUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Qp :: U :: nil) (C :: P :: Q :: A :: P :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Qp :: U :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQQpUmtmp;try rewrite HT2 in HACPQQpUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Qp :: U :: nil) (P :: nil) 3 1 2 HACPQQpUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPQpUM3 : rk(A :: P :: Qp :: U :: nil) <= 3).
{
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (A :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Qp :: U :: nil) (Qp :: A :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: A :: P :: U :: nil) ((Qp :: nil) ++ (A :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (A :: P :: U :: nil) (nil) 1 2 0 HQpMtmp HAPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQpUm3 : rk(A :: P :: Qp :: U :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) = 4) by (apply LAPQRQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUeq HAPQRQpRpUm4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Qp :: U :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUmtmp;try rewrite HT2 in HAPQRQpRpUmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Qp :: U :: nil) (A :: Qp :: nil) 4 2 3 HAPQRQpRpUmtmp HAQpmtmp HAQRQpRpMtmp Hincl); apply HT.
}

assert(HAPQpUM : rk(A :: P :: Qp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQpUm : rk(A :: P :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HAPQpUeq HAPQpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Qp :: U ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QpU requis par la preuve de (?)QpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Qp :: U ::  de rang :  3 et 3 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQpUm2 : rk(Qp :: U :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQpUeq : rk(A :: P :: Qp :: U :: nil) = 3) by (apply LAPQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpUmtmp : rk(A :: P :: Qp :: U :: nil) >= 3) by (solve_hyps_min HAPQpUeq HAPQpUm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Qp :: U :: nil) (A :: P :: U :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Qp :: U :: nil) ((A :: P :: U :: nil) ++ (Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQpUmtmp;try rewrite HT2 in HAPQpUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Qp :: U :: nil) (U :: nil) 3 1 2 HAPQpUmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HQpUM : rk(Qp :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQpUeq HQpUM2).
assert(HQpUm : rk(Qp :: U ::  nil) >= 1) by (solve_hyps_min HQpUeq HQpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpQpU *)
(* dans constructLemma(), requis par LBQPpQpRpU *)
(* dans la couche 0 *)
Lemma LABQPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpU requis par la preuve de (?)ABQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpU requis par la preuve de (?)ABQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpU requis par la preuve de (?)ABQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUm : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUeq HABQPpQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpU requis par la preuve de (?)BQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpU requis par la preuve de (?)BQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpU requis par la preuve de (?)BQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUm2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUm3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUm4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) = 4) by (apply LABQPpQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUeq HABQPpQpRpUm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUmtmp;try rewrite HT2 in HABQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUmtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUM : rk(B :: Q :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUm : rk(B :: Q :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUeq HBQPpQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpQpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Pp :: Qp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PpQpU requis par la preuve de (?)PpQpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APPpQpU requis par la preuve de (?)PpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APPpQpRpU requis par la preuve de (?)APPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRp requis par la preuve de (?)APPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRp requis par la preuve de (?)PPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPPpRpm2 : rk(P :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpeq : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) = 4) by (apply LAPQRPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRPpQpRpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((P :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpmtmp;try rewrite HT2 in HAPQRPpQpRpmtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (Rp :: nil) 4 1 3 HAPQRPpQpRpmtmp HRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)APPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm2 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm3 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpRpm2 : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQPpRpm3 : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpRpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPQPpRpeq HABCPQPpRpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpRpmtmp;try rewrite HT2 in HABCPQPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQPpRpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpRpm2 : rk(A :: P :: Pp :: Rp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpRpmtmp : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HACPQPpRpeq HACPQPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Rp :: nil) (C :: P :: Q :: A :: P :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Rp :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpRpmtmp;try rewrite HT2 in HACPQPpRpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HACPQPpRpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HAPPpRpm3 : rk(A :: P :: Pp :: Rp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpeq : rk(A :: B :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LABPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpRpmtmp : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABPRPpRpeq HABPRPpRpm4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HPPpRpeq HPPpRpm2).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (A :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: nil) (A :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((A :: P :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpmtmp;try rewrite HT2 in HABPRPpRpmtmp.
	assert(HT := rule_2 (A :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: Pp :: Rp :: nil) 4 2 3 HABPRPpRpmtmp HPPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpQpRpU requis par la preuve de (?)APPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpQpRpU requis par la preuve de (?)APPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpQpRpU requis par la preuve de (?)ACPQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpQpRpU requis par la preuve de (?)ABCPQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpQpRpU requis par la preuve de (?)ABCPQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpUm2 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpUm3 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpQpRpU requis par la preuve de (?)ACPQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpQpRpU requis par la preuve de (?)ACPQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpQpRpUm2 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQPpQpRpUm3 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpQpRpUmtmp : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCPQPpQpRpUeq HABCPQPpQpRpUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpQpRpUmtmp;try rewrite HT2 in HABCPQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQPpQpRpUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpQpRpU requis par la preuve de (?)APPpQpRpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpQpRpUm2 : rk(A :: P :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpQpRpUmtmp : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HACPQPpQpRpUeq HACPQPpQpRpUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Qp :: Rp :: U :: nil) (C :: P :: Q :: A :: P :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Qp :: Rp :: U :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpQpRpUmtmp;try rewrite HT2 in HACPQPpQpRpUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: Rp :: U :: nil) (P :: nil) 3 1 2 HACPQPpQpRpUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAPPpQpRpUm3 : rk(A :: P :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HAPPpRpmtmp : rk(A :: P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAPPpRpeq HAPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Pp :: Rp :: nil) (A :: P :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Pp :: Rp :: nil) (A :: P :: Pp :: Qp :: Rp :: U :: nil) 3 3 HAPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpQpU requis par la preuve de (?)APPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpQpU requis par la preuve de (?)APPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpQpU requis par la preuve de (?)ACPQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpQpU requis par la preuve de (?)ABCPQPpQpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpQpU requis par la preuve de (?)ABCPQPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpUm2 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpUm3 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpQpU requis par la preuve de (?)ACPQPpQpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpQpU requis par la preuve de (?)ACPQPpQpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpQpUm2 : rk(A :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQPpQpUm3 : rk(A :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpQpUmtmp : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HABCPQPpQpUeq HABCPQPpQpUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Qp :: U :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Qp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpQpUmtmp;try rewrite HT2 in HABCPQPpQpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQPpQpUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpQpU requis par la preuve de (?)APPpQpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpQpUm2 : rk(A :: P :: Pp :: Qp :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpQpUmtmp : rk(A :: C :: P :: Q :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HACPQPpQpUeq HACPQPpQpUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Qp :: U :: nil) (C :: P :: Q :: A :: P :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Qp :: U :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpQpUmtmp;try rewrite HT2 in HACPQPpQpUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: U :: nil) (P :: nil) 3 1 2 HACPQPpQpUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPPpQpUm3 : rk(A :: P :: Pp :: Qp :: U :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPPpQpRpUmtmp : rk(A :: P :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HAPPpQpRpUeq HAPPpQpRpUm3).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: Qp :: Rp :: U :: nil) (A :: Qp :: Rp :: A :: P :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: Pp :: Qp :: U :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPPpQpRpUmtmp;try rewrite HT2 in HAPPpQpRpUmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: Pp :: Qp :: U :: nil) (A :: Qp :: nil) 3 2 2 HAPPpQpRpUmtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PpQpU requis par la preuve de (?)PpQpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Pp :: Qp :: U ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HPpQpUm2 : rk(Pp :: Qp :: U :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPPpQpUmtmp : rk(A :: P :: Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HAPPpQpUeq HAPPpQpUm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Pp :: Qp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: Qp :: U :: nil) (A :: P :: U :: Pp :: Qp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Pp :: Qp :: U :: nil) ((A :: P :: U :: nil) ++ (Pp :: Qp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPPpQpUmtmp;try rewrite HT2 in HAPPpQpUmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Pp :: Qp :: U :: nil) (U :: nil) 3 1 2 HAPPpQpUmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HPpQpUm3 : rk(Pp :: Qp :: U :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: nil) = 4) by (apply LBQPpQpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUeq HBQPpQpRpUm4).
	assert(HPpUeq : rk(Pp :: U :: nil) = 2) by (apply LPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUmtmp : rk(Pp :: U :: nil) >= 2) by (solve_hyps_min HPpUeq HPpUm2).
	assert(Hincl : incl (Pp :: U :: nil) (list_inter (Pp :: Qp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: nil) (Pp :: Qp :: U :: B :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Qp :: U :: B :: Q :: Pp :: Rp :: U :: nil) ((Pp :: Qp :: U :: nil) ++ (B :: Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUmtmp;try rewrite HT2 in HBQPpQpRpUmtmp.
	assert(HT := rule_2 (Pp :: Qp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil) (Pp :: U :: nil) 4 2 3 HBQPpQpRpUmtmp HPpUmtmp HBQPpRpUMtmp Hincl);apply HT.
}

assert(HPpQpUM : rk(Pp :: Qp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HPpQpUeq HPpQpUM3).
assert(HPpQpUm : rk(Pp :: Qp :: U ::  nil) >= 1) by (solve_hyps_min HPpQpUeq HPpQpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQRpU *)
(* dans la couche 0 *)
Lemma LBQRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Rp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQRpU requis par la preuve de (?)BQRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQRpU requis par la preuve de (?)BQRpU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQRpU requis par la preuve de (?)BQRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQRpUm2 : rk(B :: Q :: Rp :: U :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Rp :: U :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBQRpUM3 : rk(B :: Q :: Rp :: U :: nil) <= 3).
{
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: nil) (B :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Rp :: U :: nil) (Rp :: B :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: B :: Q :: U :: nil) ((Rp :: nil) ++ (B :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: nil) (B :: Q :: U :: nil) (nil) 1 2 0 HRpMtmp HBQUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: Q :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HBQRpUm3 : rk(B :: Q :: Rp :: U :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpUeq : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LBPQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpUmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HBPQRPpRpUeq HBPQRPpRpUm4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: U :: nil) (B :: P :: R :: Pp :: Rp :: B :: Q :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: B :: Q :: Rp :: U :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (B :: Q :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpUmtmp;try rewrite HT2 in HBPQRPpRpUmtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: Rp :: U :: nil) (B :: Rp :: nil) 4 2 3 HBPQRPpRpUmtmp HBRpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

assert(HBQRpUM : rk(B :: Q :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQRpUm : rk(B :: Q :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HBQRpUeq HBQRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Rp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QRpU requis par la preuve de (?)QRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)QRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QRpU requis par la preuve de (?)QRpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQRpUm2 : rk(Q :: Rp :: U :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpRpUmtmp : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HPQRPpRpUeq HPQRPpRpUm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: U :: nil) (P :: R :: Pp :: Rp :: Q :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Rp :: U :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpUmtmp;try rewrite HT2 in HPQRPpRpUmtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Rp :: U :: nil) (Rp :: nil) 4 1 3 HPQRPpRpUmtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Q :: Rp :: U ::  de rang :  3 et 3 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HQRpUm3 : rk(Q :: Rp :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQRpUeq : rk(B :: Q :: Rp :: U :: nil) = 3) by (apply LBQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQRpUmtmp : rk(B :: Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HBQRpUeq HBQRpUm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (Q :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Rp :: U :: nil) (B :: Q :: U :: Q :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: Rp :: U :: nil) ((B :: Q :: U :: nil) ++ (Q :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQRpUmtmp;try rewrite HT2 in HBQRpUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (Q :: Rp :: U :: nil) (Q :: U :: nil) 3 2 2 HBQRpUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HQRpUM : rk(Q :: Rp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQRpUeq HQRpUM3).
assert(HQRpUm : rk(Q :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HQRpUeq HQRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Rp :: U ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpRpU requis par la preuve de (?)QPpRpU pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpRpU requis par la preuve de (?)QPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpRpU requis par la preuve de (?)QPpRpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Rp :: U ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpRpUm2 : rk(Q :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpRpUeq : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) = 4) by (apply LABCQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABCQPpRpUeq HABCQPpRpUm4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: U :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Rp :: U :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpRpUmtmp;try rewrite HT2 in HABCQPpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: U :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpRpUmtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Rp :: U ::  de rang :  3 et 3 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HQPpRpUm3 : rk(Q :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUmtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HBQPpRpUeq HBQPpRpUm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (Q :: Pp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Rp :: U :: nil) (B :: Q :: U :: Q :: Pp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: Pp :: Rp :: U :: nil) ((B :: Q :: U :: nil) ++ (Q :: Pp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpRpUmtmp;try rewrite HT2 in HBQPpRpUmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (Q :: Pp :: Rp :: U :: nil) (Q :: U :: nil) 3 2 2 HBQPpRpUmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQPpRpUM3 : rk(Q :: Pp :: Rp :: U :: nil) <= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Pp :: Rp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Q :: Pp :: Rp :: U :: nil) (B :: Q :: Pp :: Rp :: U :: nil) 3 3 HBQPpRpUMtmp Hcomp Hincl);apply HT.
}

assert(HQPpRpUM : rk(Q :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpRpUm : rk(Q :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HQPpRpUeq HQPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpU requis par la preuve de (?)ABRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm2 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm3 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUm4 : rk(A :: B :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABRPpRpUM : rk(A :: B :: R :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRPpRpUm : rk(A :: B :: R :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HABRPpRpUeq HABRPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpU requis par la preuve de (?)PQRPpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpRpUM : rk(P :: Q :: R :: Pp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpUm : rk(P :: Q :: R :: Pp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HPQRPpRpUeq HPQRPpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpU requis par la preuve de (?)ABCQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpU requis par la preuve de (?)ACQPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpUm2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQPpQpRpUm3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpRpUmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 3) by (solve_hyps_min HABCQPpQpRpUeq HABCQPpQpRpUm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUmtmp;try rewrite HT2 in HABCQPpQpRpUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQPpQpRpUmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUm4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HACQPpQpRpUM : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpQpRpUm : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HACQPpQpRpUeq HACQPpQpRpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRPpQpRpU : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpU requis par la preuve de (?)APQRPpQpRpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUm2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUm3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUm4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRPpQpRpUM : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRPpQpRpUm : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U ::  nil) >= 1) by (solve_hyps_min HAPQRPpQpRpUeq HAPQRPpQpRpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAUp *)
(* dans la couche 0 *)
Lemma LABQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Qp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABQpUp requis par la preuve de (?)ABQpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABQpUp requis par la preuve de (?)ABQpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQpUp requis par la preuve de (?)ABQpUp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABQpUpM3 : rk(A :: B :: Qp :: Up :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Qp :: Up :: nil) (A :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Qp :: Up :: nil) ((A :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: Qp :: Up :: nil) (nil) 1 2 0 HAMtmp HBQpUpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpUpm2 : rk(A :: B :: Qp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Qp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpUpm3 : rk(A :: B :: Qp :: Up :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: Qp :: Up :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

assert(HABQpUpM : rk(A :: B :: Qp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQpUpm : rk(A :: B :: Qp :: Up ::  nil) >= 1) by (solve_hyps_min HABQpUpeq HABQpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Up ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AUp requis par la preuve de (?)AUp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAUpm2 : rk(A :: Up :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HABQpUpeq : rk(A :: B :: Qp :: Up :: nil) = 3) by (apply LABQpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQpUpmtmp : rk(A :: B :: Qp :: Up :: nil) >= 3) by (solve_hyps_min HABQpUpeq HABQpUpm3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (A :: Up :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Qp :: Up :: nil) (A :: Up :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Up :: B :: Qp :: Up :: nil) ((A :: Up :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQpUpmtmp;try rewrite HT2 in HABQpUpmtmp.
	assert(HT := rule_2 (A :: Up :: nil) (B :: Qp :: Up :: nil) (Up :: nil) 3 1 2 HABQpUpmtmp HUpmtmp HBQpUpMtmp Hincl);apply HT.
}

assert(HAUpM : rk(A :: Up ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAUpeq HAUpM2).
assert(HAUpm : rk(A :: Up ::  nil) >= 1) by (solve_hyps_min HAUpeq HAUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQUp *)
(* dans constructLemma(), requis par LBQQpUp *)
(* dans constructLemma(), requis par LBQPpQpRpUp *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUp requis par la preuve de (?)ABQPpQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUp requis par la preuve de (?)ABQPpQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUp requis par la preuve de (?)ABQPpQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUpM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUpm : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUpeq HABQPpQpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUp requis par la preuve de (?)BQPpQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUp requis par la preuve de (?)BQPpQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUp requis par la preuve de (?)BQPpQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpm2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpm3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpm4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) = 4) by (apply LABQPpQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpeq HABQPpQpRpUpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpmtmp;try rewrite HT2 in HABQPpQpRpUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpmtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUpM : rk(B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUpm : rk(B :: Q :: Pp :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUpeq HBQPpQpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Qp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQQpUp requis par la preuve de (?)BQQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BQQpUp requis par la preuve de (?)BQQpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQQpUp requis par la preuve de (?)BQQpUp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBQQpUpM3 : rk(B :: Q :: Qp :: Up :: nil) <= 3).
{
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Q :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: Up :: nil) (Q :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: B :: Qp :: Up :: nil) ((Q :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Q :: nil) (B :: Qp :: Up :: nil) (nil) 1 2 0 HQMtmp HBQpUpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQQpUpm2 : rk(B :: Q :: Qp :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Qp :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up ::  de rang :  4 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQQpUpm3 : rk(B :: Q :: Qp :: Up :: nil) >= 3).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpeq : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: nil) = 4) by (apply LBQPpQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpeq HBQPpQpRpUpm4).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: nil) (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: Up :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpmtmp;try rewrite HT2 in HBQPpQpRpUpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: Up :: nil) (B :: Qp :: nil) 4 2 3 HBQPpQpRpUpmtmp HBQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HBQQpUpM : rk(B :: Q :: Qp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQQpUpm : rk(B :: Q :: Qp :: Up ::  nil) >= 1) by (solve_hyps_min HBQQpUpeq HBQQpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Up ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QUp requis par la preuve de (?)QUp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HQUpm2 : rk(Q :: Up :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQQpUpeq : rk(B :: Q :: Qp :: Up :: nil) = 3) by (apply LBQQpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUpmtmp : rk(B :: Q :: Qp :: Up :: nil) >= 3) by (solve_hyps_min HBQQpUpeq HBQQpUpm3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Q :: Up :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: Up :: nil) (Q :: Up :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Up :: B :: Qp :: Up :: nil) ((Q :: Up :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQQpUpmtmp;try rewrite HT2 in HBQQpUpmtmp.
	assert(HT := rule_2 (Q :: Up :: nil) (B :: Qp :: Up :: nil) (Up :: nil) 3 1 2 HBQQpUpmtmp HUpmtmp HBQpUpMtmp Hincl);apply HT.
}

assert(HQUpM : rk(Q :: Up ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQUpeq HQUpM2).
assert(HQUpm : rk(Q :: Up ::  nil) >= 1) by (solve_hyps_min HQUpeq HQUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpUp *)
(* dans constructLemma(), requis par LBQPpQpUUp *)
(* dans constructLemma(), requis par LBCQPpQpUUp *)
(* dans la couche 0 *)
Lemma LBCQPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpRpUUp requis par la preuve de (?)BCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)BCQPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpRpUUp requis par la preuve de (?)BCQPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpRpUUp requis par la preuve de (?)BCQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpRpUUpm2 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpQpRpUUpm3 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpRpUUpmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3) by (solve_hyps_min HABCQPpQpRpUUpeq HABCQPpQpRpUUpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpmtmp;try rewrite HT2 in HABCQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpQpRpUUpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQPpQpRpUUpm4 : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HBCQPpRpeq : rk(B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LBCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpRpmtmp : rk(B :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCQPpRpeq HBCQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: Pp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HBCQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCQPpQpRpUUpM : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpRpUUpm : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HBCQPpQpRpUUpeq HBCQPpQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQPpQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: Pp :: Qp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQPpQpUUp requis par la preuve de (?)BCQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpUUp requis par la preuve de (?)BCQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpUUp requis par la preuve de (?)ABCQPpQpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpUUp requis par la preuve de (?)ABCQPpQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUUpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUUpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQPpQpUUp requis par la preuve de (?)BCQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQPpQpUUp requis par la preuve de (?)BCQPpQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQPpQpUUpm2 : rk(B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: U :: Up ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQPpQpUUpm3 : rk(B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpUUpmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 3) by (solve_hyps_min HABCQPpQpUUpeq HABCQPpQpUUpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpUUpmtmp;try rewrite HT2 in HABCQPpQpUUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQPpQpUUpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCQPpQpUUpm4 : rk(B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCQPpQpRpUUpeq : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LBCQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpRpUUpmtmp : rk(B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBCQPpQpRpUUpeq HBCQPpQpRpUUpm4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpRpUUpmtmp;try rewrite HT2 in HBCQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCQPpQpRpUUpmtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCQPpQpUUpM : rk(B :: C :: Q :: Pp :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQPpQpUUpm : rk(B :: C :: Q :: Pp :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HBCQPpQpUUpeq HBCQPpQpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpUUp requis par la preuve de (?)BQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)BQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpUUp requis par la preuve de (?)BQPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpUUp requis par la preuve de (?)BQPpQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpUUpm2 : rk(B :: Q :: Pp :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBQPpQpUUpm3 : rk(B :: Q :: Pp :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABQPpQpRpUUpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpeq HABQPpQpRpUUpm4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: Qp :: Rp :: B :: Q :: Pp :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: Q :: Pp :: Qp :: U :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpmtmp;try rewrite HT2 in HABQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil) (Qp :: nil) 4 1 2 HABQPpQpRpUUpmtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Q :: Pp :: Qp :: U :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: U ::  de rang :  3 et 3 	 A : C :: Pp :: Qp :: U ::   de rang : 3 et 3 *)
assert(HBQPpQpUUpm4 : rk(B :: Q :: Pp :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCQPpQpUUpeq : rk(B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) = 4) by (apply LBCQPpQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQPpQpUUpmtmp : rk(B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBCQPpQpUUpeq HBCQPpQpUUpm4).
	assert(HPpQpUeq : rk(Pp :: Qp :: U :: nil) = 3) by (apply LPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpQpUmtmp : rk(Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HPpQpUeq HPpQpUm3).
	assert(Hincl : incl (Pp :: Qp :: U :: nil) (list_inter (C :: Pp :: Qp :: U :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Pp :: Qp :: U :: Up :: nil) (C :: Pp :: Qp :: U :: B :: Q :: Pp :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: B :: Q :: Pp :: Qp :: U :: Up :: nil) ((C :: Pp :: Qp :: U :: nil) ++ (B :: Q :: Pp :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQPpQpUUpmtmp;try rewrite HT2 in HBCQPpQpUUpmtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: U :: nil) (B :: Q :: Pp :: Qp :: U :: Up :: nil) (Pp :: Qp :: U :: nil) 4 3 3 HBCQPpQpUUpmtmp HPpQpUmtmp HCPpQpUMtmp Hincl); apply HT.
}

assert(HBQPpQpUUpM : rk(B :: Q :: Pp :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpUUpm : rk(B :: Q :: Pp :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HBQPpQpUUpeq HBQPpQpUUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpUp *)
(* dans la couche 0 *)
Lemma LBQQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Qp :: U :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQQpUUp requis par la preuve de (?)BQQpUUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpm2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpm3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpm4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpeq HABQPpQpRpUUpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpmtmp;try rewrite HT2 in HABQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpmtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQQpUUp requis par la preuve de (?)BQQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQQpUUp requis par la preuve de (?)BQQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQQpUUpm2 : rk(B :: Q :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Qp :: U :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQQpUUpm3 : rk(B :: Q :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm4).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: Up :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpmtmp;try rewrite HT2 in HBQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: Up :: nil) (B :: Qp :: nil) 4 2 3 HBQPpQpRpUUpmtmp HBQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBQQpUUpM3 : rk(B :: Q :: Qp :: U :: Up :: nil) <= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Q :: U :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: U :: Up :: nil) (B :: Q :: U :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: B :: Qp :: Up :: nil) ((B :: Q :: U :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Q :: U :: nil) (B :: Qp :: Up :: nil) (B :: nil) 2 2 1 HBQUMtmp HBQpUpMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBQQpUUpM : rk(B :: Q :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQQpUUpm : rk(B :: Q :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HBQQpUUpeq HBQQpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Pp :: Up ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpUp requis par la preuve de (?)PpUp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPpUpm2 : rk(Pp :: Up :: nil) >= 2).
{
	assert(HBQQpUUpeq : rk(B :: Q :: Qp :: U :: Up :: nil) = 3) by (apply LBQQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUUpMtmp : rk(B :: Q :: Qp :: U :: Up :: nil) <= 3) by (solve_hyps_max HBQQpUUpeq HBQQpUUpM3).
	assert(HBQPpQpUUpeq : rk(B :: Q :: Pp :: Qp :: U :: Up :: nil) = 4) by (apply LBQPpQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpUUpmtmp : rk(B :: Q :: Pp :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpUUpeq HBQPpQpUUpm4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (B :: Q :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: U :: Up :: nil) (Pp :: Up :: B :: Q :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: B :: Q :: Qp :: U :: Up :: nil) ((Pp :: Up :: nil) ++ (B :: Q :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpUUpmtmp;try rewrite HT2 in HBQPpQpUUpmtmp.
	assert(HT := rule_2 (Pp :: Up :: nil) (B :: Q :: Qp :: U :: Up :: nil) (Up :: nil) 4 1 3 HBQPpQpUUpmtmp HUpmtmp HBQQpUUpMtmp Hincl);apply HT.
}

assert(HPpUpM : rk(Pp :: Up ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpUpeq HPpUpM2).
assert(HPpUpm : rk(Pp :: Up ::  nil) >= 1) by (solve_hyps_min HPpUpeq HPpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpUp *)
(* dans constructLemma(), requis par LCQPpQpUpOo *)
(* dans constructLemma(), requis par LACQPpQpUpOo *)
(* dans la couche 0 *)
Lemma LACQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpUpOo requis par la preuve de (?)ACQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpUpOo requis par la preuve de (?)ACQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpUpOo requis par la preuve de (?)ACQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpUpOom2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUpOom3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUpOom4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HACQPpQpRpUpOoM : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpQpRpUpOom : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HACQPpQpRpUpOoeq HACQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpUpOo requis par la preuve de (?)ACQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpUpOo requis par la preuve de (?)ACQPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpUpOo requis par la preuve de (?)ACQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpUpOom2 : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpUpOom3 : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HACQPpQpUpOom4 : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HACQPpQpRpUpOoeq : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LACQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpQpRpUpOomtmp : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HACQPpQpRpUpOoeq HACQPpQpRpUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpRpUpOomtmp;try rewrite HT2 in HACQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HACQPpQpRpUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HACQPpQpUpOoM : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpQpUpOom : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HACQPpQpUpOoeq HACQPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQPpQpUpOo requis par la preuve de (?)CQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQPpQpUpOo requis par la preuve de (?)CQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpUpOo requis par la preuve de (?)CQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpUpOo requis par la preuve de (?)ABCQPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpUpOo requis par la preuve de (?)ABCQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpUpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQPpQpUpOo requis par la preuve de (?)CQPpQpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQPpQpUpOom2 : rk(C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQPpQpUpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HABCQPpQpUpOoeq HABCQPpQpUpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpUpOomtmp;try rewrite HT2 in HABCQPpQpUpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCQPpQpUpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HCQPpQpUpOom3 : rk(C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HACQPpQpRpUpOoeq : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LACQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpQpRpUpOomtmp : rk(A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HACQPpQpRpUpOoeq HACQPpQpRpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpRpUpOomtmp;try rewrite HT2 in HACQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HACQPpQpRpUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HCQPpQpUpOom4 : rk(C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HACQPpQpUpOoeq : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LACQPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpQpUpOomtmp : rk(A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HACQPpQpUpOoeq HACQPpQpUpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: C :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (C :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACQPpQpUpOomtmp;try rewrite HT2 in HACQPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HACQPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HCQPpQpUpOoM : rk(C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQPpQpUpOom : rk(C :: Q :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HCQPpQpUpOoeq HCQPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Qp :: Up ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QpUp requis par la preuve de (?)QpUp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HQpUpm2 : rk(Qp :: Up :: nil) >= 2).
{
	assert(HCQPpQpOoeq : rk(C :: Q :: Pp :: Qp :: Oo :: nil) = 3) by (apply LCQPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpOoMtmp : rk(C :: Q :: Pp :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HCQPpQpOoeq HCQPpQpOoM3).
	assert(HCQPpQpUpOoeq : rk(C :: Q :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LCQPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpQpUpOomtmp : rk(C :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HCQPpQpUpOoeq HCQPpQpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Qp :: Up :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: Up :: C :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: Up :: C :: Q :: Pp :: Qp :: Oo :: nil) ((Qp :: Up :: nil) ++ (C :: Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCQPpQpUpOomtmp;try rewrite HT2 in HCQPpQpUpOomtmp.
	assert(HT := rule_2 (Qp :: Up :: nil) (C :: Q :: Pp :: Qp :: Oo :: nil) (Qp :: nil) 4 1 3 HCQPpQpUpOomtmp HQpmtmp HCQPpQpOoMtmp Hincl);apply HT.
}

assert(HQpUpM : rk(Qp :: Up ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQpUpeq HQpUpM2).
assert(HQpUpm : rk(Qp :: Up ::  nil) >= 1) by (solve_hyps_min HQpUpeq HQpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPRQpUp *)
(* dans constructLemma(), requis par LBPRQpUp *)
(* dans la couche 0 *)
Lemma LABPRQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Qp :: Rp :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRQpRpUp requis par la preuve de (?)ABPRQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRQpRpUp requis par la preuve de (?)ABPRQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRQpRpUp requis par la preuve de (?)ABPRQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRQpRpUpm2 : rk(A :: B :: P :: R :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRQpRpUpm3 : rk(A :: B :: P :: R :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRQpRpUpm4 : rk(A :: B :: P :: R :: Qp :: Rp :: Up :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Qp :: Rp :: Up :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRQpRpUpM : rk(A :: B :: P :: R :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRQpRpUpm : rk(A :: B :: P :: R :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HABPRQpRpUpeq HABPRQpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Qp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPRQpUp requis par la preuve de (?)BPRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRQpUp requis par la preuve de (?)BPRQpUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRQpUp requis par la preuve de (?)BPRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRQpUp requis par la preuve de (?)BCPQRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRQpUp requis par la preuve de (?)ABCPQRQpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRQpUp requis par la preuve de (?)ABCPQRQpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRQpUpm2 : rk(A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRQpUpm3 : rk(A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRQpUp requis par la preuve de (?)BCPQRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRQpUp requis par la preuve de (?)BCPQRQpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRQpUpm2 : rk(B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Qp :: Up :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: Qp :: Up ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQRQpUpm3 : rk(B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRQpUpmtmp : rk(A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 3) by (solve_hyps_min HABCPQRQpUpeq HABCPQRQpUpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: R :: Qp :: Up :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRQpUpmtmp;try rewrite HT2 in HABCPQRQpUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Qp :: Up :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQRQpUpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRQpUp requis par la preuve de (?)BPRQpUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Qp :: Up ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRQpUpm2 : rk(B :: P :: R :: Qp :: Up :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRQpUpmtmp : rk(B :: C :: P :: Q :: R :: Qp :: Up :: nil) >= 3) by (solve_hyps_min HBCPQRQpUpeq HBCPQRQpUpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Qp :: Up :: nil) (C :: P :: Q :: B :: P :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Qp :: Up :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRQpUpmtmp;try rewrite HT2 in HBCPQRQpUpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Qp :: Up :: nil) (P :: nil) 3 1 2 HBCPQRQpUpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBPRQpUpM3 : rk(B :: P :: R :: Qp :: Up :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: P :: R :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Qp :: Up :: nil) (B :: P :: R :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: B :: Qp :: Up :: nil) ((B :: P :: R :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (B :: Qp :: Up :: nil) (B :: nil) 2 2 1 HBPRMtmp HBQpUpMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Qp :: Rp :: Up ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRQpUpm3 : rk(B :: P :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRQpRpUpeq : rk(A :: B :: P :: R :: Qp :: Rp :: Up :: nil) = 4) by (apply LABPRQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRQpRpUpmtmp : rk(A :: B :: P :: R :: Qp :: Rp :: Up :: nil) >= 4) by (solve_hyps_min HABPRQpRpUpeq HABPRQpRpUpm4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Qp :: Rp :: Up :: nil) (A :: Qp :: Rp :: B :: P :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Qp :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRQpRpUpmtmp;try rewrite HT2 in HABPRQpRpUpmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Qp :: Up :: nil) (Qp :: nil) 4 1 2 HABPRQpRpUpmtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HBPRQpUpM : rk(B :: P :: R :: Qp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRQpUpm : rk(B :: P :: R :: Qp :: Up ::  nil) >= 1) by (solve_hyps_min HBPRQpUpeq HBPRQpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: R :: Qp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRQpUp requis par la preuve de (?)PRQpUp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpUp requis par la preuve de (?)PRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRQpUUp requis par la preuve de (?)PQRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)PQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUUpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpUUpm2 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpUUpm3 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPQRQpUUpm4 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPQRQpRpUUpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUUpeq HAPQRQpRpUUpm4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: Q :: R :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUUpmtmp;try rewrite HT2 in HAPQRQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) (A :: Qp :: nil) 4 2 2 HAPQRQpRpUUpmtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpUUp requis par la preuve de (?)PQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpUUp requis par la preuve de (?)PQRQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpUUpm3 : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: U :: Up ::  de rang :  4 et 4 	 AiB : Q :: R :: U ::  de rang :  3 et 3 	 A : A :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpUUpm4 : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HAQRUeq : rk(A :: Q :: R :: U :: nil) = 3) by (apply LAQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUMtmp : rk(A :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAQRUeq HAQRUM3).
	assert(HAPQRQpUUpmtmp : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRQpUUpeq HAPQRQpUUpm4).
	assert(HQRUeq : rk(Q :: R :: U :: nil) = 3) by (apply LQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRUmtmp : rk(Q :: R :: U :: nil) >= 3) by (solve_hyps_min HQRUeq HQRUm3).
	assert(Hincl : incl (Q :: R :: U :: nil) (list_inter (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: U :: Up :: nil) (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Up :: nil) ((A :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpUUpmtmp;try rewrite HT2 in HAPQRQpUUpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil) (Q :: R :: U :: nil) 4 3 3 HAPQRQpUUpmtmp HQRUmtmp HAQRUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpUp requis par la preuve de (?)PQRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpUp requis par la preuve de (?)PQRQpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpUpm3 : rk(P :: Q :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: U :: Up ::  de rang :  4 et 4 	 AiB : P :: Q :: R ::  de rang :  3 et 3 	 A : P :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpUpm4 : rk(P :: Q :: R :: Qp :: Up :: nil) >= 4).
{
	assert(HPQRUeq : rk(P :: Q :: R :: U :: nil) = 3) by (apply LPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRUMtmp : rk(P :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HPQRUeq HPQRUM3).
	assert(HPQRQpUUpmtmp : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HPQRQpUUpeq HPQRQpUUpm4).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: U :: Up :: nil) (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Up :: nil) ((P :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpUUpmtmp;try rewrite HT2 in HPQRQpUUpmtmp.
	assert(HT := rule_4 (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Up :: nil) (P :: Q :: R :: nil) 4 3 3 HPQRQpUUpmtmp HPQRmtmp HPQRUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRQpUp requis par la preuve de (?)PRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRQpRpUp requis par la preuve de (?)PRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRQpRpUp requis par la preuve de (?)APRQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRQpRpUp requis par la preuve de (?)APRQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRQpRpUp requis par la preuve de (?)ACPQRQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRQpRpUp requis par la preuve de (?)ABCPQRQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRQpRpUp requis par la preuve de (?)ABCPQRQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRQpRpUpm2 : rk(A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRQpRpUpm3 : rk(A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRQpRpUp requis par la preuve de (?)ACPQRQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRQpRpUp requis par la preuve de (?)ACPQRQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRQpRpUpm2 : rk(A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQRQpRpUpm3 : rk(A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRQpRpUpmtmp : rk(A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HABCPQRQpRpUpeq HABCPQRQpRpUpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRQpRpUpmtmp;try rewrite HT2 in HABCPQRQpRpUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQRQpRpUpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRQpRpUp requis par la preuve de (?)APRQpRpUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Qp :: Rp :: Up ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRQpRpUpm2 : rk(A :: P :: R :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRQpRpUpmtmp : rk(A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HACPQRQpRpUpeq HACPQRQpRpUpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Qp :: Rp :: Up :: nil) (C :: P :: Q :: A :: P :: R :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Qp :: Rp :: Up :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRQpRpUpmtmp;try rewrite HT2 in HACPQRQpRpUpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Qp :: Rp :: Up :: nil) (P :: nil) 3 1 2 HACPQRQpRpUpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRQpRpUpm3 : rk(A :: P :: R :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Qp :: Rp :: Up :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRQpUp requis par la preuve de (?)PRQpUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Qp :: Rp :: Up ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HPRQpUpm2 : rk(P :: R :: Qp :: Up :: nil) >= 2).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPRQpRpUpmtmp : rk(A :: P :: R :: Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HAPRQpRpUpeq HAPRQpRpUpm3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (P :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Qp :: Rp :: Up :: nil) (A :: Qp :: Rp :: P :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: P :: R :: Qp :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (P :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRQpRpUpmtmp;try rewrite HT2 in HAPRQpRpUpmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (P :: R :: Qp :: Up :: nil) (Qp :: nil) 3 1 2 HAPRQpRpUpmtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Up ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Q :: Up ::   de rang : 2 et 2 *)
assert(HPRQpUpm3 : rk(P :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HQUpeq : rk(Q :: Up :: nil) = 2) by (apply LQUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUpMtmp : rk(Q :: Up :: nil) <= 2) by (solve_hyps_max HQUpeq HQUpM2).
	assert(HPQRQpUpmtmp : rk(P :: Q :: R :: Qp :: Up :: nil) >= 4) by (solve_hyps_min HPQRQpUpeq HPQRQpUpm4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Q :: Up :: nil) (P :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Up :: nil) (Q :: Up :: P :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Up :: P :: R :: Qp :: Up :: nil) ((Q :: Up :: nil) ++ (P :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpUpmtmp;try rewrite HT2 in HPQRQpUpmtmp.
	assert(HT := rule_4 (Q :: Up :: nil) (P :: R :: Qp :: Up :: nil) (Up :: nil) 4 1 2 HPQRQpUpmtmp HUpmtmp HQUpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPRQpUpM3 : rk(P :: R :: Qp :: Up :: nil) <= 3).
{
	assert(HBPRQpUpeq : rk(B :: P :: R :: Qp :: Up :: nil) = 3) by (apply LBPRQpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRQpUpMtmp : rk(B :: P :: R :: Qp :: Up :: nil) <= 3) by (solve_hyps_max HBPRQpUpeq HBPRQpUpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: R :: Qp :: Up :: nil) (B :: P :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (P :: R :: Qp :: Up :: nil) (B :: P :: R :: Qp :: Up :: nil) 3 3 HBPRQpUpMtmp Hcomp Hincl);apply HT.
}

assert(HPRQpUpM : rk(P :: R :: Qp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRQpUpm : rk(P :: R :: Qp :: Up ::  nil) >= 1) by (solve_hyps_min HPRQpUpeq HPRQpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LPQRQpUp *)
(* dans constructLemma(), requis par LPQRQpUUp *)
(* dans constructLemma(), requis par LAPQRQpUUp *)
(* dans la couche 0 *)
Lemma LAPQRQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUUp requis par la preuve de (?)APQRQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUUpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUUpM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUUpm : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUUpeq HAPQRQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpUUp requis par la preuve de (?)APQRQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpUUpm2 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpUUpm3 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPQRQpUUpm4 : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPQRQpRpUUpeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LAPQRQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUUpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUUpeq HAPQRQpRpUUpm4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: Q :: R :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUUpmtmp;try rewrite HT2 in HAPQRQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Up :: nil) (A :: Qp :: nil) 4 2 2 HAPQRQpRpUUpmtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HAPQRQpUUpM : rk(A :: P :: Q :: R :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpUUpm : rk(A :: P :: Q :: R :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HAPQRQpUUpeq HAPQRQpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpUUp requis par la preuve de (?)PQRQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpUUp requis par la preuve de (?)PQRQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpUUpm3 : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: U :: Up ::  de rang :  4 et 4 	 AiB : Q :: R :: U ::  de rang :  3 et 3 	 A : A :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpUUpm4 : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 4).
{
	assert(HAQRUeq : rk(A :: Q :: R :: U :: nil) = 3) by (apply LAQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUMtmp : rk(A :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAQRUeq HAQRUM3).
	assert(HAPQRQpUUpeq : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) = 4) by (apply LAPQRQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpUUpmtmp : rk(A :: P :: Q :: R :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRQpUUpeq HAPQRQpUUpm4).
	assert(HQRUeq : rk(Q :: R :: U :: nil) = 3) by (apply LQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRUmtmp : rk(Q :: R :: U :: nil) >= 3) by (solve_hyps_min HQRUeq HQRUm3).
	assert(Hincl : incl (Q :: R :: U :: nil) (list_inter (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: U :: Up :: nil) (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Up :: nil) ((A :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpUUpmtmp;try rewrite HT2 in HAPQRQpUUpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Up :: nil) (Q :: R :: U :: nil) 4 3 3 HAPQRQpUUpmtmp HQRUmtmp HAQRUMtmp Hincl); apply HT.
}

assert(HPQRQpUUpM : rk(P :: Q :: R :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpUUpm : rk(P :: Q :: R :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HPQRQpUUpeq HPQRQpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpUp requis par la preuve de (?)PQRQpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpUp requis par la preuve de (?)PQRQpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpUpm3 : rk(P :: Q :: R :: Qp :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: U :: Up ::  de rang :  4 et 4 	 AiB : P :: Q :: R ::  de rang :  3 et 3 	 A : P :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpUpm4 : rk(P :: Q :: R :: Qp :: Up :: nil) >= 4).
{
	assert(HPQRUeq : rk(P :: Q :: R :: U :: nil) = 3) by (apply LPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRUMtmp : rk(P :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HPQRUeq HPQRUM3).
	assert(HPQRQpUUpeq : rk(P :: Q :: R :: Qp :: U :: Up :: nil) = 4) by (apply LPQRQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRQpUUpmtmp : rk(P :: Q :: R :: Qp :: U :: Up :: nil) >= 4) by (solve_hyps_min HPQRQpUUpeq HPQRQpUUpm4).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: U :: Up :: nil) (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Up :: nil) ((P :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpUUpmtmp;try rewrite HT2 in HPQRQpUUpmtmp.
	assert(HT := rule_4 (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Up :: nil) (P :: Q :: R :: nil) 4 3 3 HPQRQpUUpmtmp HPQRmtmp HPQRUMtmp Hincl); apply HT.
}

assert(HPQRQpUpM : rk(P :: Q :: R :: Qp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpUpm : rk(P :: Q :: R :: Qp :: Up ::  nil) >= 1) by (solve_hyps_min HPQRQpUpeq HPQRQpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LARpUp *)
(* dans constructLemma(), requis par LAQQpRpUpOo *)
(* dans constructLemma(), requis par LAQPpQpRpUpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpOo requis par la preuve de (?)ABQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpOo requis par la preuve de (?)ABQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpOo requis par la preuve de (?)ABQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpOo requis par la preuve de (?)AQPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpOo requis par la preuve de (?)AQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpOo requis par la preuve de (?)AQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpOomtmp;try rewrite HT2 in HABQPpQpRpUpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HAQPpQpRpUpOoM : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpQpRpUpOom : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HAQPpQpRpUpOoeq HAQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpOo requis par la preuve de (?)AQQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpOo requis par la preuve de (?)AQQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpOo requis par la preuve de (?)AQQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpOom2 : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpOom3 : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpOom4 : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpOoeq : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LAQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpQpRpUpOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpOoeq HAQPpQpRpUpOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpOomtmp;try rewrite HT2 in HAQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HAQQpRpUpOoM : rk(A :: Q :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpUpOom : rk(A :: Q :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpRpUpOoeq HAQQpRpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LARpUp *)
(* dans la couche 0 *)
Lemma LAQQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQQpRpOo requis par la preuve de (?)AQQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpOo requis par la preuve de (?)AQQpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpOo requis par la preuve de (?)AQQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpOom2 : rk(A :: Q :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQQpRpOoM3 : rk(A :: Q :: Qp :: Rp :: Oo :: nil) <= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Q :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Qp :: Rp :: nil) (Q :: Qp :: Oo :: nil) (Qp :: nil) 2 2 1 HAQpRpMtmp HQQpOoMtmp HQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpOom3 : rk(A :: Q :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAQQpRpOoM : rk(A :: Q :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpOom : rk(A :: Q :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpRpOoeq HAQQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARpUp requis par la preuve de (?)ARpUp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARpUp requis par la preuve de (?)ARpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARpUpm2 : rk(A :: Rp :: Up :: nil) >= 2).
{
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Rp :: nil) (A :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Rp :: nil) (A :: Rp :: Up :: nil) 2 2 HARpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HARpUpm3 : rk(A :: Rp :: Up :: nil) >= 3).
{
	assert(HAQQpRpOoeq : rk(A :: Q :: Qp :: Rp :: Oo :: nil) = 3) by (apply LAQQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpOoMtmp : rk(A :: Q :: Qp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HAQQpRpOoeq HAQQpRpOoM3).
	assert(HAQQpRpUpOoeq : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LAQQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpUpOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpOoeq HAQQpRpUpOom4).
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hincl : incl (A :: Rp :: nil) (list_inter (A :: Rp :: Up :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: Oo :: nil) (A :: Rp :: Up :: A :: Q :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Rp :: Up :: A :: Q :: Qp :: Rp :: Oo :: nil) ((A :: Rp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpOomtmp;try rewrite HT2 in HAQQpRpUpOomtmp.
	assert(HT := rule_2 (A :: Rp :: Up :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil) (A :: Rp :: nil) 4 2 3 HAQQpRpUpOomtmp HARpmtmp HAQQpRpOoMtmp Hincl);apply HT.
}

assert(HARpUpM : rk(A :: Rp :: Up ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HARpUpeq HARpUpM3).
assert(HARpUpm : rk(A :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HARpUpeq HARpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABRpUp *)
(* dans la couche 0 *)
Lemma LABPpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Pp :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpRpUp requis par la preuve de (?)ABPpRpUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpRpUp requis par la preuve de (?)ABPpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpRpUp requis par la preuve de (?)ABPpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpRpUpm2 : rk(A :: B :: Pp :: Rp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: Rp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpRpUpm3 : rk(A :: B :: Pp :: Rp :: Up :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: Pp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: Pp :: Rp :: Up :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABPpRpUpM3 : rk(A :: B :: Pp :: Rp :: Up :: nil) <= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: Pp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Pp :: Rp :: Up :: nil) (B :: Pp :: Rp :: A :: Pp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: Pp :: Up :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: Pp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Pp :: Rp :: nil) (A :: Pp :: Up :: nil) (Pp :: nil) 2 2 1 HBPpRpMtmp HAPpUpMtmp HPpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABPpRpUpM : rk(A :: B :: Pp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPpRpUpm : rk(A :: B :: Pp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HABPpRpUpeq HABPpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRpUp requis par la preuve de (?)ABRpUp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRpUp requis par la preuve de (?)ABRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRpUp requis par la preuve de (?)ABRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRpUpm2 : rk(A :: B :: Rp :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Rp :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRpUpm3 : rk(A :: B :: Rp :: Up :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: Rp :: Up :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABRpUpM3 : rk(A :: B :: Rp :: Up :: nil) <= 3).
{
	assert(HABPpRpUpeq : rk(A :: B :: Pp :: Rp :: Up :: nil) = 3) by (apply LABPpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpRpUpMtmp : rk(A :: B :: Pp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HABPpRpUpeq HABPpRpUpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: Up :: nil) (A :: B :: Pp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Rp :: Up :: nil) (A :: B :: Pp :: Rp :: Up :: nil) 3 3 HABPpRpUpMtmp Hcomp Hincl);apply HT.
}

assert(HABRpUpM : rk(A :: B :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRpUpm : rk(A :: B :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HABRpUpeq HABRpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpRpUp *)
(* dans constructLemma(), requis par LBQpRpUp *)
(* dans constructLemma(), requis par LBQPpQpRpUUp *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUp requis par la preuve de (?)ABQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpm : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpeq HABQPpQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUp requis par la preuve de (?)BQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpm2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpm3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpm4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LABQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpeq HABQPpQpRpUUpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpmtmp;try rewrite HT2 in HABQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpmtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpm : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQpRpUp requis par la preuve de (?)BQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpRpUp requis par la preuve de (?)BQpRpUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpRpUp requis par la preuve de (?)BQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpRpUpm2 : rk(B :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBQpRpUpM3 : rk(B :: Qp :: Rp :: Up :: nil) <= 3).
{
	assert(HRpMtmp : rk(Rp :: nil) <= 1) by (solve_hyps_max HRpeq HRpM1).
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: nil) (B :: Qp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: nil) (Rp :: B :: Qp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: B :: Qp :: Up :: nil) ((Rp :: nil) ++ (B :: Qp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: nil) (B :: Qp :: Up :: nil) (nil) 1 2 0 HRpMtmp HBQpUpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HBQpRpUpm3 : rk(B :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUUpeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LBQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: nil) ((B :: Q :: Pp :: Rp :: U :: nil) ++ (B :: Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpmtmp;try rewrite HT2 in HBQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: nil) (B :: Rp :: nil) 4 2 3 HBQPpQpRpUUpmtmp HBRpmtmp HBQPpRpUMtmp Hincl); apply HT.
}

assert(HBQpRpUpM : rk(B :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQpRpUpm : rk(B :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HBQpRpUpeq HBQpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Qp :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QpRpUp requis par la preuve de (?)QpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpm4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUUpm2 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUUpmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUUpeq HABCQPpQpRpUUpm4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpmtmp;try rewrite HT2 in HABCQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUUpmtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUUpm3 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUUpm4 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LBQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpmtmp;try rewrite HT2 in HBQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUUpmtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QpRpUp requis par la preuve de (?)QpRpUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQpRpUpm2 : rk(Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUUpmtmp : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HQPpQpRpUUpeq HQPpQpRpUUpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Q :: Pp :: Rp :: U :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Qp :: Rp :: Up :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUUpmtmp;try rewrite HT2 in HQPpQpRpUUpmtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Qp :: Rp :: Up :: nil) (Rp :: nil) 4 1 3 HQPpQpRpUUpmtmp HRpmtmp HQPpRpUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Qp :: Rp :: Up ::  de rang :  3 et 3 	 AiB : Qp :: Up ::  de rang :  2 et 2 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HQpRpUpm3 : rk(Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQpRpUpeq : rk(B :: Qp :: Rp :: Up :: nil) = 3) by (apply LBQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpRpUpmtmp : rk(B :: Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HBQpRpUpeq HBQpRpUpm3).
	assert(HQpUpeq : rk(Qp :: Up :: nil) = 2) by (apply LQpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpUpmtmp : rk(Qp :: Up :: nil) >= 2) by (solve_hyps_min HQpUpeq HQpUpm2).
	assert(Hincl : incl (Qp :: Up :: nil) (list_inter (B :: Qp :: Up :: nil) (Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: nil) (B :: Qp :: Up :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Qp :: Rp :: Up :: nil) ((B :: Qp :: Up :: nil) ++ (Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQpRpUpmtmp;try rewrite HT2 in HBQpRpUpmtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Qp :: Rp :: Up :: nil) (Qp :: Up :: nil) 3 2 2 HBQpRpUpmtmp HQpUpmtmp HBQpUpMtmp Hincl); apply HT.
}

assert(HQpRpUpM : rk(Qp :: Rp :: Up ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQpRpUpeq HQpRpUpM3).
assert(HQpRpUpm : rk(Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HQpRpUpeq HQpRpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQpRpUp *)
(* dans la couche 0 *)
Lemma LAPpQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: Qp :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpQpRpUp requis par la preuve de (?)APpQpRpUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpQpRpUp requis par la preuve de (?)APpQpRpUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpQpRpUp requis par la preuve de (?)APpQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpQpRpUpm2 : rk(A :: Pp :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: nil) (A :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: nil) (A :: Pp :: Qp :: Rp :: Up :: nil) 2 2 HAQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAPpQpRpUpM3 : rk(A :: Pp :: Qp :: Rp :: Up :: nil) <= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: Pp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: Qp :: Rp :: Up :: nil) (A :: Qp :: Rp :: A :: Pp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: Pp :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: Pp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Qp :: Rp :: nil) (A :: Pp :: Up :: nil) (A :: nil) 2 2 1 HAQpRpMtmp HAPpUpMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPpQpRpUpm3 : rk(A :: Pp :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (A :: Pp :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (A :: Pp :: Qp :: Rp :: Up :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPpQpRpUpM : rk(A :: Pp :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpQpRpUpm : rk(A :: Pp :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HAPpQpRpUpeq HAPpQpRpUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQpRpUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Qp :: Rp :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQpRpUp requis par la preuve de (?)AQpRpUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQpRpUp requis par la preuve de (?)AQpRpUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQpRpUp requis par la preuve de (?)AQpRpUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQpRpUpm2 : rk(A :: Qp :: Rp :: Up :: nil) >= 2).
{
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: nil) (A :: Qp :: Rp :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: nil) (A :: Qp :: Rp :: Up :: nil) 2 2 HAQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAQpRpUpM3 : rk(A :: Qp :: Rp :: Up :: nil) <= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HUpMtmp : rk(Up :: nil) <= 1) by (solve_hyps_max HUpeq HUpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Qp :: Rp :: nil) (Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Qp :: Rp :: Up :: nil) (A :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: nil) ((A :: Qp :: Rp :: nil) ++ (Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Qp :: Rp :: nil) (Up :: nil) (nil) 2 1 0 HAQpRpMtmp HUpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Pp :: Qp :: Rp :: Up ::  de rang :  3 et 3 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQpRpUpm3 : rk(A :: Qp :: Rp :: Up :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPpQpRpUpeq : rk(A :: Pp :: Qp :: Rp :: Up :: nil) = 3) by (apply LAPpQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpUpmtmp : rk(A :: Pp :: Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HAPpQpRpUpeq HAPpQpRpUpm3).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Qp :: Rp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: Qp :: Rp :: Up :: nil) (A :: Pp :: Up :: A :: Qp :: Rp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Qp :: Rp :: Up :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Qp :: Rp :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPpQpRpUpmtmp;try rewrite HT2 in HAPpQpRpUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Qp :: Rp :: Up :: nil) (A :: Up :: nil) 3 2 2 HAPpQpRpUpmtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HAQpRpUpM : rk(A :: Qp :: Rp :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQpRpUpm : rk(A :: Qp :: Rp :: Up ::  nil) >= 1) by (solve_hyps_min HAQpRpUpeq HAQpRpUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LUUp *)
(* dans la couche 0 *)
Lemma LAPpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: U :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpUUp requis par la preuve de (?)APpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUUp requis par la preuve de (?)APpUUp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUUp requis par la preuve de (?)APpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPpQpUUp requis par la preuve de (?)ACPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPpQpUUp requis par la preuve de (?)ABCPpQpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPpQpUUp requis par la preuve de (?)ABCPpQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUUpm2 : rk(A :: B :: C :: Pp :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Pp :: Qp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPpQpUUpm3 : rk(A :: B :: C :: Pp :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: C :: Pp :: Qp :: U :: Up :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUUp requis par la preuve de (?)ACPpQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUUp requis par la preuve de (?)ACPpQpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUUpm2 : rk(A :: C :: Pp :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Pp :: Qp :: U :: Up ::  de rang :  3 et 4 	 AiB : A :: C :: Qp ::  de rang :  3 et 3 	 A : A :: B :: C :: Qp ::   de rang : 3 et 3 *)
assert(HACPpQpUUpm3 : rk(A :: C :: Pp :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HABCQpeq : rk(A :: B :: C :: Qp :: nil) = 3) by (apply LABCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQpMtmp : rk(A :: B :: C :: Qp :: nil) <= 3) by (solve_hyps_max HABCQpeq HABCQpM3).
	assert(HABCPpQpUUpmtmp : rk(A :: B :: C :: Pp :: Qp :: U :: Up :: nil) >= 3) by (solve_hyps_min HABCPpQpUUpeq HABCPpQpUUpm3).
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hincl : incl (A :: C :: Qp :: nil) (list_inter (A :: B :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Pp :: Qp :: U :: Up :: nil) (A :: B :: C :: Qp :: A :: C :: Pp :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Qp :: A :: C :: Pp :: Qp :: U :: Up :: nil) ((A :: B :: C :: Qp :: nil) ++ (A :: C :: Pp :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPpQpUUpmtmp;try rewrite HT2 in HABCPpQpUUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: nil) (A :: C :: Qp :: nil) 3 3 3 HABCPpQpUUpmtmp HACQpmtmp HABCQpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUUp requis par la preuve de (?)APpUUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Up ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUUpm2 : rk(A :: Pp :: U :: Up :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUUpmtmp : rk(A :: C :: Pp :: Qp :: U :: Up :: nil) >= 3) by (solve_hyps_min HACPpQpUUpeq HACPpQpUUpm3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Up :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Up :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUUpmtmp;try rewrite HT2 in HACPpQpUUpmtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: nil) (Pp :: nil) 3 1 2 HACPpQpUUpmtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPpUUpM3 : rk(A :: Pp :: U :: Up :: nil) <= 3).
{
	assert(HUMtmp : rk(U :: nil) <= 1) by (solve_hyps_max HUeq HUM1).
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (U :: nil) (A :: Pp :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: nil) (U :: A :: Pp :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (U :: A :: Pp :: Up :: nil) ((U :: nil) ++ (A :: Pp :: Up :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (U :: nil) (A :: Pp :: Up :: nil) (nil) 1 2 0 HUMtmp HAPpUpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUUpm3 : rk(A :: Pp :: U :: Up :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

assert(HAPpUUpM : rk(A :: Pp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpUUpm : rk(A :: Pp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HAPpUUpeq HAPpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(U :: Up ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour UUp requis par la preuve de (?)UUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Pp :: U :: Up ::  de rang :  3 et 3 	 AiB : Up ::  de rang :  1 et 1 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HUUpm2 : rk(U :: Up :: nil) >= 2).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPpUUpeq : rk(A :: Pp :: U :: Up :: nil) = 3) by (apply LAPpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUUpmtmp : rk(A :: Pp :: U :: Up :: nil) >= 3) by (solve_hyps_min HAPpUUpeq HAPpUUpm3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (A :: Pp :: Up :: nil) (U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: nil) (A :: Pp :: Up :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: U :: Up :: nil) ((A :: Pp :: Up :: nil) ++ (U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPpUUpmtmp;try rewrite HT2 in HAPpUUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (U :: Up :: nil) (Up :: nil) 3 1 2 HAPpUUpmtmp HUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HUUpM : rk(U :: Up ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HUUpeq HUUpM2).
assert(HUUpm : rk(U :: Up ::  nil) >= 1) by (solve_hyps_min HUUpeq HUUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQUUp *)
(* dans la couche 0 *)
Lemma LAQPpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpUUp requis par la preuve de (?)AQPpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpUUp requis par la preuve de (?)AQPpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQPpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUUpm2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUUpm3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUUpm4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpUUp requis par la preuve de (?)APQPpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpUUp requis par la preuve de (?)APQPpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUUpm2 : rk(A :: P :: Q :: Pp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpUUpm3 : rk(A :: P :: Q :: Pp :: U :: Up :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpUUpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpUUpeq HAPQRPpQpRpUUpm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: Up :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpUUpmtmp;try rewrite HT2 in HAPQRPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: Up :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpUUpmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpUUp requis par la preuve de (?)AQPpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpUUp requis par la preuve de (?)AQPpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpUUpm2 : rk(A :: Q :: Pp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Pp :: U :: Up ::  de rang :  3 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQPpUUpm3 : rk(A :: Q :: Pp :: U :: Up :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQPpUUpmtmp : rk(A :: P :: Q :: Pp :: U :: Up :: nil) >= 3) by (solve_hyps_min HAPQPpUUpeq HAPQPpUUpm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: Pp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Pp :: U :: Up :: nil) (A :: P :: U :: A :: Q :: Pp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: Pp :: U :: Up :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: Pp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQPpUUpmtmp;try rewrite HT2 in HAPQPpUUpmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: Pp :: U :: Up :: nil) (A :: U :: nil) 3 2 2 HAPQPpUUpmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpUUpm4 : rk(A :: Q :: Pp :: U :: Up :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: Q :: Pp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: Q :: Pp :: U :: Up :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HAQPpUUpM : rk(A :: Q :: Pp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpUUpm : rk(A :: Q :: Pp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HAQPpUUpeq HAQPpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: U :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QUUp requis par la preuve de (?)QUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQUUp requis par la preuve de (?)QUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQUUp requis par la preuve de (?)APQUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQUUp requis par la preuve de (?)APQUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUUpm2 : rk(A :: P :: Q :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQUUpm3 : rk(A :: P :: Q :: U :: Up :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUUpeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LAPQRQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUUpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUUpeq HAPQRQpRpUUpm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Up :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUUpmtmp;try rewrite HT2 in HAPQRQpRpUUpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Up :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpUUpmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QUUp requis par la preuve de (?)QUUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: U :: Up ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQUUpm2 : rk(Q :: U :: Up :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQUUpmtmp : rk(A :: P :: Q :: U :: Up :: nil) >= 3) by (solve_hyps_min HAPQUUpeq HAPQUUpm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: Up :: nil) (A :: P :: U :: Q :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: U :: Up :: nil) ((A :: P :: U :: nil) ++ (Q :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQUUpmtmp;try rewrite HT2 in HAPQUUpmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: U :: Up :: nil) (U :: nil) 3 1 2 HAPQUUpmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: U :: Up ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HQUUpm3 : rk(Q :: U :: Up :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpUUpeq : rk(A :: Q :: Pp :: U :: Up :: nil) = 4) by (apply LAQPpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUUpmtmp : rk(A :: Q :: Pp :: U :: Up :: nil) >= 4) by (solve_hyps_min HAQPpUUpeq HAQPpUUpm4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (A :: Pp :: Up :: nil) (Q :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: U :: Up :: nil) (A :: Pp :: Up :: Q :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: Q :: U :: Up :: nil) ((A :: Pp :: Up :: nil) ++ (Q :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpUUpmtmp;try rewrite HT2 in HAQPpUUpmtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (Q :: U :: Up :: nil) (Up :: nil) 4 1 2 HAQPpUUpmtmp HUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HQUUpM : rk(Q :: U :: Up ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQUUpeq HQUUpM3).
assert(HQUUpm : rk(Q :: U :: Up ::  nil) >= 1) by (solve_hyps_min HQUUpeq HQUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: U :: Up ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpUUp requis par la preuve de (?)QQpUUp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpUUp requis par la preuve de (?)QQpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpUUp requis par la preuve de (?)QQpUUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpUUpm2 : rk(Q :: Qp :: U :: Up :: nil) >= 2).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LBQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: Pp :: Qp :: Rp :: Q :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Qp :: U :: Up :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpmtmp;try rewrite HT2 in HBQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Qp :: U :: Up :: nil) (Qp :: nil) 4 1 3 HBQPpQpRpUUpmtmp HQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Q :: Qp :: U :: Up ::  de rang :  3 et 3 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HQQpUUpm3 : rk(Q :: Qp :: U :: Up :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQQpUUpeq : rk(B :: Q :: Qp :: U :: Up :: nil) = 3) by (apply LBQQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUUpmtmp : rk(B :: Q :: Qp :: U :: Up :: nil) >= 3) by (solve_hyps_min HBQQpUUpeq HBQQpUUpm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (Q :: Qp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: U :: Up :: nil) (B :: Q :: U :: Q :: Qp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: Qp :: U :: Up :: nil) ((B :: Q :: U :: nil) ++ (Q :: Qp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQQpUUpmtmp;try rewrite HT2 in HBQQpUUpmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (Q :: Qp :: U :: Up :: nil) (Q :: U :: nil) 3 2 2 HBQQpUUpmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HQQpUUpM3 : rk(Q :: Qp :: U :: Up :: nil) <= 3).
{
	assert(HBQQpUUpeq : rk(B :: Q :: Qp :: U :: Up :: nil) = 3) by (apply LBQQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUUpMtmp : rk(B :: Q :: Qp :: U :: Up :: nil) <= 3) by (solve_hyps_max HBQQpUUpeq HBQQpUUpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Q :: Qp :: U :: Up :: nil) (B :: Q :: Qp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Q :: Qp :: U :: Up :: nil) (B :: Q :: Qp :: U :: Up :: nil) 3 3 HBQQpUUpMtmp Hcomp Hincl);apply HT.
}

assert(HQQpUUpM : rk(Q :: Qp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpUUpm : rk(Q :: Qp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HQQpUUpeq HQQpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpm4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUUp requis par la preuve de (?)QPpQpRpUUp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUUpm2 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUUpmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUUpeq HABCQPpQpRpUUpm4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpmtmp;try rewrite HT2 in HABCQPpQpRpUUpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUUpmtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUUpm3 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUUpm4 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) = 4) by (apply LBQPpQpRpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpeq HBQPpQpRpUUpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpmtmp;try rewrite HT2 in HBQPpQpRpUUpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUUpmtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUUpM : rk(Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUUpm : rk(Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUUpeq HQPpQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUp requis par la preuve de (?)ABCQPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpm4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUUpM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUUpm : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUUpeq HABCQPpQpRpUUpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRPpQpRpUUp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpUUp requis par la preuve de (?)APQRPpQpRpUUp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUUpm2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUUpm3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUUpm4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRPpQpRpUUpM : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRPpQpRpUUpm : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up ::  nil) >= 1) by (solve_hyps_min HAPQRPpQpRpUUpeq HAPQRPpQpRpUUpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAD *)
(* dans constructLemma(), requis par LARUD *)
(* dans la couche 0 *)
Lemma LAPRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRUD requis par la preuve de (?)APRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRUD requis par la preuve de (?)APRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRUD requis par la preuve de (?)APRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQRUD requis par la preuve de (?)ACPQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQRUD requis par la preuve de (?)ABCPQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQRUD requis par la preuve de (?)ABCPQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRUDm2 : rk(A :: B :: C :: P :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQRUDm3 : rk(A :: B :: C :: P :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: R :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRUD requis par la preuve de (?)ACPQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRUD requis par la preuve de (?)ACPQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRUDm2 : rk(A :: C :: P :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: U :: D :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQRUDm3 : rk(A :: C :: P :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQRUDmtmp : rk(A :: B :: C :: P :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCPQRUDeq HABCPQRUDm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: R :: U :: D :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: R :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQRUDmtmp;try rewrite HT2 in HABCPQRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: R :: U :: D :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQRUDmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRUD requis par la preuve de (?)APRUD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRUDm2 : rk(A :: P :: R :: U :: D :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRUDmtmp : rk(A :: C :: P :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HACPQRUDeq HACPQRUDm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: U :: D :: nil) (C :: P :: Q :: A :: P :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: U :: D :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRUDmtmp;try rewrite HT2 in HACPQRUDmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: U :: D :: nil) (P :: nil) 3 1 2 HACPQRUDmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: D ::  de rang :  4 et 4 	 AiB : A :: R ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRUDm3 : rk(A :: P :: R :: U :: D :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDeq HAPQRQpRpUDm4).
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hincl : incl (A :: R :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: U :: D :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDmtmp;try rewrite HT2 in HAPQRQpRpUDmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: U :: D :: nil) (A :: R :: nil) 4 2 3 HAPQRQpRpUDmtmp HARmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAPRUDM3 : rk(A :: P :: R :: U :: D :: nil) <= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: U :: D :: nil) (A :: P :: U :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: R :: U :: D :: nil) ((A :: P :: U :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: P :: U :: nil) (R :: U :: D :: nil) (U :: nil) 2 2 1 HAPUMtmp HRUDMtmp HUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAPRUDM : rk(A :: P :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRUDm : rk(A :: P :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HAPRUDeq HAPRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARUD requis par la preuve de (?)ARUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARUD requis par la preuve de (?)ARUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARUD requis par la preuve de (?)ARUD pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HARUDM3 : rk(A :: R :: U :: D :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: U :: D :: nil) (A :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: R :: U :: D :: nil) ((A :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (R :: U :: D :: nil) (nil) 1 2 0 HAMtmp HRUDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARUDm2 : rk(A :: R :: U :: D :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: U :: D :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: U :: D ::  de rang :  3 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HARUDm3 : rk(A :: R :: U :: D :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRUDeq : rk(A :: P :: R :: U :: D :: nil) = 3) by (apply LAPRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRUDmtmp : rk(A :: P :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HAPRUDeq HAPRUDm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: U :: D :: nil) (A :: P :: U :: A :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: R :: U :: D :: nil) ((A :: P :: U :: nil) ++ (A :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRUDmtmp;try rewrite HT2 in HAPRUDmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: R :: U :: D :: nil) (A :: U :: nil) 3 2 2 HAPRUDmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HARUDM : rk(A :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARUDm : rk(A :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HARUDeq HARUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: D ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD requis par la preuve de (?)AD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HADm2 : rk(A :: D :: nil) >= 2).
{
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HARUDeq : rk(A :: R :: U :: D :: nil) = 3) by (apply LARUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARUDmtmp : rk(A :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HARUDeq HARUDm3).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: U :: D :: nil) (A :: D :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: R :: U :: D :: nil) ((A :: D :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HARUDmtmp;try rewrite HT2 in HARUDmtmp.
	assert(HT := rule_2 (A :: D :: nil) (R :: U :: D :: nil) (D :: nil) 3 1 2 HARUDmtmp HDmtmp HRUDMtmp Hincl);apply HT.
}

assert(HADM : rk(A :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HADeq HADM2).
assert(HADm : rk(A :: D ::  nil) >= 1) by (solve_hyps_min HADeq HADm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: D ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDM2 : rk(A :: B :: D :: nil) <= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: D :: nil) (A :: B :: C :: D :: Dp :: nil) 2 2 HABCDDpMtmp Hcomp Hincl);apply HT.
}

assert(HABDM : rk(A :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDeq HABDM3).
assert(HABDm : rk(A :: B :: D ::  nil) >= 1) by (solve_hyps_min HABDeq HABDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQD requis par la preuve de (?)AQD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQD requis par la preuve de (?)AQD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQDm2 : rk(A :: Q :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAQDm3 : rk(A :: Q :: D :: nil) >= 3).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCQDDpeq : rk(A :: B :: C :: Q :: D :: Dp :: nil) = 3) by (apply LABCQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQDDpmtmp : rk(A :: B :: C :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCQDDpeq HABCQDDpm3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: Q :: D :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: D :: Dp :: nil) (A :: Q :: D :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: D :: A :: B :: C :: D :: Dp :: nil) ((A :: Q :: D :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQDDpmtmp;try rewrite HT2 in HABCQDDpmtmp.
	assert(HT := rule_2 (A :: Q :: D :: nil) (A :: B :: C :: D :: Dp :: nil) (A :: D :: nil) 3 2 2 HABCQDDpmtmp HADmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HAQDM : rk(A :: Q :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAQDeq HAQDM3).
assert(HAQDm : rk(A :: Q :: D ::  nil) >= 1) by (solve_hyps_min HAQDeq HAQDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(R :: D ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RD requis par la preuve de (?)RD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HRDm2 : rk(R :: D :: nil) >= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABCRDDpeq : rk(A :: B :: C :: R :: D :: Dp :: nil) = 3) by (apply LABCRDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRDDpmtmp : rk(A :: B :: C :: R :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABCRDDpeq HABCRDDpm3).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (R :: D :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: D :: Dp :: nil) (R :: D :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: D :: A :: B :: C :: D :: Dp :: nil) ((R :: D :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRDDpmtmp;try rewrite HT2 in HABCRDDpmtmp.
	assert(HT := rule_2 (R :: D :: nil) (A :: B :: C :: D :: Dp :: nil) (D :: nil) 3 1 2 HABCRDDpmtmp HDmtmp HABCDDpMtmp Hincl);apply HT.
}

assert(HRDM : rk(R :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRDeq HRDM2).
assert(HRDm : rk(R :: D ::  nil) >= 1) by (solve_hyps_min HRDeq HRDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQPpD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpD requis par la preuve de (?)AQPpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRPpD requis par la preuve de (?)AQPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)AQRPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRPpD requis par la preuve de (?)AQRPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRPpD requis par la preuve de (?)AQRPpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRPpDm2 : rk(A :: Q :: R :: Pp :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Pp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Pp :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: R :: Pp :: Rp :: D ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HAQRPpDm3 : rk(A :: Q :: R :: Pp :: D :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABQRPpRpDmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 4) by (solve_hyps_min HABQRPpRpDeq HABQRPpRpDm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: Q :: R :: Pp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) (B :: Pp :: Rp :: A :: Q :: R :: Pp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: Q :: R :: Pp :: D :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Pp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpDmtmp;try rewrite HT2 in HABQRPpRpDmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: Q :: R :: Pp :: D :: nil) (Pp :: nil) 4 1 2 HABQRPpRpDmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRD requis par la preuve de (?)AQPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRD requis par la preuve de (?)AQRD pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRD requis par la preuve de (?)AQRD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRDm2 : rk(A :: Q :: R :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAQRDM3 : rk(A :: Q :: R :: D :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Q :: R :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: D :: nil) (A :: Q :: R :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: D :: nil) ((A :: Q :: R :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (D :: nil) (nil) 2 1 0 HAQRMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpD requis par la preuve de (?)AQPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpD requis par la preuve de (?)AQPpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpDm2 : rk(A :: Q :: Pp :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: Q :: R :: Pp :: D ::  de rang :  3 et 4 	 AiB : A :: Q :: D ::  de rang :  3 et 3 	 A : A :: Q :: R :: D ::   de rang : 2 et 3 *)
assert(HAQPpDm3 : rk(A :: Q :: Pp :: D :: nil) >= 3).
{
	assert(HAQRDMtmp : rk(A :: Q :: R :: D :: nil) <= 3) by (solve_hyps_max HAQRDeq HAQRDM3).
	assert(HAQRPpDmtmp : rk(A :: Q :: R :: Pp :: D :: nil) >= 3) by (solve_hyps_min HAQRPpDeq HAQRPpDm3).
	assert(HAQDeq : rk(A :: Q :: D :: nil) = 3) by (apply LAQD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQDmtmp : rk(A :: Q :: D :: nil) >= 3) by (solve_hyps_min HAQDeq HAQDm3).
	assert(Hincl : incl (A :: Q :: D :: nil) (list_inter (A :: Q :: R :: D :: nil) (A :: Q :: Pp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Pp :: D :: nil) (A :: Q :: R :: D :: A :: Q :: Pp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: D :: A :: Q :: Pp :: D :: nil) ((A :: Q :: R :: D :: nil) ++ (A :: Q :: Pp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRPpDmtmp;try rewrite HT2 in HAQRPpDmtmp.
	assert(HT := rule_4 (A :: Q :: R :: D :: nil) (A :: Q :: Pp :: D :: nil) (A :: Q :: D :: nil) 3 3 3 HAQRPpDmtmp HAQDmtmp HAQRDMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpDm4 : rk(A :: Q :: Pp :: D :: nil) >= 4).
{
	assert(HAQRUDeq : rk(A :: Q :: R :: U :: D :: nil) = 3) by (apply LAQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUDMtmp : rk(A :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAQRUDeq HAQRUDM3).
	assert(HAQRPpUDeq : rk(A :: Q :: R :: Pp :: U :: D :: nil) = 4) by (apply LAQRPpUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRPpUDmtmp : rk(A :: Q :: R :: Pp :: U :: D :: nil) >= 4) by (solve_hyps_min HAQRPpUDeq HAQRPpUDm4).
	assert(HAQDeq : rk(A :: Q :: D :: nil) = 3) by (apply LAQD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQDmtmp : rk(A :: Q :: D :: nil) >= 3) by (solve_hyps_min HAQDeq HAQDm3).
	assert(Hincl : incl (A :: Q :: D :: nil) (list_inter (A :: Q :: Pp :: D :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Pp :: U :: D :: nil) (A :: Q :: Pp :: D :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: D :: A :: Q :: R :: U :: D :: nil) ((A :: Q :: Pp :: D :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRPpUDmtmp;try rewrite HT2 in HAQRPpUDmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: D :: nil) (A :: Q :: R :: U :: D :: nil) (A :: Q :: D :: nil) 4 3 3 HAQRPpUDmtmp HAQDmtmp HAQRUDMtmp Hincl);apply HT.
}

assert(HAQPpDM : rk(A :: Q :: Pp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpDm : rk(A :: Q :: Pp :: D ::  nil) >= 1) by (solve_hyps_min HAQPpDeq HAQPpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LARPpD *)
(* dans la couche 0 *)
Lemma LARPpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Pp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARPpUD requis par la preuve de (?)ARPpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ARPpUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm2 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm3 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm4 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARPpUD requis par la preuve de (?)ARPpUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARPpUD requis par la preuve de (?)ARPpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARPpUDm2 : rk(A :: R :: Pp :: U :: D :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Pp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Pp :: U :: D :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Rp :: U :: D ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HARPpUDm3 : rk(A :: R :: Pp :: U :: D :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABRPpRpUDmtmp : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 4) by (solve_hyps_min HABRPpRpUDeq HABRPpRpUDm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: R :: Pp :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Rp :: U :: D :: nil) (B :: Pp :: Rp :: A :: R :: Pp :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: R :: Pp :: U :: D :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: R :: Pp :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpRpUDmtmp;try rewrite HT2 in HABRPpRpUDmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: R :: Pp :: U :: D :: nil) (Pp :: nil) 4 1 2 HABRPpRpUDmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARPpUDm4 : rk(A :: R :: Pp :: U :: D :: nil) >= 4).
{
	assert(HARPpUeq : rk(A :: R :: Pp :: U :: nil) = 4) by (apply LARPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARPpUmtmp : rk(A :: R :: Pp :: U :: nil) >= 4) by (solve_hyps_min HARPpUeq HARPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Pp :: U :: nil) (A :: R :: Pp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Pp :: U :: nil) (A :: R :: Pp :: U :: D :: nil) 4 4 HARPpUmtmp Hcomp Hincl);apply HT.
}

assert(HARPpUDM : rk(A :: R :: Pp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARPpUDm : rk(A :: R :: Pp :: U :: D ::  nil) >= 1) by (solve_hyps_min HARPpUDeq HARPpUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARPpD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Pp :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARPpD requis par la preuve de (?)ARPpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ARPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm2 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm3 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm4 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARPpD requis par la preuve de (?)ARPpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARPpD requis par la preuve de (?)ARPpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARPpDm2 : rk(A :: R :: Pp :: D :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Pp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Pp :: D :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Rp :: D ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HARPpDm3 : rk(A :: R :: Pp :: D :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABRPpRpDmtmp : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 4) by (solve_hyps_min HABRPpRpDeq HABRPpRpDm4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: R :: Pp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Rp :: D :: nil) (B :: Pp :: Rp :: A :: R :: Pp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: R :: Pp :: D :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: R :: Pp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpRpDmtmp;try rewrite HT2 in HABRPpRpDmtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: R :: Pp :: D :: nil) (Pp :: nil) 4 1 2 HABRPpRpDmtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HARPpDm4 : rk(A :: R :: Pp :: D :: nil) >= 4).
{
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HARPpUDeq : rk(A :: R :: Pp :: U :: D :: nil) = 4) by (apply LARPpUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARPpUDmtmp : rk(A :: R :: Pp :: U :: D :: nil) >= 4) by (solve_hyps_min HARPpUDeq HARPpUDm4).
	assert(HRDeq : rk(R :: D :: nil) = 2) by (apply LRD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRDmtmp : rk(R :: D :: nil) >= 2) by (solve_hyps_min HRDeq HRDm2).
	assert(Hincl : incl (R :: D :: nil) (list_inter (A :: R :: Pp :: D :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: Pp :: U :: D :: nil) (A :: R :: Pp :: D :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: R :: Pp :: D :: R :: U :: D :: nil) ((A :: R :: Pp :: D :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HARPpUDmtmp;try rewrite HT2 in HARPpUDmtmp.
	assert(HT := rule_2 (A :: R :: Pp :: D :: nil) (R :: U :: D :: nil) (R :: D :: nil) 4 2 2 HARPpUDmtmp HRDmtmp HRUDMtmp Hincl);apply HT.
}

assert(HARPpDM : rk(A :: R :: Pp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARPpDm : rk(A :: R :: Pp :: D ::  nil) >= 1) by (solve_hyps_min HARPpDeq HARPpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRPpRpD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Pp :: Rp :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpD requis par la preuve de (?)ABRPpRpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm2 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm3 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpDm4 : rk(A :: B :: R :: Pp :: Rp :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABRPpRpDM : rk(A :: B :: R :: Pp :: Rp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRPpRpDm : rk(A :: B :: R :: Pp :: Rp :: D ::  nil) >= 1) by (solve_hyps_min HABRPpRpDeq HABRPpRpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQRPpRpD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: Pp :: Rp :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRpD requis par la preuve de (?)ABQRPpRpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpDm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQRPpRpDM : rk(A :: B :: Q :: R :: Pp :: Rp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRPpRpDm : rk(A :: B :: Q :: R :: Pp :: Rp :: D ::  nil) >= 1) by (solve_hyps_min HABQRPpRpDeq HABQRPpRpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABQUD *)
(* dans la couche 0 *)
Lemma LABQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRUD requis par la preuve de (?)ABQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRUD requis par la preuve de (?)ABQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRUD requis par la preuve de (?)ABQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRUDm2 : rk(A :: B :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRUDm3 : rk(A :: B :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABQRUDM3 : rk(A :: B :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HAQRUDeq : rk(A :: Q :: R :: U :: D :: nil) = 3) by (apply LAQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUDMtmp : rk(A :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAQRUDeq HAQRUDM3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: U :: D :: nil) (B :: Q :: U :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: A :: Q :: R :: U :: D :: nil) ((B :: Q :: U :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Q :: U :: nil) (A :: Q :: R :: U :: D :: nil) (Q :: U :: nil) 2 3 2 HBQUMtmp HAQRUDMtmp HQUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABQRUDM : rk(A :: B :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRUDm : rk(A :: B :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HABQRUDeq HABQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQUD requis par la preuve de (?)ABQUD pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQUD requis par la preuve de (?)ABQUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQUD requis par la preuve de (?)ABQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQUDm2 : rk(A :: B :: Q :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQUDm3 : rk(A :: B :: Q :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQUDM3 : rk(A :: B :: Q :: U :: D :: nil) <= 3).
{
	assert(HABQRUDeq : rk(A :: B :: Q :: R :: U :: D :: nil) = 3) by (apply LABQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUDMtmp : rk(A :: B :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HABQRUDeq HABQRUDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: U :: D :: nil) (A :: B :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Q :: U :: D :: nil) (A :: B :: Q :: R :: U :: D :: nil) 3 3 HABQRUDMtmp Hcomp Hincl);apply HT.
}

assert(HABQUDM : rk(A :: B :: Q :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQUDm : rk(A :: B :: Q :: U :: D ::  nil) >= 1) by (solve_hyps_min HABQUDeq HABQUDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCQUD *)
(* dans la couche 0 *)
Lemma LCQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQRUD requis par la preuve de (?)CQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQRUD requis par la preuve de (?)CQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)BCQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm2 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm3 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQRUD requis par la preuve de (?)BCQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQRUD requis par la preuve de (?)BCQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQRUDm2 : rk(B :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: R :: U :: D :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQRUDm3 : rk(B :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUDmtmp : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQRUDeq HABCQRUDm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: D :: nil) (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUDmtmp;try rewrite HT2 in HABCQRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: D :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQRUDmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQRUD requis par la preuve de (?)CQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQRUD requis par la preuve de (?)CQRUD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQRUDm2 : rk(C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUDmtmp : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQRUDeq HABCQRUDm3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: D :: nil) (A :: B :: C :: Q :: C :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: R :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUDmtmp;try rewrite HT2 in HABCQRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: R :: U :: D :: nil) (C :: Q :: nil) 3 2 3 HABCQRUDmtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQRUDm3 : rk(C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQRUDmtmp : rk(B :: C :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HBCQRUDeq HBCQRUDm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: R :: U :: D :: nil) (B :: Q :: U :: C :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: R :: U :: D :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQRUDmtmp;try rewrite HT2 in HBCQRUDmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: R :: U :: D :: nil) (Q :: U :: nil) 3 2 2 HBCQRUDmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCQRUDM3 : rk(C :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HCQRUeq : rk(C :: Q :: R :: U :: nil) = 3) by (apply LCQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQRUMtmp : rk(C :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HCQRUeq HCQRUM3).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRUeq : rk(R :: U :: nil) = 2) by (apply LRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRUmtmp : rk(R :: U :: nil) >= 2) by (solve_hyps_min HRUeq HRUm2).
	assert(Hincl : incl (R :: U :: nil) (list_inter (C :: Q :: R :: U :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Q :: R :: U :: D :: nil) (C :: Q :: R :: U :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Q :: R :: U :: R :: U :: D :: nil) ((C :: Q :: R :: U :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Q :: R :: U :: nil) (R :: U :: D :: nil) (R :: U :: nil) 3 2 2 HCQRUMtmp HRUDMtmp HRUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCQRUDM : rk(C :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQRUDm : rk(C :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HCQRUDeq HCQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCQUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: Q :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CQUD requis par la preuve de (?)CQUD pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQUD requis par la preuve de (?)CQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQUD requis par la preuve de (?)BCQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm2 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm3 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQUD requis par la preuve de (?)BCQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQUD requis par la preuve de (?)BCQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQUDm2 : rk(B :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: U :: D :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: U :: D ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQUDm3 : rk(B :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQUDmtmp : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQUDeq HABCQUDm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: D :: nil) (A :: B :: C :: Q :: B :: C :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQUDmtmp;try rewrite HT2 in HABCQUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: U :: D :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQUDmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CQUD requis par la preuve de (?)CQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CQUD requis par la preuve de (?)CQUD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: U :: D ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCQUDm2 : rk(C :: Q :: U :: D :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQUDmtmp : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQUDeq HABCQUDm3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: D :: nil) (A :: B :: C :: Q :: C :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: Q :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQUDmtmp;try rewrite HT2 in HABCQUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: Q :: U :: D :: nil) (C :: Q :: nil) 3 2 3 HABCQUDmtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Q :: U :: D ::  de rang :  3 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCQUDm3 : rk(C :: Q :: U :: D :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCQUDmtmp : rk(B :: C :: Q :: U :: D :: nil) >= 3) by (solve_hyps_min HBCQUDeq HBCQUDm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: U :: D :: nil) (B :: Q :: U :: C :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: Q :: U :: D :: nil) ((B :: Q :: U :: nil) ++ (C :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQUDmtmp;try rewrite HT2 in HBCQUDmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: Q :: U :: D :: nil) (Q :: U :: nil) 3 2 2 HBCQUDmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCQUDM3 : rk(C :: Q :: U :: D :: nil) <= 3).
{
	assert(HCQRUDeq : rk(C :: Q :: R :: U :: D :: nil) = 3) by (apply LCQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQRUDMtmp : rk(C :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HCQRUDeq HCQRUDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Q :: U :: D :: nil) (C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Q :: U :: D :: nil) (C :: Q :: R :: U :: D :: nil) 3 3 HCQRUDMtmp Hcomp Hincl);apply HT.
}

assert(HCQUDM : rk(C :: Q :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCQUDm : rk(C :: Q :: U :: D ::  nil) >= 1) by (solve_hyps_min HCQUDeq HCQUDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACQUD *)
(* dans la couche 0 *)
Lemma LACQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQRUD requis par la preuve de (?)ACQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ACQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm2 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm3 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQRUD requis par la preuve de (?)ACQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQRUD requis par la preuve de (?)ACQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQRUDm2 : rk(A :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: R :: U :: D :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQRUDm3 : rk(A :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUDmtmp : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQRUDeq HABCQRUDm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: D :: nil) (A :: B :: C :: Q :: A :: C :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: R :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUDmtmp;try rewrite HT2 in HABCQRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: R :: U :: D :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQRUDmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACQRUDM3 : rk(A :: C :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HACQUeq : rk(A :: C :: Q :: U :: nil) = 3) by (apply LACQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQUMtmp : rk(A :: C :: Q :: U :: nil) <= 3) by (solve_hyps_max HACQUeq HACQUM3).
	assert(HAQRUDeq : rk(A :: Q :: R :: U :: D :: nil) = 3) by (apply LAQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUDMtmp : rk(A :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAQRUDeq HAQRUDM3).
	assert(HAQUeq : rk(A :: Q :: U :: nil) = 3) by (apply LAQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQUmtmp : rk(A :: Q :: U :: nil) >= 3) by (solve_hyps_min HAQUeq HAQUm3).
	assert(Hincl : incl (A :: Q :: U :: nil) (list_inter (A :: C :: Q :: U :: nil) (A :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Q :: R :: U :: D :: nil) (A :: C :: Q :: U :: A :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Q :: U :: A :: Q :: R :: U :: D :: nil) ((A :: C :: Q :: U :: nil) ++ (A :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: Q :: U :: nil) (A :: Q :: R :: U :: D :: nil) (A :: Q :: U :: nil) 3 3 3 HACQUMtmp HAQRUDMtmp HAQUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACQRUDM : rk(A :: C :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQRUDm : rk(A :: C :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HACQRUDeq HACQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQUD requis par la preuve de (?)ACQUD pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ACQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm2 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm3 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQUD requis par la preuve de (?)ACQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQUD requis par la preuve de (?)ACQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQUDm2 : rk(A :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: U :: D :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: U :: D ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACQUDm3 : rk(A :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQUDmtmp : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQUDeq HABCQUDm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: D :: nil) (A :: B :: C :: Q :: A :: C :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: Q :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQUDmtmp;try rewrite HT2 in HABCQUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: Q :: U :: D :: nil) (A :: C :: Q :: nil) 3 3 3 HABCQUDmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQUDM3 : rk(A :: C :: Q :: U :: D :: nil) <= 3).
{
	assert(HACQRUDeq : rk(A :: C :: Q :: R :: U :: D :: nil) = 3) by (apply LACQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQRUDMtmp : rk(A :: C :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HACQRUDeq HACQRUDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: U :: D :: nil) (A :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Q :: U :: D :: nil) (A :: C :: Q :: R :: U :: D :: nil) 3 3 HACQRUDMtmp Hcomp Hincl);apply HT.
}

assert(HACQUDM : rk(A :: C :: Q :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQUDm : rk(A :: C :: Q :: U :: D ::  nil) >= 1) by (solve_hyps_min HACQUDeq HACQUDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCQUD *)
(* dans constructLemma(), requis par LBCQRUD *)
(* dans la couche 0 *)
Lemma LBQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQRUD requis par la preuve de (?)BQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUDm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQRUD requis par la preuve de (?)BQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQRUD requis par la preuve de (?)BQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQRUDm2 : rk(B :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: R :: U :: D :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: P :: Q :: R :: Pp :: Rp :: U :: D ::  de rang :  4 et 4 	 AiB : B :: R ::  de rang :  2 et 2 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HBQRUDm3 : rk(B :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpUDmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4) by (solve_hyps_min HBPQRPpRpUDeq HBPQRPpRpUDm4).
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hincl : incl (B :: R :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) (B :: P :: R :: Pp :: Rp :: B :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: B :: Q :: R :: U :: D :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (B :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpUDmtmp;try rewrite HT2 in HBPQRPpRpUDmtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: R :: U :: D :: nil) (B :: R :: nil) 4 2 3 HBPQRPpRpUDmtmp HBRmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBQRUDM3 : rk(B :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (B :: Q :: U :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: R :: U :: D :: nil) (B :: Q :: U :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: R :: U :: D :: nil) ((B :: Q :: U :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Q :: U :: nil) (R :: U :: D :: nil) (U :: nil) 2 2 1 HBQUMtmp HRUDMtmp HUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBQRUDM : rk(B :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQRUDm : rk(B :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HBQRUDeq HBQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQRUD requis par la preuve de (?)BCQRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)BCQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQRUD requis par la preuve de (?)ABCQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm2 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQRUDm3 : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: R :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQRUD requis par la preuve de (?)BCQRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQRUD requis par la preuve de (?)BCQRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQRUDm2 : rk(B :: C :: Q :: R :: U :: D :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: R :: U :: D :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: R :: U :: D ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQRUDm3 : rk(B :: C :: Q :: R :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQRUDmtmp : rk(A :: B :: C :: Q :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQRUDeq HABCQRUDm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: R :: U :: D :: nil) (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: R :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQRUDmtmp;try rewrite HT2 in HABCQRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: R :: U :: D :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQRUDmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCQRUDM3 : rk(B :: C :: Q :: R :: U :: D :: nil) <= 3).
{
	assert(HCQRUeq : rk(C :: Q :: R :: U :: nil) = 3) by (apply LCQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQRUMtmp : rk(C :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HCQRUeq HCQRUM3).
	assert(HBQRUDeq : rk(B :: Q :: R :: U :: D :: nil) = 3) by (apply LBQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQRUDMtmp : rk(B :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HBQRUDeq HBQRUDM3).
	assert(HQRUeq : rk(Q :: R :: U :: nil) = 3) by (apply LQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRUmtmp : rk(Q :: R :: U :: nil) >= 3) by (solve_hyps_min HQRUeq HQRUm3).
	assert(Hincl : incl (Q :: R :: U :: nil) (list_inter (C :: Q :: R :: U :: nil) (B :: Q :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: R :: U :: D :: nil) (C :: Q :: R :: U :: B :: Q :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Q :: R :: U :: B :: Q :: R :: U :: D :: nil) ((C :: Q :: R :: U :: nil) ++ (B :: Q :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Q :: R :: U :: nil) (B :: Q :: R :: U :: D :: nil) (Q :: R :: U :: nil) 3 3 3 HCQRUMtmp HBQRUDMtmp HQRUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCQRUDM : rk(B :: C :: Q :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQRUDm : rk(B :: C :: Q :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HBCQRUDeq HBCQRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCQUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: Q :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCQUD requis par la preuve de (?)BCQUD pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQUD requis par la preuve de (?)BCQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQUD requis par la preuve de (?)ABCQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm2 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDm3 : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCQUD requis par la preuve de (?)BCQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCQUD requis par la preuve de (?)BCQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCQUDm2 : rk(B :: C :: Q :: U :: D :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Q :: U :: D :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: U :: D ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCQUDm3 : rk(B :: C :: Q :: U :: D :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCQUDmtmp : rk(A :: B :: C :: Q :: U :: D :: nil) >= 3) by (solve_hyps_min HABCQUDeq HABCQUDm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: D :: nil) (A :: B :: C :: Q :: B :: C :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: Q :: U :: D :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQUDmtmp;try rewrite HT2 in HABCQUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: Q :: U :: D :: nil) (B :: C :: Q :: nil) 3 3 3 HABCQUDmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCQUDM3 : rk(B :: C :: Q :: U :: D :: nil) <= 3).
{
	assert(HBCQRUDeq : rk(B :: C :: Q :: R :: U :: D :: nil) = 3) by (apply LBCQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQRUDMtmp : rk(B :: C :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HBCQRUDeq HBCQRUDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: U :: D :: nil) (B :: C :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: Q :: U :: D :: nil) (B :: C :: Q :: R :: U :: D :: nil) 3 3 HBCQRUDMtmp Hcomp Hincl);apply HT.
}

assert(HBCQUDM : rk(B :: C :: Q :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQUDm : rk(B :: C :: Q :: U :: D ::  nil) >= 1) by (solve_hyps_min HBCQUDeq HBCQUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQUD requis par la preuve de (?)APQUD pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQUD requis par la preuve de (?)APQUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQUD requis par la preuve de (?)APQUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUDm2 : rk(A :: P :: Q :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: D ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQUDm3 : rk(A :: P :: Q :: U :: D :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDeq HAPQRQpRpUDm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: D :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDmtmp;try rewrite HT2 in HAPQRQpRpUDmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: D :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpUDmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUDM3 : rk(A :: P :: Q :: U :: D :: nil) <= 3).
{
	assert(HAPQRUDeq : rk(A :: P :: Q :: R :: U :: D :: nil) = 3) by (apply LAPQRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRUDMtmp : rk(A :: P :: Q :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HAPQRUDeq HAPQRUDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: U :: D :: nil) (A :: P :: Q :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: P :: Q :: U :: D :: nil) (A :: P :: Q :: R :: U :: D :: nil) 3 3 HAPQRUDMtmp Hcomp Hincl);apply HT.
}

assert(HAPQUDM : rk(A :: P :: Q :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQUDm : rk(A :: P :: Q :: U :: D ::  nil) >= 1) by (solve_hyps_min HAPQUDeq HAPQUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRUD requis par la preuve de (?)ABRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRUD requis par la preuve de (?)ABRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRUD requis par la preuve de (?)ABRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRUDm2 : rk(A :: B :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRUDm3 : rk(A :: B :: R :: U :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: U :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HABRUDM3 : rk(A :: B :: R :: U :: D :: nil) <= 3).
{
	assert(HABRUeq : rk(A :: B :: R :: U :: nil) = 3) by (apply LABRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRUMtmp : rk(A :: B :: R :: U :: nil) <= 3) by (solve_hyps_max HABRUeq HABRUM3).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRUeq : rk(R :: U :: nil) = 2) by (apply LRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRUmtmp : rk(R :: U :: nil) >= 2) by (solve_hyps_min HRUeq HRUm2).
	assert(Hincl : incl (R :: U :: nil) (list_inter (A :: B :: R :: U :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: U :: D :: nil) (A :: B :: R :: U :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: R :: U :: R :: U :: D :: nil) ((A :: B :: R :: U :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: R :: U :: nil) (R :: U :: D :: nil) (R :: U :: nil) 3 2 2 HABRUMtmp HRUDMtmp HRUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABRUDM : rk(A :: B :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRUDm : rk(A :: B :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HABRUDeq HABRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCRUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: R :: U :: D ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCRUD requis par la preuve de (?)BCRUD pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCRUD requis par la preuve de (?)BCRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCRUD requis par la preuve de (?)ABCRUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCRUD requis par la preuve de (?)ABCRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRUDm2 : rk(A :: B :: C :: R :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: R :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCRUDm3 : rk(A :: B :: C :: R :: U :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: R :: U :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCRUD requis par la preuve de (?)BCRUD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCRUD requis par la preuve de (?)BCRUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCRUDm2 : rk(B :: C :: R :: U :: D :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: R :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: R :: U :: D :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: R :: U :: D ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCRUDm3 : rk(B :: C :: R :: U :: D :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCRUDmtmp : rk(A :: B :: C :: R :: U :: D :: nil) >= 3) by (solve_hyps_min HABCRUDeq HABCRUDm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: R :: U :: D :: nil) (A :: B :: C :: R :: B :: C :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: R :: U :: D :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCRUDmtmp;try rewrite HT2 in HABCRUDmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: R :: U :: D :: nil) (B :: C :: R :: nil) 3 3 3 HABCRUDmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBCRUDM3 : rk(B :: C :: R :: U :: D :: nil) <= 3).
{
	assert(HBCRUeq : rk(B :: C :: R :: U :: nil) = 3) by (apply LBCRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRUMtmp : rk(B :: C :: R :: U :: nil) <= 3) by (solve_hyps_max HBCRUeq HBCRUM3).
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRUeq : rk(R :: U :: nil) = 2) by (apply LRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRUmtmp : rk(R :: U :: nil) >= 2) by (solve_hyps_min HRUeq HRUm2).
	assert(Hincl : incl (R :: U :: nil) (list_inter (B :: C :: R :: U :: nil) (R :: U :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: R :: U :: D :: nil) (B :: C :: R :: U :: R :: U :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: R :: U :: R :: U :: D :: nil) ((B :: C :: R :: U :: nil) ++ (R :: U :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: R :: U :: nil) (R :: U :: D :: nil) (R :: U :: nil) 3 2 2 HBCRUMtmp HRUDMtmp HRUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCRUDM : rk(B :: C :: R :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCRUDm : rk(B :: C :: R :: U :: D ::  nil) >= 1) by (solve_hyps_min HBCRUDeq HBCRUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRPpRpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Pp :: Rp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpRpUD requis par la preuve de (?)ABRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm2 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm3 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpRpUDm4 : rk(A :: B :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABRPpRpUDM : rk(A :: B :: R :: Pp :: Rp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRPpRpUDm : rk(A :: B :: R :: Pp :: Rp :: U :: D ::  nil) >= 1) by (solve_hyps_min HABRPpRpUDeq HABRPpRpUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQRPpRpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRPpRpUD requis par la preuve de (?)ABQRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm2 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm3 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRPpRpUDm4 : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: Q :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQRPpRpUDM : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRPpRpUDm : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: D ::  nil) >= 1) by (solve_hyps_min HABQRPpRpUDeq HABQRPpRpUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPQRPpRpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUD requis par la preuve de (?)BPQRPpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUDm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPQRPpRpUDM : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPQRPpRpUDm : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D ::  nil) >= 1) by (solve_hyps_min HBPQRPpRpUDeq HBPQRPpRpUDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpRpUD : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUD requis par la preuve de (?)APQRQpRpUD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUDM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUDm : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUDeq HAPQRQpRpUDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LQUDp *)
(* dans constructLemma(), requis par LQRpUUpDp *)
(* dans constructLemma(), requis par LQQpRpUUpDp *)
(* dans constructLemma(), requis par LQPpQpRpUUpDp *)
(* dans constructLemma(), requis par LBQPpQpRpUUpDp *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDp requis par la preuve de (?)ABQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDp requis par la preuve de (?)ABQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDp requis par la preuve de (?)ABQPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpm2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpm3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDpm4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpDpM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpDpm : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpDpeq HABQPpQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDp requis par la preuve de (?)BQPpQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDp requis par la preuve de (?)BQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDp requis par la preuve de (?)BQPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpm2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpm3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDpm4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDpeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) = 4) by (apply LABQPpQpRpUUpDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpDpmtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDpeq HABQPpQpRpUUpDpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDpmtmp;try rewrite HT2 in HABQPpQpRpUUpDpmtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDpmtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpDpM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpDpm : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpDpeq HBQPpQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUUpDp requis par la preuve de (?)QPpQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUUpDp requis par la preuve de (?)QPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)QPpQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpDpm4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUUpDp requis par la preuve de (?)QPpQpRpUUpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUUpDpm2 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUUpDpmtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUUpDpeq HABCQPpQpRpUUpDpm4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpDpmtmp;try rewrite HT2 in HABCQPpQpRpUUpDpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUUpDpmtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUUpDpm3 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUUpDpm4 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpDpeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) = 4) by (apply LBQPpQpRpUUpDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpDpmtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDpeq HBQPpQpRpUUpDpm4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDpmtmp;try rewrite HT2 in HBQPpQpRpUUpDpmtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUUpDpmtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUUpDpM : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUUpDpm : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUUpDpeq HQPpQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUUpDp requis par la preuve de (?)QQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)QQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm2 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm3 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm4 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUUpDp requis par la preuve de (?)QQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUUpDp requis par la preuve de (?)QQpRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUUpDp requis par la preuve de (?)PQRPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUUpDp requis par la preuve de (?)PQRPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUUpDpm3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUUpDpm4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUUpDp requis par la preuve de (?)QQpRpUUpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDpm2 : rk(Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUUpDpmtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUUpDpeq HPQRPpQpRpUUpDpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUUpDpmtmp;try rewrite HT2 in HPQRPpQpRpUUpDpmtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUUpDpmtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQQpRpUUpDpm3 : rk(Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQQpRpUUpDpmtmp : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HAPQQpRpUUpDpeq HAPQQpRpUUpDpm4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) ((A :: P :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQQpRpUUpDpmtmp;try rewrite HT2 in HAPQQpRpUUpDpmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil) (U :: nil) 4 1 2 HAPQQpRpUUpDpmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Q :: Rp :: U ::  de rang :  3 et 3 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDpm4 : rk(Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUUpDpeq : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) = 4) by (apply LQPpQpRpUUpDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpQpRpUUpDpmtmp : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HQPpQpRpUUpDpeq HQPpQpRpUUpDpm4).
	assert(HQRpUeq : rk(Q :: Rp :: U :: nil) = 3) by (apply LQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUmtmp : rk(Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HQRpUeq HQRpUm3).
	assert(Hincl : incl (Q :: Rp :: U :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUUpDpmtmp;try rewrite HT2 in HQPpQpRpUUpDpmtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: Dp :: nil) (Q :: Rp :: U :: nil) 4 3 3 HQPpQpRpUUpDpmtmp HQRpUmtmp HQPpRpUMtmp Hincl); apply HT.
}

assert(HQQpRpUUpDpM : rk(Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUUpDpm : rk(Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HQQpRpUUpDpeq HQQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRpUUpDp requis par la preuve de (?)QRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQRpUUpDp requis par la preuve de (?)QRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BQRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUUpDpm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUUpDpm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUUpDpm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQRpUUpDp requis par la preuve de (?)BQRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQRpUUpDp requis par la preuve de (?)BQRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQRpUUpDpm2 : rk(B :: Q :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Rp :: U :: Up :: Dp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HBQRpUUpDpm3 : rk(B :: Q :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpUUpDpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpUUpDpeq HBPQRPpRpUUpDpm4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) (B :: P :: R :: Pp :: Rp :: B :: Q :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: B :: Q :: Rp :: U :: Up :: Dp :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (B :: Q :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpUUpDpmtmp;try rewrite HT2 in HBPQRPpRpUUpDpmtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (B :: Q :: Rp :: U :: Up :: Dp :: nil) (B :: Rp :: nil) 4 2 3 HBPQRPpRpUUpDpmtmp HBRpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRpUUpDp requis par la preuve de (?)QRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpRpUUpDp requis par la preuve de (?)QRpUUpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpUUpDp requis par la preuve de (?)PQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpUUpDp requis par la preuve de (?)PQRPpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUUpDpm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUUpDpm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRpUUpDp requis par la preuve de (?)QRpUUpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQRpUUpDpm2 : rk(Q :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpRpUUpDpmtmp : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HPQRPpRpUUpDpeq HPQRPpRpUUpDpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) (P :: R :: Pp :: Rp :: Q :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Rp :: U :: Up :: Dp :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpRpUUpDpmtmp;try rewrite HT2 in HPQRPpRpUUpDpmtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Rp :: U :: Up :: Dp :: nil) (Rp :: nil) 4 1 3 HPQRPpRpUUpDpmtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: Q :: Rp :: U :: Up :: Dp ::  de rang :  3 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HQRpUUpDpm3 : rk(Q :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBQRpUUpDpmtmp : rk(B :: Q :: Rp :: U :: Up :: Dp :: nil) >= 3) by (solve_hyps_min HBQRpUUpDpeq HBQRpUUpDpm3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (Q :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Rp :: U :: Up :: Dp :: nil) (B :: Q :: U :: Q :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: Rp :: U :: Up :: Dp :: nil) ((B :: Q :: U :: nil) ++ (Q :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQRpUUpDpmtmp;try rewrite HT2 in HBQRpUUpDpmtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (Q :: Rp :: U :: Up :: Dp :: nil) (Q :: U :: nil) 3 2 2 HBQRpUUpDpmtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: U :: Up :: Dp ::  de rang :  4 et 4 	 AiB : Q :: U :: Up ::  de rang :  3 et 3 	 A : Q :: Qp :: U :: Up ::   de rang : 3 et 3 *)
assert(HQRpUUpDpm4 : rk(Q :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HQQpUUpeq : rk(Q :: Qp :: U :: Up :: nil) = 3) by (apply LQQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpUUpMtmp : rk(Q :: Qp :: U :: Up :: nil) <= 3) by (solve_hyps_max HQQpUUpeq HQQpUUpM3).
	assert(HQQpRpUUpDpeq : rk(Q :: Qp :: Rp :: U :: Up :: Dp :: nil) = 4) by (apply LQQpRpUUpDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpRpUUpDpmtmp : rk(Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HQQpRpUUpDpeq HQQpRpUUpDpm4).
	assert(HQUUpeq : rk(Q :: U :: Up :: nil) = 3) by (apply LQUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUUpmtmp : rk(Q :: U :: Up :: nil) >= 3) by (solve_hyps_min HQUUpeq HQUUpm3).
	assert(Hincl : incl (Q :: U :: Up :: nil) (list_inter (Q :: Qp :: U :: Up :: nil) (Q :: Rp :: U :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: U :: Up :: Dp :: nil) (Q :: Qp :: U :: Up :: Q :: Rp :: U :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: U :: Up :: Q :: Rp :: U :: Up :: Dp :: nil) ((Q :: Qp :: U :: Up :: nil) ++ (Q :: Rp :: U :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUUpDpmtmp;try rewrite HT2 in HQQpRpUUpDpmtmp.
	assert(HT := rule_4 (Q :: Qp :: U :: Up :: nil) (Q :: Rp :: U :: Up :: Dp :: nil) (Q :: U :: Up :: nil) 4 3 3 HQQpRpUUpDpmtmp HQUUpmtmp HQQpUUpMtmp Hincl); apply HT.
}

assert(HQRpUUpDpM : rk(Q :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRpUUpDpm : rk(Q :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HQRpUUpDpeq HQRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQUDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: U :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QUDp requis par la preuve de (?)QUDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQUDp requis par la preuve de (?)QUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQUDp requis par la preuve de (?)APQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQUDp requis par la preuve de (?)APQUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUDpm2 : rk(A :: P :: Q :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Dp ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQUDpm3 : rk(A :: P :: Q :: U :: Dp :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDpeq HAPQRQpRpUDpm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Dp :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: U :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDpmtmp;try rewrite HT2 in HAPQRQpRpUDpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Dp :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpUDpmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QUDp requis par la preuve de (?)QUDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: U :: Dp ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQUDpm2 : rk(Q :: U :: Dp :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQUDpmtmp : rk(A :: P :: Q :: U :: Dp :: nil) >= 3) by (solve_hyps_min HAPQUDpeq HAPQUDpm3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: U :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: Dp :: nil) (A :: P :: U :: Q :: U :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: U :: Dp :: nil) ((A :: P :: U :: nil) ++ (Q :: U :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQUDpmtmp;try rewrite HT2 in HAPQUDpmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: U :: Dp :: nil) (U :: nil) 3 1 2 HAPQUDpmtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HQUDpm3 : rk(Q :: U :: Dp :: nil) >= 3).
{
	assert(HRpUpDpMtmp : rk(Rp :: Up :: Dp :: nil) <= 2) by (solve_hyps_max HRpUpDpeq HRpUpDpM2).
	assert(HQRpUUpDpeq : rk(Q :: Rp :: U :: Up :: Dp :: nil) = 4) by (apply LQRpUUpDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUUpDpmtmp : rk(Q :: Rp :: U :: Up :: Dp :: nil) >= 4) by (solve_hyps_min HQRpUUpDpeq HQRpUUpDpm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Q :: U :: Dp :: nil) (Rp :: Up :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Rp :: U :: Up :: Dp :: nil) (Q :: U :: Dp :: Rp :: Up :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: U :: Dp :: Rp :: Up :: Dp :: nil) ((Q :: U :: Dp :: nil) ++ (Rp :: Up :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRpUUpDpmtmp;try rewrite HT2 in HQRpUUpDpmtmp.
	assert(HT := rule_2 (Q :: U :: Dp :: nil) (Rp :: Up :: Dp :: nil) (Dp :: nil) 4 1 2 HQRpUUpDpmtmp HDpmtmp HRpUpDpMtmp Hincl);apply HT.
}

assert(HQUDpM : rk(Q :: U :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HQUDpeq HQUDpM3).
assert(HQUDpm : rk(Q :: U :: Dp ::  nil) >= 1) by (solve_hyps_min HQUDpeq HQUDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQUDp *)
(* dans la couche 0 *)
Lemma LABCQUDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: U :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQUDDp requis par la preuve de (?)ABCQUDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQUDDp requis par la preuve de (?)ABCQUDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQUDDp requis par la preuve de (?)ABCQUDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDDpm2 : rk(A :: B :: C :: Q :: U :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQUDDpm3 : rk(A :: B :: C :: Q :: U :: D :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCQUDDpM3 : rk(A :: B :: C :: Q :: U :: D :: Dp :: nil) <= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Q :: U :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: U :: D :: Dp :: nil) (B :: Q :: U :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: A :: B :: C :: D :: Dp :: nil) ((B :: Q :: U :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Q :: U :: nil) (A :: B :: C :: D :: Dp :: nil) (B :: nil) 2 2 1 HBQUMtmp HABCDDpMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCQUDDpM : rk(A :: B :: C :: Q :: U :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQUDDpm : rk(A :: B :: C :: Q :: U :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCQUDDpeq HABCQUDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQUDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: U :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQUDp requis par la preuve de (?)AQUDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQUDp requis par la preuve de (?)AQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQUDp requis par la preuve de (?)APQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQUDp requis par la preuve de (?)APQUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQUDpm2 : rk(A :: P :: Q :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Dp ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQUDpm3 : rk(A :: P :: Q :: U :: Dp :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDpeq HAPQRQpRpUDpm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: U :: Dp :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: U :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDpmtmp;try rewrite HT2 in HAPQRQpRpUDpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: U :: Dp :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpUDpmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQUDp requis par la preuve de (?)AQUDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQUDp requis par la preuve de (?)AQUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQUDpm2 : rk(A :: Q :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: U :: Dp ::  de rang :  3 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQUDpm3 : rk(A :: Q :: U :: Dp :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQUDpmtmp : rk(A :: P :: Q :: U :: Dp :: nil) >= 3) by (solve_hyps_min HAPQUDpeq HAPQUDpm3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: U :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: U :: Dp :: nil) (A :: P :: U :: A :: Q :: U :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: U :: Dp :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: U :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQUDpmtmp;try rewrite HT2 in HAPQUDpmtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: U :: Dp :: nil) (A :: U :: nil) 3 2 2 HAPQUDpmtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQUDpM3 : rk(A :: Q :: U :: Dp :: nil) <= 3).
{
	assert(HABCQUDDpeq : rk(A :: B :: C :: Q :: U :: D :: Dp :: nil) = 3) by (apply LABCQUDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQUDDpMtmp : rk(A :: B :: C :: Q :: U :: D :: Dp :: nil) <= 3) by (solve_hyps_max HABCQUDDpeq HABCQUDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: U :: Dp :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Q :: U :: Dp :: nil) (A :: B :: C :: Q :: U :: D :: Dp :: nil) 3 3 HABCQUDDpMtmp Hcomp Hincl);apply HT.
}

assert(HAQUDpM : rk(A :: Q :: U :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQUDpm : rk(A :: Q :: U :: Dp ::  nil) >= 1) by (solve_hyps_min HAQUDpeq HAQUDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpRpUDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDp requis par la preuve de (?)APQRQpRpUDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUDpM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUDpm : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Dp ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUDpeq HAPQRQpRpUDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpRpUUpDp requis par la preuve de (?)PQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpRpUUpDp requis par la preuve de (?)PQRPpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpRpUUpDpm3 : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpRpUUpDpm4 : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpRpUUpDpM : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpRpUUpDpm : rk(P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HPQRPpRpUUpDpeq HPQRPpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPQRPpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUUpDp requis par la preuve de (?)BPQRPpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUUpDpm2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUUpDpm3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUUpDpm4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPQRPpRpUUpDpM : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPQRPpRpUUpDpm : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HBPQRPpRpUUpDpeq HBPQRPpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUUpDp requis par la preuve de (?)APQQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm2 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm3 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDpm4 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQQpRpUUpDpM : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQQpRpUUpDpm : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HAPQQpRpUUpDpeq HAPQQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUpDp requis par la preuve de (?)ABCQPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDpm2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDpm3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpDpm4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUUpDpM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUUpDpm : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUUpDpeq HABCQPpQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUUpDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUUpDp requis par la preuve de (?)PQRPpQpRpUUpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUUpDp requis par la preuve de (?)PQRPpQpRpUUpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUUpDpm3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUUpDpm4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUUpDpM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUUpDpm : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: Dp ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUUpDpeq HPQRPpQpRpUUpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADDp requis par la preuve de (?)ADDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQDDp requis par la preuve de (?)ADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQDDp requis par la preuve de (?)AQDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQDDp requis par la preuve de (?)ABQDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQDDp requis par la preuve de (?)ABQDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQDDpm2 : rk(A :: B :: Q :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQDDpm3 : rk(A :: B :: Q :: D :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: D :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQDDp requis par la preuve de (?)AQDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQDDp requis par la preuve de (?)AQDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQDDpm2 : rk(A :: Q :: D :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: D :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: D :: Dp ::  de rang :  3 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: B :: D ::   de rang : 2 et 2 *)
assert(HAQDDpm3 : rk(A :: Q :: D :: Dp :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 2) by (apply LABD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 2) by (solve_hyps_max HABDeq HABDM2).
	assert(HABQDDpmtmp : rk(A :: B :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HABQDDpeq HABQDDpm3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: B :: D :: nil) (A :: Q :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: D :: Dp :: nil) (A :: B :: D :: A :: Q :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: A :: Q :: D :: Dp :: nil) ((A :: B :: D :: nil) ++ (A :: Q :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQDDpmtmp;try rewrite HT2 in HABQDDpmtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (A :: Q :: D :: Dp :: nil) (A :: D :: nil) 3 2 2 HABQDDpmtmp HADmtmp HABDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQD requis par la preuve de (?)ADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQD requis par la preuve de (?)AQD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQDm2 : rk(A :: Q :: D :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: D :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADDp requis par la preuve de (?)ADDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: Q :: D :: Dp ::  de rang :  3 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: Q :: D ::   de rang : 2 et 3 *)
assert(HADDpm2 : rk(A :: D :: Dp :: nil) >= 2).
{
	assert(HAQDMtmp : rk(A :: Q :: D :: nil) <= 3) by (solve_hyps_max HAQDeq HAQDM3).
	assert(HAQDDpmtmp : rk(A :: Q :: D :: Dp :: nil) >= 3) by (solve_hyps_min HAQDDpeq HAQDDpm3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: Q :: D :: nil) (A :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: D :: Dp :: nil) (A :: Q :: D :: A :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: D :: A :: D :: Dp :: nil) ((A :: Q :: D :: nil) ++ (A :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQDDpmtmp;try rewrite HT2 in HAQDDpmtmp.
	assert(HT := rule_4 (A :: Q :: D :: nil) (A :: D :: Dp :: nil) (A :: D :: nil) 3 2 3 HAQDDpmtmp HADmtmp HAQDMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADDpM2 : rk(A :: D :: Dp :: nil) <= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil) 2 2 HABCDDpMtmp Hcomp Hincl);apply HT.
}

assert(HADDpM : rk(A :: D :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADDpeq HADDpM3).
assert(HADDpm : rk(A :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HADDpeq HADDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDDp *)
(* dans constructLemma(), requis par LBQQpUDDpOo *)
(* dans constructLemma(), requis par LABQQpUDDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUDDpOo requis par la preuve de (?)ABQPpQpRpUDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUDDpOo requis par la preuve de (?)ABQPpQpRpUDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUDDpOo requis par la preuve de (?)ABQPpQpRpUDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUDDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUDDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUDDpOoeq HABQPpQpRpUDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQQpUDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQQpUDDpOo requis par la preuve de (?)ABQQpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQQpUDDpOo requis par la preuve de (?)ABQQpUDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQQpUDDpOo requis par la preuve de (?)ABQQpUDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpUDDpOom2 : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpUDDpOom3 : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Qp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQQpUDDpOom4 : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpUDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUDDpOoeq HABQPpQpRpUDDpOom4).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hincl : incl (A :: B :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUDDpOomtmp;try rewrite HT2 in HABQPpQpRpUDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) (A :: B :: Qp :: nil) 4 3 3 HABQPpQpRpUDDpOomtmp HABQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQQpUDDpOoM : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQQpUDDpOom : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQQpUDDpOoeq HABQQpUDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQQpUDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQQpUDDpOo requis par la preuve de (?)BQQpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQQpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUDDpOoeq HABQPpQpRpUDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUDDpOomtmp;try rewrite HT2 in HABQPpQpRpUDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQQpUDDpOo requis par la preuve de (?)BQQpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQQpUDDpOo requis par la preuve de (?)BQQpUDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQQpUDDpOom2 : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQQpUDDpOom3 : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUDDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUDDpOoeq HBQPpQpRpUDDpOom4).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUDDpOomtmp;try rewrite HT2 in HBQPpQpRpUDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) (B :: Qp :: nil) 4 2 3 HBQPpQpRpUDDpOomtmp HBQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Qp :: U :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: U :: Dp ::  de rang :  3 et 3 	 A : A :: Q :: U :: Dp ::   de rang : 3 et 3 *)
assert(HBQQpUDDpOom4 : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQUDpeq : rk(A :: Q :: U :: Dp :: nil) = 3) by (apply LAQUDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQUDpMtmp : rk(A :: Q :: U :: Dp :: nil) <= 3) by (solve_hyps_max HAQUDpeq HAQUDpM3).
	assert(HABQQpUDDpOoeq : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) = 4) by (apply LABQQpUDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQQpUDDpOomtmp : rk(A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQQpUDDpOoeq HABQQpUDDpOom4).
	assert(HQUDpeq : rk(Q :: U :: Dp :: nil) = 3) by (apply LQUDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUDpmtmp : rk(Q :: U :: Dp :: nil) >= 3) by (solve_hyps_min HQUDpeq HQUDpm3).
	assert(Hincl : incl (Q :: U :: Dp :: nil) (list_inter (A :: Q :: U :: Dp :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) (A :: Q :: U :: Dp :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: U :: Dp :: B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) ((A :: Q :: U :: Dp :: nil) ++ (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQQpUDDpOomtmp;try rewrite HT2 in HABQQpUDDpOomtmp.
	assert(HT := rule_4 (A :: Q :: U :: Dp :: nil) (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) (Q :: U :: Dp :: nil) 4 3 3 HABQQpUDDpOomtmp HQUDpmtmp HAQUDpMtmp Hincl); apply HT.
}

assert(HBQQpUDDpOoM : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQQpUDDpOom : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQQpUDDpOoeq HBQQpUDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDDp *)
(* dans la couche 0 *)
Lemma LBQQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Qp :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQQpUOo requis par la preuve de (?)BQQpUOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUOoeq HABQPpQpRpUOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUOomtmp;try rewrite HT2 in HABQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQQpUOo requis par la preuve de (?)BQQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQQpUOo requis par la preuve de (?)BQQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQQpUOom2 : rk(B :: Q :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Qp :: U :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQQpUOom3 : rk(B :: Q :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUOoeq HBQPpQpRpUOom4).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: B :: Q :: Qp :: U :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUOomtmp;try rewrite HT2 in HBQPpQpRpUOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (B :: Q :: Qp :: U :: Oo :: nil) (B :: Qp :: nil) 4 2 3 HBQPpQpRpUOomtmp HBQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBQQpUOoM3 : rk(B :: Q :: Qp :: U :: Oo :: nil) <= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (B :: Q :: U :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: U :: Oo :: nil) (B :: Q :: U :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: Q :: Qp :: Oo :: nil) ((B :: Q :: U :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Q :: U :: nil) (Q :: Qp :: Oo :: nil) (Q :: nil) 2 2 1 HBQUMtmp HQQpOoMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBQQpUOoM : rk(B :: Q :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQQpUOom : rk(B :: Q :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBQQpUOoeq HBQQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: D :: Dp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BDDp requis par la preuve de (?)BDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDDp requis par la preuve de (?)BDDp pour la règle 6  *)
(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBDDpM2 : rk(B :: D :: Dp :: nil) <= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil) 2 2 HABCDDpMtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HBDDpm2 : rk(B :: D :: Dp :: nil) >= 2).
{
	assert(HBQQpUOoeq : rk(B :: Q :: Qp :: U :: Oo :: nil) = 3) by (apply LBQQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUOoMtmp : rk(B :: Q :: Qp :: U :: Oo :: nil) <= 3) by (solve_hyps_max HBQQpUOoeq HBQQpUOoM3).
	assert(HBQQpUDDpOoeq : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) = 4) by (apply LBQQpUDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUDDpOomtmp : rk(B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQQpUDDpOoeq HBQQpUDDpOom4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: D :: Dp :: nil) (B :: Q :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Qp :: U :: D :: Dp :: Oo :: nil) (B :: D :: Dp :: B :: Q :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: Dp :: B :: Q :: Qp :: U :: Oo :: nil) ((B :: D :: Dp :: nil) ++ (B :: Q :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQQpUDDpOomtmp;try rewrite HT2 in HBQQpUDDpOomtmp.
	assert(HT := rule_2 (B :: D :: Dp :: nil) (B :: Q :: Qp :: U :: Oo :: nil) (B :: nil) 4 1 3 HBQQpUDDpOomtmp HBmtmp HBQQpUOoMtmp Hincl);apply HT.
}

assert(HBDDpM : rk(B :: D :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDDpeq HBDDpM3).
assert(HBDDpm : rk(B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HBDDpeq HBDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDDp requis par la preuve de (?)ABDDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDDp requis par la preuve de (?)ABDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDDpm2 : rk(A :: B :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDDpM2 : rk(A :: B :: D :: Dp :: nil) <= 2).
{
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: D :: Dp :: nil) (A :: B :: C :: D :: Dp :: nil) 2 2 HABCDDpMtmp Hcomp Hincl);apply HT.
}

assert(HABDDpM : rk(A :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDDpm : rk(A :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABDDpeq HABDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPQDDp *)
(* dans la couche 0 *)
Lemma LABCPQDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: P :: Q :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQDDp requis par la preuve de (?)ABCPQDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQDDp requis par la preuve de (?)ABCPQDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQDDp requis par la preuve de (?)ABCPQDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQDDpm2 : rk(A :: B :: C :: P :: Q :: D :: Dp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQDDpm3 : rk(A :: B :: C :: P :: Q :: D :: Dp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et -4*)
assert(HABCPQDDpM3 : rk(A :: B :: C :: P :: Q :: D :: Dp :: nil) <= 3).
{
	assert(HABPQeq : rk(A :: B :: P :: Q :: nil) = 3) by (apply LABPQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQMtmp : rk(A :: B :: P :: Q :: nil) <= 3) by (solve_hyps_max HABPQeq HABPQM3).
	assert(HABCDDpMtmp : rk(A :: B :: C :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABCDDpeq HABCDDpM2).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: P :: Q :: nil) (A :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: D :: Dp :: nil) (A :: B :: P :: Q :: A :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: A :: B :: C :: D :: Dp :: nil) ((A :: B :: P :: Q :: nil) ++ (A :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: P :: Q :: nil) (A :: B :: C :: D :: Dp :: nil) (A :: B :: nil) 3 2 2 HABPQMtmp HABCDDpMtmp HABmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCPQDDpM : rk(A :: B :: C :: P :: Q :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCPQDDpm : rk(A :: B :: C :: P :: Q :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABCPQDDpeq HABCPQDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: D :: Dp ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQDDp requis par la preuve de (?)APQDDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpDDpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpDDpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpDDpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQDDp requis par la preuve de (?)APQDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQDDp requis par la preuve de (?)APQDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQDDpm2 : rk(A :: P :: Q :: D :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: D :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: D :: Dp ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQDDpm3 : rk(A :: P :: Q :: D :: Dp :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpDDpmtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HAPQRQpRpDDpeq HAPQRQpRpDDpm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: D :: Dp :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpDDpmtmp;try rewrite HT2 in HAPQRQpRpDDpmtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: D :: Dp :: nil) (A :: Q :: nil) 4 2 3 HAPQRQpRpDDpmtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQDDpM3 : rk(A :: P :: Q :: D :: Dp :: nil) <= 3).
{
	assert(HABCPQDDpeq : rk(A :: B :: C :: P :: Q :: D :: Dp :: nil) = 3) by (apply LABCPQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCPQDDpMtmp : rk(A :: B :: C :: P :: Q :: D :: Dp :: nil) <= 3) by (solve_hyps_max HABCPQDDpeq HABCPQDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: D :: Dp :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: P :: Q :: D :: Dp :: nil) (A :: B :: C :: P :: Q :: D :: Dp :: nil) 3 3 HABCPQDDpMtmp Hcomp Hincl);apply HT.
}

assert(HAPQDDpM : rk(A :: P :: Q :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQDDpm : rk(A :: P :: Q :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HAPQDDpeq HAPQDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpRpDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpDDp requis par la preuve de (?)APQRQpRpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpDDpm2 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpDDpm3 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpDDpm4 : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: D :: Dp :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpDDpM : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpDDpm : rk(A :: P :: Q :: R :: Qp :: Rp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpDDpeq HAPQRQpRpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBOo *)
(* dans constructLemma(), requis par LBCPQPpOo *)
(* dans la couche 0 *)
Lemma LBCPQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)BCPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)BCPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)BCPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpUDOom2 : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpUDOom3 : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpUDOom4 : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HCQPpUeq : rk(C :: Q :: Pp :: U :: nil) = 4) by (apply LCQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpUmtmp : rk(C :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HCQPpUeq HCQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (C :: Q :: Pp :: U :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Q :: Pp :: U :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HCQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HBCPQPpUDOoM : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPQPpUDOom : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPQPpUDOoeq HBCPQPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCPQPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: Q :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BCPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BCPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BCPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpOom2 : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpOom3 : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : B :: C :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HBCPQPpOom4 : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 4).
{
	assert(HBCQUDeq : rk(B :: C :: Q :: U :: D :: nil) = 3) by (apply LBCQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQUDMtmp : rk(B :: C :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HBCQUDeq HBCQUDM3).
	assert(HBCPQPpUDOoeq : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LBCPQPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPQPpUDOomtmp : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBCPQPpUDOoeq HBCPQPpUDOom4).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (B :: C :: Q :: U :: D :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (B :: C :: Q :: U :: D :: B :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Q :: U :: D :: B :: C :: P :: Q :: Pp :: Oo :: nil) ((B :: C :: Q :: U :: D :: nil) ++ (B :: C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpUDOomtmp;try rewrite HT2 in HBCPQPpUDOomtmp.
	assert(HT := rule_4 (B :: C :: Q :: U :: D :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil) (B :: C :: Q :: nil) 4 3 3 HBCPQPpUDOomtmp HBCQmtmp HBCQUDMtmp Hincl); apply HT.
}

assert(HBCPQPpOoM : rk(B :: C :: P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPQPpOom : rk(B :: C :: P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPQPpOoeq HBCPQPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBOo *)
(* dans constructLemma(), requis par LCPQPpOo *)
(* dans la couche 0 *)
Lemma LCPQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPQPpUDOo requis par la preuve de (?)CPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)CPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)BCPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpUDOo requis par la preuve de (?)BCPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpUDOom2 : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpUDOom3 : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQPpUDOo requis par la preuve de (?)CPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpUDOo requis par la preuve de (?)CPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpUDOo requis par la preuve de (?)ABCPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpUDOo requis par la preuve de (?)ABCPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpUDOom2 : rk(A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpUDOom3 : rk(A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQPpUDOo requis par la preuve de (?)CPQPpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQPpUDOom2 : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpUDOomtmp : rk(A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQPpUDOoeq HABCPQPpUDOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpUDOomtmp;try rewrite HT2 in HABCPQPpUDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQPpUDOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HCPQPpUDOom3 : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBCPQPpUDOomtmp : rk(B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpUDOoeq HBCPQPpUDOom3).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (B :: Q :: U :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) ((B :: Q :: U :: nil) ++ (C :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpUDOomtmp;try rewrite HT2 in HBCPQPpUDOomtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (Q :: U :: nil) 3 2 2 HBCPQPpUDOomtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCPQPpUDOom4 : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HCQPpUeq : rk(C :: Q :: Pp :: U :: nil) = 4) by (apply LCQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQPpUmtmp : rk(C :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HCQPpUeq HCQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (C :: Q :: Pp :: U :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Q :: Pp :: U :: nil) (C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HCQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HCPQPpUDOoM : rk(C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQPpUDOom : rk(C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQPpUDOoeq HCPQPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Q :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)ABCPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)ABCPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpOom2 : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpOom3 : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQPpOom2 : rk(C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpOomtmp : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQPpOoeq HABCPQPpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpOomtmp;try rewrite HT2 in HABCPQPpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQPpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HCPQPpOoM3 : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: Oo :: nil) (C :: P :: Q :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: P :: Pp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: P :: Q :: nil) (P :: Pp :: Oo :: nil) (P :: nil) 2 2 1 HCPQMtmp HPPpOoMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : C :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HCPQPpOom3 : rk(C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HCQUDeq : rk(C :: Q :: U :: D :: nil) = 3) by (apply LCQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQUDMtmp : rk(C :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HCQUDeq HCQUDM3).
	assert(HCPQPpUDOoeq : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LCPQPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpUDOomtmp : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HCPQPpUDOoeq HCPQPpUDOom4).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (C :: Q :: U :: D :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (C :: Q :: U :: D :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Q :: U :: D :: C :: P :: Q :: Pp :: Oo :: nil) ((C :: Q :: U :: D :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQPpUDOomtmp;try rewrite HT2 in HCPQPpUDOomtmp.
	assert(HT := rule_4 (C :: Q :: U :: D :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (C :: Q :: nil) 4 2 3 HCPQPpUDOomtmp HCQmtmp HCQUDMtmp Hincl); apply HT.
}

assert(HCPQPpOoM : rk(C :: P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQPpOom : rk(C :: P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQPpOoeq HCPQPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BOo requis par la preuve de (?)BOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HBOom2 : rk(B :: Oo :: nil) >= 2).
{
	assert(HCPQPpOoeq : rk(C :: P :: Q :: Pp :: Oo :: nil) = 3) by (apply LCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpOoMtmp : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQPpOoeq HCPQPpOoM3).
	assert(HBCPQPpOoeq : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LBCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPQPpOomtmp : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HBCPQPpOoeq HBCPQPpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (B :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Oo :: nil) (B :: Oo :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: C :: P :: Q :: Pp :: Oo :: nil) ((B :: Oo :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpOomtmp;try rewrite HT2 in HBCPQPpOomtmp.
	assert(HT := rule_2 (B :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (Oo :: nil) 4 1 3 HBCPQPpOomtmp HOomtmp HCPQPpOoMtmp Hincl);apply HT.
}

assert(HBOoM : rk(B :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBOoeq HBOoM2).
assert(HBOom : rk(B :: Oo ::  nil) >= 1) by (solve_hyps_min HBOoeq HBOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABOo *)
(* dans constructLemma(), requis par LABPRPpOo *)
(* dans la couche 0 *)
Lemma LABPRPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpUDOo requis par la preuve de (?)ABPRPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpUDOo requis par la preuve de (?)ABPRPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpUDOo requis par la preuve de (?)ABPRPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpUDOom2 : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpUDOom3 : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPRPpUDOom4 : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HARPpUeq : rk(A :: R :: Pp :: U :: nil) = 4) by (apply LARPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARPpUmtmp : rk(A :: R :: Pp :: U :: nil) >= 4) by (solve_hyps_min HARPpUeq HARPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Pp :: U :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Pp :: U :: nil) (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) 4 4 HARPpUmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpUDOoM : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpUDOom : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpUDOoeq HABPRPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpOo requis par la preuve de (?)ABPRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpOo requis par la preuve de (?)ABPRPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpOo requis par la preuve de (?)ABPRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpOom2 : rk(A :: B :: P :: R :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpOom3 : rk(A :: B :: P :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: R ::  de rang :  3 et 3 	 A : A :: B :: R :: U :: D ::   de rang : 3 et 3 *)
assert(HABPRPpOom4 : rk(A :: B :: P :: R :: Pp :: Oo :: nil) >= 4).
{
	assert(HABRUDeq : rk(A :: B :: R :: U :: D :: nil) = 3) by (apply LABRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRUDMtmp : rk(A :: B :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HABRUDeq HABRUDM3).
	assert(HABPRPpUDOoeq : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LABPRPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpUDOomtmp : rk(A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpUDOoeq HABPRPpUDOom4).
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hincl : incl (A :: B :: R :: nil) (list_inter (A :: B :: R :: U :: D :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: U :: D :: Oo :: nil) (A :: B :: R :: U :: D :: A :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: R :: U :: D :: A :: B :: P :: R :: Pp :: Oo :: nil) ((A :: B :: R :: U :: D :: nil) ++ (A :: B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpUDOomtmp;try rewrite HT2 in HABPRPpUDOomtmp.
	assert(HT := rule_4 (A :: B :: R :: U :: D :: nil) (A :: B :: P :: R :: Pp :: Oo :: nil) (A :: B :: R :: nil) 4 3 3 HABPRPpUDOomtmp HABRmtmp HABRUDMtmp Hincl); apply HT.
}

assert(HABPRPpOoM : rk(A :: B :: P :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpOom : rk(A :: B :: P :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpOoeq HABPRPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABOo *)
(* dans constructLemma(), requis par LBPRPpOo *)
(* dans constructLemma(), requis par LBPRPpQpUpOo *)
(* dans constructLemma(), requis par LABPRPpQpUpOo *)
(* dans la couche 0 *)
Lemma LABPRPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUpOo requis par la preuve de (?)ABPRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUpOo requis par la preuve de (?)ABPRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUpOo requis par la preuve de (?)ABPRPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpQpRpUpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpRpUpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpRpUpOoeq HABPRPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpUpOo requis par la preuve de (?)ABPRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpUpOo requis par la preuve de (?)ABPRPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpUpOo requis par la preuve de (?)ABPRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPRPpQpUpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABPRPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpRpUpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpOoeq HABPRPpQpRpUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpOomtmp;try rewrite HT2 in HABPRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPRPpQpRpUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABPRPpQpUpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpUpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpUpOoeq HABPRPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUpOo requis par la preuve de (?)BPRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUpOo requis par la preuve de (?)BPRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUpOo requis par la preuve de (?)BPRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUpOo requis par la preuve de (?)BCPQRPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUpOo requis par la preuve de (?)BCPQRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUpOo requis par la preuve de (?)BPRPpQpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpOom2 : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUpOoeq HBCPQRPpQpUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUpOomtmp;try rewrite HT2 in HBCPQRPpQpUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpOom3 : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABPRPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpRpUpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpOoeq HABPRPpQpRpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpOomtmp;try rewrite HT2 in HABPRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpOom4 : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPRPpQpUpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LABPRPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpUpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpUpOoeq HABPRPpQpUpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpUpOomtmp;try rewrite HT2 in HABPRPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABPRPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HBPRPpQpUpOoM : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpQpUpOom : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpQpUpOoeq HBPRPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPRPpOo requis par la preuve de (?)BPRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpOo requis par la preuve de (?)BPRPpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpOo requis par la preuve de (?)BPRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpOo requis par la preuve de (?)BCPQRPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpOo requis par la preuve de (?)BCPQRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpOo requis par la preuve de (?)BPRPpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpOom2 : rk(B :: P :: R :: Pp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpOoeq HBCPQRPpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpOomtmp;try rewrite HT2 in HBCPQRPpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBPRPpOoM3 : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Oo :: nil) (B :: P :: R :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: P :: Pp :: Oo :: nil) ((B :: P :: R :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (P :: Pp :: Oo :: nil) (P :: nil) 2 2 1 HBPRMtmp HPPpOoMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpOom3 : rk(B :: P :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBPRPpQpUpOoeq : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LBPRPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpUpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUpOoeq HBPRPpQpUpOom4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: P :: R :: Pp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUpOomtmp;try rewrite HT2 in HBPRPpQpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: Oo :: nil) (B :: nil) 4 1 2 HBPRPpQpUpOomtmp HBmtmp HBQpUpMtmp Hincl); apply HT.
}

assert(HBPRPpOoM : rk(B :: P :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpOom : rk(B :: P :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpOoeq HBPRPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABOo requis par la preuve de (?)ABOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABOo requis par la preuve de (?)ABOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABOom2 : rk(A :: B :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABOom3 : rk(A :: B :: Oo :: nil) >= 3).
{
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOoMtmp : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBPRPpOoeq HBPRPpOoM3).
	assert(HABPRPpOoeq : rk(A :: B :: P :: R :: Pp :: Oo :: nil) = 4) by (apply LABPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpOomtmp : rk(A :: B :: P :: R :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpOoeq HABPRPpOom4).
	assert(HBOoeq : rk(B :: Oo :: nil) = 2) by (apply LBOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBOomtmp : rk(B :: Oo :: nil) >= 2) by (solve_hyps_min HBOoeq HBOom2).
	assert(Hincl : incl (B :: Oo :: nil) (list_inter (A :: B :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Oo :: nil) (A :: B :: Oo :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: B :: P :: R :: Pp :: Oo :: nil) ((A :: B :: Oo :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpOomtmp;try rewrite HT2 in HABPRPpOomtmp.
	assert(HT := rule_2 (A :: B :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil) (B :: Oo :: nil) 4 2 3 HABPRPpOomtmp HBOomtmp HBPRPpOoMtmp Hincl);apply HT.
}

assert(HABOoM : rk(A :: B :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABOoeq HABOoM3).
assert(HABOom : rk(A :: B :: Oo ::  nil) >= 1) by (solve_hyps_min HABOoeq HABOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPOo *)
(* dans constructLemma(), requis par LPQRQpOo *)
(* dans constructLemma(), requis par LPQRQpUOo *)
(* dans constructLemma(), requis par LAPQRQpUOo *)
(* dans la couche 0 *)
Lemma LAPQRQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUOo requis par la preuve de (?)APQRQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUOo requis par la preuve de (?)APQRQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUOo requis par la preuve de (?)APQRQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUOoM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUOom : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUOoeq HAPQRQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpUOo requis par la preuve de (?)APQRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpUOo requis par la preuve de (?)APQRQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpUOo requis par la preuve de (?)APQRQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpUOom2 : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpUOom3 : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPQRQpUOom4 : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPQRQpRpUOoeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LAPQRQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUOomtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUOoeq HAPQRQpRpUOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUOomtmp;try rewrite HT2 in HAPQRQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HAPQRQpRpUOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HAPQRQpUOoM : rk(A :: P :: Q :: R :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpUOom : rk(A :: P :: Q :: R :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRQpUOoeq HAPQRQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpUOo requis par la preuve de (?)PQRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpUOo requis par la preuve de (?)PQRQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpUOom3 : rk(P :: Q :: R :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: U :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Q :: R :: U ::  de rang :  3 et 3 	 A : A :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpUOom4 : rk(P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQRUeq : rk(A :: Q :: R :: U :: nil) = 3) by (apply LAQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUMtmp : rk(A :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAQRUeq HAQRUM3).
	assert(HAPQRQpUOoeq : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LAPQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpUOomtmp : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpUOoeq HAPQRQpUOom4).
	assert(HQRUeq : rk(Q :: R :: U :: nil) = 3) by (apply LQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRUmtmp : rk(Q :: R :: U :: nil) >= 3) by (solve_hyps_min HQRUeq HQRUm3).
	assert(Hincl : incl (Q :: R :: U :: nil) (list_inter (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: U :: P :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpUOomtmp;try rewrite HT2 in HAPQRQpUOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: U :: Oo :: nil) (Q :: R :: U :: nil) 4 3 3 HAPQRQpUOomtmp HQRUmtmp HAQRUMtmp Hincl); apply HT.
}

assert(HPQRQpUOoM : rk(P :: Q :: R :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpUOom : rk(P :: Q :: R :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRQpUOoeq HPQRQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Qp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : P :: Q :: R ::  de rang :  3 et 3 	 A : P :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HPQRQpOom4 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4).
{
	assert(HPQRUeq : rk(P :: Q :: R :: U :: nil) = 3) by (apply LPQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRUMtmp : rk(P :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HPQRUeq HPQRUM3).
	assert(HPQRQpUOoeq : rk(P :: Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LPQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRQpUOomtmp : rk(P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HPQRQpUOoeq HPQRQpUOom4).
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hincl : incl (P :: Q :: R :: nil) (list_inter (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: U :: Oo :: nil) (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Q :: R :: U :: P :: Q :: R :: Qp :: Oo :: nil) ((P :: Q :: R :: U :: nil) ++ (P :: Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpUOomtmp;try rewrite HT2 in HPQRQpUOomtmp.
	assert(HT := rule_4 (P :: Q :: R :: U :: nil) (P :: Q :: R :: Qp :: Oo :: nil) (P :: Q :: R :: nil) 4 3 3 HPQRQpUOomtmp HPQRmtmp HPQRUMtmp Hincl); apply HT.
}

assert(HPQRQpOoM : rk(P :: Q :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRQpOom : rk(P :: Q :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRQpOoeq HPQRQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPOo *)
(* dans constructLemma(), requis par LQRQpOo *)
(* dans constructLemma(), requis par LQRQpUOo *)
(* dans la couche 0 *)
Lemma LAQRQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRQpUOo requis par la preuve de (?)AQRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRQpRpUOo requis par la preuve de (?)AQRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpRpUOo requis par la preuve de (?)AQRQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpRpUOo requis par la preuve de (?)AQRQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpUOom2 : rk(A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpUOom3 : rk(A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpUOo requis par la preuve de (?)AQRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpUOo requis par la preuve de (?)AQRQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpUOom2 : rk(A :: Q :: R :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Q :: R :: Qp :: Rp :: U :: Oo ::  de rang :  3 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAQRQpUOom3 : rk(A :: Q :: R :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAQRQpRpUOomtmp : rk(A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HAQRQpRpUOoeq HAQRQpRpUOom3).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: A :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRQpRpUOomtmp;try rewrite HT2 in HAQRQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 3 2 2 HAQRQpRpUOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAQRQpUOom4 : rk(A :: Q :: R :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQRQpUOoeq : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LAPQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpUOomtmp : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpUOoeq HAPQRQpUOom4).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) (A :: P :: U :: A :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: P :: U :: nil) ++ (A :: Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpUOomtmp;try rewrite HT2 in HAPQRQpUOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: Q :: R :: Qp :: U :: Oo :: nil) (A :: U :: nil) 4 2 2 HAPQRQpUOomtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

assert(HAQRQpUOoM : rk(A :: Q :: R :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRQpUOom : rk(A :: Q :: R :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAQRQpUOoeq HAQRQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: R :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QRQpUOo requis par la preuve de (?)QRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QRQpUOo requis par la preuve de (?)QRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUOo requis par la preuve de (?)QRQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUOo requis par la preuve de (?)PQRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUOo requis par la preuve de (?)PQRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpUOo requis par la preuve de (?)QRQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQRQpUOom2 : rk(Q :: R :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUOoeq HPQRPpQpRpUOom4).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: R :: Qp :: U :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUOomtmp;try rewrite HT2 in HPQRPpQpRpUOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: R :: Qp :: U :: Oo :: nil) (R :: nil) 4 1 3 HPQRPpQpRpUOomtmp HRmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQRQpUOom3 : rk(Q :: R :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQRQpUOoeq : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LAPQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpUOomtmp : rk(A :: P :: Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpUOoeq HAPQRQpUOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: U :: Oo :: nil) (A :: P :: U :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: P :: U :: nil) ++ (Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpUOomtmp;try rewrite HT2 in HAPQRQpUOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: R :: Qp :: U :: Oo :: nil) (U :: nil) 4 1 2 HAPQRQpUOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Q :: R :: U ::  de rang :  3 et 3 	 A : A :: Q :: R :: U ::   de rang : 3 et 3 *)
assert(HQRQpUOom4 : rk(Q :: R :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQRUeq : rk(A :: Q :: R :: U :: nil) = 3) by (apply LAQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRUMtmp : rk(A :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HAQRUeq HAQRUM3).
	assert(HAQRQpUOoeq : rk(A :: Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LAQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpUOomtmp : rk(A :: Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAQRQpUOoeq HAQRQpUOom4).
	assert(HQRUeq : rk(Q :: R :: U :: nil) = 3) by (apply LQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRUmtmp : rk(Q :: R :: U :: nil) >= 3) by (solve_hyps_min HQRUeq HQRUm3).
	assert(Hincl : incl (Q :: R :: U :: nil) (list_inter (A :: Q :: R :: U :: nil) (Q :: R :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: U :: Oo :: nil) (A :: Q :: R :: U :: Q :: R :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: U :: Q :: R :: Qp :: U :: Oo :: nil) ((A :: Q :: R :: U :: nil) ++ (Q :: R :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRQpUOomtmp;try rewrite HT2 in HAQRQpUOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: U :: nil) (Q :: R :: Qp :: U :: Oo :: nil) (Q :: R :: U :: nil) 4 3 3 HAQRQpUOomtmp HQRUmtmp HAQRUMtmp Hincl); apply HT.
}

assert(HQRQpUOoM : rk(Q :: R :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpUOom : rk(Q :: R :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HQRQpUOoeq HQRQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQRQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: R :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QRQpOo requis par la preuve de (?)QRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)QRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRQpOo requis par la preuve de (?)PQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRQpOom3 : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Qp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PQp requis par la preuve de (?)QRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QRQpOo requis par la preuve de (?)QRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QRQpOo requis par la preuve de (?)QRQpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HQRQpOoM3 : rk(Q :: R :: Qp :: Oo :: nil) <= 3).
{
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (R :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: Oo :: nil) (R :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: Q :: Qp :: Oo :: nil) ((R :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: nil) (Q :: Qp :: Oo :: nil) (nil) 1 2 0 HRMtmp HQQpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : P :: Q :: R :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : P :: Qp ::   de rang : 1 et 2 *)
assert(HQRQpOom2 : rk(Q :: R :: Qp :: Oo :: nil) >= 2).
{
	assert(HPQpMtmp : rk(P :: Qp :: nil) <= 2) by (solve_hyps_max HPQpeq HPQpM2).
	assert(HPQRQpOomtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HPQRQpOoeq HPQRQpOom3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (P :: Qp :: nil) (Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: nil) (P :: Qp :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Qp :: Q :: R :: Qp :: Oo :: nil) ((P :: Qp :: nil) ++ (Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOomtmp;try rewrite HT2 in HPQRQpOomtmp.
	assert(HT := rule_4 (P :: Qp :: nil) (Q :: R :: Qp :: Oo :: nil) (Qp :: nil) 3 1 2 HPQRQpOomtmp HQpmtmp HPQpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Q :: R :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : Qp :: U ::   de rang : 2 et 2 *)
assert(HQRQpOom3 : rk(Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HQpUeq : rk(Qp :: U :: nil) = 2) by (apply LQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpUMtmp : rk(Qp :: U :: nil) <= 2) by (solve_hyps_max HQpUeq HQpUM2).
	assert(HQRQpUOoeq : rk(Q :: R :: Qp :: U :: Oo :: nil) = 4) by (apply LQRQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRQpUOomtmp : rk(Q :: R :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HQRQpUOoeq HQRQpUOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (Qp :: U :: nil) (Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: R :: Qp :: U :: Oo :: nil) (Qp :: U :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: U :: Q :: R :: Qp :: Oo :: nil) ((Qp :: U :: nil) ++ (Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQRQpUOomtmp;try rewrite HT2 in HQRQpUOomtmp.
	assert(HT := rule_4 (Qp :: U :: nil) (Q :: R :: Qp :: Oo :: nil) (Qp :: nil) 4 1 2 HQRQpUOomtmp HQpmtmp HQpUMtmp Hincl); apply HT.
}

assert(HQRQpOoM : rk(Q :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQRQpOom : rk(Q :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HQRQpOoeq HQRQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour POo requis par la preuve de (?)POo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPOom2 : rk(P :: Oo :: nil) >= 2).
{
	assert(HQRQpOoeq : rk(Q :: R :: Qp :: Oo :: nil) = 3) by (apply LQRQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRQpOoMtmp : rk(Q :: R :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HQRQpOoeq HQRQpOoM3).
	assert(HPQRQpOoeq : rk(P :: Q :: R :: Qp :: Oo :: nil) = 4) by (apply LPQRQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRQpOomtmp : rk(P :: Q :: R :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRQpOoeq HPQRQpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Oo :: nil) (Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Qp :: Oo :: nil) (P :: Oo :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Oo :: Q :: R :: Qp :: Oo :: nil) ((P :: Oo :: nil) ++ (Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRQpOomtmp;try rewrite HT2 in HPQRQpOomtmp.
	assert(HT := rule_2 (P :: Oo :: nil) (Q :: R :: Qp :: Oo :: nil) (Oo :: nil) 4 1 3 HPQRQpOomtmp HOomtmp HQRQpOoMtmp Hincl);apply HT.
}

assert(HPOoM : rk(P :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPOoeq HPOoM2).
assert(HPOom : rk(P :: Oo ::  nil) >= 1) by (solve_hyps_min HPOoeq HPOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPOo *)
(* dans constructLemma(), requis par LACPQPpOo *)
(* dans la couche 0 *)
Lemma LACPQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpUDOo requis par la preuve de (?)ACPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpUDOo requis par la preuve de (?)ACPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpUDOo requis par la preuve de (?)ACPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpUDOom2 : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpUDOom3 : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpUDOom4 : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HACPQPpUDOoM : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACPQPpUDOom : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HACPQPpUDOoeq HACPQPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACPQPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: P :: Q :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)ACPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)ACPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)ACPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpOom2 : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpOom3 : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: C :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HACPQPpOom4 : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 4).
{
	assert(HACQUDeq : rk(A :: C :: Q :: U :: D :: nil) = 3) by (apply LACQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQUDMtmp : rk(A :: C :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HACQUDeq HACQUDM3).
	assert(HACPQPpUDOoeq : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LACPQPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACPQPpUDOomtmp : rk(A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HACPQPpUDOoeq HACPQPpUDOom4).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: C :: Q :: U :: D :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: C :: Q :: U :: D :: A :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Q :: U :: D :: A :: C :: P :: Q :: Pp :: Oo :: nil) ((A :: C :: Q :: U :: D :: nil) ++ (A :: C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpUDOomtmp;try rewrite HT2 in HACPQPpUDOomtmp.
	assert(HT := rule_4 (A :: C :: Q :: U :: D :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil) (A :: C :: Q :: nil) 4 3 3 HACPQPpUDOomtmp HACQmtmp HACQUDMtmp Hincl); apply HT.
}

assert(HACPQPpOoM : rk(A :: C :: P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACPQPpOom : rk(A :: C :: P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HACPQPpOoeq HACPQPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APOo requis par la preuve de (?)APOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQOo requis par la preuve de (?)APOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQOo requis par la preuve de (?)ACPQOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQOo requis par la preuve de (?)ACPQOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQOom2 : rk(A :: C :: P :: Q :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQOom3 : rk(A :: C :: P :: Q :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APOo requis par la preuve de (?)APOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPOom2 : rk(A :: P :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQOomtmp : rk(A :: C :: P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HACPQOoeq HACPQOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Oo :: nil) (C :: P :: Q :: A :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQOomtmp;try rewrite HT2 in HACPQOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Oo :: nil) (P :: nil) 3 1 2 HACPQOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAPOom3 : rk(A :: P :: Oo :: nil) >= 3).
{
	assert(HCPQPpOoeq : rk(C :: P :: Q :: Pp :: Oo :: nil) = 3) by (apply LCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpOoMtmp : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQPpOoeq HCPQPpOoM3).
	assert(HACPQPpOoeq : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LACPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACPQPpOomtmp : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HACPQPpOoeq HACPQPpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (A :: P :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Oo :: nil) (A :: P :: Oo :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Oo :: C :: P :: Q :: Pp :: Oo :: nil) ((A :: P :: Oo :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpOomtmp;try rewrite HT2 in HACPQPpOomtmp.
	assert(HT := rule_2 (A :: P :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (P :: Oo :: nil) 4 2 3 HACPQPpOomtmp HPOomtmp HCPQPpOoMtmp Hincl);apply HT.
}

assert(HAPOoM : rk(A :: P :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAPOoeq HAPOoM3).
assert(HAPOom : rk(A :: P :: Oo ::  nil) >= 1) by (solve_hyps_min HAPOoeq HAPOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPOo requis par la preuve de (?)BPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQOo requis par la preuve de (?)BPOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQOo requis par la preuve de (?)BCPQOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQOo requis par la preuve de (?)BCPQOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQOom2 : rk(B :: C :: P :: Q :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQOom3 : rk(B :: C :: P :: Q :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPOo requis par la preuve de (?)BPOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPOom2 : rk(B :: P :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQOomtmp : rk(B :: C :: P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQOoeq HBCPQOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Oo :: nil) (C :: P :: Q :: B :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQOomtmp;try rewrite HT2 in HBCPQOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Oo :: nil) (P :: nil) 3 1 2 HBCPQOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBPOom3 : rk(B :: P :: Oo :: nil) >= 3).
{
	assert(HCPQPpOoeq : rk(C :: P :: Q :: Pp :: Oo :: nil) = 3) by (apply LCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpOoMtmp : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQPpOoeq HCPQPpOoM3).
	assert(HBCPQPpOoeq : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LBCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPQPpOomtmp : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HBCPQPpOoeq HBCPQPpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (B :: P :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Oo :: nil) (B :: P :: Oo :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: Oo :: C :: P :: Q :: Pp :: Oo :: nil) ((B :: P :: Oo :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpOomtmp;try rewrite HT2 in HBCPQPpOomtmp.
	assert(HT := rule_2 (B :: P :: Oo :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (P :: Oo :: nil) 4 2 3 HBCPQPpOomtmp HPOomtmp HCPQPpOoMtmp Hincl);apply HT.
}

assert(HBPOoM : rk(B :: P :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBPOoeq HBPOoM3).
assert(HBPOom : rk(B :: P :: Oo ::  nil) >= 1) by (solve_hyps_min HBPOoeq HBPOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPOo requis par la preuve de (?)ABPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPROo requis par la preuve de (?)ABPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPROo requis par la preuve de (?)ABPROo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPROo requis par la preuve de (?)ABPROo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPROom2 : rk(A :: B :: P :: R :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPROom3 : rk(A :: B :: P :: R :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPROo requis par la preuve de (?)ABPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPROo requis par la preuve de (?)BPROo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BPROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BCPQROo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BCPQROo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQROom2 : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQROom3 : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPROo requis par la preuve de (?)BPROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPROom2 : rk(B :: P :: R :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQROomtmp : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQROoeq HBCPQROom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQROomtmp;try rewrite HT2 in HBCPQROomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Oo :: nil) (P :: nil) 3 1 2 HBCPQROomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBPROoM3 : rk(B :: P :: R :: Oo :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: P :: R :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Oo :: nil) (B :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: nil) ((B :: P :: R :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (Oo :: nil) (nil) 2 1 0 HBPRMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPOo requis par la preuve de (?)ABPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPOo requis par la preuve de (?)ABPOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPOom2 : rk(A :: B :: P :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HABPOom3 : rk(A :: B :: P :: Oo :: nil) >= 3).
{
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HABPROomtmp : rk(A :: B :: P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HABPROoeq HABPROom3).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (A :: B :: P :: Oo :: nil) (B :: P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Oo :: nil) (A :: B :: P :: Oo :: B :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Oo :: B :: P :: R :: Oo :: nil) ((A :: B :: P :: Oo :: nil) ++ (B :: P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPROomtmp;try rewrite HT2 in HABPROomtmp.
	assert(HT := rule_2 (A :: B :: P :: Oo :: nil) (B :: P :: R :: Oo :: nil) (B :: P :: Oo :: nil) 3 3 3 HABPROomtmp HBPOomtmp HBPROoMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABPOom4 : rk(A :: B :: P :: Oo :: nil) >= 4).
{
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOoMtmp : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBPRPpOoeq HBPRPpOoM3).
	assert(HABPRPpOoeq : rk(A :: B :: P :: R :: Pp :: Oo :: nil) = 4) by (apply LABPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpOomtmp : rk(A :: B :: P :: R :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpOoeq HABPRPpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (A :: B :: P :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Oo :: nil) (A :: B :: P :: Oo :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Oo :: B :: P :: R :: Pp :: Oo :: nil) ((A :: B :: P :: Oo :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpOomtmp;try rewrite HT2 in HABPRPpOomtmp.
	assert(HT := rule_2 (A :: B :: P :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HABPRPpOomtmp HBPOomtmp HBPRPpOoMtmp Hincl);apply HT.
}

assert(HABPOoM : rk(A :: B :: P :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPOom : rk(A :: B :: P :: Oo ::  nil) >= 1) by (solve_hyps_min HABPOoeq HABPOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LCPOo *)
(* dans constructLemma(), requis par LBCPRPpOo *)
(* dans la couche 0 *)
Lemma LBCPRPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpUDOo requis par la preuve de (?)BCPRPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpUDOo requis par la preuve de (?)BCPRPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpUDOo requis par la preuve de (?)BCPRPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpUDOom2 : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpUDOom3 : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpUDOom4 : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HBCRPpUeq : rk(B :: C :: R :: Pp :: U :: nil) = 4) by (apply LBCRPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRPpUmtmp : rk(B :: C :: R :: Pp :: U :: nil) >= 4) by (solve_hyps_min HBCRPpUeq HBCRPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Pp :: U :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Pp :: U :: nil) (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) 4 4 HBCRPpUmtmp Hcomp Hincl);apply HT.
}

assert(HBCPRPpUDOoM : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpUDOom : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpUDOoeq HBCPRPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCPRPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpOo requis par la preuve de (?)BCPRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpOo requis par la preuve de (?)BCPRPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpOo requis par la preuve de (?)BCPRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpOom2 : rk(B :: C :: P :: R :: Pp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpOom3 : rk(B :: C :: P :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : B :: C :: R :: U :: D ::   de rang : 3 et 3 *)
assert(HBCPRPpOom4 : rk(B :: C :: P :: R :: Pp :: Oo :: nil) >= 4).
{
	assert(HBCRUDeq : rk(B :: C :: R :: U :: D :: nil) = 3) by (apply LBCRUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRUDMtmp : rk(B :: C :: R :: U :: D :: nil) <= 3) by (solve_hyps_max HBCRUDeq HBCRUDM3).
	assert(HBCPRPpUDOoeq : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LBCPRPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpUDOomtmp : rk(B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpUDOoeq HBCPRPpUDOom4).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (B :: C :: R :: U :: D :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: U :: D :: Oo :: nil) (B :: C :: R :: U :: D :: B :: C :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: R :: U :: D :: B :: C :: P :: R :: Pp :: Oo :: nil) ((B :: C :: R :: U :: D :: nil) ++ (B :: C :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpUDOomtmp;try rewrite HT2 in HBCPRPpUDOomtmp.
	assert(HT := rule_4 (B :: C :: R :: U :: D :: nil) (B :: C :: P :: R :: Pp :: Oo :: nil) (B :: C :: R :: nil) 4 3 3 HBCPRPpUDOomtmp HBCRmtmp HBCRUDMtmp Hincl); apply HT.
}

assert(HBCPRPpOoM : rk(B :: C :: P :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpOom : rk(B :: C :: P :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpOoeq HBCPRPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPOo requis par la preuve de (?)CPOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPROo requis par la preuve de (?)CPOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPROo requis par la preuve de (?)BCPROo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPROo requis par la preuve de (?)BCPROo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPROom2 : rk(B :: C :: P :: R :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPROom3 : rk(B :: C :: P :: R :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CPOo requis par la preuve de (?)CPOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPOom2 : rk(C :: P :: Oo :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPROomtmp : rk(B :: C :: P :: R :: Oo :: nil) >= 3) by (solve_hyps_min HBCPROoeq HBCPROom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Oo :: nil) (B :: P :: R :: C :: P :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Oo :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPROomtmp;try rewrite HT2 in HBCPROomtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Oo :: nil) (P :: nil) 3 1 2 HBCPROomtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCPOom3 : rk(C :: P :: Oo :: nil) >= 3).
{
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOoMtmp : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBPRPpOoeq HBPRPpOoM3).
	assert(HBCPRPpOoeq : rk(B :: C :: P :: R :: Pp :: Oo :: nil) = 4) by (apply LBCPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpOomtmp : rk(B :: C :: P :: R :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpOoeq HBCPRPpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (C :: P :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Oo :: nil) (C :: P :: Oo :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Oo :: B :: P :: R :: Pp :: Oo :: nil) ((C :: P :: Oo :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpOomtmp;try rewrite HT2 in HBCPRPpOomtmp.
	assert(HT := rule_2 (C :: P :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil) (P :: Oo :: nil) 4 2 3 HBCPRPpOomtmp HPOomtmp HBPRPpOoMtmp Hincl);apply HT.
}

assert(HCPOoM : rk(C :: P :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCPOoeq HCPOoM3).
assert(HCPOom : rk(C :: P :: Oo ::  nil) >= 1) by (solve_hyps_min HCPOoeq HCPOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPQOo *)
(* dans constructLemma(), requis par LABPQPpOo *)
(* dans la couche 0 *)
Lemma LABPQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpUDOo requis par la preuve de (?)ABPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpUDOo requis par la preuve de (?)ABPQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpUDOo requis par la preuve de (?)ABPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpUDOom2 : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpUDOom3 : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpUDOom4 : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HABPQPpUDOoM : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpUDOom : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpUDOoeq HABPQPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpOo requis par la preuve de (?)ABPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpOo requis par la preuve de (?)ABPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpOo requis par la preuve de (?)ABPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpOom2 : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpOom3 : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Q ::  de rang :  3 et 3 	 A : A :: B :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HABPQPpOom4 : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 4).
{
	assert(HABQUDeq : rk(A :: B :: Q :: U :: D :: nil) = 3) by (apply LABQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQUDMtmp : rk(A :: B :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HABQUDeq HABQUDM3).
	assert(HABPQPpUDOoeq : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LABPQPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpUDOomtmp : rk(A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpUDOoeq HABPQPpUDOom4).
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hincl : incl (A :: B :: Q :: nil) (list_inter (A :: B :: Q :: U :: D :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: B :: Q :: U :: D :: A :: B :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Q :: U :: D :: A :: B :: P :: Q :: Pp :: Oo :: nil) ((A :: B :: Q :: U :: D :: nil) ++ (A :: B :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpUDOomtmp;try rewrite HT2 in HABPQPpUDOomtmp.
	assert(HT := rule_4 (A :: B :: Q :: U :: D :: nil) (A :: B :: P :: Q :: Pp :: Oo :: nil) (A :: B :: Q :: nil) 4 3 3 HABPQPpUDOomtmp HABQmtmp HABQUDMtmp Hincl); apply HT.
}

assert(HABPQPpOoM : rk(A :: B :: P :: Q :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpOom : rk(A :: B :: P :: Q :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpOoeq HABPQPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQOo requis par la preuve de (?)ABPQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQOo requis par la preuve de (?)ABPQOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQOo requis par la preuve de (?)ABPQOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQOom2 : rk(A :: B :: P :: Q :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQOom3 : rk(A :: B :: P :: Q :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABPQOom4 : rk(A :: B :: P :: Q :: Oo :: nil) >= 4).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HABPQPpOoeq : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LABPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpOomtmp : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpOoeq HABPQPpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (A :: B :: P :: Q :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Oo :: nil) (A :: B :: P :: Q :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: Oo :: P :: Pp :: Oo :: nil) ((A :: B :: P :: Q :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpOomtmp;try rewrite HT2 in HABPQPpOomtmp.
	assert(HT := rule_2 (A :: B :: P :: Q :: Oo :: nil) (P :: Pp :: Oo :: nil) (P :: Oo :: nil) 4 2 2 HABPQPpOomtmp HPOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HABPQOoM : rk(A :: B :: P :: Q :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQOom : rk(A :: B :: P :: Q :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQOoeq HABPQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Q :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPQOo requis par la preuve de (?)CPQOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQOo requis par la preuve de (?)CPQOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQOo requis par la preuve de (?)CPQOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQOo requis par la preuve de (?)ABCPQOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQOo requis par la preuve de (?)ABCPQOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQOom2 : rk(A :: B :: C :: P :: Q :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQOom3 : rk(A :: B :: C :: P :: Q :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQOo requis par la preuve de (?)CPQOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQOom2 : rk(C :: P :: Q :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQOomtmp : rk(A :: B :: C :: P :: Q :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQOoeq HABCPQOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQOomtmp;try rewrite HT2 in HABCPQOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HCPQOoM3 : rk(C :: P :: Q :: Oo :: nil) <= 3).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: P :: Q :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Oo :: nil) (C :: P :: Q :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: Oo :: nil) ((C :: P :: Q :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: P :: Q :: nil) (Oo :: nil) (nil) 2 1 0 HCPQMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HCPQOom3 : rk(C :: P :: Q :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HCPQPpOoeq : rk(C :: P :: Q :: Pp :: Oo :: nil) = 3) by (apply LCPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpOomtmp : rk(C :: P :: Q :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HCPQPpOoeq HCPQPpOom3).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (C :: P :: Q :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: Oo :: nil) (C :: P :: Q :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: Oo :: P :: Pp :: Oo :: nil) ((C :: P :: Q :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQPpOomtmp;try rewrite HT2 in HCPQPpOomtmp.
	assert(HT := rule_2 (C :: P :: Q :: Oo :: nil) (P :: Pp :: Oo :: nil) (P :: Oo :: nil) 3 2 2 HCPQPpOomtmp HPOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HCPQOoM : rk(C :: P :: Q :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQOom : rk(C :: P :: Q :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQOoeq HCPQOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPROo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPROo requis par la preuve de (?)BPROo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPROo requis par la preuve de (?)BPROo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BPROo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BCPQROo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQROo requis par la preuve de (?)BCPQROo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQROom2 : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQROom3 : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPROo requis par la preuve de (?)BPROo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPROom2 : rk(B :: P :: R :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQROomtmp : rk(B :: C :: P :: Q :: R :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQROoeq HBCPQROom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQROomtmp;try rewrite HT2 in HBCPQROomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Oo :: nil) (P :: nil) 3 1 2 HBCPQROomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBPROoM3 : rk(B :: P :: R :: Oo :: nil) <= 3).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: P :: R :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Oo :: nil) (B :: P :: R :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: nil) ((B :: P :: R :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: P :: R :: nil) (Oo :: nil) (nil) 2 1 0 HBPRMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBPROom3 : rk(B :: P :: R :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOomtmp : rk(B :: P :: R :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBPRPpOoeq HBPRPpOom3).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Oo :: nil) (B :: P :: R :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: P :: Pp :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpOomtmp;try rewrite HT2 in HBPRPpOomtmp.
	assert(HT := rule_2 (B :: P :: R :: Oo :: nil) (P :: Pp :: Oo :: nil) (P :: Oo :: nil) 3 2 2 HBPRPpOomtmp HPOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HBPROoM : rk(B :: P :: R :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPROom : rk(B :: P :: R :: Oo ::  nil) >= 1) by (solve_hyps_min HBPROoeq HBPROom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPpOo *)
(* dans constructLemma(), requis par LQPpQpOo *)
(* dans constructLemma(), requis par LBQPpQpUpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpUpOo requis par la preuve de (?)ABQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpUpOo requis par la preuve de (?)ABQPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpUpOo requis par la preuve de (?)ABQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpUpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpUpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABQPpQpUpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABQPpQpRpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpOomtmp;try rewrite HT2 in HABQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABQPpQpRpUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABQPpQpUpOoM : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpUpOom : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpUpOoeq HABQPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpUpOo requis par la preuve de (?)BQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpUpOo requis par la preuve de (?)BQPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpUpOo requis par la preuve de (?)BQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpUpOom2 : rk(B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBQPpQpUpOom3 : rk(B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABQPpQpRpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpOomtmp;try rewrite HT2 in HABQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABQPpQpRpUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBQPpQpUpOom4 : rk(B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABQPpQpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpUpOoeq HABQPpQpUpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: Q :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: Q :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpUpOomtmp;try rewrite HT2 in HABQPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: Q :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABQPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HBQPpQpUpOoM : rk(B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpUpOom : rk(B :: Q :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpUpOoeq HBQPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpOo requis par la preuve de (?)QPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpOo requis par la preuve de (?)PQRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpOo requis par la preuve de (?)PQRPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpOo requis par la preuve de (?)QPpQpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HQPpQpOoM3 : rk(Q :: Pp :: Qp :: Oo :: nil) <= 3).
{
	assert(HPpMtmp : rk(Pp :: nil) <= 1) by (solve_hyps_max HPpeq HPpM1).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Pp :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Oo :: nil) (Pp :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Q :: Qp :: Oo :: nil) ((Pp :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Pp :: nil) (Q :: Qp :: Oo :: nil) (nil) 1 2 0 HPpMtmp HQQpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpOom2 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpOoeq HPQRPpQpRpOom4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Pp :: Qp :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpOomtmp;try rewrite HT2 in HPQRPpQpRpOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Oo :: nil) (Pp :: nil) 4 1 3 HPQRPpQpRpOomtmp HPpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HQPpQpOom3 : rk(Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQPpQpUpOoeq : rk(B :: Q :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LBQPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpUpOomtmp : rk(B :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpUpOoeq HBQPpQpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (B :: Qp :: Up :: nil) (Q :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: Q :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Q :: Pp :: Qp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Q :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpUpOomtmp;try rewrite HT2 in HBQPpQpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Q :: Pp :: Qp :: Oo :: nil) (Qp :: nil) 4 1 2 HBQPpQpUpOomtmp HQpmtmp HBQpUpMtmp Hincl); apply HT.
}

assert(HQPpQpOoM : rk(Q :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpOom : rk(Q :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpOoeq HQPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Pp :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpOo requis par la preuve de (?)PpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HPpOom2 : rk(Pp :: Oo :: nil) >= 2).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQPpQpOoeq : rk(Q :: Pp :: Qp :: Oo :: nil) = 3) by (apply LQPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpQpOomtmp : rk(Q :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HQPpQpOoeq HQPpQpOom3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Pp :: Oo :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Oo :: nil) (Pp :: Oo :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Oo :: Q :: Qp :: Oo :: nil) ((Pp :: Oo :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpOomtmp;try rewrite HT2 in HQPpQpOomtmp.
	assert(HT := rule_2 (Pp :: Oo :: nil) (Q :: Qp :: Oo :: nil) (Oo :: nil) 3 1 2 HQPpQpOomtmp HOomtmp HQQpOoMtmp Hincl);apply HT.
}

assert(HPpOoM : rk(Pp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HPpOoeq HPpOoM2).
assert(HPpOom : rk(Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HPpOoeq HPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPpOo *)
(* dans la couche 0 *)
Lemma LAPPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APPpOo requis par la preuve de (?)APPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)APPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)ACPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpOo requis par la preuve de (?)ACPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpOom2 : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpOom3 : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APPpOo requis par la preuve de (?)APPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpOo requis par la preuve de (?)APPpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAPPpOoM3 : rk(A :: P :: Pp :: Oo :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: Oo :: nil) (A :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Pp :: Oo :: nil) ((A :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (P :: Pp :: Oo :: nil) (nil) 1 2 0 HAMtmp HPPpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpOom2 : rk(A :: P :: Pp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpOomtmp : rk(A :: C :: P :: Q :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQPpOoeq HACPQPpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Oo :: nil) (C :: P :: Q :: A :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpOomtmp;try rewrite HT2 in HACPQPpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Oo :: nil) (P :: nil) 3 1 2 HACPQPpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 AiB : A :: P :: Oo ::  de rang :  3 et 3 	 A : A :: B :: P :: Q :: Oo ::   de rang : 4 et 4 *)
assert(HAPPpOom3 : rk(A :: P :: Pp :: Oo :: nil) >= 3).
{
	assert(HABPQOoeq : rk(A :: B :: P :: Q :: Oo :: nil) = 4) by (apply LABPQOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQOoMtmp : rk(A :: B :: P :: Q :: Oo :: nil) <= 4) by (solve_hyps_max HABPQOoeq HABPQOoM4).
	assert(HABPQPpOoeq : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LABPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpOomtmp : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpOoeq HABPQPpOom4).
	assert(HAPOoeq : rk(A :: P :: Oo :: nil) = 3) by (apply LAPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPOomtmp : rk(A :: P :: Oo :: nil) >= 3) by (solve_hyps_min HAPOoeq HAPOom3).
	assert(Hincl : incl (A :: P :: Oo :: nil) (list_inter (A :: B :: P :: Q :: Oo :: nil) (A :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Oo :: nil) (A :: B :: P :: Q :: Oo :: A :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: Oo :: A :: P :: Pp :: Oo :: nil) ((A :: B :: P :: Q :: Oo :: nil) ++ (A :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpOomtmp;try rewrite HT2 in HABPQPpOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: Oo :: nil) (A :: P :: Pp :: Oo :: nil) (A :: P :: Oo :: nil) 4 3 4 HABPQPpOomtmp HAPOomtmp HABPQOoMtmp Hincl); apply HT.
}

assert(HAPPpOoM : rk(A :: P :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPPpOom : rk(A :: P :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPPpOoeq HAPPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpOo requis par la preuve de (?)APpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpOo requis par la preuve de (?)APpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpOo requis par la preuve de (?)ACPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpOo requis par la preuve de (?)ACPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpOom2 : rk(A :: C :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpOom3 : rk(A :: C :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour APpOo requis par la preuve de (?)APpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpOom2 : rk(A :: Pp :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpOomtmp : rk(A :: C :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpOoeq HACPpQpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpOomtmp;try rewrite HT2 in HACPpQpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAPpOom3 : rk(A :: Pp :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HAPPpOoeq : rk(A :: P :: Pp :: Oo :: nil) = 3) by (apply LAPPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPPpOomtmp : rk(A :: P :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HAPPpOoeq HAPPpOom3).
	assert(HPpOoeq : rk(Pp :: Oo :: nil) = 2) by (apply LPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (A :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: Oo :: nil) (A :: Pp :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Oo :: P :: Pp :: Oo :: nil) ((A :: Pp :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPPpOomtmp;try rewrite HT2 in HAPPpOomtmp.
	assert(HT := rule_2 (A :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil) (Pp :: Oo :: nil) 3 2 2 HAPPpOomtmp HPpOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HAPpOoM : rk(A :: Pp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAPpOoeq HAPpOoM3).
assert(HAPpOom : rk(A :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPpOoeq HAPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBPpOo *)
(* dans la couche 0 *)
Lemma LBPPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPPpOo requis par la preuve de (?)BPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BCPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpOo requis par la preuve de (?)BCPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpOom2 : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpOom3 : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPPpOo requis par la preuve de (?)BPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpOo requis par la preuve de (?)BPPpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBPPpOoM3 : rk(B :: P :: Pp :: Oo :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Oo :: nil) (B :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: Pp :: Oo :: nil) ((B :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (P :: Pp :: Oo :: nil) (nil) 1 2 0 HBMtmp HPPpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpOom2 : rk(B :: P :: Pp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpOomtmp : rk(B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpOoeq HBCPQPpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpOomtmp;try rewrite HT2 in HBCPQPpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : A :: B :: P :: Q :: Oo ::   de rang : 4 et 4 *)
assert(HBPPpOom3 : rk(B :: P :: Pp :: Oo :: nil) >= 3).
{
	assert(HABPQOoeq : rk(A :: B :: P :: Q :: Oo :: nil) = 4) by (apply LABPQOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQOoMtmp : rk(A :: B :: P :: Q :: Oo :: nil) <= 4) by (solve_hyps_max HABPQOoeq HABPQOoM4).
	assert(HABPQPpOoeq : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LABPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpOomtmp : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpOoeq HABPQPpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (A :: B :: P :: Q :: Oo :: nil) (B :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Oo :: nil) (A :: B :: P :: Q :: Oo :: B :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: Oo :: B :: P :: Pp :: Oo :: nil) ((A :: B :: P :: Q :: Oo :: nil) ++ (B :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpOomtmp;try rewrite HT2 in HABPQPpOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: Oo :: nil) (B :: P :: Pp :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 4 HABPQPpOomtmp HBPOomtmp HABPQOoMtmp Hincl); apply HT.
}

assert(HBPPpOoM : rk(B :: P :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPPpOom : rk(B :: P :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPPpOoeq HBPPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPpOo requis par la preuve de (?)BPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPpQpOo requis par la preuve de (?)BPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPpQpOo requis par la preuve de (?)BCPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPpQpOo requis par la preuve de (?)BCPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPpQpOom2 : rk(B :: C :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Pp :: Qp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPpQpOom3 : rk(B :: C :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Qp :: nil) (B :: C :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Qp :: nil) (B :: C :: Pp :: Qp :: Oo :: nil) 3 3 HBCQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPpOo requis par la preuve de (?)BPpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Pp :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HBPpOom2 : rk(B :: Pp :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HBCPpQpOomtmp : rk(B :: C :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPpQpOoeq HBCPpQpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (B :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Pp :: Qp :: Oo :: nil) (C :: Pp :: Qp :: B :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: B :: Pp :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (B :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPpQpOomtmp;try rewrite HT2 in HBCPpQpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (B :: Pp :: Oo :: nil) (Pp :: nil) 3 1 2 HBCPpQpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBPpOom3 : rk(B :: Pp :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPPpOoeq : rk(B :: P :: Pp :: Oo :: nil) = 3) by (apply LBPPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPPpOomtmp : rk(B :: P :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBPPpOoeq HBPPpOom3).
	assert(HPpOoeq : rk(Pp :: Oo :: nil) = 2) by (apply LPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (B :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Oo :: nil) (B :: Pp :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Oo :: P :: Pp :: Oo :: nil) ((B :: Pp :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpOomtmp;try rewrite HT2 in HBPPpOomtmp.
	assert(HT := rule_2 (B :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil) (Pp :: Oo :: nil) 3 2 2 HBPPpOomtmp HPpOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HBPpOoM : rk(B :: Pp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBPpOoeq HBPpOoM3).
assert(HBPpOom : rk(B :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPpOoeq HBPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPpOo *)
(* dans la couche 0 *)
Lemma LABPPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPPpOo requis par la preuve de (?)ABPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom2 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom3 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom4 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPPp requis par la preuve de (?)ABPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm2 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm3 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpm2 : rk(B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQPpm3 : rk(B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HABCPQPpeq HABCPQPpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpmtmp;try rewrite HT2 in HABCPQPpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQPpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpm2 : rk(B :: P :: Pp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpmtmp : rk(B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HBCPQPpeq HBCPQPpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: nil) (C :: P :: Q :: B :: P :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpmtmp;try rewrite HT2 in HBCPQPpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: nil) (P :: nil) 3 1 2 HBCPQPpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPPpOo requis par la preuve de (?)ABPPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPPpOo requis par la preuve de (?)ABPPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpOom2 : rk(A :: B :: P :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Pp ::  de rang :  2 et 3 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HABPPpOom3 : rk(A :: B :: P :: Pp :: Oo :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpOomtmp : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpRpOoeq HABPRPpRpOom4).
	assert(HBPPpmtmp : rk(B :: P :: Pp :: nil) >= 2) by (solve_hyps_min HBPPpeq HBPPpm2).
	assert(Hincl : incl (B :: P :: Pp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: Oo :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (A :: B :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpOomtmp;try rewrite HT2 in HABPRPpRpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: Oo :: nil) (B :: P :: Pp :: nil) 4 2 3 HABPRPpRpOomtmp HBPPpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: P :: Oo ::  de rang :  4 et 4 	 A : A :: B :: P :: Q :: Oo ::   de rang : 4 et 4 *)
assert(HABPPpOom4 : rk(A :: B :: P :: Pp :: Oo :: nil) >= 4).
{
	assert(HABPQOoeq : rk(A :: B :: P :: Q :: Oo :: nil) = 4) by (apply LABPQOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQOoMtmp : rk(A :: B :: P :: Q :: Oo :: nil) <= 4) by (solve_hyps_max HABPQOoeq HABPQOoM4).
	assert(HABPQPpOoeq : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) = 4) by (apply LABPQPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpOomtmp : rk(A :: B :: P :: Q :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpOoeq HABPQPpOom4).
	assert(HABPOoeq : rk(A :: B :: P :: Oo :: nil) = 4) by (apply LABPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPOomtmp : rk(A :: B :: P :: Oo :: nil) >= 4) by (solve_hyps_min HABPOoeq HABPOom4).
	assert(Hincl : incl (A :: B :: P :: Oo :: nil) (list_inter (A :: B :: P :: Q :: Oo :: nil) (A :: B :: P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Oo :: nil) (A :: B :: P :: Q :: Oo :: A :: B :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: Oo :: A :: B :: P :: Pp :: Oo :: nil) ((A :: B :: P :: Q :: Oo :: nil) ++ (A :: B :: P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpOomtmp;try rewrite HT2 in HABPQPpOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: Oo :: nil) (A :: B :: P :: Pp :: Oo :: nil) (A :: B :: P :: Oo :: nil) 4 4 4 HABPQPpOomtmp HABPOomtmp HABPQOoMtmp Hincl); apply HT.
}

assert(HABPPpOoM : rk(A :: B :: P :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPPpOom : rk(A :: B :: P :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPPpOoeq HABPPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Pp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpOo requis par la preuve de (?)ABPpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpUDOom2 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpUDOom3 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpUDOom4 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpOo requis par la preuve de (?)ABPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpOo requis par la preuve de (?)ABPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpOom2 : rk(A :: B :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HABPpOom3 : rk(A :: B :: Pp :: Oo :: nil) >= 3).
{
	assert(HABQUDeq : rk(A :: B :: Q :: U :: D :: nil) = 3) by (apply LABQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQUDMtmp : rk(A :: B :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HABQUDeq HABQUDM3).
	assert(HABQPpUDOomtmp : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpUDOoeq HABQPpUDOom4).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: Q :: U :: D :: nil) (A :: B :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) (A :: B :: Q :: U :: D :: A :: B :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Q :: U :: D :: A :: B :: Pp :: Oo :: nil) ((A :: B :: Q :: U :: D :: nil) ++ (A :: B :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpUDOomtmp;try rewrite HT2 in HABQPpUDOomtmp.
	assert(HT := rule_4 (A :: B :: Q :: U :: D :: nil) (A :: B :: Pp :: Oo :: nil) (A :: B :: nil) 4 2 3 HABQPpUDOomtmp HABmtmp HABQUDMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABPpOom4 : rk(A :: B :: Pp :: Oo :: nil) >= 4).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HABPPpOoeq : rk(A :: B :: P :: Pp :: Oo :: nil) = 4) by (apply LABPPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPPpOomtmp : rk(A :: B :: P :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPPpOoeq HABPPpOom4).
	assert(HPpOoeq : rk(Pp :: Oo :: nil) = 2) by (apply LPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpOomtmp : rk(Pp :: Oo :: nil) >= 2) by (solve_hyps_min HPpOoeq HPpOom2).
	assert(Hincl : incl (Pp :: Oo :: nil) (list_inter (A :: B :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Pp :: Oo :: nil) (A :: B :: Pp :: Oo :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Oo :: P :: Pp :: Oo :: nil) ((A :: B :: Pp :: Oo :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPPpOomtmp;try rewrite HT2 in HABPPpOomtmp.
	assert(HT := rule_2 (A :: B :: Pp :: Oo :: nil) (P :: Pp :: Oo :: nil) (Pp :: Oo :: nil) 4 2 2 HABPPpOomtmp HPpOomtmp HPPpOoMtmp Hincl);apply HT.
}

assert(HABPpOoM : rk(A :: B :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPpOom : rk(A :: B :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPpOoeq HABPpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBRPpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R :: Pp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BRPpOo requis par la preuve de (?)BRPpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom2 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom3 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom4 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpUpOom2 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpUpOom3 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABRPpQpUpOom4 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABRPpQpRpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpRpUpOoeq HABRPpQpRpUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpRpUpOomtmp;try rewrite HT2 in HABRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABRPpQpRpUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpQpUpOom2 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: R :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBRPpQpUpOom3 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABRPpQpRpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpRpUpOoeq HABRPpQpRpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpRpUpOomtmp;try rewrite HT2 in HABRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABRPpQpRpUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBRPpQpUpOom4 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABRPpQpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpUpOoeq HABRPpQpUpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpUpOomtmp;try rewrite HT2 in HABRPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABRPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BRPpOo requis par la preuve de (?)BRPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BRPpOo requis par la preuve de (?)BRPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpOom2 : rk(B :: R :: Pp :: Oo :: nil) >= 2).
{
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: R :: nil) (B :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: nil) (B :: R :: Pp :: Oo :: nil) 2 2 HBRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBRPpOom3 : rk(B :: R :: Pp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBRPpQpUpOomtmp : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBRPpQpUpOoeq HBRPpQpUpOom4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: R :: Pp :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: B :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: R :: Pp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBRPpQpUpOomtmp;try rewrite HT2 in HBRPpQpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: R :: Pp :: Oo :: nil) (B :: nil) 4 1 2 HBRPpQpUpOomtmp HBmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpOoM3 : rk(B :: R :: Pp :: Oo :: nil) <= 3).
{
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOoMtmp : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBPRPpOoeq HBPRPpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Pp :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: R :: Pp :: Oo :: nil) (B :: P :: R :: Pp :: Oo :: nil) 3 3 HBPRPpOoMtmp Hcomp Hincl);apply HT.
}

assert(HBRPpOoM : rk(B :: R :: Pp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBRPpOom : rk(B :: R :: Pp :: Oo ::  nil) >= 1) by (solve_hyps_min HBRPpOoeq HBRPpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQpOo *)
(* dans constructLemma(), requis par LPPpQpOo *)
(* dans la couche 0 *)
Lemma LBPRPpQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpOo requis par la preuve de (?)BPRPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)BPRPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpOo requis par la preuve de (?)BPRPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpOo requis par la preuve de (?)BPRPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpOo requis par la preuve de (?)BCPQRPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpOo requis par la preuve de (?)BCPQRPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpOo requis par la preuve de (?)BPRPpQpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpOom2 : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpOoeq HBCPQRPpQpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpOomtmp;try rewrite HT2 in HBCPQRPpQpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpOom3 : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpOoeq HABPRPpQpRpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpOomtmp;try rewrite HT2 in HABPRPpQpRpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpQpOom4 : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBPRPpQpUpOoeq : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LBPRPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpUpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUpOoeq HBPRPpQpUpOom4).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: B :: P :: R :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: P :: R :: Pp :: Qp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: P :: R :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUpOomtmp;try rewrite HT2 in HBPRPpQpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Oo :: nil) (B :: Qp :: nil) 4 2 2 HBPRPpQpUpOomtmp HBQpmtmp HBQpUpMtmp Hincl); apply HT.
}

assert(HBPRPpQpOoM : rk(B :: P :: R :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpQpOom : rk(B :: P :: R :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpQpOoeq HBPRPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPPpQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Pp :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APPpQpRpOo requis par la preuve de (?)PPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRp requis par la preuve de (?)APPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRp requis par la preuve de (?)PPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPPpRpm2 : rk(P :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpeq : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) = 4) by (apply LAPQRPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRPpQpRpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((P :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpmtmp;try rewrite HT2 in HAPQRPpQpRpmtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (Rp :: nil) 4 1 3 HAPQRPpQpRpmtmp HRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)APPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpRp requis par la preuve de (?)ABCPQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm2 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpRpm3 : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpRp requis par la preuve de (?)ACPQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpRpm2 : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : A :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HACPQPpRpm3 : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpRpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPQPpRpeq HABCPQPpRpm3).
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hincl : incl (A :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: A :: C :: P :: Q :: Pp :: Rp :: nil) ((A :: B :: C :: Q :: nil) ++ (A :: C :: P :: Q :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpRpmtmp;try rewrite HT2 in HABCPQPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: nil) 3 3 3 HABCPQPpRpmtmp HACQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpRp requis par la preuve de (?)APPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpRpm2 : rk(A :: P :: Pp :: Rp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpRpmtmp : rk(A :: C :: P :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HACPQPpRpeq HACPQPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Rp :: nil) (C :: P :: Q :: A :: P :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Rp :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpRpmtmp;try rewrite HT2 in HACPQPpRpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HACPQPpRpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HAPPpRpm3 : rk(A :: P :: Pp :: Rp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpeq : rk(A :: B :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LABPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpRpmtmp : rk(A :: B :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABPRPpRpeq HABPRPpRpm4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HPPpRpeq HPPpRpm2).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (A :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: nil) (A :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((A :: P :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpmtmp;try rewrite HT2 in HABPRPpRpmtmp.
	assert(HT := rule_2 (A :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: Pp :: Rp :: nil) 4 2 3 HABPRPpRpmtmp HPPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpQpRpOo requis par la preuve de (?)APPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)APPpQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)ACPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)ACPQPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpQpRpOom2 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpQpRpOom3 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpQpRpOo requis par la preuve de (?)APPpQpRpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpQpRpOom2 : rk(A :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpQpRpOomtmp : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQPpQpRpOoeq HACPQPpQpRpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (C :: P :: Q :: A :: P :: Pp :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: Qp :: Rp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpQpRpOomtmp;try rewrite HT2 in HACPQPpQpRpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: Qp :: Rp :: Oo :: nil) (P :: nil) 3 1 2 HACPQPpQpRpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAPPpQpRpOom3 : rk(A :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HAPPpRpmtmp : rk(A :: P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAPPpRpeq HAPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Pp :: Rp :: nil) (A :: P :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Pp :: Rp :: nil) (A :: P :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HAPPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpQpOo requis par la preuve de (?)PPpQpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HPPpQpOoM3 : rk(P :: Pp :: Qp :: Oo :: nil) <= 3).
{
	assert(HQpMtmp : rk(Qp :: nil) <= 1) by (solve_hyps_max HQpeq HQpM1).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Qp :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Oo :: nil) (Qp :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Qp :: P :: Pp :: Oo :: nil) ((Qp :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Qp :: nil) (P :: Pp :: Oo :: nil) (nil) 1 2 0 HQpMtmp HPPpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Pp :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HPPpQpOom2 : rk(P :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPPpQpRpOomtmp : rk(A :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HAPPpQpRpOoeq HAPPpQpRpOom3).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (P :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: P :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: P :: Pp :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (P :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPPpQpRpOomtmp;try rewrite HT2 in HAPPpQpRpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (P :: Pp :: Qp :: Oo :: nil) (Qp :: nil) 3 1 2 HAPPpQpRpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Oo ::  de rang :  2 et 2 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HPPpQpOom3 : rk(P :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpOoeq : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) = 4) by (apply LBPRPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpOoeq HBPRPpQpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (P :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Oo :: nil) (B :: P :: R :: Oo :: P :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: P :: Pp :: Qp :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (P :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpOomtmp;try rewrite HT2 in HBPRPpQpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (P :: Pp :: Qp :: Oo :: nil) (P :: Oo :: nil) 4 2 3 HBPRPpQpOomtmp HPOomtmp HBPROoMtmp Hincl); apply HT.
}

assert(HPPpQpOoM : rk(P :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPPpQpOom : rk(P :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HPPpQpOoeq HPPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Qp :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour QpOo requis par la preuve de (?)QpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: Qp :: Oo ::  de rang :  3 et 3 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HQpOom2 : rk(Qp :: Oo :: nil) >= 2).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPPpQpOoeq : rk(P :: Pp :: Qp :: Oo :: nil) = 3) by (apply LPPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPPpQpOomtmp : rk(P :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HPPpQpOoeq HPPpQpOom3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Oo :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: Qp :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpQpOomtmp;try rewrite HT2 in HPPpQpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (Qp :: Oo :: nil) (Oo :: nil) 3 1 2 HPPpQpOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

assert(HQpOoM : rk(Qp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HQpOoeq HQpOoM2).
assert(HQpOom : rk(Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HQpOoeq HQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAQpOo *)
(* dans constructLemma(), requis par LAQQpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpOo requis par la preuve de (?)ABQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpOo requis par la preuve de (?)ABQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpOo requis par la preuve de (?)ABQPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpOoeq HABQPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQQpOo requis par la preuve de (?)AQQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQQpOo requis par la preuve de (?)AQQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpOo requis par la preuve de (?)AQQpOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAQQpOoM3 : rk(A :: Q :: Qp :: Oo :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Oo :: nil) (A :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Qp :: Oo :: nil) ((A :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Q :: Qp :: Oo :: nil) (nil) 1 2 0 HAMtmp HQQpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpOom2 : rk(A :: Q :: Qp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQQpOom3 : rk(A :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LABQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpOoeq HABQPpQpRpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpOomtmp;try rewrite HT2 in HABQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: Oo :: nil) (A :: Qp :: nil) 4 2 3 HABQPpQpRpOomtmp HAQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HAQQpOoM : rk(A :: Q :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpOom : rk(A :: Q :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpOoeq HAQQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQpOo requis par la preuve de (?)AQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AQpOo requis par la preuve de (?)AQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQpOom2 : rk(A :: Qp :: Oo :: nil) >= 2).
{
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: nil) (A :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: nil) (A :: Qp :: Oo :: nil) 2 2 HAQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAQpOom3 : rk(A :: Qp :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HAQQpOoeq : rk(A :: Q :: Qp :: Oo :: nil) = 3) by (apply LAQQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpOomtmp : rk(A :: Q :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HAQQpOoeq HAQQpOom3).
	assert(HQpOoeq : rk(Qp :: Oo :: nil) = 2) by (apply LQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpOomtmp : rk(Qp :: Oo :: nil) >= 2) by (solve_hyps_min HQpOoeq HQpOom2).
	assert(Hincl : incl (Qp :: Oo :: nil) (list_inter (A :: Qp :: Oo :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Oo :: nil) (A :: Qp :: Oo :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Oo :: Q :: Qp :: Oo :: nil) ((A :: Qp :: Oo :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpOomtmp;try rewrite HT2 in HAQQpOomtmp.
	assert(HT := rule_2 (A :: Qp :: Oo :: nil) (Q :: Qp :: Oo :: nil) (Qp :: Oo :: nil) 3 2 2 HAQQpOomtmp HQpOomtmp HQQpOoMtmp Hincl);apply HT.
}

assert(HAQpOoM : rk(A :: Qp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAQpOoeq HAQpOoM3).
assert(HAQpOom : rk(A :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQpOoeq HAQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQpOo *)
(* dans la couche 0 *)
Lemma LBPPpQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Pp :: Qp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpOo requis par la preuve de (?)BPPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)ABPPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)ABPPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpQpUpOom2 : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpQpUpOom3 : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BCPQPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BCPQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUpOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUpOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUpOom2 : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUpOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUpOoeq HBCPQPpQpUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUpOomtmp;try rewrite HT2 in HBCPQPpQpUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPPpQpUpOom3 : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPPpQpUpOomtmp : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HABPPpQpUpOoeq HABPPpQpUpOom3).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPPpQpUpOomtmp;try rewrite HT2 in HABPPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 3 2 2 HABPPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpOo requis par la preuve de (?)BPPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpOo requis par la preuve de (?)BPPpQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpOo requis par la preuve de (?)BCPQPpQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpOo requis par la preuve de (?)BCPQPpQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpOo requis par la preuve de (?)BPPpQpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpOom2 : rk(B :: P :: Pp :: Qp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpOoeq HBCPQPpQpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpOomtmp;try rewrite HT2 in HBCPQPpQpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: P :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : B :: Qp ::  de rang :  2 et 2 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBPPpQpOom3 : rk(B :: P :: Pp :: Qp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBPPpQpUpOomtmp : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBPPpQpUpOoeq HBPPpQpUpOom3).
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hincl : incl (B :: Qp :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: P :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: B :: P :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: P :: Pp :: Qp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: P :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpQpUpOomtmp;try rewrite HT2 in HBPPpQpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: P :: Pp :: Qp :: Oo :: nil) (B :: Qp :: nil) 3 2 2 HBPPpQpUpOomtmp HBQpmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpOom4 : rk(B :: P :: Pp :: Qp :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpOoeq : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) = 4) by (apply LBPRPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpOoeq HBPRPpQpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpOomtmp;try rewrite HT2 in HBPRPpQpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

assert(HBPPpQpOoM : rk(B :: P :: Pp :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPPpQpOom : rk(B :: P :: Pp :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPPpQpOoeq HBPPpQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQpOo requis par la preuve de (?)BQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BQpOo requis par la preuve de (?)BQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpOom2 : rk(B :: Qp :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: P :: Pp :: Qp :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HBQpOom3 : rk(B :: Qp :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPPpQpOoeq : rk(B :: P :: Pp :: Qp :: Oo :: nil) = 4) by (apply LBPPpQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPPpQpOomtmp : rk(B :: P :: Pp :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HBPPpQpOoeq HBPPpQpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (B :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Qp :: Oo :: nil) (P :: Pp :: Oo :: B :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: B :: Qp :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (B :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpQpOomtmp;try rewrite HT2 in HBPPpQpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (B :: Qp :: Oo :: nil) (Oo :: nil) 4 1 2 HBPPpQpOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

assert(HBQpOoM : rk(B :: Qp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBQpOoeq HBQpOoM3).
assert(HBQpOom : rk(B :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQpOoeq HBQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABQpOo *)
(* dans la couche 0 *)
Lemma LABQQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Qp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQQpOo requis par la preuve de (?)ABQQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQQpOo requis par la preuve de (?)ABQQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQQpOo requis par la preuve de (?)ABQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpOom2 : rk(A :: B :: Q :: Qp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Qp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpOom3 : rk(A :: B :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Qp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQQpOom4 : rk(A :: B :: Q :: Qp :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LABQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpOoeq HABQPpQpRpOom4).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hincl : incl (A :: B :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpOomtmp;try rewrite HT2 in HABQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: Oo :: nil) (A :: B :: Qp :: nil) 4 3 3 HABQPpQpRpOomtmp HABQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQQpOoM : rk(A :: B :: Q :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQQpOom : rk(A :: B :: Q :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQQpOoeq HABQQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Qp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQpOo requis par la preuve de (?)ABQpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQpOo requis par la preuve de (?)ABQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQpOo requis par la preuve de (?)ABQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpOom2 : rk(A :: B :: Qp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Qp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpOom3 : rk(A :: B :: Qp :: Oo :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: Qp :: Oo :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABQpOom4 : rk(A :: B :: Qp :: Oo :: nil) >= 4).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HABQQpOoeq : rk(A :: B :: Q :: Qp :: Oo :: nil) = 4) by (apply LABQQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQQpOomtmp : rk(A :: B :: Q :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HABQQpOoeq HABQQpOom4).
	assert(HQpOoeq : rk(Qp :: Oo :: nil) = 2) by (apply LQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpOomtmp : rk(Qp :: Oo :: nil) >= 2) by (solve_hyps_min HQpOoeq HQpOom2).
	assert(Hincl : incl (Qp :: Oo :: nil) (list_inter (A :: B :: Qp :: Oo :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Qp :: Oo :: nil) (A :: B :: Qp :: Oo :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Qp :: Oo :: Q :: Qp :: Oo :: nil) ((A :: B :: Qp :: Oo :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQQpOomtmp;try rewrite HT2 in HABQQpOomtmp.
	assert(HT := rule_2 (A :: B :: Qp :: Oo :: nil) (Q :: Qp :: Oo :: nil) (Qp :: Oo :: nil) 4 2 2 HABQQpOomtmp HQpOomtmp HQQpOoMtmp Hincl);apply HT.
}

assert(HABQpOoM : rk(A :: B :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQpOom : rk(A :: B :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQpOoeq HABQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LCPQpOo *)
(* dans constructLemma(), requis par LCPQQpOo *)
(* dans constructLemma(), requis par LCPQPpQpRpOo *)
(* dans la couche 0 *)
Lemma LACPQPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)ACPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)ACPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpQpRpOo requis par la preuve de (?)ACPQPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpQpRpOom2 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpQpRpOom3 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpQpRpOom4 : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HACPQPpQpRpOoM : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACPQPpQpRpOom : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HACPQPpQpRpOoeq HACPQPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPQPpQpRpOo requis par la preuve de (?)CPQPpQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRp requis par la preuve de (?)CPPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRp requis par la preuve de (?)PPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPPpRpm2 : rk(P :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpeq : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) = 4) by (apply LAPQRPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRPpQpRpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((P :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpmtmp;try rewrite HT2 in HAPQRPpQpRpmtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (Rp :: nil) 4 1 3 HAPQRPpQpRpmtmp HRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)CPPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm2 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm3 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpRpm2 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCPRPpRpm3 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCPRPpRpmtmp : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPRPpRpeq HABCPRPpRpm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: R :: Pp :: Rp :: nil) (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPRPpRpmtmp;try rewrite HT2 in HABCPRPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) (B :: C :: R :: nil) 3 3 3 HABCPRPpRpmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPPpRpm2 : rk(C :: P :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPRPpRpmtmp : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBCPRPpRpeq HBCPRPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Rp :: nil) (B :: P :: R :: C :: P :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Pp :: Rp :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpRpmtmp;try rewrite HT2 in HBCPRPpRpmtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HBCPRPpRpmtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HCPPpRpm3 : rk(C :: P :: Pp :: Rp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBCPRPpRpeq : rk(B :: C :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LBCPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpRpmtmp : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCPRPpRpeq HBCPRPpRpm4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HPPpRpeq HPPpRpm2).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (C :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Rp :: nil) (C :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((C :: P :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpRpmtmp;try rewrite HT2 in HBCPRPpRpmtmp.
	assert(HT := rule_2 (C :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: Pp :: Rp :: nil) 4 2 3 HBCPRPpRpmtmp HPPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQPpQpRpOo requis par la preuve de (?)CPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpQpRpOo requis par la preuve de (?)CPQPpQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpQpRpOo requis par la preuve de (?)ABCPQPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpQpRpOo requis par la preuve de (?)ABCPQPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpOom2 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpQpRpOom3 : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQPpQpRpOo requis par la preuve de (?)CPQPpQpRpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQPpQpRpOom2 : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpQpRpOomtmp : rk(A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQPpQpRpOoeq HABCPQPpQpRpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpQpRpOomtmp;try rewrite HT2 in HABCPQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQPpQpRpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HCPQPpQpRpOom3 : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HCPPpRpmtmp : rk(C :: P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HCPPpRpeq HCPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: P :: Pp :: Rp :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: P :: Pp :: Rp :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HCPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HCPQPpQpRpOom4 : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HACPQPpQpRpOoeq : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LACPQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACPQPpQpRpOomtmp : rk(A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HACPQPpQpRpOoeq HACPQPpQpRpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpQpRpOomtmp;try rewrite HT2 in HACPQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HACPQPpQpRpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HCPQPpQpRpOoM : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQPpQpRpOom : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQPpQpRpOoeq HCPQPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Q :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPQQpOo requis par la preuve de (?)CPQQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQQpOo requis par la preuve de (?)CPQQpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQQpOo requis par la preuve de (?)CPQQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQQpOo requis par la preuve de (?)ABCPQQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQQpOo requis par la preuve de (?)ABCPQQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpOom2 : rk(A :: B :: C :: P :: Q :: Qp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Qp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQQpOom3 : rk(A :: B :: C :: P :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Qp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQQpOo requis par la preuve de (?)CPQQpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQQpOom2 : rk(C :: P :: Q :: Qp :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQQpOomtmp : rk(A :: B :: C :: P :: Q :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQQpOoeq HABCPQQpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Qp :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Qp :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQQpOomtmp;try rewrite HT2 in HABCPQQpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Qp :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQQpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HCPQQpOoM3 : rk(C :: P :: Q :: Qp :: Oo :: nil) <= 3).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (C :: P :: Q :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Qp :: Oo :: nil) (C :: P :: Q :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: Q :: Qp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: P :: Q :: nil) (Q :: Qp :: Oo :: nil) (Q :: nil) 2 2 1 HCPQMtmp HQQpOoMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : C :: Qp ::  de rang :  2 et 2 	 A : C :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HCPQQpOom3 : rk(C :: P :: Q :: Qp :: Oo :: nil) >= 3).
{
	assert(HCPpQpRpeq : rk(C :: Pp :: Qp :: Rp :: nil) = 3) by (apply LCPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpRpMtmp : rk(C :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HCPpQpRpeq HCPpQpRpM3).
	assert(HCPQPpQpRpOoeq : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LCPQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpQpRpOomtmp : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HCPQPpQpRpOoeq HCPQPpQpRpOom4).
	assert(HCQpeq : rk(C :: Qp :: nil) = 2) by (apply LCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQpmtmp : rk(C :: Qp :: nil) >= 2) by (solve_hyps_min HCQpeq HCQpm2).
	assert(Hincl : incl (C :: Qp :: nil) (list_inter (C :: Pp :: Qp :: Rp :: nil) (C :: P :: Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (C :: Pp :: Qp :: Rp :: C :: P :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: Rp :: C :: P :: Q :: Qp :: Oo :: nil) ((C :: Pp :: Qp :: Rp :: nil) ++ (C :: P :: Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQPpQpRpOomtmp;try rewrite HT2 in HCPQPpQpRpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: Rp :: nil) (C :: P :: Q :: Qp :: Oo :: nil) (C :: Qp :: nil) 4 2 3 HCPQPpQpRpOomtmp HCQpmtmp HCPpQpRpMtmp Hincl); apply HT.
}

assert(HCPQQpOoM : rk(C :: P :: Q :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQQpOom : rk(C :: P :: Q :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQQpOoeq HCPQQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPQpOo requis par la preuve de (?)CPQpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQpOo requis par la preuve de (?)CPQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRQpOo requis par la preuve de (?)CPQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRQpOo requis par la preuve de (?)BCPRQpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRQpOo requis par la preuve de (?)BCPRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRQpOom2 : rk(B :: C :: P :: R :: Qp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Qp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRQpOom3 : rk(B :: C :: P :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Qp :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQpOo requis par la preuve de (?)CPQpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Qp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPQpOom2 : rk(C :: P :: Qp :: Oo :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPRQpOomtmp : rk(B :: C :: P :: R :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPRQpOoeq HBCPRQpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Qp :: Oo :: nil) (B :: P :: R :: C :: P :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Qp :: Oo :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRQpOomtmp;try rewrite HT2 in HBCPRQpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Qp :: Oo :: nil) (P :: nil) 3 1 2 HBCPRQpOomtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCPQpOom3 : rk(C :: P :: Qp :: Oo :: nil) >= 3).
{
	assert(HCPOoeq : rk(C :: P :: Oo :: nil) = 3) by (apply LCPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPOomtmp : rk(C :: P :: Oo :: nil) >= 3) by (solve_hyps_min HCPOoeq HCPOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: P :: Oo :: nil) (C :: P :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: P :: Oo :: nil) (C :: P :: Qp :: Oo :: nil) 3 3 HCPOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCPQpOoM3 : rk(C :: P :: Qp :: Oo :: nil) <= 3).
{
	assert(HCPQQpOoeq : rk(C :: P :: Q :: Qp :: Oo :: nil) = 3) by (apply LCPQQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQQpOoMtmp : rk(C :: P :: Q :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQQpOoeq HCPQQpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: P :: Qp :: Oo :: nil) (C :: P :: Q :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: P :: Qp :: Oo :: nil) (C :: P :: Q :: Qp :: Oo :: nil) 3 3 HCPQQpOoMtmp Hcomp Hincl);apply HT.
}

assert(HCPQpOoM : rk(C :: P :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQpOom : rk(C :: P :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQpOoeq HCPQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LARQpOo *)
(* dans constructLemma(), requis par LAQRQpOo *)
(* dans constructLemma(), requis par LAQRQpRpOo *)
(* dans la couche 0 *)
Lemma LAQRQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: Qp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRQpOo requis par la preuve de (?)AQRQpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpOo requis par la preuve de (?)AQRQpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpOo requis par la preuve de (?)AQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpOom2 : rk(A :: Q :: R :: Qp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQRQpOoM3 : rk(A :: Q :: R :: Qp :: Oo :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (A :: Q :: R :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Oo :: nil) (A :: Q :: R :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Q :: Qp :: Oo :: nil) ((A :: Q :: R :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (Q :: Qp :: Oo :: nil) (Q :: nil) 2 2 1 HAQRMtmp HQQpOoMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRQpRpOo requis par la preuve de (?)AQRQpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpRpOo requis par la preuve de (?)AQRQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpRpOo requis par la preuve de (?)AQRQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpOom2 : rk(A :: Q :: R :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: Rp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpRpOom3 : rk(A :: Q :: R :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 4*)
assert(HAQRQpRpOoM3 : rk(A :: Q :: R :: Qp :: Rp :: Oo :: nil) <= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAQRQpOoMtmp : rk(A :: Q :: R :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HAQRQpOoeq HAQRQpOoM3).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: A :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: Q :: R :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Oo :: nil) (A :: Qp :: nil) 2 3 2 HAQpRpMtmp HAQRQpOoMtmp HAQpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAQRQpRpOoM : rk(A :: Q :: R :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRQpRpOom : rk(A :: Q :: R :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQRQpRpOoeq HAQRQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQRQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: R :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQRQpOo requis par la preuve de (?)AQRQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRQpOo requis par la preuve de (?)AQRQpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRQpOo requis par la preuve de (?)AQRQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRQpOom2 : rk(A :: Q :: R :: Qp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: R :: Qp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAQRQpOoM3 : rk(A :: Q :: R :: Qp :: Oo :: nil) <= 3).
{
	assert(HAQRMtmp : rk(A :: Q :: R :: nil) <= 2) by (solve_hyps_max HAQReq HAQRM2).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (A :: Q :: R :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Oo :: nil) (A :: Q :: R :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Q :: Qp :: Oo :: nil) ((A :: Q :: R :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Q :: R :: nil) (Q :: Qp :: Oo :: nil) (Q :: nil) 2 2 1 HAQRMtmp HQQpOoMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Q :: R :: Qp :: Rp :: Oo ::  de rang :  3 et 3 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAQRQpOom3 : rk(A :: Q :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAQRQpRpOoeq : rk(A :: Q :: R :: Qp :: Rp :: Oo :: nil) = 3) by (apply LAQRQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpOomtmp : rk(A :: Q :: R :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HAQRQpRpOoeq HAQRQpRpOom3).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: R :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: A :: Q :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: Q :: R :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRQpRpOomtmp;try rewrite HT2 in HAQRQpRpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: Q :: R :: Qp :: Oo :: nil) (A :: Qp :: nil) 3 2 2 HAQRQpRpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HAQRQpOoM : rk(A :: Q :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRQpOom : rk(A :: Q :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQRQpOoeq HAQRQpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARQpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Qp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARQpOo requis par la preuve de (?)ARQpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpOom2 : rk(A :: R :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Qp :: Rp :: Oo :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpOom3 : rk(A :: R :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARQpOo requis par la preuve de (?)ARQpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARQpOo requis par la preuve de (?)ARQpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpOom2 : rk(A :: R :: Qp :: Oo :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Qp :: Oo :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: R :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HARQpOom3 : rk(A :: R :: Qp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HARQpRpOomtmp : rk(A :: R :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HARQpRpOoeq HARQpRpOom3).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: R :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: A :: R :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: R :: Qp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: R :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HARQpRpOomtmp;try rewrite HT2 in HARQpRpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: R :: Qp :: Oo :: nil) (A :: Qp :: nil) 3 2 2 HARQpRpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpOoM3 : rk(A :: R :: Qp :: Oo :: nil) <= 3).
{
	assert(HAQRQpOoeq : rk(A :: Q :: R :: Qp :: Oo :: nil) = 3) by (apply LAQRQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpOoMtmp : rk(A :: Q :: R :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HAQRQpOoeq HAQRQpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Qp :: Oo :: nil) (A :: Q :: R :: Qp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: R :: Qp :: Oo :: nil) (A :: Q :: R :: Qp :: Oo :: nil) 3 3 HAQRQpOoMtmp Hcomp Hincl);apply HT.
}

assert(HARQpOoM : rk(A :: R :: Qp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARQpOom : rk(A :: R :: Qp :: Oo ::  nil) >= 1) by (solve_hyps_min HARQpOoeq HARQpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpOo *)
(* dans constructLemma(), requis par LCPQpRpOo *)
(* dans la couche 0 *)
Lemma LCPPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPPpQpRpOo requis par la preuve de (?)CPPpQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PPpRp requis par la preuve de (?)CPPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PPpRp requis par la preuve de (?)PPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HPPpRpm2 : rk(P :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpeq : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) = 4) by (apply LAPQRPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRPpQpRpmtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpeq HAPQRPpQpRpm4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: nil) (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Rp :: A :: Q :: R :: Qp :: Rp :: nil) ((P :: Pp :: Rp :: nil) ++ (A :: Q :: R :: Qp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpmtmp;try rewrite HT2 in HAPQRPpQpRpmtmp.
	assert(HT := rule_2 (P :: Pp :: Rp :: nil) (A :: Q :: R :: Qp :: Rp :: nil) (Rp :: nil) 4 1 3 HAPQRPpQpRpmtmp HRpmtmp HAQRQpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)CPPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPRPpRp requis par la preuve de (?)ABCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm2 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPRPpRpm3 : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: C :: P :: R :: Pp :: Rp :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpRp requis par la preuve de (?)BCPRPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpRpm2 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : B :: C :: R ::  de rang :  3 et 3 	 A : A :: B :: C :: R ::   de rang : 3 et 3 *)
assert(HBCPRPpRpm3 : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 3).
{
	assert(HABCReq : rk(A :: B :: C :: R :: nil) = 3) by (apply LABCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCRMtmp : rk(A :: B :: C :: R :: nil) <= 3) by (solve_hyps_max HABCReq HABCRM3).
	assert(HABCPRPpRpmtmp : rk(A :: B :: C :: P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HABCPRPpRpeq HABCPRPpRpm3).
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hincl : incl (B :: C :: R :: nil) (list_inter (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: R :: Pp :: Rp :: nil) (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: R :: B :: C :: P :: R :: Pp :: Rp :: nil) ((A :: B :: C :: R :: nil) ++ (B :: C :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPRPpRpmtmp;try rewrite HT2 in HABCPRPpRpmtmp.
	assert(HT := rule_4 (A :: B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Rp :: nil) (B :: C :: R :: nil) 3 3 3 HABCPRPpRpmtmp HBCRmtmp HABCRMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPPpRp requis par la preuve de (?)CPPpRp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Rp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPPpRpm2 : rk(C :: P :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPRPpRpmtmp : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBCPRPpRpeq HBCPRPpRpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Rp :: nil) (B :: P :: R :: C :: P :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Pp :: Rp :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpRpmtmp;try rewrite HT2 in HBCPRPpRpmtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Pp :: Rp :: nil) (P :: nil) 3 1 2 HBCPRPpRpmtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HCPPpRpm3 : rk(C :: P :: Pp :: Rp :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBCPRPpRpeq : rk(B :: C :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LBCPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpRpmtmp : rk(B :: C :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBCPRPpRpeq HBCPRPpRpm4).
	assert(HPPpRpmtmp : rk(P :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HPPpRpeq HPPpRpm2).
	assert(Hincl : incl (P :: Pp :: Rp :: nil) (list_inter (C :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Rp :: nil) (C :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((C :: P :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpRpmtmp;try rewrite HT2 in HBCPRPpRpmtmp.
	assert(HT := rule_2 (C :: P :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (P :: Pp :: Rp :: nil) 4 2 3 HBCPRPpRpmtmp HPPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPPpQpRpOo requis par la preuve de (?)CPPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpRpOo requis par la preuve de (?)CPPpQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpRpOo requis par la preuve de (?)BCPRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpRpOo requis par la preuve de (?)BCPRPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpRpOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPPpQpRpOo requis par la preuve de (?)CPPpQpRpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPPpQpRpOom2 : rk(C :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPRPpQpRpOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPRPpQpRpOoeq HBCPRPpQpRpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) (B :: P :: R :: C :: P :: Pp :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Pp :: Qp :: Rp :: Oo :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpRpOomtmp;try rewrite HT2 in HBCPRPpQpRpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil) (P :: nil) 3 1 2 HBCPRPpQpRpOomtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HCPPpQpRpOom3 : rk(C :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HCPPpRpmtmp : rk(C :: P :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HCPPpRpeq HCPPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: P :: Pp :: Rp :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: P :: Pp :: Rp :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HCPPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: P :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : C :: P :: Oo ::  de rang :  3 et 3 	 A : C :: P :: Q :: Oo ::   de rang : 3 et 3 *)
assert(HCPPpQpRpOom4 : rk(C :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HCPQOoeq : rk(C :: P :: Q :: Oo :: nil) = 3) by (apply LCPQOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQOoMtmp : rk(C :: P :: Q :: Oo :: nil) <= 3) by (solve_hyps_max HCPQOoeq HCPQOoM3).
	assert(HCPQPpQpRpOoeq : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LCPQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpQpRpOomtmp : rk(C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HCPQPpQpRpOoeq HCPQPpQpRpOom4).
	assert(HCPOoeq : rk(C :: P :: Oo :: nil) = 3) by (apply LCPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPOomtmp : rk(C :: P :: Oo :: nil) >= 3) by (solve_hyps_min HCPOoeq HCPOom3).
	assert(Hincl : incl (C :: P :: Oo :: nil) (list_inter (C :: P :: Q :: Oo :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (C :: P :: Q :: Oo :: C :: P :: Pp :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: Oo :: C :: P :: Pp :: Qp :: Rp :: Oo :: nil) ((C :: P :: Q :: Oo :: nil) ++ (C :: P :: Pp :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQPpQpRpOomtmp;try rewrite HT2 in HCPQPpQpRpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: Oo :: nil) (C :: P :: Pp :: Qp :: Rp :: Oo :: nil) (C :: P :: Oo :: nil) 4 3 3 HCPQPpQpRpOomtmp HCPOomtmp HCPQOoMtmp Hincl); apply HT.
}

assert(HCPPpQpRpOoM : rk(C :: P :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPPpQpRpOom : rk(C :: P :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPPpQpRpOoeq HCPPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCPQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(C :: P :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CPQpRpOo requis par la preuve de (?)CPQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQpRpOo requis par la preuve de (?)CPQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRQpRpOo requis par la preuve de (?)CPQpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRQpRpOo requis par la preuve de (?)BCPRQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRQpRpOo requis par la preuve de (?)BCPRQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRQpRpOom2 : rk(B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRQpRpOom3 : rk(B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQpRpOo requis par la preuve de (?)CPQpRpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : B :: P :: R ::   de rang : 2 et 2 *)
assert(HCPQpRpOom2 : rk(C :: P :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBPRMtmp : rk(B :: P :: R :: nil) <= 2) by (solve_hyps_max HBPReq HBPRM2).
	assert(HBCPRQpRpOomtmp : rk(B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPRQpRpOoeq HBCPRQpRpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (B :: P :: R :: nil) (C :: P :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Qp :: Rp :: Oo :: nil) (B :: P :: R :: C :: P :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: C :: P :: Qp :: Rp :: Oo :: nil) ((B :: P :: R :: nil) ++ (C :: P :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRQpRpOomtmp;try rewrite HT2 in HBCPRQpRpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: nil) (C :: P :: Qp :: Rp :: Oo :: nil) (P :: nil) 3 1 2 HBCPRQpRpOomtmp HPmtmp HBPRMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCPQpRpOom3 : rk(C :: P :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HCPOoeq : rk(C :: P :: Oo :: nil) = 3) by (apply LCPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPOomtmp : rk(C :: P :: Oo :: nil) >= 3) by (solve_hyps_min HCPOoeq HCPOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: P :: Oo :: nil) (C :: P :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: P :: Oo :: nil) (C :: P :: Qp :: Rp :: Oo :: nil) 3 3 HCPOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : C :: P :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : P :: Oo ::  de rang :  2 et 2 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HCPQpRpOom4 : rk(C :: P :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HCPPpQpRpOoeq : rk(C :: P :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LCPPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPPpQpRpOomtmp : rk(C :: P :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HCPPpQpRpOoeq HCPPpQpRpOom4).
	assert(HPOoeq : rk(P :: Oo :: nil) = 2) by (apply LPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPOomtmp : rk(P :: Oo :: nil) >= 2) by (solve_hyps_min HPOoeq HPOom2).
	assert(Hincl : incl (P :: Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (C :: P :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Pp :: Qp :: Rp :: Oo :: nil) (P :: Pp :: Oo :: C :: P :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: C :: P :: Qp :: Rp :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (C :: P :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPPpQpRpOomtmp;try rewrite HT2 in HCPPpQpRpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (C :: P :: Qp :: Rp :: Oo :: nil) (P :: Oo :: nil) 4 2 2 HCPPpQpRpOomtmp HPOomtmp HPPpOoMtmp Hincl); apply HT.
}

assert(HCPQpRpOoM : rk(C :: P :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCPQpRpOom : rk(C :: P :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HCPQpRpOoeq HCPQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour RpOo requis par la preuve de (?)RpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : C :: P :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : C :: P :: Qp :: Oo ::   de rang : 3 et 3 *)
assert(HRpOom2 : rk(Rp :: Oo :: nil) >= 2).
{
	assert(HCPQpOoeq : rk(C :: P :: Qp :: Oo :: nil) = 3) by (apply LCPQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQpOoMtmp : rk(C :: P :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQpOoeq HCPQpOoM3).
	assert(HCPQpRpOoeq : rk(C :: P :: Qp :: Rp :: Oo :: nil) = 4) by (apply LCPQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQpRpOomtmp : rk(C :: P :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HCPQpRpOoeq HCPQpRpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (C :: P :: Qp :: Oo :: nil) (Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Qp :: Rp :: Oo :: nil) (C :: P :: Qp :: Oo :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Qp :: Oo :: Rp :: Oo :: nil) ((C :: P :: Qp :: Oo :: nil) ++ (Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQpRpOomtmp;try rewrite HT2 in HCPQpRpOomtmp.
	assert(HT := rule_4 (C :: P :: Qp :: Oo :: nil) (Rp :: Oo :: nil) (Oo :: nil) 4 1 3 HCPQpRpOomtmp HOomtmp HCPQpOoMtmp Hincl); apply HT.
}

assert(HRpOoM : rk(Rp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HRpOoeq HRpOoM2).
assert(HRpOom : rk(Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HRpOoeq HRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LARpOo *)
(* dans la couche 0 *)
Lemma LABPpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpRpOo requis par la preuve de (?)ABPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpRpOo requis par la preuve de (?)ABPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpRpOo requis par la preuve de (?)ABPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpRpOom2 : rk(A :: B :: Pp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpRpOom3 : rk(A :: B :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Rp :: nil) (A :: B :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Rp :: nil) (A :: B :: Pp :: Rp :: Oo :: nil) 3 3 HABRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPpRpOom4 : rk(A :: B :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABPpOoeq : rk(A :: B :: Pp :: Oo :: nil) = 4) by (apply LABPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpOomtmp : rk(A :: B :: Pp :: Oo :: nil) >= 4) by (solve_hyps_min HABPpOoeq HABPpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Pp :: Oo :: nil) (A :: B :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Pp :: Oo :: nil) (A :: B :: Pp :: Rp :: Oo :: nil) 4 4 HABPpOomtmp Hcomp Hincl);apply HT.
}

assert(HABPpRpOoM : rk(A :: B :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPpRpOom : rk(A :: B :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPpRpOoeq HABPpRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LARpOo *)
(* dans la couche 0 *)
Lemma LBPpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Pp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPpRpOo requis par la preuve de (?)BPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPpRpOo requis par la preuve de (?)BPpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPpQpRpOo requis par la preuve de (?)BPpRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPpQpRpOo requis par la preuve de (?)BCPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPpQpRpOo requis par la preuve de (?)BCPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPpQpRpOom2 : rk(B :: C :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPpQpRpOom3 : rk(B :: C :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Qp :: nil) (B :: C :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Qp :: nil) (B :: C :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HBCQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPpRpOo requis par la preuve de (?)BPpRpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Pp :: Qp :: Rp :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HBPpRpOom2 : rk(B :: Pp :: Rp :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HBCPpQpRpOomtmp : rk(B :: C :: Pp :: Qp :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPpQpRpOoeq HBCPpQpRpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (B :: Pp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Pp :: Qp :: Rp :: Oo :: nil) (C :: Pp :: Qp :: B :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: B :: Pp :: Rp :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (B :: Pp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPpQpRpOomtmp;try rewrite HT2 in HBCPpQpRpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (B :: Pp :: Rp :: Oo :: nil) (Pp :: nil) 3 1 2 HBCPpQpRpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBPpRpOoM3 : rk(B :: Pp :: Rp :: Oo :: nil) <= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Pp :: Rp :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Pp :: Rp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: Oo :: nil) ((B :: Pp :: Rp :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Pp :: Rp :: nil) (Oo :: nil) (nil) 2 1 0 HBPpRpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPpRpOom3 : rk(B :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HBPpOoeq : rk(B :: Pp :: Oo :: nil) = 3) by (apply LBPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpOomtmp : rk(B :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBPpOoeq HBPpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Pp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Pp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil) 3 3 HBPpOomtmp Hcomp Hincl);apply HT.
}

assert(HBPpRpOoM : rk(B :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPpRpOom : rk(B :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPpRpOoeq HBPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ARpOo requis par la preuve de (?)ARpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ARpOo requis par la preuve de (?)ARpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARpOom2 : rk(A :: Rp :: Oo :: nil) >= 2).
{
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Rp :: nil) (A :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Rp :: nil) (A :: Rp :: Oo :: nil) 2 2 HARpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HARpOom3 : rk(A :: Rp :: Oo :: nil) >= 3).
{
	assert(HBPpRpOoeq : rk(B :: Pp :: Rp :: Oo :: nil) = 3) by (apply LBPpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpRpOoMtmp : rk(B :: Pp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HBPpRpOoeq HBPpRpOoM3).
	assert(HABPpRpOoeq : rk(A :: B :: Pp :: Rp :: Oo :: nil) = 4) by (apply LABPpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpRpOomtmp : rk(A :: B :: Pp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABPpRpOoeq HABPpRpOom4).
	assert(HRpOoeq : rk(Rp :: Oo :: nil) = 2) by (apply LRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpOomtmp : rk(Rp :: Oo :: nil) >= 2) by (solve_hyps_min HRpOoeq HRpOom2).
	assert(Hincl : incl (Rp :: Oo :: nil) (list_inter (A :: Rp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Pp :: Rp :: Oo :: nil) (A :: Rp :: Oo :: B :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Rp :: Oo :: B :: Pp :: Rp :: Oo :: nil) ((A :: Rp :: Oo :: nil) ++ (B :: Pp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPpRpOomtmp;try rewrite HT2 in HABPpRpOomtmp.
	assert(HT := rule_2 (A :: Rp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil) (Rp :: Oo :: nil) 4 2 3 HABPpRpOomtmp HRpOomtmp HBPpRpOoMtmp Hincl);apply HT.
}

assert(HARpOoM : rk(A :: Rp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HARpOoeq HARpOoM3).
assert(HARpOom : rk(A :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HARpOoeq HARpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRpOo requis par la preuve de (?)AQRpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRpOo requis par la preuve de (?)AQRpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRpOo requis par la preuve de (?)AQRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRpOom2 : rk(A :: Q :: Rp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Rp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp ::  de rang :  2 et 2 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQRpOom3 : rk(A :: Q :: Rp :: Oo :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) = 4) by (apply LABQPpQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpOoeq HABQPpQpRpOom4).
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hincl : incl (A :: Rp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Rp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpOomtmp;try rewrite HT2 in HABQPpQpRpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Rp :: Oo :: nil) (A :: Rp :: nil) 4 2 3 HABQPpQpRpOomtmp HARpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRpOoM3 : rk(A :: Q :: Rp :: Oo :: nil) <= 3).
{
	assert(HAQQpRpOoeq : rk(A :: Q :: Qp :: Rp :: Oo :: nil) = 3) by (apply LAQQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpOoMtmp : rk(A :: Q :: Qp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HAQQpRpOoeq HAQQpRpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Rp :: Oo :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Q :: Rp :: Oo :: nil) (A :: Q :: Qp :: Rp :: Oo :: nil) 3 3 HAQQpRpOoMtmp Hcomp Hincl);apply HT.
}

assert(HAQRpOoM : rk(A :: Q :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRpOom : rk(A :: Q :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQRpOoeq HAQRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRRpOo *)
(* dans constructLemma(), requis par LBRRpOo *)
(* dans la couche 0 *)
Lemma LBRPpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R :: Pp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BRPpRpOo requis par la preuve de (?)BRPpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BRPpRpOo requis par la preuve de (?)BRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BRPpRpOo requis par la preuve de (?)BRPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpRpOom2 : rk(B :: R :: Pp :: Rp :: Oo :: nil) >= 2).
{
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: R :: nil) (B :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: nil) (B :: R :: Pp :: Rp :: Oo :: nil) 2 2 HBRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpRpOom3 : rk(B :: R :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HBRRpeq : rk(B :: R :: Rp :: nil) = 3) by (apply LBRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpmtmp : rk(B :: R :: Rp :: nil) >= 3) by (solve_hyps_min HBRRpeq HBRRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: nil) (B :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: Rp :: nil) (B :: R :: Pp :: Rp :: Oo :: nil) 3 3 HBRRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBRPpRpOoM3 : rk(B :: R :: Pp :: Rp :: Oo :: nil) <= 3).
{
	assert(HBRPpOoeq : rk(B :: R :: Pp :: Oo :: nil) = 3) by (apply LBRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRPpOoMtmp : rk(B :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBRPpOoeq HBRPpOoM3).
	assert(HBPpRpOoeq : rk(B :: Pp :: Rp :: Oo :: nil) = 3) by (apply LBPpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpRpOoMtmp : rk(B :: Pp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HBPpRpOoeq HBPpRpOoM3).
	assert(HBPpOoeq : rk(B :: Pp :: Oo :: nil) = 3) by (apply LBPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpOomtmp : rk(B :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HBPpOoeq HBPpOom3).
	assert(Hincl : incl (B :: Pp :: Oo :: nil) (list_inter (B :: R :: Pp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: R :: Pp :: Rp :: Oo :: nil) (B :: R :: Pp :: Oo :: B :: Pp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: R :: Pp :: Oo :: B :: Pp :: Rp :: Oo :: nil) ((B :: R :: Pp :: Oo :: nil) ++ (B :: Pp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: R :: Pp :: Oo :: nil) (B :: Pp :: Rp :: Oo :: nil) (B :: Pp :: Oo :: nil) 3 3 3 HBRPpOoMtmp HBPpRpOoMtmp HBPpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBRPpRpOoM : rk(B :: R :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBRPpRpOom : rk(B :: R :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HBRPpRpOoeq HBRPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBRRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BRRpOo requis par la preuve de (?)BRRpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BRRpOo requis par la preuve de (?)BRRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BRRpOo requis par la preuve de (?)BRRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRRpOom2 : rk(B :: R :: Rp :: Oo :: nil) >= 2).
{
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: R :: nil) (B :: R :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: nil) (B :: R :: Rp :: Oo :: nil) 2 2 HBRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRRpOom3 : rk(B :: R :: Rp :: Oo :: nil) >= 3).
{
	assert(HBRRpeq : rk(B :: R :: Rp :: nil) = 3) by (apply LBRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpmtmp : rk(B :: R :: Rp :: nil) >= 3) by (solve_hyps_min HBRRpeq HBRRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: nil) (B :: R :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: Rp :: nil) (B :: R :: Rp :: Oo :: nil) 3 3 HBRRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRRpOoM3 : rk(B :: R :: Rp :: Oo :: nil) <= 3).
{
	assert(HBRPpRpOoeq : rk(B :: R :: Pp :: Rp :: Oo :: nil) = 3) by (apply LBRPpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRPpRpOoMtmp : rk(B :: R :: Pp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HBRPpRpOoeq HBRPpRpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: Oo :: nil) (B :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: R :: Rp :: Oo :: nil) (B :: R :: Pp :: Rp :: Oo :: nil) 3 3 HBRPpRpOoMtmp Hcomp Hincl);apply HT.
}

assert(HBRRpOoM : rk(B :: R :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBRRpOom : rk(B :: R :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HBRRpOoeq HBRRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRRpOo *)
(* dans constructLemma(), requis par LARQpRpOo *)
(* dans la couche 0 *)
Lemma LAQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Qp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AQpRpOo requis par la preuve de (?)AQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQpRpOo requis par la preuve de (?)AQpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQpRpOo requis par la preuve de (?)AQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQpRpOom2 : rk(A :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: nil) (A :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: nil) (A :: Qp :: Rp :: Oo :: nil) 2 2 HAQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAQpRpOoM3 : rk(A :: Qp :: Rp :: Oo :: nil) <= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Qp :: Rp :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Qp :: Rp :: nil) (Oo :: nil) (nil) 2 1 0 HAQpRpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQpRpOom3 : rk(A :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HAQpOoeq : rk(A :: Qp :: Oo :: nil) = 3) by (apply LAQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpOomtmp : rk(A :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HAQpOoeq HAQpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Qp :: Oo :: nil) (A :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Qp :: Oo :: nil) (A :: Qp :: Rp :: Oo :: nil) 3 3 HAQpOomtmp Hcomp Hincl);apply HT.
}

assert(HAQpRpOoM : rk(A :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQpRpOom : rk(A :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQpRpOoeq HAQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: R :: Qp :: Rp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpRpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARQpRpOo requis par la preuve de (?)ARQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpOom2 : rk(A :: R :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HAReq : rk(A :: R :: nil) = 2) by (apply LAR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARmtmp : rk(A :: R :: nil) >= 2) by (solve_hyps_min HAReq HARm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: R :: nil) (A :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: nil) (A :: R :: Qp :: Rp :: Oo :: nil) 2 2 HARmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARQpRpOom3 : rk(A :: R :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: R :: Qp :: Rp :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HARQpRpOoM3 : rk(A :: R :: Qp :: Rp :: Oo :: nil) <= 3).
{
	assert(HARQpOoeq : rk(A :: R :: Qp :: Oo :: nil) = 3) by (apply LARQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARQpOoMtmp : rk(A :: R :: Qp :: Oo :: nil) <= 3) by (solve_hyps_max HARQpOoeq HARQpOoM3).
	assert(HAQpRpOoeq : rk(A :: Qp :: Rp :: Oo :: nil) = 3) by (apply LAQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpOoMtmp : rk(A :: Qp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HAQpRpOoeq HAQpRpOoM3).
	assert(HAQpOoeq : rk(A :: Qp :: Oo :: nil) = 3) by (apply LAQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpOomtmp : rk(A :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HAQpOoeq HAQpOom3).
	assert(Hincl : incl (A :: Qp :: Oo :: nil) (list_inter (A :: R :: Qp :: Oo :: nil) (A :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: R :: Qp :: Rp :: Oo :: nil) (A :: R :: Qp :: Oo :: A :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: R :: Qp :: Oo :: A :: Qp :: Rp :: Oo :: nil) ((A :: R :: Qp :: Oo :: nil) ++ (A :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: R :: Qp :: Oo :: nil) (A :: Qp :: Rp :: Oo :: nil) (A :: Qp :: Oo :: nil) 3 3 3 HARQpOoMtmp HAQpRpOoMtmp HAQpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HARQpRpOoM : rk(A :: R :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARQpRpOom : rk(A :: R :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HARQpRpOoeq HARQpRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRRpOo *)
(* dans la couche 0 *)
Lemma LABRQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRQpRpOo requis par la preuve de (?)ABRQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRQpRpOo requis par la preuve de (?)ABRQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRQpRpOo requis par la preuve de (?)ABRQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRQpRpOom2 : rk(A :: B :: R :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRQpRpOom3 : rk(A :: B :: R :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRQpRpOom4 : rk(A :: B :: R :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Qp :: Rp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABRQpRpOoM : rk(A :: B :: R :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRQpRpOom : rk(A :: B :: R :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HABRQpRpOoeq HABRQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(R :: Rp :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour RRpOo requis par la preuve de (?)RRpOo pour la règle 3  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour RRpOo requis par la preuve de (?)RRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HRRpOom2 : rk(R :: Rp :: Oo :: nil) >= 2).
{
	assert(HRRpeq : rk(R :: Rp :: nil) = 2) by (apply LRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpmtmp : rk(R :: Rp :: nil) >= 2) by (solve_hyps_min HRRpeq HRRpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (R :: Rp :: nil) (R :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (R :: Rp :: nil) (R :: Rp :: Oo :: nil) 2 2 HRRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HRRpOoM2 : rk(R :: Rp :: Oo :: nil) <= 2).
{
	assert(HBRRpOoeq : rk(B :: R :: Rp :: Oo :: nil) = 3) by (apply LBRRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpOoMtmp : rk(B :: R :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HBRRpOoeq HBRRpOoM3).
	assert(HARQpRpOoeq : rk(A :: R :: Qp :: Rp :: Oo :: nil) = 3) by (apply LARQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARQpRpOoMtmp : rk(A :: R :: Qp :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HARQpRpOoeq HARQpRpOoM3).
	assert(HABRQpRpOoeq : rk(A :: B :: R :: Qp :: Rp :: Oo :: nil) = 4) by (apply LABRQpRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRQpRpOomtmp : rk(A :: B :: R :: Qp :: Rp :: Oo :: nil) >= 4) by (solve_hyps_min HABRQpRpOoeq HABRQpRpOom4).
	assert(Hincl : incl (R :: Rp :: Oo :: nil) (list_inter (B :: R :: Rp :: Oo :: nil) (A :: R :: Qp :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Qp :: Rp :: Oo :: nil) (B :: R :: Rp :: Oo :: A :: R :: Qp :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: R :: Rp :: Oo :: A :: R :: Qp :: Rp :: Oo :: nil) ((B :: R :: Rp :: Oo :: nil) ++ (A :: R :: Qp :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRQpRpOomtmp;try rewrite HT2 in HABRQpRpOomtmp.
	assert(HT := rule_3 (B :: R :: Rp :: Oo :: nil) (A :: R :: Qp :: Rp :: Oo :: nil) (R :: Rp :: Oo :: nil) 3 3 4 HBRRpOoMtmp HARQpRpOoMtmp HABRQpRpOomtmp Hincl);apply HT.
}


assert(HRRpOoM : rk(R :: Rp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HRRpOoeq HRRpOoM3).
assert(HRRpOom : rk(R :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HRRpOoeq HRRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRpOo requis par la preuve de (?)ABPRPpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom2 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom3 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpOom4 : rk(A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpRpOoM : rk(A :: B :: P :: R :: Pp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpRpOom : rk(A :: B :: P :: R :: Pp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpRpOoeq HABPRPpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpOo requis par la preuve de (?)ABPRPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpQpRpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpRpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpRpOoeq HABPRPpQpRpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpOo requis par la preuve de (?)PQRPpQpRpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpOo requis par la preuve de (?)PQRPpQpRpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpOoeq HPQRPpQpRpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAUOo *)
(* dans constructLemma(), requis par LAQQpUOo *)
(* dans constructLemma(), requis par LABQQpUOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUOo requis par la preuve de (?)ABQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUOoeq HABQPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQQpUOo requis par la preuve de (?)ABQQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQQpUOo requis par la preuve de (?)ABQQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQQpUOo requis par la preuve de (?)ABQQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpUOom2 : rk(A :: B :: Q :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpUOom3 : rk(A :: B :: Q :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Qp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQQpUOom4 : rk(A :: B :: Q :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpUOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LABQPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUOoeq HABQPpQpRpUOom4).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hincl : incl (A :: B :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: U :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUOomtmp;try rewrite HT2 in HABQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: U :: Oo :: nil) (A :: B :: Qp :: nil) 4 3 3 HABQPpQpRpUOomtmp HABQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQQpUOoM : rk(A :: B :: Q :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQQpUOom : rk(A :: B :: Q :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABQQpUOoeq HABQQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpUOo requis par la preuve de (?)AQQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpUOo requis par la preuve de (?)AQQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpUOo requis par la preuve de (?)AQQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpUOom2 : rk(A :: Q :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: U :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQQpUOom3 : rk(A :: Q :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpUOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LABQPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUOoeq HABQPpQpRpUOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: U :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUOomtmp;try rewrite HT2 in HABQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 4 2 3 HABQPpQpRpUOomtmp HAQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Q :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Q :: U ::  de rang :  2 et 2 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HAQQpUOom4 : rk(A :: Q :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HABQQpUOoeq : rk(A :: B :: Q :: Qp :: U :: Oo :: nil) = 4) by (apply LABQQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQQpUOomtmp : rk(A :: B :: Q :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABQQpUOoeq HABQQpUOom4).
	assert(HQUeq : rk(Q :: U :: nil) = 2) by (apply LQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQUmtmp : rk(Q :: U :: nil) >= 2) by (solve_hyps_min HQUeq HQUm2).
	assert(Hincl : incl (Q :: U :: nil) (list_inter (B :: Q :: U :: nil) (A :: Q :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Qp :: U :: Oo :: nil) (B :: Q :: U :: A :: Q :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: A :: Q :: Qp :: U :: Oo :: nil) ((B :: Q :: U :: nil) ++ (A :: Q :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQQpUOomtmp;try rewrite HT2 in HABQQpUOomtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (A :: Q :: Qp :: U :: Oo :: nil) (Q :: U :: nil) 4 2 2 HABQQpUOomtmp HQUmtmp HBQUMtmp Hincl); apply HT.
}

assert(HAQQpUOoM : rk(A :: Q :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpUOom : rk(A :: Q :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpUOoeq HAQQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AUOo requis par la preuve de (?)AUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APUOo requis par la preuve de (?)AUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APUOo requis par la preuve de (?)APUOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)APUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)ACPQUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)ACPQUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQUOom2 : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQUOom3 : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APUOo requis par la preuve de (?)APUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPUOom2 : rk(A :: P :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQUOomtmp : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 3) by (solve_hyps_min HACPQUOoeq HACPQUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: U :: Oo :: nil) (C :: P :: Q :: A :: P :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQUOomtmp;try rewrite HT2 in HACPQUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: U :: Oo :: nil) (P :: nil) 3 1 2 HACPQUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAPUOoM3 : rk(A :: P :: U :: Oo :: nil) <= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: P :: U :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: U :: Oo :: nil) (A :: P :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Oo :: nil) ((A :: P :: U :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: P :: U :: nil) (Oo :: nil) (nil) 2 1 0 HAPUMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AUOo requis par la preuve de (?)AUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: U :: Oo ::  de rang :  2 et 3 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAUOom2 : rk(A :: U :: Oo :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPUOomtmp : rk(A :: P :: U :: Oo :: nil) >= 2) by (solve_hyps_min HAPUOoeq HAPUOom2).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: U :: Oo :: nil) (A :: P :: U :: A :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: U :: Oo :: nil) ((A :: P :: U :: nil) ++ (A :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPUOomtmp;try rewrite HT2 in HAPUOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: U :: Oo :: nil) (A :: U :: nil) 2 2 2 HAPUOomtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Q :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HAUOom3 : rk(A :: U :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HAQQpUOoeq : rk(A :: Q :: Qp :: U :: Oo :: nil) = 4) by (apply LAQQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpUOomtmp : rk(A :: Q :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpUOoeq HAQQpUOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (A :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: U :: Oo :: nil) (Q :: Qp :: Oo :: A :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: A :: U :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (A :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpUOomtmp;try rewrite HT2 in HAQQpUOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (A :: U :: Oo :: nil) (Oo :: nil) 4 1 2 HAQQpUOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

assert(HAUOoM : rk(A :: U :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAUOoeq HAUOoM3).
assert(HAUOom : rk(A :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAUOoeq HAUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABUOo *)
(* dans la couche 0 *)
Lemma LABPUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPUOo requis par la preuve de (?)ABPUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPUOo requis par la preuve de (?)ABPUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPUOo requis par la preuve de (?)ABPUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPUOom2 : rk(A :: B :: P :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPUOom3 : rk(A :: B :: P :: U :: Oo :: nil) >= 3).
{
	assert(HABOoeq : rk(A :: B :: Oo :: nil) = 3) by (apply LABOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABOomtmp : rk(A :: B :: Oo :: nil) >= 3) by (solve_hyps_min HABOoeq HABOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Oo :: nil) (A :: B :: P :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Oo :: nil) (A :: B :: P :: U :: Oo :: nil) 3 3 HABOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPUOom4 : rk(A :: B :: P :: U :: Oo :: nil) >= 4).
{
	assert(HABPOoeq : rk(A :: B :: P :: Oo :: nil) = 4) by (apply LABPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPOomtmp : rk(A :: B :: P :: Oo :: nil) >= 4) by (solve_hyps_min HABPOoeq HABPOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: P :: Oo :: nil) (A :: B :: P :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: P :: Oo :: nil) (A :: B :: P :: U :: Oo :: nil) 4 4 HABPOomtmp Hcomp Hincl);apply HT.
}

assert(HABPUOoM : rk(A :: B :: P :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPUOom : rk(A :: B :: P :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABPUOoeq HABPUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABUOo *)
(* dans la couche 0 *)
Lemma LAPUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APUOo requis par la preuve de (?)APUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APUOo requis par la preuve de (?)APUOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)APUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)ACPQUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQUOo requis par la preuve de (?)ACPQUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQUOom2 : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQUOom3 : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APUOo requis par la preuve de (?)APUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPUOom2 : rk(A :: P :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQUOomtmp : rk(A :: C :: P :: Q :: U :: Oo :: nil) >= 3) by (solve_hyps_min HACPQUOoeq HACPQUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: U :: Oo :: nil) (C :: P :: Q :: A :: P :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQUOomtmp;try rewrite HT2 in HACPQUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: U :: Oo :: nil) (P :: nil) 3 1 2 HACPQUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAPUOoM3 : rk(A :: P :: U :: Oo :: nil) <= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: P :: U :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: U :: Oo :: nil) (A :: P :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Oo :: nil) ((A :: P :: U :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: P :: U :: nil) (Oo :: nil) (nil) 2 1 0 HAPUMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPUOom3 : rk(A :: P :: U :: Oo :: nil) >= 3).
{
	assert(HAPOoeq : rk(A :: P :: Oo :: nil) = 3) by (apply LAPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPOomtmp : rk(A :: P :: Oo :: nil) >= 3) by (solve_hyps_min HAPOoeq HAPOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Oo :: nil) (A :: P :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Oo :: nil) (A :: P :: U :: Oo :: nil) 3 3 HAPOomtmp Hcomp Hincl);apply HT.
}

assert(HAPUOoM : rk(A :: P :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPUOom : rk(A :: P :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAPUOoeq HAPUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABUOo requis par la preuve de (?)ABUOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABUOo requis par la preuve de (?)ABUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABUOo requis par la preuve de (?)ABUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABUOom2 : rk(A :: B :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABUOom3 : rk(A :: B :: U :: Oo :: nil) >= 3).
{
	assert(HABOoeq : rk(A :: B :: Oo :: nil) = 3) by (apply LABOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABOomtmp : rk(A :: B :: Oo :: nil) >= 3) by (solve_hyps_min HABOoeq HABOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Oo :: nil) (A :: B :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Oo :: nil) (A :: B :: U :: Oo :: nil) 3 3 HABOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABUOom4 : rk(A :: B :: U :: Oo :: nil) >= 4).
{
	assert(HAPUOoeq : rk(A :: P :: U :: Oo :: nil) = 3) by (apply LAPUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPUOoMtmp : rk(A :: P :: U :: Oo :: nil) <= 3) by (solve_hyps_max HAPUOoeq HAPUOoM3).
	assert(HABPUOoeq : rk(A :: B :: P :: U :: Oo :: nil) = 4) by (apply LABPUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPUOomtmp : rk(A :: B :: P :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPUOoeq HABPUOom4).
	assert(HAUOoeq : rk(A :: U :: Oo :: nil) = 3) by (apply LAUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUOomtmp : rk(A :: U :: Oo :: nil) >= 3) by (solve_hyps_min HAUOoeq HAUOom3).
	assert(Hincl : incl (A :: U :: Oo :: nil) (list_inter (A :: B :: U :: Oo :: nil) (A :: P :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: U :: Oo :: nil) (A :: B :: U :: Oo :: A :: P :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: U :: Oo :: A :: P :: U :: Oo :: nil) ((A :: B :: U :: Oo :: nil) ++ (A :: P :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPUOomtmp;try rewrite HT2 in HABPUOomtmp.
	assert(HT := rule_2 (A :: B :: U :: Oo :: nil) (A :: P :: U :: Oo :: nil) (A :: U :: Oo :: nil) 4 3 3 HABPUOomtmp HAUOomtmp HAPUOoMtmp Hincl);apply HT.
}

assert(HABUOoM : rk(A :: B :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABUOom : rk(A :: B :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABUOoeq HABUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPpUOo *)
(* dans la couche 0 *)
Lemma LAPPpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Pp :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APPpUOo requis par la preuve de (?)APPpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APPpUOo requis par la preuve de (?)APPpUOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQPpUOo requis par la preuve de (?)APPpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQPpUOo requis par la preuve de (?)ACPQPpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQPpUOo requis par la preuve de (?)ACPQPpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQPpUOom2 : rk(A :: C :: P :: Q :: Pp :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Pp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Pp :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQPpUOom3 : rk(A :: C :: P :: Q :: Pp :: U :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Pp :: U :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APPpUOo requis par la preuve de (?)APPpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Pp :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPPpUOom2 : rk(A :: P :: Pp :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQPpUOomtmp : rk(A :: C :: P :: Q :: Pp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HACPQPpUOoeq HACPQPpUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Pp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Pp :: U :: Oo :: nil) (C :: P :: Q :: A :: P :: Pp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Pp :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Pp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQPpUOomtmp;try rewrite HT2 in HACPQPpUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Pp :: U :: Oo :: nil) (P :: nil) 3 1 2 HACPQPpUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAPPpUOoM3 : rk(A :: P :: Pp :: U :: Oo :: nil) <= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (A :: P :: U :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Pp :: U :: Oo :: nil) (A :: P :: U :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: P :: Pp :: Oo :: nil) ((A :: P :: U :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: P :: U :: nil) (P :: Pp :: Oo :: nil) (P :: nil) 2 2 1 HAPUMtmp HPPpOoMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPPpUOom3 : rk(A :: P :: Pp :: U :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: P :: Pp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: P :: Pp :: U :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

assert(HAPPpUOoM : rk(A :: P :: Pp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPPpUOom : rk(A :: P :: Pp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAPPpUOoeq HAPPpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APpUOo requis par la preuve de (?)APpUOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUOo requis par la preuve de (?)APpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUOo requis par la preuve de (?)APpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUOo requis par la preuve de (?)ACPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUOo requis par la preuve de (?)ACPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUOom2 : rk(A :: C :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUOom3 : rk(A :: C :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUOo requis par la preuve de (?)APpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUOom2 : rk(A :: Pp :: U :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUOomtmp : rk(A :: C :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUOoeq HACPpQpUOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUOomtmp;try rewrite HT2 in HACPpQpUOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUOom3 : rk(A :: Pp :: U :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUOoM3 : rk(A :: Pp :: U :: Oo :: nil) <= 3).
{
	assert(HAPPpUOoeq : rk(A :: P :: Pp :: U :: Oo :: nil) = 3) by (apply LAPPpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPPpUOoMtmp : rk(A :: P :: Pp :: U :: Oo :: nil) <= 3) by (solve_hyps_max HAPPpUOoeq HAPPpUOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: Oo :: nil) (A :: P :: Pp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Pp :: U :: Oo :: nil) (A :: P :: Pp :: U :: Oo :: nil) 3 3 HAPPpUOoMtmp Hcomp Hincl);apply HT.
}

assert(HAPpUOoM : rk(A :: Pp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpUOom : rk(A :: Pp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HAPpUOoeq HAPpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp :: U :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpUOo requis par la preuve de (?)BQpUOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpRpUOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpUOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpUOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCPRPpQpUOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCPRPpQpRpUOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpRpUOoeq HBCPRPpQpRpUOom4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpRpUOomtmp;try rewrite HT2 in HBCPRPpQpRpUOomtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCPRPpQpRpUOomtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BCPQRPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BCPQRPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUOom2 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUOoeq HBCPQRPpQpUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUOomtmp;try rewrite HT2 in HBCPQRPpQpUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUOom3 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUOoeq HABPRPpQpRpUOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUOomtmp;try rewrite HT2 in HABPRPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: U ::  de rang :  3 et 3 	 A : C :: Pp :: Qp :: U ::   de rang : 3 et 3 *)
assert(HBPRPpQpUOom4 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCPRPpQpUOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpUOoeq HBCPRPpQpUOom4).
	assert(HPpQpUeq : rk(Pp :: Qp :: U :: nil) = 3) by (apply LPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpQpUmtmp : rk(Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HPpQpUeq HPpQpUm3).
	assert(Hincl : incl (Pp :: Qp :: U :: nil) (list_inter (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((C :: Pp :: Qp :: U :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpUOomtmp;try rewrite HT2 in HBCPRPpQpUOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (Pp :: Qp :: U :: nil) 4 3 3 HBCPRPpQpUOomtmp HPpQpUmtmp HCPpQpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUOoeq HABPQPpQpRpUOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUOomtmp;try rewrite HT2 in HABPQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPU requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQU requis par la preuve de (?)BPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm2 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm3 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQUm2 : rk(B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQUm3 : rk(B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQUmtmp : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HABCPQUeq HABCPQUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: U :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQUmtmp;try rewrite HT2 in HABCPQUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPU requis par la preuve de (?)BPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPUm2 : rk(B :: P :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQUmtmp : rk(B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HBCPQUeq HBCPQUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: U :: nil) (C :: P :: Q :: B :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: U :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQUmtmp;try rewrite HT2 in HBCPQUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: U :: nil) (P :: nil) 3 1 2 HBCPQUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BCPQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BCPQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUOom2 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUOoeq HBCPQPpQpUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUOomtmp;try rewrite HT2 in HBCPQPpQpUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: U ::  de rang :  2 et 3 	 A : A :: B :: P :: Q :: U ::   de rang : 3 et 3 *)
assert(HBPPpQpUOom3 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABPQUeq : rk(A :: B :: P :: Q :: U :: nil) = 3) by (apply LABPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQUMtmp : rk(A :: B :: P :: Q :: U :: nil) <= 3) by (solve_hyps_max HABPQUeq HABPQUM3).
	assert(HABPQPpQpUOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpUOoeq HABPQPpQpUOom4).
	assert(HBPUmtmp : rk(B :: P :: U :: nil) >= 2) by (solve_hyps_min HBPUeq HBPUm2).
	assert(Hincl : incl (B :: P :: U :: nil) (list_inter (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((A :: B :: P :: Q :: U :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpUOomtmp;try rewrite HT2 in HABPQPpQpUOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: U :: nil) 4 2 3 HABPQPpQpUOomtmp HBPUmtmp HABPQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpUOom4 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpUOomtmp : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUOoeq HBPRPpQpUOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUOomtmp;try rewrite HT2 in HBPRPpQpUOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpUOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpUOo requis par la preuve de (?)BQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpUOo requis par la preuve de (?)BQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpUOom2 : rk(B :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: U :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HBQpUOom3 : rk(B :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPPpQpUOomtmp : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBPPpQpUOoeq HBPPpQpUOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (B :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Qp :: U :: Oo :: nil) (P :: Pp :: Oo :: B :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: B :: Qp :: U :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (B :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpQpUOomtmp;try rewrite HT2 in HBPPpQpUOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (B :: Qp :: U :: Oo :: nil) (Oo :: nil) 4 1 2 HBPPpQpUOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpUOoM3 : rk(B :: Qp :: U :: Oo :: nil) <= 3).
{
	assert(HBQQpUOoeq : rk(B :: Q :: Qp :: U :: Oo :: nil) = 3) by (apply LBQQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQQpUOoMtmp : rk(B :: Q :: Qp :: U :: Oo :: nil) <= 3) by (solve_hyps_max HBQQpUOoeq HBQQpUOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: U :: Oo :: nil) (B :: Q :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: Qp :: U :: Oo :: nil) (B :: Q :: Qp :: U :: Oo :: nil) 3 3 HBQQpUOoMtmp Hcomp Hincl);apply HT.
}

assert(HBQpUOoM : rk(B :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQpUOom : rk(B :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBQpUOoeq HBQpUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBPPpQpUOo *)
(* dans constructLemma(), requis par LBPRPpQpUOo *)
(* dans constructLemma(), requis par LBCPRPpQpUOo *)
(* dans la couche 0 *)
Lemma LBCPRPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpRpUOo requis par la preuve de (?)BCPRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpRpUOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCPRPpQpRpUOoM : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpQpRpUOom : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpQpRpUOoeq HBCPRPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCPRPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpUOo requis par la preuve de (?)BCPRPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpUOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpUOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCPRPpQpUOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCPRPpQpRpUOoeq : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LBCPRPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpQpRpUOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpRpUOoeq HBCPRPpQpRpUOom4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpRpUOomtmp;try rewrite HT2 in HBCPRPpQpRpUOomtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCPRPpQpRpUOomtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCPRPpQpUOoM : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpQpUOom : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpQpUOoeq HBCPRPpQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BCPQRPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUOo requis par la preuve de (?)BCPQRPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUOo requis par la preuve de (?)BPRPpQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUOom2 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUOoeq HBCPQRPpQpUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUOomtmp;try rewrite HT2 in HBCPQRPpQpUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUOom3 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUOoeq HABPRPpQpRpUOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUOomtmp;try rewrite HT2 in HABPRPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: U ::  de rang :  3 et 3 	 A : C :: Pp :: Qp :: U ::   de rang : 3 et 3 *)
assert(HBPRPpQpUOom4 : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCPRPpQpUOoeq : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) = 4) by (apply LBCPRPpQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpQpUOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpUOoeq HBCPRPpQpUOom4).
	assert(HPpQpUeq : rk(Pp :: Qp :: U :: nil) = 3) by (apply LPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpQpUmtmp : rk(Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HPpQpUeq HPpQpUm3).
	assert(Hincl : incl (Pp :: Qp :: U :: nil) (list_inter (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) ((C :: Pp :: Qp :: U :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpUOomtmp;try rewrite HT2 in HBCPRPpQpUOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (Pp :: Qp :: U :: nil) 4 3 3 HBCPRPpQpUOomtmp HPpQpUmtmp HCPpQpUMtmp Hincl); apply HT.
}

assert(HBPRPpQpUOoM : rk(B :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpQpUOom : rk(B :: P :: R :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpQpUOoeq HBPRPpQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUOoeq HABPQPpQpRpUOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUOomtmp;try rewrite HT2 in HABPQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPU requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQU requis par la preuve de (?)BPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm2 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm3 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQUm2 : rk(B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQUm3 : rk(B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQUmtmp : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HABCPQUeq HABCPQUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: U :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQUmtmp;try rewrite HT2 in HABCPQUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPU requis par la preuve de (?)BPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPUm2 : rk(B :: P :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQUmtmp : rk(B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HBCPQUeq HBCPQUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: U :: nil) (C :: P :: Q :: B :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: U :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQUmtmp;try rewrite HT2 in HBCPQUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: U :: nil) (P :: nil) 3 1 2 HBCPQUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BCPQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUOo requis par la preuve de (?)BCPQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUOo requis par la preuve de (?)BPPpQpUOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUOom2 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUOoeq HBCPQPpQpUOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUOomtmp;try rewrite HT2 in HBCPQPpQpUOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: U ::  de rang :  2 et 3 	 A : A :: B :: P :: Q :: U ::   de rang : 3 et 3 *)
assert(HBPPpQpUOom3 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABPQUeq : rk(A :: B :: P :: Q :: U :: nil) = 3) by (apply LABPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQUMtmp : rk(A :: B :: P :: Q :: U :: nil) <= 3) by (solve_hyps_max HABPQUeq HABPQUM3).
	assert(HABPQPpQpUOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpUOoeq HABPQPpQpUOom4).
	assert(HBPUmtmp : rk(B :: P :: U :: nil) >= 2) by (solve_hyps_min HBPUeq HBPUm2).
	assert(Hincl : incl (B :: P :: U :: nil) (list_inter (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((A :: B :: P :: Q :: U :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpUOomtmp;try rewrite HT2 in HABPQPpQpUOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: U :: nil) 4 2 3 HABPQPpQpUOomtmp HBPUmtmp HABPQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: U :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpUOom4 : rk(B :: P :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpUOoeq : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) = 4) by (apply LBPRPpQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpUOomtmp : rk(B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUOoeq HBPRPpQpUOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUOomtmp;try rewrite HT2 in HBPRPpQpUOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpUOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

assert(HBPPpQpUOoM : rk(B :: P :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPPpQpUOom : rk(B :: P :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBPPpQpUOoeq HBPPpQpUOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPQPpQpUOo *)
(* dans la couche 0 *)
Lemma LABPQPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUOo requis par la preuve de (?)ABPQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPQPpQpRpUOoM : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpQpRpUOom : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpQpRpUOoeq HABPQPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQPpQpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUOo requis par la preuve de (?)ABPQPpQpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUOoeq : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LABPQPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpQpRpUOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUOoeq HABPQPpQpRpUOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUOomtmp;try rewrite HT2 in HABPQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABPQPpQpUOoM : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpQpUOom : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpQpUOoeq HABPQPpQpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUOo requis par la preuve de (?)BQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) = 4) by (apply LABQPpQpRpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUOoeq HABQPpQpRpUOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUOomtmp;try rewrite HT2 in HABQPpQpRpUOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUOoeq HBQPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACQPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACQPpQpRpUOo requis par la preuve de (?)ACQPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACQPpQpRpUOom2 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUOom3 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACQPpQpRpUOom4 : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HACQPpRpeq : rk(A :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LACQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQPpRpmtmp : rk(A :: C :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HACQPpRpeq HACQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: Pp :: Rp :: nil) (A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HACQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HACQPpQpRpUOoM : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACQPpQpRpUOom : rk(A :: C :: Q :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HACQPpQpRpUOoeq HACQPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUOo requis par la preuve de (?)ABPRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpQpRpUOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpRpUOom : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpRpUOoeq HABPRPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUOo requis par la preuve de (?)PQRPpQpRpUOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUOo requis par la preuve de (?)PQRPpQpRpUOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUOoeq HPQRPpQpRpUOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour APpUpOo requis par la preuve de (?)APpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUpOo requis par la preuve de (?)APpUpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUpOo requis par la preuve de (?)APpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUpOo requis par la preuve de (?)ACPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUpOo requis par la preuve de (?)ACPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUpOom2 : rk(A :: C :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUpOom3 : rk(A :: C :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUpOo requis par la preuve de (?)APpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUpOom2 : rk(A :: Pp :: Up :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUpOomtmp : rk(A :: C :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUpOoeq HACPpQpUpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: Up :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: Up :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUpOomtmp;try rewrite HT2 in HACPpQpUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: Up :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAPpUpOoM3 : rk(A :: Pp :: Up :: Oo :: nil) <= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Pp :: Up :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: Up :: Oo :: nil) (A :: Pp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Pp :: Up :: nil) (Oo :: nil) (nil) 2 1 0 HAPpUpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUpOom3 : rk(A :: Pp :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpOoeq : rk(A :: Pp :: Oo :: nil) = 3) by (apply LAPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpOomtmp : rk(A :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HAPpOoeq HAPpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: Oo :: nil) (A :: Pp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: Oo :: nil) (A :: Pp :: Up :: Oo :: nil) 3 3 HAPpOomtmp Hcomp Hincl);apply HT.
}

assert(HAPpUpOoM : rk(A :: Pp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpUpOom : rk(A :: Pp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HAPpUpOoeq HAPpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQpUpOo *)
(* dans la couche 0 *)
Lemma LBPPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)ABPPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPPpQpUpOo requis par la preuve de (?)ABPPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpQpUpOom2 : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpQpUpOom3 : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BCPQPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUpOo requis par la preuve de (?)BCPQPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUpOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUpOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUpOo requis par la preuve de (?)BPPpQpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUpOom2 : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUpOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUpOoeq HBCPQPpQpUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUpOomtmp;try rewrite HT2 in HBCPQPpQpUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Pp :: Qp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPPpQpUpOom3 : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPPpQpUpOomtmp : rk(A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HABPPpQpUpOoeq HABPPpQpUpOom3).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPPpQpUpOomtmp;try rewrite HT2 in HABPPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 3 2 2 HABPPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpUpOom4 : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpUpOoeq : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LBPRPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpUpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUpOoeq HBPRPpQpUpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Up :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: Up :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUpOomtmp;try rewrite HT2 in HBPRPpQpUpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpUpOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

assert(HBPPpQpUpOoM : rk(B :: P :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPPpQpUpOom : rk(B :: P :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBPPpQpUpOoeq HBPPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BQpUpOo requis par la preuve de (?)BQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpUpOo requis par la preuve de (?)BQpUpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpUpOo requis par la preuve de (?)BQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpUpOom2 : rk(B :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Up :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBQpUpOoM3 : rk(B :: Qp :: Up :: Oo :: nil) <= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Qp :: Up :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Up :: Oo :: nil) (B :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Qp :: Up :: nil) (Oo :: nil) (nil) 2 1 0 HBQpUpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: P :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HBQpUpOom3 : rk(B :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPPpQpUpOoeq : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LBPPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPPpQpUpOomtmp : rk(B :: P :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPPpQpUpOoeq HBPPpQpUpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (B :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Qp :: Up :: Oo :: nil) (P :: Pp :: Oo :: B :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: B :: Qp :: Up :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (B :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpQpUpOomtmp;try rewrite HT2 in HBPPpQpUpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (B :: Qp :: Up :: Oo :: nil) (Oo :: nil) 4 1 2 HBPPpQpUpOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

assert(HBQpUpOoM : rk(B :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQpUpOom : rk(B :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBQpUpOoeq HBQpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBRPpQpUpOo *)
(* dans constructLemma(), requis par LABRPpQpUpOo *)
(* dans la couche 0 *)
Lemma LABRPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpQpRpUpOo requis par la preuve de (?)ABRPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom2 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom3 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpRpUpOom4 : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABRPpQpRpUpOoM : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRPpQpRpUpOom : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABRPpQpRpUpOoeq HABRPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABRPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: R :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABRPpQpUpOo requis par la preuve de (?)ABRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpUpOom2 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABRPpQpUpOom3 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABRPpQpUpOom4 : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABRPpQpRpUpOoeq : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABRPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRPpQpRpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpRpUpOoeq HABRPpQpRpUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpRpUpOomtmp;try rewrite HT2 in HABRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABRPpQpRpUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABRPpQpUpOoM : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABRPpQpUpOom : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABRPpQpUpOoeq HABRPpQpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBRPpQpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: R :: Pp :: Qp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BRPpQpUpOo requis par la preuve de (?)BRPpQpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBRPpQpUpOom2 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 2).
{
	assert(HBReq : rk(B :: R :: nil) = 2) by (apply LBR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRmtmp : rk(B :: R :: nil) >= 2) by (solve_hyps_min HBReq HBRm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: R :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) 2 2 HBRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBRPpQpUpOom3 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABRPpQpRpUpOoeq : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABRPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRPpQpRpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpRpUpOoeq HABRPpQpRpUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpRpUpOomtmp;try rewrite HT2 in HABRPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABRPpQpRpUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: R :: Pp :: Qp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBRPpQpUpOom4 : rk(B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABRPpQpUpOoeq : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) = 4) by (apply LABRPpQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRPpQpUpOomtmp : rk(A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABRPpQpUpOoeq HABRPpQpUpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) (A :: Pp :: Up :: B :: R :: Pp :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: R :: Pp :: Qp :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: R :: Pp :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABRPpQpUpOomtmp;try rewrite HT2 in HABRPpQpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: R :: Pp :: Qp :: Up :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABRPpQpUpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HBRPpQpUpOoM : rk(B :: R :: Pp :: Qp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBRPpQpUpOom : rk(B :: R :: Pp :: Qp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBRPpQpUpOoeq HBRPpQpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpUpOo *)
(* dans la couche 0 *)
Lemma LQQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpOo requis par la preuve de (?)QQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpOomtmp;try rewrite HT2 in HABQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpOoeq HABCQPpQpRpUpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpOomtmp;try rewrite HT2 in HABCQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpOoeq HBQPpQpRpUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpOomtmp;try rewrite HT2 in HBQPpQpRpUpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpOo requis par la preuve de (?)QQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpOo requis par la preuve de (?)QQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpOo requis par la preuve de (?)PQRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpOo requis par la preuve de (?)PQRPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpOo requis par la preuve de (?)QQpRpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpOom2 : rk(Q :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpOoeq HPQRPpQpRpUpOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpOomtmp;try rewrite HT2 in HPQRPpQpRpUpOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpOom3 : rk(Q :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpOoeq HQPpQpRpUpOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpOomtmp;try rewrite HT2 in HQPpQpRpUpOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpOom4 : rk(Q :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpOoeq : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LAQQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpUpOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpOoeq HAQQpRpUpOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpOomtmp;try rewrite HT2 in HAQQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

assert(HQQpRpUpOoM : rk(Q :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUpOom : rk(Q :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUpOoeq HQQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour RpUpOo requis par la preuve de (?)RpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpRpUpOo requis par la preuve de (?)RpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpOoeq HABQPpQpRpUUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpOomtmp;try rewrite HT2 in HABQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpRpUpOo requis par la preuve de (?)BQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpRpUpOo requis par la preuve de (?)BQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpRpUpOom2 : rk(B :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HBQpRpUpOom3 : rk(B :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUUpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpOoeq HBQPpQpRpUUpOom4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: Oo :: nil) ((B :: Q :: Pp :: Rp :: U :: nil) ++ (B :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpOomtmp;try rewrite HT2 in HBQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: Oo :: nil) (B :: Rp :: nil) 4 2 3 HBQPpQpRpUUpOomtmp HBRpmtmp HBQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour RpUpOo requis par la preuve de (?)RpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Qp :: Rp :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HRpUpOom2 : rk(Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQpRpUpOomtmp : rk(B :: Qp :: Rp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBQpRpUpOoeq HBQpRpUpOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (B :: Qp :: Up :: nil) (Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: Oo :: nil) (B :: Qp :: Up :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Rp :: Up :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQpRpUpOomtmp;try rewrite HT2 in HBQpRpUpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Rp :: Up :: Oo :: nil) (Up :: nil) 3 1 2 HBQpRpUpOomtmp HUpmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HRpUpOom3 : rk(Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpRpUpOoeq : rk(Q :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LQQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpRpUpOomtmp : rk(Q :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUpOoeq HQQpRpUpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Up :: Oo :: nil) (Q :: Qp :: Oo :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: Rp :: Up :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUpOomtmp;try rewrite HT2 in HQQpRpUpOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (Rp :: Up :: Oo :: nil) (Oo :: nil) 4 1 2 HQQpRpUpOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

assert(HRpUpOoM : rk(Rp :: Up :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HRpUpOoeq HRpUpOoM3).
assert(HRpUpOom : rk(Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUpOoeq HRpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpRpUpOo *)
(* dans la couche 0 *)
Lemma LBQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpOo requis par la preuve de (?)BQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpOoeq HABQPpQpRpUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpOomtmp;try rewrite HT2 in HABQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUpOom : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUpOoeq HBQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpOo requis par la preuve de (?)QPpQpRpUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpOoeq HABCQPpQpRpUpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpOomtmp;try rewrite HT2 in HABCQPpQpRpUpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) = 4) by (apply LBQPpQpRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpOoeq HBQPpQpRpUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpOomtmp;try rewrite HT2 in HBQPpQpRpUpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUpOoM : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUpOom : rk(Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUpOoeq HQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpOo requis par la preuve de (?)ABCQPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUpOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUpOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUpOoeq HABCQPpQpRpUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpOo requis par la preuve de (?)PQRPpQpRpUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpOo requis par la preuve de (?)PQRPpQpRpUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUpOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUpOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUpOoeq HPQRPpQpRpUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LUUpOo *)
(* dans constructLemma(), requis par LAUUpOo *)
(* dans la couche 0 *)
Lemma LAPpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Pp :: U :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUUpOom2 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUUpOom3 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUUpOom2 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUUpOomtmp : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUUpOoeq HACPpQpUUpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUUpOomtmp;try rewrite HT2 in HACPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUUpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUUpOom3 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAPpUUpOoM3 : rk(A :: Pp :: U :: Up :: Oo :: nil) <= 3).
{
	assert(HAPpUOoeq : rk(A :: Pp :: U :: Oo :: nil) = 3) by (apply LAPpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUOoMtmp : rk(A :: Pp :: U :: Oo :: nil) <= 3) by (solve_hyps_max HAPpUOoeq HAPpUOoM3).
	assert(HAPpUpOoeq : rk(A :: Pp :: Up :: Oo :: nil) = 3) by (apply LAPpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUpOoMtmp : rk(A :: Pp :: Up :: Oo :: nil) <= 3) by (solve_hyps_max HAPpUpOoeq HAPpUpOoM3).
	assert(HAPpOoeq : rk(A :: Pp :: Oo :: nil) = 3) by (apply LAPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpOomtmp : rk(A :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HAPpOoeq HAPpOom3).
	assert(Hincl : incl (A :: Pp :: Oo :: nil) (list_inter (A :: Pp :: U :: Oo :: nil) (A :: Pp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: Oo :: nil) (A :: Pp :: U :: Oo :: A :: Pp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: U :: Oo :: A :: Pp :: Up :: Oo :: nil) ((A :: Pp :: U :: Oo :: nil) ++ (A :: Pp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Pp :: U :: Oo :: nil) (A :: Pp :: Up :: Oo :: nil) (A :: Pp :: Oo :: nil) 3 3 3 HAPpUOoMtmp HAPpUpOoMtmp HAPpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAPpUUpOoM : rk(A :: Pp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPpUUpOom : rk(A :: Pp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HAPpUUpOoeq HAPpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: U :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AUUpOo requis par la preuve de (?)AUUpOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)AUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUUpOom2 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUUpOom3 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUUpOom2 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUUpOomtmp : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUUpOoeq HACPpQpUUpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUUpOomtmp;try rewrite HT2 in HACPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUUpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUUpOom3 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AUUpOo requis par la preuve de (?)AUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APUUpOo requis par la preuve de (?)AUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQUUpOo requis par la preuve de (?)APUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQUUpOo requis par la preuve de (?)ACPQUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQUUpOo requis par la preuve de (?)ACPQUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQUUpOom2 : rk(A :: C :: P :: Q :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: U :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQUUpOom3 : rk(A :: C :: P :: Q :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: U :: Up :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APUUpOo requis par la preuve de (?)APUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPUUpOom2 : rk(A :: P :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQUUpOomtmp : rk(A :: C :: P :: Q :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HACPQUUpOoeq HACPQUUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: U :: Up :: Oo :: nil) (C :: P :: Q :: A :: P :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: U :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQUUpOomtmp;try rewrite HT2 in HACPQUUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: U :: Up :: Oo :: nil) (P :: nil) 3 1 2 HACPQUUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AUUpOo requis par la preuve de (?)AUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: U :: Up :: Oo ::  de rang :  2 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HAUUpOom2 : rk(A :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPUUpOomtmp : rk(A :: P :: U :: Up :: Oo :: nil) >= 2) by (solve_hyps_min HAPUUpOoeq HAPUUpOom2).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: U :: Up :: Oo :: nil) (A :: P :: U :: A :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: U :: Up :: Oo :: nil) ((A :: P :: U :: nil) ++ (A :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPUUpOomtmp;try rewrite HT2 in HAPUUpOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: U :: Up :: Oo :: nil) (A :: U :: nil) 2 2 2 HAPUUpOomtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Pp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAUUpOom3 : rk(A :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPpUUpOomtmp : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HAPpUUpOoeq HAPpUUpOom3).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: Oo :: nil) (A :: Pp :: Up :: A :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: U :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPpUUpOomtmp;try rewrite HT2 in HAPpUUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: U :: Up :: Oo :: nil) (A :: Up :: nil) 3 2 2 HAPpUUpOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAUUpOoM3 : rk(A :: U :: Up :: Oo :: nil) <= 3).
{
	assert(HAPpUUpOoeq : rk(A :: Pp :: U :: Up :: Oo :: nil) = 3) by (apply LAPpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUUpOoMtmp : rk(A :: Pp :: U :: Up :: Oo :: nil) <= 3) by (solve_hyps_max HAPpUUpOoeq HAPpUUpOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: U :: Up :: Oo :: nil) (A :: Pp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: U :: Up :: Oo :: nil) (A :: Pp :: U :: Up :: Oo :: nil) 3 3 HAPpUUpOoMtmp Hcomp Hincl);apply HT.
}

assert(HAUUpOoM : rk(A :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAUUpOom : rk(A :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HAUUpOoeq HAUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LUUpOo *)
(* dans la couche 0 *)
Lemma LBQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Qp :: U :: Up :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpUUpOo requis par la preuve de (?)BQpUUpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpRpUUpOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUUpOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUUpOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpUUpOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpUUpOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCPRPpQpUUpOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCPRPpQpRpUUpOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpRpUUpOoeq HBCPRPpQpRpUUpOom4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpRpUUpOomtmp;try rewrite HT2 in HBCPRPpQpRpUUpOomtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCPRPpQpRpUUpOomtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BCPQRPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BCPQRPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUUpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUUpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUUpOom2 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUUpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUUpOoeq HBCPQRPpQpUUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUUpOomtmp;try rewrite HT2 in HBCPQRPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUUpOom3 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUUpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUUpOoeq HABPRPpQpRpUUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUUpOomtmp;try rewrite HT2 in HABPRPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: U ::  de rang :  3 et 3 	 A : C :: Pp :: Qp :: U ::   de rang : 3 et 3 *)
assert(HBPRPpQpUUpOom4 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCPRPpQpUUpOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpUUpOoeq HBCPRPpQpUUpOom4).
	assert(HPpQpUeq : rk(Pp :: Qp :: U :: nil) = 3) by (apply LPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpQpUmtmp : rk(Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HPpQpUeq HPpQpUm3).
	assert(Hincl : incl (Pp :: Qp :: U :: nil) (list_inter (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: Pp :: Qp :: U :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpUUpOomtmp;try rewrite HT2 in HBCPRPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (Pp :: Qp :: U :: nil) 4 3 3 HBCPRPpQpUUpOomtmp HPpQpUmtmp HCPpQpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUUpOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUUpOoeq HABPQPpQpRpUUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUUpOomtmp;try rewrite HT2 in HABPQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPU requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQU requis par la preuve de (?)BPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm2 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm3 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQUm2 : rk(B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQUm3 : rk(B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQUmtmp : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HABCPQUeq HABCPQUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: U :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQUmtmp;try rewrite HT2 in HABCPQUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPU requis par la preuve de (?)BPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPUm2 : rk(B :: P :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQUmtmp : rk(B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HBCPQUeq HBCPQUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: U :: nil) (C :: P :: Q :: B :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: U :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQUmtmp;try rewrite HT2 in HBCPQUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: U :: nil) (P :: nil) 3 1 2 HBCPQUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BCPQPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BCPQPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUUpOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUUpOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUUpOom2 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUUpOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUUpOoeq HBCPQPpQpUUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUUpOomtmp;try rewrite HT2 in HBCPQPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: U ::  de rang :  2 et 3 	 A : A :: B :: P :: Q :: U ::   de rang : 3 et 3 *)
assert(HBPPpQpUUpOom3 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABPQUeq : rk(A :: B :: P :: Q :: U :: nil) = 3) by (apply LABPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQUMtmp : rk(A :: B :: P :: Q :: U :: nil) <= 3) by (solve_hyps_max HABPQUeq HABPQUM3).
	assert(HABPQPpQpUUpOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpUUpOoeq HABPQPpQpUUpOom4).
	assert(HBPUmtmp : rk(B :: P :: U :: nil) >= 2) by (solve_hyps_min HBPUeq HBPUm2).
	assert(Hincl : incl (B :: P :: U :: nil) (list_inter (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: B :: P :: Q :: U :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpUUpOomtmp;try rewrite HT2 in HABPQPpQpUUpOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: U :: nil) 4 2 3 HABPQPpQpUUpOomtmp HBPUmtmp HABPQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpUUpOom4 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpUUpOomtmp : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUUpOoeq HBPRPpQpUUpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUUpOomtmp;try rewrite HT2 in HBPRPpQpUUpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpUUpOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpUUpOo requis par la preuve de (?)BQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpUUpOo requis par la preuve de (?)BQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpUUpOom2 : rk(B :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: U :: Up :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HBQpUUpOom3 : rk(B :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HBPPpQpUUpOomtmp : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPPpQpUUpOoeq HBPPpQpUUpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (B :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (P :: Pp :: Oo :: B :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: B :: Qp :: U :: Up :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (B :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPPpQpUUpOomtmp;try rewrite HT2 in HBPPpQpUUpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (B :: Qp :: U :: Up :: Oo :: nil) (Oo :: nil) 4 1 2 HBPPpQpUUpOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBQpUUpOoM3 : rk(B :: Qp :: U :: Up :: Oo :: nil) <= 3).
{
	assert(HBQpUOoeq : rk(B :: Qp :: U :: Oo :: nil) = 3) by (apply LBQpUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpUOoMtmp : rk(B :: Qp :: U :: Oo :: nil) <= 3) by (solve_hyps_max HBQpUOoeq HBQpUOoM3).
	assert(HBQpUpOoeq : rk(B :: Qp :: Up :: Oo :: nil) = 3) by (apply LBQpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpUpOoMtmp : rk(B :: Qp :: Up :: Oo :: nil) <= 3) by (solve_hyps_max HBQpUpOoeq HBQpUpOoM3).
	assert(HBQpOoeq : rk(B :: Qp :: Oo :: nil) = 3) by (apply LBQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpOomtmp : rk(B :: Qp :: Oo :: nil) >= 3) by (solve_hyps_min HBQpOoeq HBQpOom3).
	assert(Hincl : incl (B :: Qp :: Oo :: nil) (list_inter (B :: Qp :: U :: Oo :: nil) (B :: Qp :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: U :: Up :: Oo :: nil) (B :: Qp :: U :: Oo :: B :: Qp :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: U :: Oo :: B :: Qp :: Up :: Oo :: nil) ((B :: Qp :: U :: Oo :: nil) ++ (B :: Qp :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Qp :: U :: Oo :: nil) (B :: Qp :: Up :: Oo :: nil) (B :: Qp :: Oo :: nil) 3 3 3 HBQpUOoMtmp HBQpUpOoMtmp HBQpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBQpUUpOoM : rk(B :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQpUUpOom : rk(B :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBQpUUpOoeq HBQpUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LUUpOo *)
(* dans la couche 0 *)
Lemma LABQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Qp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQpUUpOo requis par la preuve de (?)ABQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQpUUpOo requis par la preuve de (?)ABQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQpUUpOo requis par la preuve de (?)ABQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpUUpOom2 : rk(A :: B :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQpUUpOom3 : rk(A :: B :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil) 3 3 HABQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQpUUpOom4 : rk(A :: B :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQpOoeq : rk(A :: B :: Qp :: Oo :: nil) = 4) by (apply LABQpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQpOomtmp : rk(A :: B :: Qp :: Oo :: nil) >= 4) by (solve_hyps_min HABQpOoeq HABQpOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Qp :: Oo :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Qp :: Oo :: nil) (A :: B :: Qp :: U :: Up :: Oo :: nil) 4 4 HABQpOomtmp Hcomp Hincl);apply HT.
}

assert(HABQpUUpOoM : rk(A :: B :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQpUUpOom : rk(A :: B :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABQpUUpOoeq HABQpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(U :: Up :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour UUpOo requis par la preuve de (?)UUpOo pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)UUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUUpOo requis par la preuve de (?)ACPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUUpOom2 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUUpOom3 : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUUpOo requis par la preuve de (?)APpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUUpOom2 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUUpOomtmp : rk(A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUUpOoeq HACPpQpUUpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Up :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUUpOomtmp;try rewrite HT2 in HACPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUUpOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUUpOom3 : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour UUpOo requis par la preuve de (?)UUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: Pp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HUUpOom2 : rk(U :: Up :: Oo :: nil) >= 2).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPpUUpOomtmp : rk(A :: Pp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HAPpUUpOoeq HAPpUUpOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (A :: Pp :: Up :: nil) (U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: Oo :: nil) (A :: Pp :: Up :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: U :: Up :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPpUUpOomtmp;try rewrite HT2 in HAPpUUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (U :: Up :: Oo :: nil) (Up :: nil) 3 1 2 HAPpUUpOomtmp HUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HUUpOoM2 : rk(U :: Up :: Oo :: nil) <= 2).
{
	assert(HAUUpOoeq : rk(A :: U :: Up :: Oo :: nil) = 3) by (apply LAUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUUpOoMtmp : rk(A :: U :: Up :: Oo :: nil) <= 3) by (solve_hyps_max HAUUpOoeq HAUUpOoM3).
	assert(HBQpUUpOoeq : rk(B :: Qp :: U :: Up :: Oo :: nil) = 3) by (apply LBQpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpUUpOoMtmp : rk(B :: Qp :: U :: Up :: Oo :: nil) <= 3) by (solve_hyps_max HBQpUUpOoeq HBQpUUpOoM3).
	assert(HABQpUUpOoeq : rk(A :: B :: Qp :: U :: Up :: Oo :: nil) = 4) by (apply LABQpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQpUUpOomtmp : rk(A :: B :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQpUUpOoeq HABQpUUpOom4).
	assert(Hincl : incl (U :: Up :: Oo :: nil) (list_inter (A :: U :: Up :: Oo :: nil) (B :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Qp :: U :: Up :: Oo :: nil) (A :: U :: Up :: Oo :: B :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: U :: Up :: Oo :: B :: Qp :: U :: Up :: Oo :: nil) ((A :: U :: Up :: Oo :: nil) ++ (B :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQpUUpOomtmp;try rewrite HT2 in HABQpUUpOomtmp.
	assert(HT := rule_3 (A :: U :: Up :: Oo :: nil) (B :: Qp :: U :: Up :: Oo :: nil) (U :: Up :: Oo :: nil) 3 3 4 HAUUpOoMtmp HBQpUUpOoMtmp HABQpUUpOomtmp Hincl);apply HT.
}


assert(HUUpOoM : rk(U :: Up :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HUUpOoeq HUUpOoM3).
assert(HUUpOom : rk(U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HUUpOoeq HUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBPPpQpUUpOo *)
(* dans constructLemma(), requis par LBPRPpQpUUpOo *)
(* dans constructLemma(), requis par LBCPRPpQpUUpOo *)
(* dans la couche 0 *)
Lemma LBCPRPpQpRpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpRpUUpOo requis par la preuve de (?)BCPRPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpRpUUpOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUUpOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpRpUUpOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBCRRpeq : rk(B :: C :: R :: Rp :: nil) = 4) by (apply LBCRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRRpmtmp : rk(B :: C :: R :: Rp :: nil) >= 4) by (solve_hyps_min HBCRRpeq HBCRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HBCRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBCPRPpQpRpUUpOoM : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpQpRpUUpOom : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpQpRpUUpOoeq HBCPRPpQpRpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCPRPpQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPRPpQpUUpOo requis par la preuve de (?)BCPRPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPRPpQpUUpOom2 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPRPpQpUUpOom3 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCReq : rk(B :: C :: R :: nil) = 3) by (apply LBCR with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCRmtmp : rk(B :: C :: R :: nil) >= 3) by (solve_hyps_min HBCReq HBCRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: R :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Qp ::  de rang :  3 et 3 	 A : B :: C :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBCPRPpQpUUpOom4 : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBCQpRpeq : rk(B :: C :: Qp :: Rp :: nil) = 3) by (apply LBCQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpRpMtmp : rk(B :: C :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBCQpRpeq HBCQpRpM3).
	assert(HBCPRPpQpRpUUpOoeq : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) = 4) by (apply LBCPRPpQpRpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpQpRpUUpOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpRpUUpOoeq HBCPRPpQpRpUUpOom4).
	assert(HBCQpeq : rk(B :: C :: Qp :: nil) = 3) by (apply LBCQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQpmtmp : rk(B :: C :: Qp :: nil) >= 3) by (solve_hyps_min HBCQpeq HBCQpm3).
	assert(Hincl : incl (B :: C :: Qp :: nil) (list_inter (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Qp :: Rp :: B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((B :: C :: Qp :: Rp :: nil) ++ (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpRpUUpOomtmp;try rewrite HT2 in HBCPRPpQpRpUUpOomtmp.
	assert(HT := rule_4 (B :: C :: Qp :: Rp :: nil) (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: C :: Qp :: nil) 4 3 3 HBCPRPpQpRpUUpOomtmp HBCQpmtmp HBCQpRpMtmp Hincl); apply HT.
}

assert(HBCPRPpQpUUpOoM : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCPRPpQpUUpOom : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBCPRPpQpUUpOoeq HBCPRPpQpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BCPQRPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUUpOo requis par la preuve de (?)BCPQRPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUUpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUUpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUUpOo requis par la preuve de (?)BPRPpQpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUUpOom2 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUUpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUUpOoeq HBCPQRPpQpUUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUUpOomtmp;try rewrite HT2 in HBCPQRPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUUpOom3 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUUpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUUpOoeq HABPRPpQpRpUUpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUUpOomtmp;try rewrite HT2 in HABPRPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUUpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: U ::  de rang :  3 et 3 	 A : C :: Pp :: Qp :: U ::   de rang : 3 et 3 *)
assert(HBPRPpQpUUpOom4 : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HCPpQpUeq : rk(C :: Pp :: Qp :: U :: nil) = 3) by (apply LCPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPpQpUMtmp : rk(C :: Pp :: Qp :: U :: nil) <= 3) by (solve_hyps_max HCPpQpUeq HCPpQpUM3).
	assert(HBCPRPpQpUUpOoeq : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) = 4) by (apply LBCPRPpQpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCPRPpQpUUpOomtmp : rk(B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBCPRPpQpUUpOoeq HBCPRPpQpUUpOom4).
	assert(HPpQpUeq : rk(Pp :: Qp :: U :: nil) = 3) by (apply LPpQpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpQpUmtmp : rk(Pp :: Qp :: U :: nil) >= 3) by (solve_hyps_min HPpQpUeq HPpQpUm3).
	assert(Hincl : incl (Pp :: Qp :: U :: nil) (list_inter (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: U :: B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: Pp :: Qp :: U :: nil) ++ (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPRPpQpUUpOomtmp;try rewrite HT2 in HBCPRPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: U :: nil) (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (Pp :: Qp :: U :: nil) 4 3 3 HBCPRPpQpUUpOomtmp HPpQpUmtmp HCPpQpUMtmp Hincl); apply HT.
}

assert(HBPRPpQpUUpOoM : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpQpUUpOom : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpQpUUpOoeq HBPRPpQpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPPpQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Pp :: Qp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUUpOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUUpOoeq HABPQPpQpRpUUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUUpOomtmp;try rewrite HT2 in HABPQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPU requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQU requis par la preuve de (?)BPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQU requis par la preuve de (?)ABCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm2 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: U :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQUm3 : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: U :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQU requis par la preuve de (?)BCPQU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQUm2 : rk(B :: C :: P :: Q :: U :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: U :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQUm3 : rk(B :: C :: P :: Q :: U :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQUmtmp : rk(A :: B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HABCPQUeq HABCPQUm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: U :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: U :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQUmtmp;try rewrite HT2 in HABCPQUmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: U :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQUmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPU requis par la preuve de (?)BPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: U ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPUm2 : rk(B :: P :: U :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQUmtmp : rk(B :: C :: P :: Q :: U :: nil) >= 3) by (solve_hyps_min HBCPQUeq HBCPQUm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: U :: nil) (C :: P :: Q :: B :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: U :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQUmtmp;try rewrite HT2 in HBCPQUmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: U :: nil) (P :: nil) 3 1 2 HBCPQUmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BCPQPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPpQpUUpOo requis par la preuve de (?)BCPQPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpQpUUpOom2 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQPpQpUUpOom3 : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPPpQpUUpOo requis par la preuve de (?)BPPpQpUUpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpQpUUpOom2 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpQpUUpOomtmp : rk(B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQPpQpUUpOoeq HBCPQPpQpUUpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpQpUUpOomtmp;try rewrite HT2 in HBCPQPpQpUUpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (P :: nil) 3 1 2 HBCPQPpQpUUpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: U ::  de rang :  2 et 3 	 A : A :: B :: P :: Q :: U ::   de rang : 3 et 3 *)
assert(HBPPpQpUUpOom3 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABPQUeq : rk(A :: B :: P :: Q :: U :: nil) = 3) by (apply LABPQU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQUMtmp : rk(A :: B :: P :: Q :: U :: nil) <= 3) by (solve_hyps_max HABPQUeq HABPQUM3).
	assert(HABPQPpQpUUpOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpUUpOoeq HABPQPpQpUUpOom4).
	assert(HBPUmtmp : rk(B :: P :: U :: nil) >= 2) by (solve_hyps_min HBPUeq HBPUm2).
	assert(Hincl : incl (B :: P :: U :: nil) (list_inter (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: P :: Q :: U :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: B :: P :: Q :: U :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpUUpOomtmp;try rewrite HT2 in HABPQPpQpUUpOomtmp.
	assert(HT := rule_4 (A :: B :: P :: Q :: U :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: U :: nil) 4 2 3 HABPQPpQpUUpOomtmp HBPUmtmp HABPQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Oo ::  de rang :  3 et 3 	 A : B :: P :: R :: Oo ::   de rang : 3 et 3 *)
assert(HBPPpQpUUpOom4 : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HBPROoeq : rk(B :: P :: R :: Oo :: nil) = 3) by (apply LBPROo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPROoMtmp : rk(B :: P :: R :: Oo :: nil) <= 3) by (solve_hyps_max HBPROoeq HBPROoM3).
	assert(HBPRPpQpUUpOoeq : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) = 4) by (apply LBPRPpQpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpQpUUpOomtmp : rk(B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUUpOoeq HBPRPpQpUUpOom4).
	assert(HBPOoeq : rk(B :: P :: Oo :: nil) = 3) by (apply LBPOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPOomtmp : rk(B :: P :: Oo :: nil) >= 3) by (solve_hyps_min HBPOoeq HBPOom3).
	assert(Hincl : incl (B :: P :: Oo :: nil) (list_inter (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Oo :: B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) ((B :: P :: R :: Oo :: nil) ++ (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUUpOomtmp;try rewrite HT2 in HBPRPpQpUUpOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Oo :: nil) (B :: P :: Pp :: Qp :: U :: Up :: Oo :: nil) (B :: P :: Oo :: nil) 4 3 3 HBPRPpQpUUpOomtmp HBPOomtmp HBPROoMtmp Hincl); apply HT.
}

assert(HBPPpQpUUpOoM : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPPpQpUUpOom : rk(B :: P :: Pp :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBPPpQpUUpOoeq HBPPpQpUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LABPQPpQpUUpOo *)
(* dans la couche 0 *)
Lemma LABPQPpQpRpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpRpUUpOo requis par la preuve de (?)ABPQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpRpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPQPpQpRpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPQPpQpRpUUpOoM : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpQpRpUUpOom : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpQpRpUUpOoeq HABPQPpQpRpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPQPpQpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPQPpQpUUpOo requis par la preuve de (?)ABPQPpQpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom2 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPQPpQpUUpOom3 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPQPpQpUUpOom4 : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPQPpQpRpUUpOoeq : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) = 4) by (apply LABPQPpQpRpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPQPpQpRpUUpOomtmp : rk(A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABPQPpQpRpUUpOoeq HABPQPpQpRpUUpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPQPpQpRpUUpOomtmp;try rewrite HT2 in HABPQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPQPpQpRpUUpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABPQPpQpUUpOoM : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPQPpQpUUpOom : rk(A :: B :: P :: Q :: Pp :: Qp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABPQPpQpUUpOoeq HABPQPpQpUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQPpQpRpUUpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpOo requis par la preuve de (?)ABQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpOoeq HABQPpQpRpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpOo requis par la preuve de (?)BQPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) = 4) by (apply LABQPpQpRpUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpOoeq HABQPpQpRpUUpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpOomtmp;try rewrite HT2 in HABQPpQpRpUUpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpOoeq HBQPpQpRpUUpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpQpRpUUpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUUpOo requis par la preuve de (?)ABPRPpQpRpUUpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUUpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpQpRpUUpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpRpUUpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: U :: Up :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpRpUUpOoeq HABPRPpQpRpUUpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LDOo *)
(* dans constructLemma(), requis par LQQpDOo *)
(* dans constructLemma(), requis par LABQQpDOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpDOo requis par la preuve de (?)ABQPpQpRpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpDOo requis par la preuve de (?)ABQPpQpRpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpDOo requis par la preuve de (?)ABQPpQpRpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpDOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpDOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpDOoeq HABQPpQpRpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQQpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Qp :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQQpDOo requis par la preuve de (?)ABQQpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQQpDOo requis par la preuve de (?)ABQQpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQQpDOo requis par la preuve de (?)ABQQpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpDOom2 : rk(A :: B :: Q :: Qp :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpDOom3 : rk(A :: B :: Q :: Qp :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Qp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQQpDOom4 : rk(A :: B :: Q :: Qp :: D :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpDOoeq HABQPpQpRpDOom4).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hincl : incl (A :: B :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: D :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Qp :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpDOomtmp;try rewrite HT2 in HABQPpQpRpDOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: D :: Oo :: nil) (A :: B :: Qp :: nil) 4 3 3 HABQPpQpRpDOomtmp HABQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQQpDOoM : rk(A :: B :: Q :: Qp :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQQpDOom : rk(A :: B :: Q :: Qp :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQQpDOoeq HABQQpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QQpDOo requis par la preuve de (?)QQpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpDOo requis par la preuve de (?)QQpDOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)QQpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpDOoeq HABQPpQpRpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpDOomtmp;try rewrite HT2 in HABQPpQpRpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpDOo requis par la preuve de (?)QQpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpDOom2 : rk(Q :: Qp :: D :: Oo :: nil) >= 2).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpDOoeq HBQPpQpRpDOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Qp :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Qp :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Qp :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Qp :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpDOomtmp;try rewrite HT2 in HBQPpQpRpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Qp :: D :: Oo :: nil) (Qp :: nil) 4 1 3 HBQPpQpRpDOomtmp HQpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HQQpDOoM3 : rk(Q :: Qp :: D :: Oo :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Q :: Qp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: D :: Oo :: nil) (D :: Q :: Qp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Q :: Qp :: Oo :: nil) ((D :: nil) ++ (Q :: Qp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Q :: Qp :: Oo :: nil) (nil) 1 2 0 HDMtmp HQQpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Qp :: D :: Oo ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: B :: D ::   de rang : 2 et 2 *)
assert(HQQpDOom3 : rk(Q :: Qp :: D :: Oo :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 2) by (apply LABD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 2) by (solve_hyps_max HABDeq HABDM2).
	assert(HABQQpDOoeq : rk(A :: B :: Q :: Qp :: D :: Oo :: nil) = 4) by (apply LABQQpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQQpDOomtmp : rk(A :: B :: Q :: Qp :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQQpDOoeq HABQQpDOom4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: B :: D :: nil) (Q :: Qp :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Qp :: D :: Oo :: nil) (A :: B :: D :: Q :: Qp :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Q :: Qp :: D :: Oo :: nil) ((A :: B :: D :: nil) ++ (Q :: Qp :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQQpDOomtmp;try rewrite HT2 in HABQQpDOomtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (Q :: Qp :: D :: Oo :: nil) (D :: nil) 4 1 2 HABQQpDOomtmp HDmtmp HABDMtmp Hincl); apply HT.
}

assert(HQQpDOoM : rk(Q :: Qp :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpDOom : rk(Q :: Qp :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpDOoeq HQQpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(D :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DOo requis par la preuve de (?)DOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: D :: Oo ::  de rang :  3 et 3 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HDOom2 : rk(D :: Oo :: nil) >= 2).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpDOoeq : rk(Q :: Qp :: D :: Oo :: nil) = 3) by (apply LQQpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpDOomtmp : rk(Q :: Qp :: D :: Oo :: nil) >= 3) by (solve_hyps_min HQQpDOoeq HQQpDOom3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: D :: Oo :: nil) (Q :: Qp :: Oo :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: D :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpDOomtmp;try rewrite HT2 in HQQpDOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (D :: Oo :: nil) (Oo :: nil) 3 1 2 HQQpDOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

assert(HDOoM : rk(D :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDOoeq HDOoM2).
assert(HDOom : rk(D :: Oo ::  nil) >= 1) by (solve_hyps_min HDOoeq HDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDOo requis par la preuve de (?)ABDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDOo requis par la preuve de (?)ABDOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDOo requis par la preuve de (?)ABDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDOom2 : rk(A :: B :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -2 et 5*)
assert(HABDOoM3 : rk(A :: B :: D :: Oo :: nil) <= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 2) by (apply LABD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 2) by (solve_hyps_max HABDeq HABDM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: D :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: Oo :: nil) (A :: B :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Oo :: nil) ((A :: B :: D :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: D :: nil) (Oo :: nil) (nil) 2 1 0 HABDMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDOom3 : rk(A :: B :: D :: Oo :: nil) >= 3).
{
	assert(HABOoeq : rk(A :: B :: Oo :: nil) = 3) by (apply LABOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABOomtmp : rk(A :: B :: Oo :: nil) >= 3) by (solve_hyps_min HABOoeq HABOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Oo :: nil) (A :: B :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Oo :: nil) (A :: B :: D :: Oo :: nil) 3 3 HABOomtmp Hcomp Hincl);apply HT.
}

assert(HABDOoM : rk(A :: B :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDOom : rk(A :: B :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABDOoeq HABDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpDOo requis par la preuve de (?)BQPpQpRpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpDOoeq HABQPpQpRpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpDOomtmp;try rewrite HT2 in HABQPpQpRpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpDOoM : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpDOom : rk(B :: Q :: Pp :: Qp :: Rp :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpDOoeq HBQPpQpRpDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LUDOo *)
(* dans la couche 0 *)
Lemma LABUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABUDOo requis par la preuve de (?)ABUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABUDOo requis par la preuve de (?)ABUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABUDOo requis par la preuve de (?)ABUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABUDOom2 : rk(A :: B :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABUDOom3 : rk(A :: B :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABOoeq : rk(A :: B :: Oo :: nil) = 3) by (apply LABOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABOomtmp : rk(A :: B :: Oo :: nil) >= 3) by (solve_hyps_min HABOoeq HABOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Oo :: nil) (A :: B :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Oo :: nil) (A :: B :: U :: D :: Oo :: nil) 3 3 HABOomtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABUDOom4 : rk(A :: B :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABUOoeq : rk(A :: B :: U :: Oo :: nil) = 4) by (apply LABUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABUOomtmp : rk(A :: B :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABUOoeq HABUOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: U :: Oo :: nil) (A :: B :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: U :: Oo :: nil) (A :: B :: U :: D :: Oo :: nil) 4 4 HABUOomtmp Hcomp Hincl);apply HT.
}

assert(HABUDOoM : rk(A :: B :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABUDOom : rk(A :: B :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABUDOoeq HABUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(U :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour UDOo requis par la preuve de (?)UDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpUDOo requis par la preuve de (?)UDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)PPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUDOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUDOom2 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpUDOom3 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpUDOomtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpUDOoeq HAPQRPpQpRpUDOom4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpUDOomtmp;try rewrite HT2 in HAPQRPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpUDOomtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUDOom4 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PUD requis par la preuve de (?)PPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CPQPpOo requis par la preuve de (?)PUD pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)ABCPQPpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPpOo requis par la preuve de (?)ABCPQPpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpOom2 : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpOom3 : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CPQPpOo requis par la preuve de (?)CPQPpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp :: Oo ::  de rang :  3 et 4 	 AiB : C :: Q ::  de rang :  2 et 2 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HCPQPpOom2 : rk(C :: P :: Q :: Pp :: Oo :: nil) >= 2).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpOomtmp : rk(A :: B :: C :: P :: Q :: Pp :: Oo :: nil) >= 3) by (solve_hyps_min HABCPQPpOoeq HABCPQPpOom3).
	assert(HCQeq : rk(C :: Q :: nil) = 2) by (apply LCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCQmtmp : rk(C :: Q :: nil) >= 2) by (solve_hyps_min HCQeq HCQm2).
	assert(Hincl : incl (C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: Oo :: nil) (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: C :: P :: Q :: Pp :: Oo :: nil) ((A :: B :: C :: Q :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpOomtmp;try rewrite HT2 in HABCPQPpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (C :: Q :: nil) 3 2 3 HABCPQPpOomtmp HCQmtmp HABCQMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HCPQPpOoM3 : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (P :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: Oo :: nil) (C :: P :: Q :: P :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: P :: Pp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (P :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: P :: Q :: nil) (P :: Pp :: Oo :: nil) (P :: nil) 2 2 1 HCPQMtmp HPPpOoMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PUD requis par la preuve de (?)PUD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HPUDm2 : rk(P :: U :: D :: nil) >= 2).
{
	assert(HCPQPpOoMtmp : rk(C :: P :: Q :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HCPQPpOoeq HCPQPpOoM3).
	assert(HCPQPpUDOoeq : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) = 4) by (apply LCPQPpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HCPQPpUDOomtmp : rk(C :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HCPQPpUDOoeq HCPQPpUDOom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: U :: D :: nil) (C :: P :: Q :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: P :: Q :: Pp :: U :: D :: Oo :: nil) (P :: U :: D :: C :: P :: Q :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: U :: D :: C :: P :: Q :: Pp :: Oo :: nil) ((P :: U :: D :: nil) ++ (C :: P :: Q :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCPQPpUDOomtmp;try rewrite HT2 in HCPQPpUDOomtmp.
	assert(HT := rule_2 (P :: U :: D :: nil) (C :: P :: Q :: Pp :: Oo :: nil) (P :: nil) 4 1 3 HCPQPpUDOomtmp HPmtmp HCPQPpOoMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpUDOo requis par la preuve de (?)PPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQPpUDOo requis par la preuve de (?)PPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDOom2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUDOom3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDOom4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPPp requis par la preuve de (?)BPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm2 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm3 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpm2 : rk(B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQPpm3 : rk(B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HABCPQPpeq HABCPQPpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpmtmp;try rewrite HT2 in HABCPQPpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQPpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpm2 : rk(B :: P :: Pp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpmtmp : rk(B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HBCPQPpeq HBCPQPpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: nil) (C :: P :: Q :: B :: P :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpmtmp;try rewrite HT2 in HBCPQPpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: nil) (P :: nil) 3 1 2 HBCPQPpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQPpUDOo requis par la preuve de (?)BPQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQPpUDOo requis par la preuve de (?)BPQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQPpUDOom2 : rk(B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Pp ::  de rang :  2 et 3 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HBPQPpUDOom3 : rk(B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpUDOomtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBPQRPpRpUDOoeq HBPQRPpRpUDOom4).
	assert(HBPPpmtmp : rk(B :: P :: Pp :: nil) >= 2) by (solve_hyps_min HBPPpeq HBPPpm2).
	assert(Hincl : incl (B :: P :: Pp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (B :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) (B :: P :: R :: Pp :: Rp :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: B :: P :: Q :: Pp :: U :: D :: Oo :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (B :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpUDOomtmp;try rewrite HT2 in HBPQRPpRpUDOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (B :: P :: Q :: Pp :: U :: D :: Oo :: nil) (B :: P :: Pp :: nil) 4 2 3 HBPQRPpRpUDOomtmp HBPPpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpUDOo requis par la preuve de (?)PPpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : B :: Q :: U ::   de rang : 2 et 2 *)
assert(HPPpUDOom2 : rk(P :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQUMtmp : rk(B :: Q :: U :: nil) <= 2) by (solve_hyps_max HBQUeq HBQUM2).
	assert(HBPQPpUDOomtmp : rk(B :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HBPQPpUDOoeq HBPQPpUDOom3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (B :: Q :: U :: nil) (P :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: Pp :: U :: D :: Oo :: nil) (B :: Q :: U :: P :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: U :: P :: Pp :: U :: D :: Oo :: nil) ((B :: Q :: U :: nil) ++ (P :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQPpUDOomtmp;try rewrite HT2 in HBPQPpUDOomtmp.
	assert(HT := rule_4 (B :: Q :: U :: nil) (P :: Pp :: U :: D :: Oo :: nil) (U :: nil) 3 1 2 HBPQPpUDOomtmp HUmtmp HBQUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: Pp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : P :: U :: D ::  de rang :  2 et 3 	 A : A :: P :: Q :: U :: D ::   de rang : 3 et 3 *)
assert(HPPpUDOom3 : rk(P :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPQUDeq : rk(A :: P :: Q :: U :: D :: nil) = 3) by (apply LAPQUD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQUDMtmp : rk(A :: P :: Q :: U :: D :: nil) <= 3) by (solve_hyps_max HAPQUDeq HAPQUDM3).
	assert(HAPQPpUDOomtmp : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQPpUDOoeq HAPQPpUDOom4).
	assert(HPUDmtmp : rk(P :: U :: D :: nil) >= 2) by (solve_hyps_min HPUDeq HPUDm2).
	assert(Hincl : incl (P :: U :: D :: nil) (list_inter (A :: P :: Q :: U :: D :: nil) (P :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: P :: Q :: U :: D :: P :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: U :: D :: P :: Pp :: U :: D :: Oo :: nil) ((A :: P :: Q :: U :: D :: nil) ++ (P :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQPpUDOomtmp;try rewrite HT2 in HAPQPpUDOomtmp.
	assert(HT := rule_4 (A :: P :: Q :: U :: D :: nil) (P :: Pp :: U :: D :: Oo :: nil) (P :: U :: D :: nil) 4 2 3 HAPQPpUDOomtmp HPUDmtmp HAPQUDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour UDOo requis par la preuve de (?)UDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HUDOom2 : rk(U :: D :: Oo :: nil) >= 2).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPPpUDOomtmp : rk(P :: Pp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HPPpUDOoeq HPPpUDOom3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: U :: D :: Oo :: nil) (P :: Pp :: Oo :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: U :: D :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpUDOomtmp;try rewrite HT2 in HPPpUDOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (U :: D :: Oo :: nil) (Oo :: nil) 3 1 2 HPPpUDOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : D :: Oo ::  de rang :  2 et 2 	 A : A :: B :: D :: Oo ::   de rang : 3 et 3 *)
assert(HUDOom3 : rk(U :: D :: Oo :: nil) >= 3).
{
	assert(HABDOoeq : rk(A :: B :: D :: Oo :: nil) = 3) by (apply LABDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDOoMtmp : rk(A :: B :: D :: Oo :: nil) <= 3) by (solve_hyps_max HABDOoeq HABDOoM3).
	assert(HABUDOoeq : rk(A :: B :: U :: D :: Oo :: nil) = 4) by (apply LABUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABUDOomtmp : rk(A :: B :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABUDOoeq HABUDOom4).
	assert(HDOoeq : rk(D :: Oo :: nil) = 2) by (apply LDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HDOomtmp : rk(D :: Oo :: nil) >= 2) by (solve_hyps_min HDOoeq HDOom2).
	assert(Hincl : incl (D :: Oo :: nil) (list_inter (A :: B :: D :: Oo :: nil) (U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: U :: D :: Oo :: nil) (A :: B :: D :: Oo :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Oo :: U :: D :: Oo :: nil) ((A :: B :: D :: Oo :: nil) ++ (U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABUDOomtmp;try rewrite HT2 in HABUDOomtmp.
	assert(HT := rule_4 (A :: B :: D :: Oo :: nil) (U :: D :: Oo :: nil) (D :: Oo :: nil) 4 2 3 HABUDOomtmp HDOomtmp HABDOoMtmp Hincl); apply HT.
}

assert(HUDOoM : rk(U :: D :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HUDOoeq HUDOoM3).
assert(HUDOom : rk(U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HUDOoeq HUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpUDOo requis par la preuve de (?)ABQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpUDOom2 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpUDOom3 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpUDOom4 : rk(A :: B :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: B :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpUDOoM : rk(A :: B :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpUDOom : rk(A :: B :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpUDOoeq HABQPpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQPpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Pp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUDOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpUDOo requis par la preuve de (?)APQPpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUDOom2 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpUDOom3 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpUDOomtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpUDOoeq HAPQRPpQpRpUDOom4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: U :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpUDOomtmp;try rewrite HT2 in HAPQRPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpUDOomtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpUDOom4 : rk(A :: P :: Q :: Pp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQPpUeq : rk(A :: Q :: Pp :: U :: nil) = 4) by (apply LAQPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpUmtmp : rk(A :: Q :: Pp :: U :: nil) >= 4) by (solve_hyps_min HAQPpUeq HAQPpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: U :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: U :: nil) (A :: P :: Q :: Pp :: U :: D :: Oo :: nil) 4 4 HAQPpUmtmp Hcomp Hincl);apply HT.
}

assert(HAPQPpUDOoM : rk(A :: P :: Q :: Pp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQPpUDOom : rk(A :: P :: Q :: Pp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQPpUDOoeq HAPQPpUDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpUDOo *)
(* dans la couche 0 *)
Lemma LRRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(R :: Rp :: U :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour RRpUDOo requis par la preuve de (?)RRpUDOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)RRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)ACPQRRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)ACPQRRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRRpUDOom2 : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRRpUDOom3 : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRRpUDOom2 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRRpUDOomtmp : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRRpUDOoeq HACPQRRpUDOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Rp :: U :: D :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRRpUDOomtmp;try rewrite HT2 in HACPQRRpUDOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) (P :: nil) 3 1 2 HACPQRRpUDOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRRpUDOom3 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: R :: Rp ::  de rang :  3 et 3 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRRpUDOom4 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDOomtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDOoeq HAPQRQpRpUDOom4).
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hincl : incl (A :: R :: Rp :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: Rp :: U :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDOomtmp;try rewrite HT2 in HAPQRQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) (A :: R :: Rp :: nil) 4 3 3 HAPQRQpRpUDOomtmp HARRpmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RRpUDOo requis par la preuve de (?)RRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RRpUDOo requis par la preuve de (?)RRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HRRpUDOom2 : rk(R :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HRRpeq : rk(R :: Rp :: nil) = 2) by (apply LRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpmtmp : rk(R :: Rp :: nil) >= 2) by (solve_hyps_min HRRpeq HRRpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (R :: Rp :: nil) (R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (R :: Rp :: nil) (R :: Rp :: U :: D :: Oo :: nil) 2 2 HRRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HRRpUDOom3 : rk(R :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRRpUDOomtmp : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPRRpUDOoeq HAPRRpUDOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (R :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Rp :: U :: D :: Oo :: nil) (A :: P :: U :: R :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: R :: Rp :: U :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (R :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRRpUDOomtmp;try rewrite HT2 in HAPRRpUDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (R :: Rp :: U :: D :: Oo :: nil) (U :: nil) 4 1 2 HAPRRpUDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HRRpUDOoM3 : rk(R :: Rp :: U :: D :: Oo :: nil) <= 3).
{
	assert(HRUDMtmp : rk(R :: U :: D :: nil) <= 2) by (solve_hyps_max HRUDeq HRUDM2).
	assert(HRRpOoeq : rk(R :: Rp :: Oo :: nil) = 2) by (apply LRRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpOoMtmp : rk(R :: Rp :: Oo :: nil) <= 2) by (solve_hyps_max HRRpOoeq HRRpOoM2).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (R :: U :: D :: nil) (R :: Rp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (R :: Rp :: U :: D :: Oo :: nil) (R :: U :: D :: R :: Rp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (R :: U :: D :: R :: Rp :: Oo :: nil) ((R :: U :: D :: nil) ++ (R :: Rp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (R :: U :: D :: nil) (R :: Rp :: Oo :: nil) (R :: nil) 2 2 1 HRUDMtmp HRRpOoMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HRRpUDOoM : rk(R :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRRpUDOom : rk(R :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HRRpUDOoeq HRRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: U :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour RpUDOo requis par la preuve de (?)RpUDOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)RpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUDOoeq HABQPpQpRpUDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUDOomtmp;try rewrite HT2 in HABQPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUDOom2 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUDOoeq HABCQPpQpRpUDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUDOomtmp;try rewrite HT2 in HABCQPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUDOom3 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUDOom4 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUDOoeq HBQPpQpRpUDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUDOomtmp;try rewrite HT2 in HBQPpQpRpUDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUDOom2 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUDOoeq HPQRPpQpRpUDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUDOomtmp;try rewrite HT2 in HPQRPpQpRpUDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQQpRpUDOom3 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQQpRpUDOomtmp : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQQpRpUDOoeq HAPQQpRpUDOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: P :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQQpRpUDOomtmp;try rewrite HT2 in HAPQQpRpUDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (U :: nil) 4 1 2 HAPQQpRpUDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Rp :: U ::  de rang :  3 et 3 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQQpRpUDOom4 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUDOomtmp : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUDOoeq HQPpQpRpUDOom4).
	assert(HQRpUeq : rk(Q :: Rp :: U :: nil) = 3) by (apply LQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUmtmp : rk(Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HQRpUeq HQRpUm3).
	assert(Hincl : incl (Q :: Rp :: U :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUDOomtmp;try rewrite HT2 in HQPpQpRpUDOomtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Rp :: U :: nil) 4 3 3 HQPpQpRpUDOomtmp HQRpUmtmp HQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RpUDOo requis par la preuve de (?)RpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRpUDOo requis par la preuve de (?)RpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRpUDOo requis par la preuve de (?)APRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRpUDOo requis par la preuve de (?)APRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRpUDOo requis par la preuve de (?)ACPQRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRpUDOo requis par la preuve de (?)ACPQRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRpUDOom2 : rk(A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRpUDOom3 : rk(A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRpUDOo requis par la preuve de (?)APRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Rp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRpUDOom2 : rk(A :: P :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRpUDOomtmp : rk(A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRpUDOoeq HACPQRpUDOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Rp :: U :: D :: Oo :: nil) (C :: P :: Q :: A :: P :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Rp :: U :: D :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRpUDOomtmp;try rewrite HT2 in HACPQRpUDOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Rp :: U :: D :: Oo :: nil) (P :: nil) 3 1 2 HACPQRpUDOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRpUDOom3 : rk(A :: P :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDOomtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDOoeq HAPQRQpRpUDOom4).
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hincl : incl (A :: Rp :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Rp :: U :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDOomtmp;try rewrite HT2 in HAPQRQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Rp :: U :: D :: Oo :: nil) (A :: Rp :: nil) 4 2 3 HAPQRQpRpUDOomtmp HARpmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RpUDOo requis par la preuve de (?)RpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Rp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HRpUDOom2 : rk(Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRpUDOomtmp : rk(A :: P :: Rp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HAPRpUDOoeq HAPRpUDOom3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Rp :: U :: D :: Oo :: nil) (A :: P :: U :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Rp :: U :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRpUDOomtmp;try rewrite HT2 in HAPRpUDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Rp :: U :: D :: Oo :: nil) (U :: nil) 3 1 2 HAPRpUDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HRpUDOom3 : rk(Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpRpUDOomtmp : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUDOoeq HQQpRpUDOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Qp :: Oo :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: Rp :: U :: D :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUDOomtmp;try rewrite HT2 in HQQpRpUDOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (Rp :: U :: D :: Oo :: nil) (Oo :: nil) 4 1 2 HQQpRpUDOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HRpUDOoM3 : rk(Rp :: U :: D :: Oo :: nil) <= 3).
{
	assert(HRRpUDOoeq : rk(R :: Rp :: U :: D :: Oo :: nil) = 3) by (apply LRRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRRpUDOoMtmp : rk(R :: Rp :: U :: D :: Oo :: nil) <= 3) by (solve_hyps_max HRRpUDOoeq HRRpUDOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Rp :: U :: D :: Oo :: nil) (R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Rp :: U :: D :: Oo :: nil) (R :: Rp :: U :: D :: Oo :: nil) 3 3 HRRpUDOoMtmp Hcomp Hincl);apply HT.
}

assert(HRpUDOoM : rk(Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRpUDOom : rk(Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUDOoeq HRpUDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAPRRpUDOo *)
(* dans la couche 0 *)
Lemma LAPQRQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUDOo requis par la preuve de (?)APQRQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUDOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUDOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUDOoM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUDOom : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUDOoeq HAPQRQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPRRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)ACPQRRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRRpUDOo requis par la preuve de (?)ACPQRRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRRpUDOom2 : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRRpUDOom3 : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRRpUDOo requis par la preuve de (?)APRRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRRpUDOom2 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRRpUDOomtmp : rk(A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRRpUDOoeq HACPQRRpUDOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Rp :: U :: D :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Rp :: U :: D :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRRpUDOomtmp;try rewrite HT2 in HACPQRRpUDOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) (P :: nil) 3 1 2 HACPQRRpUDOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRRpUDOom3 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: R :: Rp ::  de rang :  3 et 3 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRRpUDOom4 : rk(A :: P :: R :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUDOoeq : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) = 4) by (apply LAPQRQpRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQRQpRpUDOomtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUDOoeq HAPQRQpRpUDOom4).
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hincl : incl (A :: R :: Rp :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: R :: Rp :: U :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: R :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUDOomtmp;try rewrite HT2 in HAPQRQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: R :: Rp :: U :: D :: Oo :: nil) (A :: R :: Rp :: nil) 4 3 3 HAPQRQpRpUDOomtmp HARRpmtmp HAQRQpRpMtmp Hincl); apply HT.
}

assert(HAPRRpUDOoM : rk(A :: P :: R :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRRpUDOom : rk(A :: P :: R :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPRRpUDOoeq HAPRRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPQRPpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPQRPpRpUDOo requis par la preuve de (?)BPQRPpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDOom2 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBPQRPpRpUDOom3 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPQRPpRpUDOom4 : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HBPQRPpRpUDOoM : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPQRPpRpUDOom : rk(B :: P :: Q :: R :: Pp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBPQRPpRpUDOoeq HBPQRPpRpUDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpUDOo *)
(* dans constructLemma(), requis par LQPpQpRpUDOo *)
(* dans constructLemma(), requis par LBQPpQpRpUDOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUDOo requis par la preuve de (?)ABQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUDOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUDOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUDOoeq HABQPpQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUDOo requis par la preuve de (?)BQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUDOoeq HABQPpQpRpUDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUDOomtmp;try rewrite HT2 in HABQPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUDOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUDOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUDOoeq HBQPpQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUDOo requis par la preuve de (?)QPpQpRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUDOom2 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUDOoeq HABCQPpQpRpUDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUDOomtmp;try rewrite HT2 in HABCQPpQpRpUDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUDOom3 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUDOom4 : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUDOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) = 4) by (apply LBQPpQpRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUDOoeq HBQPpQpRpUDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUDOomtmp;try rewrite HT2 in HBQPpQpRpUDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUDOoM : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUDOom : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUDOoeq HQPpQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUDOo requis par la preuve de (?)QQpRpUDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUDOom2 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUDOoeq HPQRPpQpRpUDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUDOomtmp;try rewrite HT2 in HPQRPpQpRpUDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQQpRpUDOom3 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQQpRpUDOomtmp : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQQpRpUDOoeq HAPQQpRpUDOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) (A :: P :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQQpRpUDOomtmp;try rewrite HT2 in HAPQQpRpUDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (U :: nil) 4 1 2 HAPQQpRpUDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Rp :: U ::  de rang :  3 et 3 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQQpRpUDOom4 : rk(Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUDOoeq : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) = 4) by (apply LQPpQpRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpQpRpUDOomtmp : rk(Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUDOoeq HQPpQpRpUDOom4).
	assert(HQRpUeq : rk(Q :: Rp :: U :: nil) = 3) by (apply LQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUmtmp : rk(Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HQRpUeq HQRpUm3).
	assert(Hincl : incl (Q :: Rp :: U :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Q :: Qp :: Rp :: U :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUDOomtmp;try rewrite HT2 in HQPpQpRpUDOomtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: D :: Oo :: nil) (Q :: Rp :: U :: nil) 4 3 3 HQPpQpRpUDOomtmp HQRpUmtmp HQPpRpUMtmp Hincl); apply HT.
}

assert(HQQpRpUDOoM : rk(Q :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUDOom : rk(Q :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUDOoeq HQQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUDOo requis par la preuve de (?)APQQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQQpRpUDOoM : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQQpRpUDOom : rk(A :: P :: Q :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQQpRpUDOoeq HAPQQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUDOo requis par la preuve de (?)ABCQPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUDOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUDOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUDOoeq HABCQPpQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUDOo requis par la preuve de (?)PQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUDOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUDOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUDOoeq HPQRPpQpRpUDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRPpQpRpUDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpUDOo requis par la preuve de (?)APQRPpQpRpUDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpUDOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpUDOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRPpQpRpUDOoM : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRPpQpRpUDOom : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: U :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRPpQpRpUDOoeq HAPQRPpQpRpUDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpUpDOo *)
(* dans constructLemma(), requis par LRpUUpDOo *)
(* dans la couche 0 *)
Lemma LUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(U :: Up :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour UUpDOo requis par la preuve de (?)UUpDOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)UUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom2 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom3 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom4 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPPp requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm2 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm3 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpm2 : rk(B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQPpm3 : rk(B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HABCPQPpeq HABCPQPpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpmtmp;try rewrite HT2 in HABCPQPpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQPpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpm2 : rk(B :: P :: Pp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpmtmp : rk(B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HBCPQPpeq HBCPQPpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: nil) (C :: P :: Q :: B :: P :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpmtmp;try rewrite HT2 in HBCPQPpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: nil) (P :: nil) 3 1 2 HBCPQPpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpUUpDOom2 : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Pp ::  de rang :  2 et 3 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HABPPpUUpDOom3 : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpUUpDOomtmp : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpRpUUpDOoeq HABPRPpRpUUpDOom4).
	assert(HBPPpmtmp : rk(B :: P :: Pp :: nil) >= 2) by (solve_hyps_min HBPPpeq HBPPpm2).
	assert(Hincl : incl (B :: P :: Pp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpUUpDOomtmp;try rewrite HT2 in HABPRPpRpUUpDOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) (B :: P :: Pp :: nil) 4 2 3 HABPRPpRpUUpDOomtmp HBPPpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpUUpDOom2 : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Pp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HABPpUUpDOom3 : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HABPPpUUpDOomtmp : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HABPPpUUpDOoeq HABPPpUUpDOom3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) (A :: P :: U :: A :: B :: Pp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: B :: Pp :: U :: Up :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (A :: B :: Pp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPPpUUpDOomtmp;try rewrite HT2 in HABPPpUUpDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) (A :: U :: nil) 3 2 2 HABPPpUUpDOomtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABUUpDOom2 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Pp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HABUUpDOom3 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPpUUpDOomtmp : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HABPpUUpDOoeq HABPpUUpDOom3).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: B :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Up :: A :: B :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: B :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: B :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPpUUpDOomtmp;try rewrite HT2 in HABPpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) (A :: Up :: nil) 3 2 2 HABPpUUpDOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABUUpDOom4 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABUOoeq : rk(A :: B :: U :: Oo :: nil) = 4) by (apply LABUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABUOomtmp : rk(A :: B :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABUOoeq HABUOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: U :: Oo :: nil) (A :: B :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: U :: Oo :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) 4 4 HABUOomtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour UUpDOo requis par la preuve de (?)UUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APpUUpDOo requis par la preuve de (?)UUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APpUUpDOo requis par la preuve de (?)APpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPpQpUUpDOo requis par la preuve de (?)APpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPpQpUUpDOo requis par la preuve de (?)ACPpQpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPpQpUUpDOo requis par la preuve de (?)ACPpQpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPpQpUUpDOom2 : rk(A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPpQpUUpDOom3 : rk(A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HACQpeq : rk(A :: C :: Qp :: nil) = 3) by (apply LACQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQpmtmp : rk(A :: C :: Qp :: nil) >= 3) by (solve_hyps_min HACQpeq HACQpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Qp :: nil) (A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) 3 3 HACQpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APpUUpDOo requis par la preuve de (?)APpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Pp :: Qp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : C :: Pp :: Qp ::   de rang : 2 et 2 *)
assert(HAPpUUpDOom2 : rk(A :: Pp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HCPpQpMtmp : rk(C :: Pp :: Qp :: nil) <= 2) by (solve_hyps_max HCPpQpeq HCPpQpM2).
	assert(HACPpQpUUpDOomtmp : rk(A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HACPpQpUUpDOoeq HACPpQpUUpDOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Pp :: Qp :: U :: Up :: D :: Oo :: nil) (C :: Pp :: Qp :: A :: Pp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Pp :: Qp :: A :: Pp :: U :: Up :: D :: Oo :: nil) ((C :: Pp :: Qp :: nil) ++ (A :: Pp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPpQpUUpDOomtmp;try rewrite HT2 in HACPpQpUUpDOomtmp.
	assert(HT := rule_4 (C :: Pp :: Qp :: nil) (A :: Pp :: U :: Up :: D :: Oo :: nil) (Pp :: nil) 3 1 2 HACPpQpUUpDOomtmp HPpmtmp HCPpQpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPpUUpDOom3 : rk(A :: Pp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPpUeq : rk(A :: Pp :: U :: nil) = 3) by (apply LAPpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpUmtmp : rk(A :: Pp :: U :: nil) >= 3) by (solve_hyps_min HAPpUeq HAPpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Pp :: U :: nil) (A :: Pp :: U :: Up :: D :: Oo :: nil) 3 3 HAPpUmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour UUpDOo requis par la preuve de (?)UUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: Pp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HUUpDOom2 : rk(U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPpUUpDOomtmp : rk(A :: Pp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HAPpUUpDOoeq HAPpUUpDOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (A :: Pp :: Up :: nil) (U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Pp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Up :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPpUUpDOomtmp;try rewrite HT2 in HAPpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (U :: Up :: D :: Oo :: nil) (Up :: nil) 3 1 2 HAPpUUpDOomtmp HUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : D :: Oo ::  de rang :  2 et 2 	 A : A :: B :: D :: Oo ::   de rang : 3 et 3 *)
assert(HUUpDOom3 : rk(U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABDOoeq : rk(A :: B :: D :: Oo :: nil) = 3) by (apply LABDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDOoMtmp : rk(A :: B :: D :: Oo :: nil) <= 3) by (solve_hyps_max HABDOoeq HABDOoM3).
	assert(HABUUpDOomtmp : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABUUpDOoeq HABUUpDOom4).
	assert(HDOoeq : rk(D :: Oo :: nil) = 2) by (apply LDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HDOomtmp : rk(D :: Oo :: nil) >= 2) by (solve_hyps_min HDOoeq HDOom2).
	assert(Hincl : incl (D :: Oo :: nil) (list_inter (A :: B :: D :: Oo :: nil) (U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: U :: Up :: D :: Oo :: nil) (A :: B :: D :: Oo :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Oo :: U :: Up :: D :: Oo :: nil) ((A :: B :: D :: Oo :: nil) ++ (U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABUUpDOomtmp;try rewrite HT2 in HABUUpDOomtmp.
	assert(HT := rule_4 (A :: B :: D :: Oo :: nil) (U :: Up :: D :: Oo :: nil) (D :: Oo :: nil) 4 2 3 HABUUpDOomtmp HDOomtmp HABDOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HUUpDOoM3 : rk(U :: Up :: D :: Oo :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HUUpOoeq : rk(U :: Up :: Oo :: nil) = 2) by (apply LUUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HUUpOoMtmp : rk(U :: Up :: Oo :: nil) <= 2) by (solve_hyps_max HUUpOoeq HUUpOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (U :: Up :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (U :: Up :: D :: Oo :: nil) (D :: U :: Up :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: U :: Up :: Oo :: nil) ((D :: nil) ++ (U :: Up :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (U :: Up :: Oo :: nil) (nil) 1 2 0 HDMtmp HUUpOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HUUpDOoM : rk(U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HUUpDOom : rk(U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HUUpDOoeq HUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: U :: Up :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour RpUUpDOo requis par la preuve de (?)RpUUpDOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)RpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDOoeq HABQPpQpRpUUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDOomtmp;try rewrite HT2 in HABQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUUpDOom2 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUUpDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUUpDOoeq HABCQPpQpRpUUpDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpDOomtmp;try rewrite HT2 in HABCQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUUpDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUUpDOom3 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUUpDOom4 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDOoeq HBQPpQpRpUUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDOomtmp;try rewrite HT2 in HBQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDOom2 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUUpDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUUpDOoeq HPQRPpQpRpUUpDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUUpDOomtmp;try rewrite HT2 in HPQRPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUUpDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQQpRpUUpDOom3 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQQpRpUUpDOomtmp : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQQpRpUUpDOoeq HAPQQpRpUUpDOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQQpRpUUpDOomtmp;try rewrite HT2 in HAPQQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (U :: nil) 4 1 2 HAPQQpRpUUpDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Rp :: U ::  de rang :  3 et 3 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDOom4 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUUpDOomtmp : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUUpDOoeq HQPpQpRpUUpDOom4).
	assert(HQRpUeq : rk(Q :: Rp :: U :: nil) = 3) by (apply LQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUmtmp : rk(Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HQRpUeq HQRpUm3).
	assert(Hincl : incl (Q :: Rp :: U :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUUpDOomtmp;try rewrite HT2 in HQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Rp :: U :: nil) 4 3 3 HQPpQpRpUUpDOomtmp HQRpUmtmp HQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RpUUpDOo requis par la preuve de (?)RpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRpUUpDOo requis par la preuve de (?)RpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpDOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUUpDOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpDOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRpUUpDOo requis par la preuve de (?)APRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRpUUpDOo requis par la preuve de (?)APRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRpUUpDOo requis par la preuve de (?)ACPQRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRpUUpDOo requis par la preuve de (?)ACPQRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRpUUpDOom2 : rk(A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRpUUpDOom3 : rk(A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRpUUpDOo requis par la preuve de (?)APRpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRpUUpDOom2 : rk(A :: P :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRpUUpDOomtmp : rk(A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRpUUpDOoeq HACPQRpUUpDOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: Rp :: U :: Up :: D :: Oo :: nil) (C :: P :: Q :: A :: P :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: Rp :: U :: Up :: D :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRpUUpDOomtmp;try rewrite HT2 in HACPQRpUUpDOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: Rp :: U :: Up :: D :: Oo :: nil) (P :: nil) 3 1 2 HACPQRpUUpDOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPRpUUpDOom3 : rk(A :: P :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRQpRpUUpDOomtmp : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRQpRpUUpDOoeq HAPQRQpRpUUpDOom4).
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hincl : incl (A :: Rp :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRQpRpUUpDOomtmp;try rewrite HT2 in HAPQRQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Rp :: U :: Up :: D :: Oo :: nil) (A :: Rp :: nil) 4 2 3 HAPQRQpRpUUpDOomtmp HARpmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RpUUpDOo requis par la preuve de (?)RpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Rp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HRpUUpDOom2 : rk(Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPRpUUpDOomtmp : rk(A :: P :: Rp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HAPRpUUpDOoeq HAPRpUUpDOom3).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Rp :: U :: Up :: D :: Oo :: nil) (A :: P :: U :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRpUUpDOomtmp;try rewrite HT2 in HAPRpUUpDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Rp :: U :: Up :: D :: Oo :: nil) (U :: nil) 3 1 2 HAPRpUUpDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : U :: Up ::  de rang :  2 et 2 	 A : Q :: Qp :: U :: Up ::   de rang : 3 et 3 *)
assert(HRpUUpDOom3 : rk(Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HQQpUUpeq : rk(Q :: Qp :: U :: Up :: nil) = 3) by (apply LQQpUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpUUpMtmp : rk(Q :: Qp :: U :: Up :: nil) <= 3) by (solve_hyps_max HQQpUUpeq HQQpUUpM3).
	assert(HQQpRpUUpDOomtmp : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUUpDOoeq HQQpRpUUpDOom4).
	assert(HUUpeq : rk(U :: Up :: nil) = 2) by (apply LUUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HUUpmtmp : rk(U :: Up :: nil) >= 2) by (solve_hyps_min HUUpeq HUUpm2).
	assert(Hincl : incl (U :: Up :: nil) (list_inter (Q :: Qp :: U :: Up :: nil) (Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Qp :: U :: Up :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: U :: Up :: Rp :: U :: Up :: D :: Oo :: nil) ((Q :: Qp :: U :: Up :: nil) ++ (Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUUpDOomtmp;try rewrite HT2 in HQQpRpUUpDOomtmp.
	assert(HT := rule_4 (Q :: Qp :: U :: Up :: nil) (Rp :: U :: Up :: D :: Oo :: nil) (U :: Up :: nil) 4 2 3 HQQpRpUUpDOomtmp HUUpmtmp HQQpUUpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HRpUUpDOoM3 : rk(Rp :: U :: Up :: D :: Oo :: nil) <= 3).
{
	assert(HRpUDOoeq : rk(Rp :: U :: D :: Oo :: nil) = 3) by (apply LRpUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUDOoMtmp : rk(Rp :: U :: D :: Oo :: nil) <= 3) by (solve_hyps_max HRpUDOoeq HRpUDOoM3).
	assert(HUUpDOoeq : rk(U :: Up :: D :: Oo :: nil) = 3) by (apply LUUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HUUpDOoMtmp : rk(U :: Up :: D :: Oo :: nil) <= 3) by (solve_hyps_max HUUpDOoeq HUUpDOoM3).
	assert(HUDOoeq : rk(U :: D :: Oo :: nil) = 3) by (apply LUDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HUDOomtmp : rk(U :: D :: Oo :: nil) >= 3) by (solve_hyps_min HUDOoeq HUDOom3).
	assert(Hincl : incl (U :: D :: Oo :: nil) (list_inter (Rp :: U :: D :: Oo :: nil) (U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Rp :: U :: Up :: D :: Oo :: nil) (Rp :: U :: D :: Oo :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: U :: D :: Oo :: U :: Up :: D :: Oo :: nil) ((Rp :: U :: D :: Oo :: nil) ++ (U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: U :: D :: Oo :: nil) (U :: Up :: D :: Oo :: nil) (U :: D :: Oo :: nil) 3 3 3 HRpUDOoMtmp HUUpDOoMtmp HUDOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HRpUUpDOoM : rk(Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRpUUpDOom : rk(Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUUpDOoeq HRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: Up :: D :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour RpUpDOo requis par la preuve de (?)RpUpDOo pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)RpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpDOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpDOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpDOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDOomtmp;try rewrite HT2 in HABQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDOom2 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDOom3 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpDOom4 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpDOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpDOoeq HAQPpQpRpUpDOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpDOomtmp;try rewrite HT2 in HAQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpDOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDOomtmp;try rewrite HT2 in HABQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDOoeq HABCQPpQpRpUpDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDOomtmp;try rewrite HT2 in HABCQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDOoeq HBQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDOomtmp;try rewrite HT2 in HBQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpDOom2 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpDOoeq HPQRPpQpRpUpDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpDOomtmp;try rewrite HT2 in HPQRPpQpRpUpDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpDOom3 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpDOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpDOoeq HQPpQpRpUpDOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpDOomtmp;try rewrite HT2 in HQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpDOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpDOom4 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpDOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpDOoeq HAQQpRpUpDOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpDOomtmp;try rewrite HT2 in HAQQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpDOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RpUpDOo requis par la preuve de (?)RpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpRpUpDOo requis par la preuve de (?)RpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDOoeq HABQPpQpRpUUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDOomtmp;try rewrite HT2 in HABQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpRpUpDOo requis par la preuve de (?)BQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpRpUpDOo requis par la preuve de (?)BQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpRpUpDOom2 : rk(B :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HBQpRpUpDOom3 : rk(B :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDOoeq HBQPpQpRpUUpDOom4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Q :: Pp :: Rp :: U :: nil) ++ (B :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDOomtmp;try rewrite HT2 in HBQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Rp :: nil) 4 2 3 HBQPpQpRpUUpDOomtmp HBRpmtmp HBQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RpUpDOo requis par la preuve de (?)RpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HRpUpDOom2 : rk(Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQpRpUpDOomtmp : rk(B :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HBQpRpUpDOoeq HBQpRpUpDOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (B :: Qp :: Up :: nil) (Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Qp :: Up :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Rp :: Up :: D :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQpRpUpDOomtmp;try rewrite HT2 in HBQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Rp :: Up :: D :: Oo :: nil) (Up :: nil) 3 1 2 HBQpRpUpDOomtmp HUpmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HRpUpDOom3 : rk(Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpRpUpDOomtmp : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUpDOoeq HQQpRpUpDOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Q :: Qp :: Oo :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: Rp :: Up :: D :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUpDOomtmp;try rewrite HT2 in HQQpRpUpDOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (Rp :: Up :: D :: Oo :: nil) (Oo :: nil) 4 1 2 HQQpRpUpDOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HRpUpDOoM3 : rk(Rp :: Up :: D :: Oo :: nil) <= 3).
{
	assert(HRpUUpDOoeq : rk(Rp :: U :: Up :: D :: Oo :: nil) = 3) by (apply LRpUUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUUpDOoMtmp : rk(Rp :: U :: Up :: D :: Oo :: nil) <= 3) by (solve_hyps_max HRpUUpDOoeq HRpUUpDOoM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Rp :: Up :: D :: Oo :: nil) (Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Rp :: Up :: D :: Oo :: nil) (Rp :: U :: Up :: D :: Oo :: nil) 3 3 HRpUUpDOoMtmp Hcomp Hincl);apply HT.
}

assert(HRpUpDOoM : rk(Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRpUpDOom : rk(Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUpDOoeq HRpUpDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpUpDOo *)
(* dans constructLemma(), requis par LAQQpRpUpDOo *)
(* dans constructLemma(), requis par LAQPpQpRpUpDOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpDOo requis par la preuve de (?)ABQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUpDOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUpDOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpDOo requis par la preuve de (?)AQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpDOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpDOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpDOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDOomtmp;try rewrite HT2 in HABQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HAQPpQpRpUpDOoM : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpQpRpUpDOom : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAQPpQpRpUpDOoeq HAQPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpDOo requis par la preuve de (?)AQQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDOom2 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDOom3 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpDOom4 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpDOoeq : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LAQPpQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpQpRpUpDOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpDOoeq HAQPpQpRpUpDOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpDOomtmp;try rewrite HT2 in HAQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpDOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HAQQpRpUpDOoM : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpUpDOom : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpRpUpDOoeq HAQQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDOomtmp;try rewrite HT2 in HABQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDOoeq HABCQPpQpRpUpDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDOomtmp;try rewrite HT2 in HABCQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDOoeq HBQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDOomtmp;try rewrite HT2 in HBQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpDOo requis par la preuve de (?)QQpRpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpDOom2 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpDOoeq HPQRPpQpRpUpDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpDOomtmp;try rewrite HT2 in HPQRPpQpRpUpDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpDOom3 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpDOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpDOoeq HQPpQpRpUpDOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpDOomtmp;try rewrite HT2 in HQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpDOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpDOom4 : rk(Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpDOoeq : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LAQQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpUpDOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpDOoeq HAQQpRpUpDOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpDOomtmp;try rewrite HT2 in HAQQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpDOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

assert(HQQpRpUpDOoM : rk(Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUpDOom : rk(Q :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUpDOoeq HQQpRpUpDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpRpUpDOo *)
(* dans la couche 0 *)
Lemma LBQPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDOo requis par la preuve de (?)BQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDOoeq HABQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDOomtmp;try rewrite HT2 in HABQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUpDOoM : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUpDOom : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUpDOoeq HBQPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDOo requis par la preuve de (?)QPpQpRpUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDOoeq HABCQPpQpRpUpDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDOomtmp;try rewrite HT2 in HABCQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) = 4) by (apply LBQPpQpRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDOoeq HBQPpQpRpUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDOomtmp;try rewrite HT2 in HBQPpQpRpUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUpDOoM : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUpDOom : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUpDOoeq HQPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDOo requis par la preuve de (?)ABCQPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUpDOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUpDOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUpDOoeq HABCQPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDOo requis par la preuve de (?)PQRPpQpRpUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUpDOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUpDOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUpDOoeq HPQRPpQpRpUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom2 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom3 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom4 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BPPp requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCPQPp requis par la preuve de (?)ABCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm2 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCPQPpm3 : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: P :: Q :: Pp :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQPp requis par la preuve de (?)BCPQPp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQPpm2 : rk(B :: C :: P :: Q :: Pp :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: Pp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : B :: C :: Q ::  de rang :  3 et 3 	 A : A :: B :: C :: Q ::   de rang : 3 et 3 *)
assert(HBCPQPpm3 : rk(B :: C :: P :: Q :: Pp :: nil) >= 3).
{
	assert(HABCQeq : rk(A :: B :: C :: Q :: nil) = 3) by (apply LABCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQMtmp : rk(A :: B :: C :: Q :: nil) <= 3) by (solve_hyps_max HABCQeq HABCQM3).
	assert(HABCPQPpmtmp : rk(A :: B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HABCPQPpeq HABCPQPpm3).
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hincl : incl (B :: C :: Q :: nil) (list_inter (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: P :: Q :: Pp :: nil) (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: B :: C :: P :: Q :: Pp :: nil) ((A :: B :: C :: Q :: nil) ++ (B :: C :: P :: Q :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCPQPpmtmp;try rewrite HT2 in HABCPQPpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: nil) (B :: C :: P :: Q :: Pp :: nil) (B :: C :: Q :: nil) 3 3 3 HABCPQPpmtmp HBCQmtmp HABCQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BPPp requis par la preuve de (?)BPPp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: Pp ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPPpm2 : rk(B :: P :: Pp :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQPpmtmp : rk(B :: C :: P :: Q :: Pp :: nil) >= 3) by (solve_hyps_min HBCPQPpeq HBCPQPpm3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: Pp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: Pp :: nil) (C :: P :: Q :: B :: P :: Pp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: Pp :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: Pp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQPpmtmp;try rewrite HT2 in HBCPQPpmtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: Pp :: nil) (P :: nil) 3 1 2 HBCPQPpmtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPPpUUpDOo requis par la preuve de (?)ABPPpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPPpUUpDOom2 : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : B :: P :: Pp ::  de rang :  2 et 3 	 A : B :: P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HABPPpUUpDOom3 : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HABPRPpRpUUpDOomtmp : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpRpUUpDOoeq HABPRPpRpUUpDOom4).
	assert(HBPPpmtmp : rk(B :: P :: Pp :: nil) >= 2) by (solve_hyps_min HBPPpeq HBPPpm2).
	assert(Hincl : incl (B :: P :: Pp :: nil) (list_inter (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: P :: R :: Pp :: Rp :: A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) ((B :: P :: R :: Pp :: Rp :: nil) ++ (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpRpUUpDOomtmp;try rewrite HT2 in HABPRPpRpUUpDOomtmp.
	assert(HT := rule_4 (B :: P :: R :: Pp :: Rp :: nil) (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) (B :: P :: Pp :: nil) 4 2 3 HABPRPpRpUUpDOomtmp HBPPpmtmp HBPRPpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPpUUpDOo requis par la preuve de (?)ABPpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPpUUpDOom2 : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: Pp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : A :: U ::  de rang :  2 et 2 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HABPpUUpDOom3 : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HABPPpUUpDOomtmp : rk(A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HABPPpUUpDOoeq HABPPpUUpDOom3).
	assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: P :: U :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: Pp :: U :: Up :: D :: Oo :: nil) (A :: P :: U :: A :: B :: Pp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: A :: B :: Pp :: U :: Up :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (A :: B :: Pp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPPpUUpDOomtmp;try rewrite HT2 in HABPPpUUpDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) (A :: U :: nil) 3 2 2 HABPPpUUpDOomtmp HAUmtmp HAPUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABUUpDOo requis par la preuve de (?)ABUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABUUpDOom2 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Pp :: U :: Up :: D :: Oo ::  de rang :  3 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HABUUpDOom3 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPpUUpDOomtmp : rk(A :: B :: Pp :: U :: Up :: D :: Oo :: nil) >= 3) by (solve_hyps_min HABPpUUpDOoeq HABPpUUpDOom3).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: B :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Pp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Up :: A :: B :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: B :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: B :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPpUUpDOomtmp;try rewrite HT2 in HABPpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) (A :: Up :: nil) 3 2 2 HABPpUUpDOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABUUpDOom4 : rk(A :: B :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABUOoeq : rk(A :: B :: U :: Oo :: nil) = 4) by (apply LABUOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABUOomtmp : rk(A :: B :: U :: Oo :: nil) >= 4) by (solve_hyps_min HABUOoeq HABUOom4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: U :: Oo :: nil) (A :: B :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: U :: Oo :: nil) (A :: B :: U :: Up :: D :: Oo :: nil) 4 4 HABUOomtmp Hcomp Hincl);apply HT.
}

assert(HABUUpDOoM : rk(A :: B :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABUUpDOom : rk(A :: B :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABUUpDOoeq HABUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpRpUUpDOo requis par la preuve de (?)ABPRPpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom2 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom3 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpRpUUpDOom4 : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpRpUUpDOoM : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpRpUUpDOom : rk(A :: B :: P :: R :: Pp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpRpUUpDOoeq HABPRPpRpUUpDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpUUpDOo *)
(* dans constructLemma(), requis par LQPpQpRpUUpDOo *)
(* dans constructLemma(), requis par LBQPpQpRpUUpDOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDOo requis par la preuve de (?)ABQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpDOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpDOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpDOoeq HABQPpQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDOo requis par la preuve de (?)BQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) = 4) by (apply LABQPpQpRpUUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpDOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDOoeq HABQPpQpRpUUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDOomtmp;try rewrite HT2 in HABQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpDOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpDOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpDOoeq HBQPpQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUUpDOo requis par la preuve de (?)QPpQpRpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUUpDOom2 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUUpDOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUUpDOoeq HABCQPpQpRpUUpDOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUUpDOomtmp;try rewrite HT2 in HABCQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUUpDOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUUpDOom3 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUUpDOom4 : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUUpDOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) = 4) by (apply LBQPpQpRpUUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUUpDOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDOoeq HBQPpQpRpUUpDOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDOomtmp;try rewrite HT2 in HBQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUUpDOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUUpDOoM : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUUpDOom : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUUpDOoeq HQPpQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUUpDOo requis par la preuve de (?)QQpRpUUpDOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDOom2 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUUpDOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUUpDOoeq HPQRPpQpRpUUpDOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUUpDOomtmp;try rewrite HT2 in HPQRPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUUpDOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : U ::  de rang :  1 et 1 	 A : A :: P :: U ::   de rang : 2 et 2 *)
assert(HQQpRpUUpDOom3 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPUMtmp : rk(A :: P :: U :: nil) <= 2) by (solve_hyps_max HAPUeq HAPUM2).
	assert(HAPQQpRpUUpDOomtmp : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HAPQQpRpUUpDOoeq HAPQQpRpUUpDOom4).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((A :: P :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQQpRpUUpDOomtmp;try rewrite HT2 in HAPQQpRpUUpDOomtmp.
	assert(HT := rule_4 (A :: P :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (U :: nil) 4 1 2 HAPQQpRpUUpDOomtmp HUmtmp HAPUMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Rp :: U ::  de rang :  3 et 3 	 A : Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HQQpRpUUpDOom4 : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HQPpRpUeq : rk(Q :: Pp :: Rp :: U :: nil) = 3) by (apply LQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpRpUMtmp : rk(Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HQPpRpUeq HQPpRpUM3).
	assert(HQPpQpRpUUpDOoeq : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) = 4) by (apply LQPpQpRpUUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQPpQpRpUUpDOomtmp : rk(Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUUpDOoeq HQPpQpRpUUpDOom4).
	assert(HQRpUeq : rk(Q :: Rp :: U :: nil) = 3) by (apply LQRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQRpUmtmp : rk(Q :: Rp :: U :: nil) >= 3) by (solve_hyps_min HQRpUeq HQRpUm3).
	assert(Hincl : incl (Q :: Rp :: U :: nil) (list_inter (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: U :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) ((Q :: Pp :: Rp :: U :: nil) ++ (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUUpDOomtmp;try rewrite HT2 in HQPpQpRpUUpDOomtmp.
	assert(HT := rule_4 (Q :: Pp :: Rp :: U :: nil) (Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) (Q :: Rp :: U :: nil) 4 3 3 HQPpQpRpUUpDOomtmp HQRpUmtmp HQPpRpUMtmp Hincl); apply HT.
}

assert(HQQpRpUUpDOoM : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUUpDOom : rk(Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUUpDOoeq HQQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQQpRpUUpDOo requis par la preuve de (?)APQQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom2 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom3 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HAPQpRpeq : rk(A :: P :: Qp :: Rp :: nil) = 3) by (apply LAPQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQpRpmtmp : rk(A :: P :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAPQpRpeq HAPQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HAPQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQQpRpUUpDOom4 : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HAPQQpRpeq : rk(A :: P :: Q :: Qp :: Rp :: nil) = 4) by (apply LAPQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQQpRpmtmp : rk(A :: P :: Q :: Qp :: Rp :: nil) >= 4) by (solve_hyps_min HAPQQpRpeq HAPQQpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: Q :: Qp :: Rp :: nil) (A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HAPQQpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQQpRpUUpDOoM : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQQpRpUUpDOom : rk(A :: P :: Q :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQQpRpUUpDOoeq HAPQQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRQpRpUUpDOo requis par la preuve de (?)APQRQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpDOom2 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRQpRpUUpDOom3 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRQpRpUUpDOom4 : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRQpRpUUpDOoM : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRQpRpUUpDOom : rk(A :: P :: Q :: R :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRQpRpUUpDOoeq HAPQRQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUUpDOo requis par la preuve de (?)ABCQPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUUpDOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUUpDOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUUpDOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUUpDOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUUpDOoeq HABCQPpQpRpUUpDOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUUpDOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUUpDOo requis par la preuve de (?)PQRPpQpRpUUpDOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUUpDOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUUpDOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUUpDOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUUpDOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: U :: Up :: D :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUUpDOoeq HPQRPpQpRpUUpDOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LRpUpDpOo *)
(* dans constructLemma(), requis par LQQpRpUpDpOo *)
(* dans constructLemma(), requis par LAQQpRpUpDpOo *)
(* dans constructLemma(), requis par LAQPpQpRpUpDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpDpOo requis par la preuve de (?)ABQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpDpOo requis par la preuve de (?)ABQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpDpOo requis par la preuve de (?)ABQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUpDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUpDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUpDpOoeq HABQPpQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpDpOo requis par la preuve de (?)AQPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpDpOo requis par la preuve de (?)AQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpDpOo requis par la preuve de (?)AQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpDpOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpDpOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpDpOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDpOoeq HABQPpQpRpUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HAQPpQpRpUpDpOoM : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpQpRpUpDpOom : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQPpQpRpUpDpOoeq HAQPpQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpDpOo requis par la preuve de (?)AQQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpDpOo requis par la preuve de (?)AQQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpDpOo requis par la preuve de (?)AQQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDpOom2 : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDpOom3 : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpDpOom4 : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpDpOoeq : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LAQPpQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpQpRpUpDpOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpDpOoeq HAQPpQpRpUpDpOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpDpOomtmp;try rewrite HT2 in HAQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpDpOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HAQQpRpUpDpOoM : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpUpDpOom : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpRpUpDpOoeq HAQQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpDpOo requis par la preuve de (?)QQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDpOoeq HABQPpQpRpUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDpOoeq HABCQPpQpRpUpDpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDpOomtmp;try rewrite HT2 in HABCQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDpOoeq HBQPpQpRpUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDpOomtmp;try rewrite HT2 in HBQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpDpOo requis par la preuve de (?)QQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpDpOo requis par la preuve de (?)QQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDpOo requis par la preuve de (?)PQRPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDpOo requis par la preuve de (?)PQRPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpDpOo requis par la preuve de (?)QQpRpUpDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpDpOom2 : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpDpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpDpOoeq HPQRPpQpRpUpDpOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpDpOomtmp;try rewrite HT2 in HPQRPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpDpOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpDpOom3 : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpDpOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpDpOoeq HQPpQpRpUpDpOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpDpOomtmp;try rewrite HT2 in HQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpDpOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpDpOom4 : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpDpOoeq : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LAQQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpUpDpOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpDpOoeq HAQQpRpUpDpOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpDpOomtmp;try rewrite HT2 in HAQQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpDpOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

assert(HQQpRpUpDpOoM : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUpDpOom : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUpDpOoeq HQQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: Up :: Dp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour RpUpDpOo requis par la preuve de (?)RpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RpUpDpOo requis par la preuve de (?)RpUpDpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpRpUpDpOo requis par la preuve de (?)RpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDpOoeq HABQPpQpRpUUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDpOomtmp;try rewrite HT2 in HABQPpQpRpUUpDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpRpUpDpOo requis par la preuve de (?)BQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpRpUpDpOo requis par la preuve de (?)BQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpRpUpDpOom2 : rk(B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HBQpRpUpDpOom3 : rk(B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUUpDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDpOoeq HBQPpQpRpUUpDpOom4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((B :: Q :: Pp :: Rp :: U :: nil) ++ (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDpOomtmp;try rewrite HT2 in HBQPpQpRpUUpDpOomtmp.
	assert(HT := rule_4 (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (B :: Rp :: nil) 4 2 3 HBQPpQpRpUUpDpOomtmp HBRpmtmp HBQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RpUpDpOo requis par la preuve de (?)RpUpDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HRpUpDpOom2 : rk(Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQpRpUpDpOomtmp : rk(B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBQpRpUpDpOoeq HBQpRpUpDpOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (B :: Qp :: Up :: nil) (Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (B :: Qp :: Up :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Rp :: Up :: Dp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQpRpUpDpOomtmp;try rewrite HT2 in HBQpRpUpDpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Rp :: Up :: Dp :: Oo :: nil) (Up :: nil) 3 1 2 HBQpRpUpDpOomtmp HUpmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HRpUpDpOoM3 : rk(Rp :: Up :: Dp :: Oo :: nil) <= 3).
{
	assert(HRpUpDpMtmp : rk(Rp :: Up :: Dp :: nil) <= 2) by (solve_hyps_max HRpUpDpeq HRpUpDpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Rp :: Up :: Dp :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Rp :: Up :: Dp :: Oo :: nil) (Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Up :: Dp :: Oo :: nil) ((Rp :: Up :: Dp :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Up :: Dp :: nil) (Oo :: nil) (nil) 2 1 0 HRpUpDpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HRpUpDpOom3 : rk(Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpRpUpDpOoeq : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LQQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQQpRpUpDpOomtmp : rk(Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUpDpOoeq HQQpRpUpDpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Q :: Qp :: Oo :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: Rp :: Up :: Dp :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUpDpOomtmp;try rewrite HT2 in HQQpRpUpDpOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (Rp :: Up :: Dp :: Oo :: nil) (Oo :: nil) 4 1 2 HQQpRpUpDpOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

assert(HRpUpDpOoM : rk(Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRpUpDpOom : rk(Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUpDpOoeq HRpUpDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpRpUpDpOo *)
(* dans la couche 0 *)
Lemma LBQPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDpOo requis par la preuve de (?)BQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDpOoeq HABQPpQpRpUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUpDpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUpDpOom : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUpDpOoeq HBQPpQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDpOo requis par la preuve de (?)QPpQpRpUpDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDpOoeq HABCQPpQpRpUpDpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDpOomtmp;try rewrite HT2 in HABCQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDpOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) = 4) by (apply LBQPpQpRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUpDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDpOoeq HBQPpQpRpUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDpOomtmp;try rewrite HT2 in HBQPpQpRpUpDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUpDpOoM : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUpDpOom : rk(Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUpDpOoeq HQPpQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDpOo requis par la preuve de (?)ABCQPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUpDpOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUpDpOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUpDpOoeq HABCQPpQpRpUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDpOo requis par la preuve de (?)PQRPpQpRpUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDpOo requis par la preuve de (?)PQRPpQpRpUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUpDpOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUpDpOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUpDpOoeq HPQRPpQpRpUpDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQPpQpRpUUpDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDpOo requis par la preuve de (?)ABQPpQpRpUUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpDpOoeq HABQPpQpRpUUpDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUpDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDpOo requis par la preuve de (?)BQPpQpRpUUpDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDpOoeq HABQPpQpRpUUpDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDpOomtmp;try rewrite HT2 in HABQPpQpRpUUpDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpDpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpDpOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpDpOoeq HBQPpQpRpUUpDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LDDpOo *)
(* dans constructLemma(), requis par LADDpOo *)
(* dans constructLemma(), requis par LAQQpDDpOo *)
(* dans constructLemma(), requis par LABQQpDDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpDDpOo requis par la preuve de (?)ABQPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpDDpOo requis par la preuve de (?)ABQPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpDDpOo requis par la preuve de (?)ABQPpQpRpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpDDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpDDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpDDpOoeq HABQPpQpRpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQQpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Qp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQQpDDpOo requis par la preuve de (?)ABQQpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQQpDDpOo requis par la preuve de (?)ABQQpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQQpDDpOo requis par la preuve de (?)ABQQpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpDDpOom2 : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQQpDDpOom3 : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Qp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQQpDDpOom4 : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpDDpOoeq HABQPpQpRpDDpOom4).
	assert(HABQpmtmp : rk(A :: B :: Qp :: nil) >= 3) by (solve_hyps_min HABQpeq HABQpm3).
	assert(Hincl : incl (A :: B :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpDDpOomtmp;try rewrite HT2 in HABQPpQpRpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) (A :: B :: Qp :: nil) 4 3 3 HABQPpQpRpDDpOomtmp HABQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQQpDDpOoM : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQQpDDpOom : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQQpDDpOoeq HABQQpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpDDpOo requis par la preuve de (?)AQQpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpDDpOo requis par la preuve de (?)AQQpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpDDpOo requis par la preuve de (?)AQQpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpDDpOom2 : rk(A :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQQpDDpOom3 : rk(A :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpDDpOoeq HABQPpQpRpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Qp :: D :: Dp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpDDpOomtmp;try rewrite HT2 in HABQPpQpRpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 3 HABQPpQpRpDDpOomtmp HAQpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Qp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: B :: D ::   de rang : 2 et 2 *)
assert(HAQQpDDpOom4 : rk(A :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 2) by (apply LABD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 2) by (solve_hyps_max HABDeq HABDM2).
	assert(HABQQpDDpOoeq : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) = 4) by (apply LABQQpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQQpDDpOomtmp : rk(A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQQpDDpOoeq HABQQpDDpOom4).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: B :: D :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Qp :: D :: Dp :: Oo :: nil) (A :: B :: D :: A :: Q :: Qp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: A :: Q :: Qp :: D :: Dp :: Oo :: nil) ((A :: B :: D :: nil) ++ (A :: Q :: Qp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQQpDDpOomtmp;try rewrite HT2 in HABQQpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (A :: Q :: Qp :: D :: Dp :: Oo :: nil) (A :: D :: nil) 4 2 2 HABQQpDDpOomtmp HADmtmp HABDMtmp Hincl); apply HT.
}

assert(HAQQpDDpOoM : rk(A :: Q :: Qp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpDDpOom : rk(A :: Q :: Qp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpDDpOoeq HAQQpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: D :: Dp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADDpOo requis par la preuve de (?)ADDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADDpOo requis par la preuve de (?)ADDpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDDpOo requis par la preuve de (?)ADDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDDpOo requis par la preuve de (?)ABDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABDDpOom2 : rk(A :: B :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADDpOo requis par la preuve de (?)ADDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: D :: Dp :: Oo ::  de rang :  2 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: B :: D ::   de rang : 2 et 2 *)
assert(HADDpOom2 : rk(A :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 2) by (apply LABD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 2) by (solve_hyps_max HABDeq HABDM2).
	assert(HABDDpOomtmp : rk(A :: B :: D :: Dp :: Oo :: nil) >= 2) by (solve_hyps_min HABDDpOoeq HABDDpOom2).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: B :: D :: nil) (A :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: Dp :: Oo :: nil) (A :: B :: D :: A :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: A :: D :: Dp :: Oo :: nil) ((A :: B :: D :: nil) ++ (A :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDDpOomtmp;try rewrite HT2 in HABDDpOomtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (A :: D :: Dp :: Oo :: nil) (A :: D :: nil) 2 2 2 HABDDpOomtmp HADmtmp HABDMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -2 et 5*)
assert(HADDpOoM3 : rk(A :: D :: Dp :: Oo :: nil) <= 3).
{
	assert(HADDpeq : rk(A :: D :: Dp :: nil) = 2) by (apply LADDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADDpMtmp : rk(A :: D :: Dp :: nil) <= 2) by (solve_hyps_max HADDpeq HADDpM2).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: Dp :: nil) (Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: Dp :: Oo :: nil) (A :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Dp :: Oo :: nil) ((A :: D :: Dp :: nil) ++ (Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: Dp :: nil) (Oo :: nil) (nil) 2 1 0 HADDpMtmp HOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Q :: Qp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HADDpOom3 : rk(A :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HAQQpDDpOoeq : rk(A :: Q :: Qp :: D :: Dp :: Oo :: nil) = 4) by (apply LAQQpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpDDpOomtmp : rk(A :: Q :: Qp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpDDpOoeq HAQQpDDpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (A :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: D :: Dp :: Oo :: nil) (Q :: Qp :: Oo :: A :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: A :: D :: Dp :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (A :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpDDpOomtmp;try rewrite HT2 in HAQQpDDpOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (A :: D :: Dp :: Oo :: nil) (Oo :: nil) 4 1 2 HAQQpDDpOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

assert(HADDpOoM : rk(A :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADDpOom : rk(A :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HADDpOoeq HADDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LDDpOo *)
(* dans la couche 0 *)
Lemma LRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Rp :: Up :: D :: Dp :: Oo ::  nil) = 3.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour RpUpDDpOo requis par la preuve de (?)RpUpDDpOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)RpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpDDpOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpDDpOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpDDpOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDDpOom2 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDDpOom3 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpDDpOom4 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpDDpOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpDDpOoeq HAQPpQpRpUpDDpOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpDDpOomtmp;try rewrite HT2 in HAQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpDDpOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDDpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDDpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDDpOoeq HABCQPpQpRpUpDDpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABCQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDDpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDDpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDDpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDDpOoeq HBQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDDpOomtmp;try rewrite HT2 in HBQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDDpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDDpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpDDpOom2 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpDDpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpDDpOoeq HPQRPpQpRpUpDDpOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpDDpOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpDDpOom3 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpDDpOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpDDpOoeq HQPpQpRpUpDDpOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpDDpOomtmp;try rewrite HT2 in HQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpDDpOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpDDpOom4 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpDDpOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpDDpOoeq HAQQpRpUpDDpOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpDDpOomtmp;try rewrite HT2 in HAQQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpDDpOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour RpUpDDpOo requis par la preuve de (?)RpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQpRpUpDDpOo requis par la preuve de (?)RpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDDpOoeq HABQPpQpRpUUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQpRpUpDDpOo requis par la preuve de (?)BQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQpRpUpDDpOo requis par la preuve de (?)BQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQpRpUpDDpOom2 : rk(B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQpeq : rk(B :: Qp :: nil) = 2) by (apply LBQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQpmtmp : rk(B :: Qp :: nil) >= 2) by (solve_hyps_min HBQpeq HBQpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Qp :: nil) (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B :: Rp ::  de rang :  2 et 2 	 A : B :: Q :: Pp :: Rp :: U ::   de rang : 3 et 3 *)
assert(HBQpRpUpDDpOom3 : rk(B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpUeq : rk(B :: Q :: Pp :: Rp :: U :: nil) = 3) by (apply LBQPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpUMtmp : rk(B :: Q :: Pp :: Rp :: U :: nil) <= 3) by (solve_hyps_max HBQPpRpUeq HBQPpRpUM3).
	assert(HBQPpQpRpUUpDDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUUpDDpOoeq HBQPpQpRpUUpDDpOom4).
	assert(HBRpeq : rk(B :: Rp :: nil) = 2) by (apply LBRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRpmtmp : rk(B :: Rp :: nil) >= 2) by (solve_hyps_min HBRpeq HBRpm2).
	assert(Hincl : incl (B :: Rp :: nil) (list_inter (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Pp :: Rp :: U :: B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Q :: Pp :: Rp :: U :: nil) ++ (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUUpDDpOomtmp;try rewrite HT2 in HBQPpQpRpUUpDDpOomtmp.
	assert(HT := rule_4 (B :: Q :: Pp :: Rp :: U :: nil) (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Rp :: nil) 4 2 3 HBQPpQpRpUUpDDpOomtmp HBRpmtmp HBQPpRpUMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour RpUpDDpOo requis par la preuve de (?)RpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HRpUpDDpOom2 : rk(Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBQpRpUpDDpOomtmp : rk(B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBQpRpUpDDpOoeq HBQpRpUpDDpOom3).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (B :: Qp :: Up :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Qp :: Up :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQpRpUpDDpOomtmp;try rewrite HT2 in HBQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil) (Up :: nil) 3 1 2 HBQpRpUpDDpOomtmp HUpmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Q :: Qp :: Oo ::   de rang : 2 et 2 *)
assert(HRpUpDDpOom3 : rk(Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HQQpOoMtmp : rk(Q :: Qp :: Oo :: nil) <= 2) by (solve_hyps_max HQQpOoeq HQQpOoM2).
	assert(HQQpRpUpDDpOomtmp : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HQQpRpUpDDpOoeq HQQpRpUpDDpOom4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Q :: Qp :: Oo :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Q :: Qp :: Oo :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Qp :: Oo :: Rp :: Up :: D :: Dp :: Oo :: nil) ((Q :: Qp :: Oo :: nil) ++ (Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQQpRpUpDDpOomtmp;try rewrite HT2 in HQQpRpUpDDpOomtmp.
	assert(HT := rule_4 (Q :: Qp :: Oo :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil) (Oo :: nil) 4 1 2 HQQpRpUpDDpOomtmp HOomtmp HQQpOoMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HRpUpDDpOoM3 : rk(Rp :: Up :: D :: Dp :: Oo :: nil) <= 3).
{
	assert(HRpUpDOoeq : rk(Rp :: Up :: D :: Oo :: nil) = 3) by (apply LRpUpDOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUpDOoMtmp : rk(Rp :: Up :: D :: Oo :: nil) <= 3) by (solve_hyps_max HRpUpDOoeq HRpUpDOoM3).
	assert(HRpUpDpOoeq : rk(Rp :: Up :: Dp :: Oo :: nil) = 3) by (apply LRpUpDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUpDpOoMtmp : rk(Rp :: Up :: Dp :: Oo :: nil) <= 3) by (solve_hyps_max HRpUpDpOoeq HRpUpDpOoM3).
	assert(HRpUpOoeq : rk(Rp :: Up :: Oo :: nil) = 3) by (apply LRpUpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUpOomtmp : rk(Rp :: Up :: Oo :: nil) >= 3) by (solve_hyps_min HRpUpOoeq HRpUpOom3).
	assert(Hincl : incl (Rp :: Up :: Oo :: nil) (list_inter (Rp :: Up :: D :: Oo :: nil) (Rp :: Up :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Rp :: Up :: D :: Dp :: Oo :: nil) (Rp :: Up :: D :: Oo :: Rp :: Up :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Rp :: Up :: D :: Oo :: Rp :: Up :: Dp :: Oo :: nil) ((Rp :: Up :: D :: Oo :: nil) ++ (Rp :: Up :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Rp :: Up :: D :: Oo :: nil) (Rp :: Up :: Dp :: Oo :: nil) (Rp :: Up :: Oo :: nil) 3 3 3 HRpUpDOoMtmp HRpUpDpOoMtmp HRpUpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HRpUpDDpOoM : rk(Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HRpUpDDpOom : rk(Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HRpUpDDpOoeq HRpUpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LDDpOo *)
(* dans constructLemma(), requis par LARpUpDDpOo *)
(* dans constructLemma(), requis par LAQRpUpDDpOo *)
(* dans constructLemma(), requis par LABQRpUpDDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUpDDpOo requis par la preuve de (?)ABQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUpDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUpDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUpDDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUpDDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABQRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQRpUpDDpOo requis par la preuve de (?)ABQRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQRpUpDDpOo requis par la preuve de (?)ABQRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQRpUpDDpOo requis par la preuve de (?)ABQRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRpUpDDpOom2 : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQRpUpDDpOom3 : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Rp ::  de rang :  3 et 3 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HABQRpUpDDpOom4 : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HABRpmtmp : rk(A :: B :: Rp :: nil) >= 3) by (solve_hyps_min HABRpeq HABRpm3).
	assert(Hincl : incl (A :: B :: Rp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HABRpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

assert(HABQRpUpDDpOoM : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQRpUpDDpOom : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQRpUpDDpOoeq HABQRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQRpUpDDpOo requis par la preuve de (?)AQRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQRpUpDDpOo requis par la preuve de (?)AQRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQRpUpDDpOo requis par la preuve de (?)AQRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQRpUpDDpOom2 : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp ::  de rang :  2 et 2 	 A : A :: B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQRpUpDDpOom3 : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABPpQpRpeq : rk(A :: B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LABPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPpQpRpMtmp : rk(A :: B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HABPpQpRpeq HABPpQpRpM3).
	assert(HABQPpQpRpUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hincl : incl (A :: Rp :: nil) (list_inter (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Pp :: Qp :: Rp :: A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Rp :: nil) 4 2 3 HABQPpQpRpUpDDpOomtmp HARpmtmp HABPpQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: B :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HAQRpUpDDpOom4 : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABRpUpeq : rk(A :: B :: Rp :: Up :: nil) = 3) by (apply LABRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABRpUpMtmp : rk(A :: B :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HABRpUpeq HABRpUpM3).
	assert(HABQRpUpDDpOoeq : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRpUpDDpOomtmp : rk(A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQRpUpDDpOoeq HABQRpUpDDpOom4).
	assert(HARpUpeq : rk(A :: Rp :: Up :: nil) = 3) by (apply LARpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpUpmtmp : rk(A :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HARpUpeq HARpUpm3).
	assert(Hincl : incl (A :: Rp :: Up :: nil) (list_inter (A :: B :: Rp :: Up :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: Rp :: Up :: A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Rp :: Up :: A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: Rp :: Up :: nil) ++ (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRpUpDDpOomtmp;try rewrite HT2 in HABQRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: Rp :: Up :: nil) (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Rp :: Up :: nil) 4 3 3 HABQRpUpDDpOomtmp HARpUpmtmp HABRpUpMtmp Hincl); apply HT.
}

assert(HAQRpUpDDpOoM : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQRpUpDDpOom : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQRpUpDDpOoeq HAQRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LARpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ARpUpDDpOo requis par la preuve de (?)ARpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ARpUpDDpOo requis par la preuve de (?)ARpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ARpUpDDpOo requis par la preuve de (?)ARpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARpUpDDpOom2 : rk(A :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HARpeq : rk(A :: Rp :: nil) = 2) by (apply LARp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpmtmp : rk(A :: Rp :: nil) >= 2) by (solve_hyps_min HARpeq HARpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Rp :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Rp :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HARpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HARpUpDDpOom3 : rk(A :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HARpUpeq : rk(A :: Rp :: Up :: nil) = 3) by (apply LARpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpUpmtmp : rk(A :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HARpUpeq HARpUpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Rp :: Up :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Rp :: Up :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HARpUpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Rp :: Oo ::  de rang :  3 et 3 	 A : A :: Q :: Rp :: Oo ::   de rang : 3 et 3 *)
assert(HARpUpDDpOom4 : rk(A :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQRpOoeq : rk(A :: Q :: Rp :: Oo :: nil) = 3) by (apply LAQRpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRpOoMtmp : rk(A :: Q :: Rp :: Oo :: nil) <= 3) by (solve_hyps_max HAQRpOoeq HAQRpOoM3).
	assert(HAQRpUpDDpOoeq : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAQRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRpUpDDpOomtmp : rk(A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQRpUpDDpOoeq HAQRpUpDDpOom4).
	assert(HARpOoeq : rk(A :: Rp :: Oo :: nil) = 3) by (apply LARpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpOomtmp : rk(A :: Rp :: Oo :: nil) >= 3) by (solve_hyps_min HARpOoeq HARpOom3).
	assert(Hincl : incl (A :: Rp :: Oo :: nil) (list_inter (A :: Q :: Rp :: Oo :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Q :: Rp :: Oo :: A :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Rp :: Oo :: A :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Q :: Rp :: Oo :: nil) ++ (A :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQRpUpDDpOomtmp;try rewrite HT2 in HAQRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Q :: Rp :: Oo :: nil) (A :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Rp :: Oo :: nil) 4 3 3 HAQRpUpDDpOomtmp HARpOomtmp HAQRpOoMtmp Hincl); apply HT.
}

assert(HARpUpDDpOoM : rk(A :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HARpUpDDpOom : rk(A :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HARpUpDDpOoeq HARpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(D :: Dp :: Oo ::  nil) = 2.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DDpOo requis par la preuve de (?)DDpOo pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PPpDDpOo requis par la preuve de (?)DDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)PPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpDDpOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpDDpOom2 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpDDpOom3 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpDDpOomtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpDDpOoeq HAPQRPpQpRpDDpOom4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpDDpOomtmp;try rewrite HT2 in HAPQRPpQpRpDDpOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpDDpOomtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpDDpOom4 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQPpDeq : rk(A :: Q :: Pp :: D :: nil) = 4) by (apply LAQPpD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpDmtmp : rk(A :: Q :: Pp :: D :: nil) >= 4) by (solve_hyps_min HAQPpDeq HAQPpDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: D :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: D :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) 4 4 HAQPpDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour PDDp requis par la preuve de (?)PPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)PDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpDDpOom2 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpDDpOom3 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPRPpDDpOom4 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HARPpDeq : rk(A :: R :: Pp :: D :: nil) = 4) by (apply LARPpD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARPpDmtmp : rk(A :: R :: Pp :: D :: nil) >= 4) by (solve_hyps_min HARPpDeq HARPpDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Pp :: D :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Pp :: D :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 4 4 HARPpDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPRPpQpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPRPpQpRpUpDDpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom2 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUpDDpOoeq HBCPQRPpQpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUpDDpOomtmp;try rewrite HT2 in HBCPQRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom3 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUpDDpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom4 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPRPpQpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpUpDDpOoeq HABPRPpQpUpDDpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABPRPpQpUpDDpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BCPQRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BCPQRPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom2 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpDDpOoeq HBCPQRPpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpDDpOomtmp;try rewrite HT2 in HBCPQRPpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom3 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBPRPpQpUpDDpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUpDDpOoeq HBPRPpQpUpDDpOom4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (B :: Qp :: Up :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUpDDpOomtmp;try rewrite HT2 in HBPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (B :: nil) 4 1 2 HBPRPpQpUpDDpOomtmp HBmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B :: D :: Dp ::  de rang :  2 et 2 	 A : A :: B :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom4 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABDDpeq : rk(A :: B :: D :: Dp :: nil) = 2) by (apply LABDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDDpMtmp : rk(A :: B :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABDDpeq HABDDpM2).
	assert(HABPRPpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpDDpOoeq HABPRPpDDpOom4).
	assert(HBDDpeq : rk(B :: D :: Dp :: nil) = 2) by (apply LBDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBDDpmtmp : rk(B :: D :: Dp :: nil) >= 2) by (solve_hyps_min HBDDpeq HBDDpm2).
	assert(Hincl : incl (B :: D :: Dp :: nil) (list_inter (A :: B :: D :: Dp :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (A :: B :: D :: Dp :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Dp :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((A :: B :: D :: Dp :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpDDpOomtmp;try rewrite HT2 in HABPRPpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: D :: Dp :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (B :: D :: Dp :: nil) 4 2 2 HABPRPpDDpOomtmp HBDDpmtmp HABDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour PDDp requis par la preuve de (?)PDDp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 4*)
assert(HPDDpm2 : rk(P :: D :: Dp :: nil) >= 2).
{
	assert(HBPRPpOoeq : rk(B :: P :: R :: Pp :: Oo :: nil) = 3) by (apply LBPRPpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpOoMtmp : rk(B :: P :: R :: Pp :: Oo :: nil) <= 3) by (solve_hyps_max HBPRPpOoeq HBPRPpOoM3).
	assert(HBPRPpDDpOomtmp : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpDDpOoeq HBPRPpDDpOom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: D :: Dp :: nil) (B :: P :: R :: Pp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (P :: D :: Dp :: B :: P :: R :: Pp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: D :: Dp :: B :: P :: R :: Pp :: Oo :: nil) ((P :: D :: Dp :: nil) ++ (B :: P :: R :: Pp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpDDpOomtmp;try rewrite HT2 in HBPRPpDDpOomtmp.
	assert(HT := rule_2 (P :: D :: Dp :: nil) (B :: P :: R :: Pp :: Oo :: nil) (P :: nil) 4 1 3 HBPRPpDDpOomtmp HPmtmp HBPRPpOoMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PPpDDpOo requis par la preuve de (?)PPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)ACPQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)ACPQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRPpQpRpUpDDpOom2 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRPpQpRpUpDDpOom3 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRPpQpRpUpDDpOom2 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRPpQpRpUpDDpOomtmp : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRPpQpRpUpDDpOoeq HACPQRPpQpRpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HACPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HACPQRPpQpRpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRPpQpRpUpDDpOom3 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRPpQpRpUpDDpOom4 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPRPpRpeq : rk(A :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LAPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRPpRpmtmp : rk(A :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HAPRPpRpeq HAPRPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: R :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: R :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HAPRPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)ACPQRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)ACPQRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRPpQpUpDDpOom2 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRPpQpUpDDpOom3 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom2 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRPpQpUpDDpOomtmp : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRPpQpUpDDpOoeq HACPQRPpQpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRPpQpUpDDpOomtmp;try rewrite HT2 in HACPQRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HACPQRPpQpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom3 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: nil) 4 1 2 HABPRPpQpRpUpDDpOomtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom4 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPRPpQpRpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpRpUpDDpOoeq HAPRPpQpRpUpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HAPRPpQpRpUpDDpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BCPQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BCPQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpRpUpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpRpUpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpRpUpDDpOom2 : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpRpUpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpRpUpDDpOoeq HBCPQRPpQpRpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HBCPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpRpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPRPpQpRpUpDDpOom3 : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBRRpeq : rk(B :: R :: Rp :: nil) = 3) by (apply LBRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpmtmp : rk(B :: R :: Rp :: nil) >= 3) by (solve_hyps_min HBRRpeq HBRRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom2 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBPRPpQpRpUpDDpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBPRPpQpRpUpDDpOoeq HBPRPpQpRpUpDDpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Rp :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HBPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: nil) 3 1 2 HBPRPpQpRpUpDDpOomtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom3 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPRPpQpRpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpRpUpDDpOoeq HAPRPpQpRpUpDDpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Qp :: nil) 4 1 2 HAPRPpQpRpUpDDpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom4 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPRPpQpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpUpDDpOoeq HAPRPpQpUpDDpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HAPRPpQpUpDDpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PPpDDpOo requis par la preuve de (?)PPpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : P :: R :: Qp :: Up ::   de rang : 3 et 3 *)
assert(HPPpDDpOom2 : rk(P :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HPRQpUpeq : rk(P :: R :: Qp :: Up :: nil) = 3) by (apply LPRQpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRQpUpMtmp : rk(P :: R :: Qp :: Up :: nil) <= 3) by (solve_hyps_max HPRQpUpeq HPRQpUpM3).
	assert(HPRPpQpUpDDpOomtmp : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HPRPpQpUpDDpOoeq HPRPpQpUpDDpOom4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (P :: R :: Qp :: Up :: nil) (P :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: R :: Qp :: Up :: P :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Qp :: Up :: P :: Pp :: D :: Dp :: Oo :: nil) ((P :: R :: Qp :: Up :: nil) ++ (P :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPRPpQpUpDDpOomtmp;try rewrite HT2 in HPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (P :: R :: Qp :: Up :: nil) (P :: Pp :: D :: Dp :: Oo :: nil) (P :: nil) 4 1 3 HPRPpQpUpDDpOomtmp HPmtmp HPRQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: Pp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : P :: D :: Dp ::  de rang :  2 et 3 	 A : A :: P :: Q :: D :: Dp ::   de rang : 3 et 3 *)
assert(HPPpDDpOom3 : rk(P :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAPQDDpeq : rk(A :: P :: Q :: D :: Dp :: nil) = 3) by (apply LAPQDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPQDDpMtmp : rk(A :: P :: Q :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAPQDDpeq HAPQDDpM3).
	assert(HAPQPpDDpOomtmp : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPQPpDDpOoeq HAPQPpDDpOom4).
	assert(HPDDpmtmp : rk(P :: D :: Dp :: nil) >= 2) by (solve_hyps_min HPDDpeq HPDDpm2).
	assert(Hincl : incl (P :: D :: Dp :: nil) (list_inter (A :: P :: Q :: D :: Dp :: nil) (P :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) (A :: P :: Q :: D :: Dp :: P :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: P :: Q :: D :: Dp :: P :: Pp :: D :: Dp :: Oo :: nil) ((A :: P :: Q :: D :: Dp :: nil) ++ (P :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQPpDDpOomtmp;try rewrite HT2 in HAPQPpDDpOomtmp.
	assert(HT := rule_4 (A :: P :: Q :: D :: Dp :: nil) (P :: Pp :: D :: Dp :: Oo :: nil) (P :: D :: Dp :: nil) 4 2 3 HAPQPpDDpOomtmp HPDDpmtmp HAPQDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DDpOo requis par la preuve de (?)DDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : P :: Pp :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : P :: Pp :: Oo ::   de rang : 2 et 2 *)
assert(HDDpOom2 : rk(D :: Dp :: Oo :: nil) >= 2).
{
	assert(HPPpOoMtmp : rk(P :: Pp :: Oo :: nil) <= 2) by (solve_hyps_max HPPpOoeq HPPpOoM2).
	assert(HPPpDDpOomtmp : rk(P :: Pp :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HPPpDDpOoeq HPPpDDpOom3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (P :: Pp :: Oo :: nil) (D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Pp :: D :: Dp :: Oo :: nil) (P :: Pp :: Oo :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: Pp :: Oo :: D :: Dp :: Oo :: nil) ((P :: Pp :: Oo :: nil) ++ (D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPPpDDpOomtmp;try rewrite HT2 in HPPpDDpOomtmp.
	assert(HT := rule_4 (P :: Pp :: Oo :: nil) (D :: Dp :: Oo :: nil) (Oo :: nil) 3 1 2 HPPpDDpOomtmp HOomtmp HPPpOoMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HDDpOoM2 : rk(D :: Dp :: Oo :: nil) <= 2).
{
	assert(HADDpOoeq : rk(A :: D :: Dp :: Oo :: nil) = 3) by (apply LADDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADDpOoMtmp : rk(A :: D :: Dp :: Oo :: nil) <= 3) by (solve_hyps_max HADDpOoeq HADDpOoM3).
	assert(HRpUpDDpOoeq : rk(Rp :: Up :: D :: Dp :: Oo :: nil) = 3) by (apply LRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HRpUpDDpOoMtmp : rk(Rp :: Up :: D :: Dp :: Oo :: nil) <= 3) by (solve_hyps_max HRpUpDDpOoeq HRpUpDDpOoM3).
	assert(HARpUpDDpOoeq : rk(A :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LARpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARpUpDDpOomtmp : rk(A :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HARpUpDDpOoeq HARpUpDDpOom4).
	assert(Hincl : incl (D :: Dp :: Oo :: nil) (list_inter (A :: D :: Dp :: Oo :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: D :: Dp :: Oo :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Dp :: Oo :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: D :: Dp :: Oo :: nil) ++ (Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HARpUpDDpOomtmp;try rewrite HT2 in HARpUpDDpOomtmp.
	assert(HT := rule_3 (A :: D :: Dp :: Oo :: nil) (Rp :: Up :: D :: Dp :: Oo :: nil) (D :: Dp :: Oo :: nil) 3 3 4 HADDpOoMtmp HRpUpDDpOoMtmp HARpUpDDpOomtmp Hincl);apply HT.
}


assert(HDDpOoM : rk(D :: Dp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HDDpOoeq HDDpOoM3).
assert(HDDpOom : rk(D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HDDpOoeq HDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQPpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: Pp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpDDpOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQPpDDpOo requis par la preuve de (?)APQPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpDDpOom2 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Q ::  de rang :  2 et 2 	 A : A :: Q :: R :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAPQPpDDpOom3 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQRQpRpeq : rk(A :: Q :: R :: Qp :: Rp :: nil) = 3) by (apply LAQRQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQRQpRpMtmp : rk(A :: Q :: R :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAQRQpRpeq HAQRQpRpM3).
	assert(HAPQRPpQpRpDDpOomtmp : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPQRPpQpRpDDpOoeq HAPQRPpQpRpDDpOom4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: R :: Qp :: Rp :: A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) ((A :: Q :: R :: Qp :: Rp :: nil) ++ (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPQRPpQpRpDDpOomtmp;try rewrite HT2 in HAPQRPpQpRpDDpOomtmp.
	assert(HT := rule_4 (A :: Q :: R :: Qp :: Rp :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) (A :: Q :: nil) 4 2 3 HAPQRPpQpRpDDpOomtmp HAQmtmp HAQRQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQPpDDpOom4 : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQPpDeq : rk(A :: Q :: Pp :: D :: nil) = 4) by (apply LAQPpD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpDmtmp : rk(A :: Q :: Pp :: D :: nil) >= 4) by (solve_hyps_min HAQPpDeq HAQPpDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: D :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: D :: nil) (A :: P :: Q :: Pp :: D :: Dp :: Oo :: nil) 4 4 HAQPpDmtmp Hcomp Hincl);apply HT.
}

assert(HAPQPpDDpOoM : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQPpDDpOom : rk(A :: P :: Q :: Pp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQPpDDpOoeq HAPQPpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBPRPpDDpOo *)
(* dans la couche 0 *)
Lemma LABPRPpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpDDpOo requis par la preuve de (?)ABPRPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpDDpOom2 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpDDpOom3 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABPRPpDDpOom4 : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HARPpDeq : rk(A :: R :: Pp :: D :: nil) = 4) by (apply LARPpD with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARPpDmtmp : rk(A :: R :: Pp :: D :: nil) >= 4) by (solve_hyps_min HARPpDeq HARPpDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Pp :: D :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Pp :: D :: nil) (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) 4 4 HARPpDmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpDDpOoM : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpDDpOom : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpDDpOoeq HABPRPpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPRPpQpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPRPpQpRpUpDDpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom2 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUpDDpOoeq HBCPQRPpQpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUpDDpOomtmp;try rewrite HT2 in HBCPQRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom3 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUpDDpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom4 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPRPpQpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpUpDDpOoeq HABPRPpQpUpDDpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABPRPpQpUpDDpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BCPQRPpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpDDpOo requis par la preuve de (?)BCPQRPpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpDDpOo requis par la preuve de (?)BPRPpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom2 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpDDpOoeq HBCPQRPpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpDDpOomtmp;try rewrite HT2 in HBCPQRPpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Qp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom3 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQpUpMtmp : rk(B :: Qp :: Up :: nil) <= 2) by (solve_hyps_max HBQpUpeq HBQpUpM2).
	assert(HBPRPpQpUpDDpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBPRPpQpUpDDpOoeq HBPRPpQpUpDDpOom4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (B :: Qp :: Up :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Qp :: Up :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((B :: Qp :: Up :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpUpDDpOomtmp;try rewrite HT2 in HBPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Qp :: Up :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (B :: nil) 4 1 2 HBPRPpQpUpDDpOomtmp HBmtmp HBQpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : B :: D :: Dp ::  de rang :  2 et 2 	 A : A :: B :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBPRPpDDpOom4 : rk(B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABDDpeq : rk(A :: B :: D :: Dp :: nil) = 2) by (apply LABDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABDDpMtmp : rk(A :: B :: D :: Dp :: nil) <= 2) by (solve_hyps_max HABDDpeq HABDDpM2).
	assert(HABPRPpDDpOoeq : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) = 4) by (apply LABPRPpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpDDpOoeq HABPRPpDDpOom4).
	assert(HBDDpeq : rk(B :: D :: Dp :: nil) = 2) by (apply LBDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBDDpmtmp : rk(B :: D :: Dp :: nil) >= 2) by (solve_hyps_min HBDDpeq HBDDpm2).
	assert(Hincl : incl (B :: D :: Dp :: nil) (list_inter (A :: B :: D :: Dp :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (A :: B :: D :: Dp :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: Dp :: B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) ((A :: B :: D :: Dp :: nil) ++ (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpDDpOomtmp;try rewrite HT2 in HABPRPpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: D :: Dp :: nil) (B :: P :: R :: Pp :: D :: Dp :: Oo :: nil) (B :: D :: Dp :: nil) 4 2 2 HABPRPpDDpOomtmp HBDDpmtmp HABDDpMtmp Hincl); apply HT.
}

assert(HBPRPpDDpOoM : rk(B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpDDpOom : rk(B :: P :: R :: Pp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpDDpOoeq HBPRPpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPQRPpQpRpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APQRPpQpRpDDpOo requis par la preuve de (?)APQRPpQpRpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom2 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAPQRPpQpRpDDpOom3 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPQRPpQpRpDDpOom4 : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPQRPpQpRpDDpOoM : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPQRPpQpRpDDpOom : rk(A :: P :: Q :: R :: Pp :: Qp :: Rp :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPQRPpQpRpDDpOoeq HAPQRPpQpRpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUDDpOo requis par la preuve de (?)BQPpQpRpUDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUDDpOoeq HABQPpQpRpUDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUDDpOomtmp;try rewrite HT2 in HABQPpQpRpUDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUDDpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUDDpOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUDDpOoeq HBQPpQpRpUDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LPRPpQpUpDDpOo *)
(* dans constructLemma(), requis par LAPRPpQpUpDDpOo *)
(* dans la couche 0 *)
Lemma LAPRPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)ACPQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRPpQpRpUpDDpOo requis par la preuve de (?)ACPQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRPpQpRpUpDDpOom2 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRPpQpRpUpDDpOom3 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRPpQpRpUpDDpOom2 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRPpQpRpUpDDpOomtmp : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRPpQpRpUpDDpOoeq HACPQRPpQpRpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HACPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HACPQRPpQpRpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRPpQpRpUpDDpOom3 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HARRpeq : rk(A :: R :: Rp :: nil) = 3) by (apply LARRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HARRpmtmp : rk(A :: R :: Rp :: nil) >= 3) by (solve_hyps_min HARRpeq HARRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: R :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HARRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAPRPpQpRpUpDDpOom4 : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPRPpRpeq : rk(A :: P :: R :: Pp :: Rp :: nil) = 4) by (apply LAPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRPpRpmtmp : rk(A :: P :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HAPRPpRpeq HAPRPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: P :: R :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: P :: R :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HAPRPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HAPRPpQpRpUpDDpOoM : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRPpQpRpUpDDpOom : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPRPpQpRpUpDDpOoeq HAPRPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAPRPpQpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)ACPQRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACPQRPpQpUpDDpOo requis par la preuve de (?)ACPQRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACPQRPpQpUpDDpOom2 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACPQRPpQpUpDDpOom3 : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HACQeq : rk(A :: C :: Q :: nil) = 3) by (apply LACQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HACQmtmp : rk(A :: C :: Q :: nil) >= 3) by (solve_hyps_min HACQeq HACQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Q :: nil) (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HACQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour APRPpQpUpDDpOo requis par la preuve de (?)APRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom2 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HACPQRPpQpUpDDpOomtmp : rk(A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HACPQRPpQpUpDDpOoeq HACPQRPpQpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACPQRPpQpUpDDpOomtmp;try rewrite HT2 in HACPQRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HACPQRPpQpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom3 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Rp :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: nil) 4 1 2 HABPRPpQpRpUpDDpOomtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HAPRPpQpUpDDpOom4 : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPRPpQpRpUpDDpOoeq : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAPRPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRPpQpRpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpRpUpDDpOoeq HAPRPpQpRpUpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HAPRPpQpRpUpDDpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HAPRPpQpUpDDpOoM : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAPRPpQpUpDDpOom : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAPRPpQpUpDDpOoeq HAPRPpQpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPRPpQpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BCPQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpRpUpDDpOo requis par la preuve de (?)BCPQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpRpUpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpRpUpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpRpUpDDpOo requis par la preuve de (?)BPRPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpRpUpDDpOom2 : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpRpUpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpRpUpDDpOoeq HBCPQRPpQpRpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HBCPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpRpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBPRPpQpRpUpDDpOom3 : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBRRpeq : rk(B :: R :: Rp :: nil) = 3) by (apply LBRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBRRpmtmp : rk(B :: R :: Rp :: nil) >= 3) by (solve_hyps_min HBRRpeq HBRRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: R :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PRPpQpUpDDpOo requis par la preuve de (?)PRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : Pp ::  de rang :  1 et 1 	 A : B :: Pp :: Rp ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom2 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBPpRpMtmp : rk(B :: Pp :: Rp :: nil) <= 2) by (solve_hyps_max HBPpRpeq HBPpRpM2).
	assert(HBPRPpQpRpUpDDpOomtmp : rk(B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBPRPpQpRpUpDDpOoeq HBPRPpQpRpUpDDpOom3).
	assert(HPpmtmp : rk(Pp :: nil) >= 1) by (solve_hyps_min HPpeq HPpm1).
	assert(Hincl : incl (Pp :: nil) (list_inter (B :: Pp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Rp :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HBPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: nil) 3 1 2 HBPRPpQpRpUpDDpOomtmp HPpmtmp HBPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom3 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HAPRPpQpRpUpDDpOoeq : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAPRPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRPpQpRpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpRpUpDDpOoeq HAPRPpQpRpUpDDpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Qp :: nil) 4 1 2 HAPRPpQpRpUpDDpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HPRPpQpUpDDpOom4 : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAPRPpQpUpDDpOoeq : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAPRPpQpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPRPpQpUpDDpOomtmp : rk(A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAPRPpQpUpDDpOoeq HAPRPpQpUpDDpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAPRPpQpUpDDpOomtmp;try rewrite HT2 in HAPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HAPRPpQpUpDDpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HPRPpQpUpDDpOoM : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPRPpQpUpDDpOom : rk(P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HPRPpQpUpDDpOoeq HPRPpQpUpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBPRPpQpUpDDpOo *)
(* dans constructLemma(), requis par LABPRPpQpUpDDpOo *)
(* dans la couche 0 *)
Lemma LABPRPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpRpUpDDpOo requis par la preuve de (?)ABPRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpRpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABRRpmtmp : rk(A :: B :: R :: Rp :: nil) >= 4) by (solve_hyps_min HABRRpeq HABRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABRRpmtmp Hcomp Hincl);apply HT.
}

assert(HABPRPpQpRpUpDDpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpRpUpDDpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABPRPpQpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABPRPpQpUpDDpOo requis par la preuve de (?)ABPRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom2 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABPRPpQpUpDDpOom3 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABRmtmp : rk(A :: B :: R :: nil) >= 3) by (solve_hyps_min HABReq HABRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: R :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Qp ::  de rang :  2 et 2 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HABPRPpQpUpDDpOom4 : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABPRPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HAQpeq : rk(A :: Qp :: nil) = 2) by (apply LAQp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpmtmp : rk(A :: Qp :: nil) >= 2) by (solve_hyps_min HAQpeq HAQpm2).
	assert(Hincl : incl (A :: Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: nil) 4 2 2 HABPRPpQpRpUpDDpOomtmp HAQpmtmp HAQpRpMtmp Hincl); apply HT.
}

assert(HABPRPpQpUpDDpOoM : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABPRPpQpUpDDpOom : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABPRPpQpUpDDpOoeq HABPRPpQpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBPRPpQpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCPQRPpQpUpDDpOo requis par la preuve de (?)BCPQRPpQpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBCPQRPpQpUpDDpOom2 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCPQRPpQpUpDDpOom3 : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBCQeq : rk(B :: C :: Q :: nil) = 3) by (apply LBCQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBCQmtmp : rk(B :: C :: Q :: nil) >= 3) by (solve_hyps_min HBCQeq HBCQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Q :: nil) (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBCQmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BPRPpQpUpDDpOo requis par la preuve de (?)BPRPpQpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  3 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : C :: P :: Q ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom2 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HCPQMtmp : rk(C :: P :: Q :: nil) <= 2) by (solve_hyps_max HCPQeq HCPQM2).
	assert(HBCPQRPpQpUpDDpOomtmp : rk(B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HBCPQRPpQpUpDDpOoeq HBCPQRPpQpUpDDpOom3).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: P :: Q :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: P :: Q :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((C :: P :: Q :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCPQRPpQpUpDDpOomtmp;try rewrite HT2 in HBCPQRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (C :: P :: Q :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (P :: nil) 3 1 2 HBCPQRPpQpUpDDpOomtmp HPmtmp HCPQMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp ::  de rang :  1 et 1 	 A : A :: Qp :: Rp ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom3 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQpRpMtmp : rk(A :: Qp :: Rp :: nil) <= 2) by (solve_hyps_max HAQpRpeq HAQpRpM2).
	assert(HABPRPpQpRpUpDDpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABPRPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpRpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpRpUpDDpOoeq HABPRPpQpRpUpDDpOom4).
	assert(HQpmtmp : rk(Qp :: nil) >= 1) by (solve_hyps_min HQpeq HQpm1).
	assert(Hincl : incl (Qp :: nil) (list_inter (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpRpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Qp :: nil) 4 1 2 HABPRPpQpRpUpDDpOomtmp HQpmtmp HAQpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HBPRPpQpUpDDpOom4 : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HABPRPpQpUpDDpOoeq : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABPRPpQpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABPRPpQpUpDDpOomtmp : rk(A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABPRPpQpUpDDpOoeq HABPRPpQpUpDDpOom4).
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpmtmp : rk(Pp :: Up :: nil) >= 2) by (solve_hyps_min HPpUpeq HPpUpm2).
	assert(Hincl : incl (Pp :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABPRPpQpUpDDpOomtmp;try rewrite HT2 in HABPRPpQpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: nil) 4 2 2 HABPRPpQpUpDDpOomtmp HPpUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HBPRPpQpUpDDpOoM : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBPRPpQpUpDDpOom : rk(B :: P :: R :: Pp :: Qp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBPRPpQpUpDDpOoeq HBPRPpQpUpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQQpRpUpDDpOo *)
(* dans constructLemma(), requis par LAQQpRpUpDDpOo *)
(* dans la couche 0 *)
Lemma LAQPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpRp requis par la preuve de (?)AQPpRp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpRpm2 : rk(A :: Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Rp :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAQPpRpm3 : rk(A :: Q :: Pp :: Rp :: nil) >= 3).
{
	assert(HABQRUeq : rk(A :: B :: Q :: R :: U :: nil) = 3) by (apply LABQRU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRUMtmp : rk(A :: B :: Q :: R :: U :: nil) <= 3) by (solve_hyps_max HABQRUeq HABQRUM3).
	assert(HABQRPpRpUeq : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) = 4) by (apply LABQRPpRpU with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQRPpRpUmtmp : rk(A :: B :: Q :: R :: Pp :: Rp :: U :: nil) >= 4) by (solve_hyps_min HABQRPpRpUeq HABQRPpRpUm4).
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hincl : incl (A :: Q :: nil) (list_inter (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: R :: Pp :: Rp :: U :: nil) (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Q :: Pp :: Rp :: A :: B :: Q :: R :: U :: nil) ((A :: Q :: Pp :: Rp :: nil) ++ (A :: B :: Q :: R :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQRPpRpUmtmp;try rewrite HT2 in HABQRPpRpUmtmp.
	assert(HT := rule_2 (A :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: R :: U :: nil) (A :: Q :: nil) 4 2 3 HABQRPpRpUmtmp HAQmtmp HABQRUMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQPpQpRpUpDDpOo requis par la preuve de (?)AQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQPpQpRpUpDDpOom2 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAQPpQpRpUpDDpOom3 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQPpRpmtmp : rk(A :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HAQPpRpeq HAQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Pp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HAQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HAQPpQpRpUpDDpOom4 : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HABQPpQpRpUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HAQPpQpRpUpDDpOoM : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQPpQpRpUpDDpOom : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQPpQpRpUpDDpOoeq HAQPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAQQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AQQpRpUpDDpOo requis par la preuve de (?)AQQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDDpOom2 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HAQeq : rk(A :: Q :: nil) = 2) by (apply LAQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQmtmp : rk(A :: Q :: nil) >= 2) by (solve_hyps_min HAQeq HAQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HAQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAQQpRpUpDDpOom3 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HAQQpRpeq : rk(A :: Q :: Qp :: Rp :: nil) = 3) by (apply LAQQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpmtmp : rk(A :: Q :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HAQQpRpeq HAQQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Q :: Qp :: Rp :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HAQQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : A :: Up ::  de rang :  2 et 2 	 A : A :: Pp :: Up ::   de rang : 2 et 2 *)
assert(HAQQpRpUpDDpOom4 : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpUpMtmp : rk(A :: Pp :: Up :: nil) <= 2) by (solve_hyps_max HAPpUpeq HAPpUpM2).
	assert(HAQPpQpRpUpDDpOoeq : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQPpQpRpUpDDpOomtmp : rk(A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQPpQpRpUpDDpOoeq HAQPpQpRpUpDDpOom4).
	assert(HAUpeq : rk(A :: Up :: nil) = 2) by (apply LAUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAUpmtmp : rk(A :: Up :: nil) >= 2) by (solve_hyps_min HAUpeq HAUpm2).
	assert(Hincl : incl (A :: Up :: nil) (list_inter (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Up :: A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Up :: nil) ++ (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQPpQpRpUpDDpOomtmp;try rewrite HT2 in HAQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Up :: nil) (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Up :: nil) 4 2 2 HAQPpQpRpUpDDpOomtmp HAUpmtmp HAPpUpMtmp Hincl); apply HT.
}

assert(HAQQpRpUpDDpOoM : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAQQpRpUpDDpOom : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HAQQpRpUpDDpOoeq HAQQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDDpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDDpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDDpOoeq HABCQPpQpRpUpDDpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABCQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDDpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDDpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDDpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDDpOoeq HBQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDDpOomtmp;try rewrite HT2 in HBQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDDpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDDpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QQpRpUpDDpOo requis par la preuve de (?)QQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Rp ::  de rang :  1 et 1 	 A : P :: R :: Pp :: Rp ::   de rang : 3 et 3 *)
assert(HQQpRpUpDDpOom2 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HPRPpRpeq : rk(P :: R :: Pp :: Rp :: nil) = 3) by (apply LPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPRPpRpMtmp : rk(P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HPRPpRpeq HPRPpRpM3).
	assert(HPQRPpQpRpUpDDpOomtmp : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HPQRPpQpRpUpDDpOoeq HPQRPpQpRpUpDDpOom4).
	assert(HRpmtmp : rk(Rp :: nil) >= 1) by (solve_hyps_min HRpeq HRpm1).
	assert(Hincl : incl (Rp :: nil) (list_inter (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: R :: Pp :: Rp :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((P :: R :: Pp :: Rp :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HPQRPpQpRpUpDDpOomtmp;try rewrite HT2 in HPQRPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (P :: R :: Pp :: Rp :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Rp :: nil) 4 1 3 HPQRPpQpRpUpDDpOomtmp HRpmtmp HPRPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Up ::  de rang :  1 et 1 	 A : Pp :: Up ::   de rang : 2 et 2 *)
assert(HQQpRpUpDDpOom3 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpUpeq : rk(Pp :: Up :: nil) = 2) by (apply LPpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPpUpMtmp : rk(Pp :: Up :: nil) <= 2) by (solve_hyps_max HPpUpeq HPpUpM2).
	assert(HQPpQpRpUpDDpOomtmp : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HQPpQpRpUpDDpOoeq HQPpQpRpUpDDpOom4).
	assert(HUpmtmp : rk(Up :: nil) >= 1) by (solve_hyps_min HUpeq HUpm1).
	assert(Hincl : incl (Up :: nil) (list_inter (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Pp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((Pp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HQPpQpRpUpDDpOomtmp;try rewrite HT2 in HQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (Pp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Up :: nil) 4 1 2 HQPpQpRpUpDDpOomtmp HUpmtmp HPpUpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Qp :: Rp :: Up ::  de rang :  3 et 3 	 A : A :: Qp :: Rp :: Up ::   de rang : 3 et 3 *)
assert(HQQpRpUpDDpOom4 : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAQpRpUpeq : rk(A :: Qp :: Rp :: Up :: nil) = 3) by (apply LAQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQpRpUpMtmp : rk(A :: Qp :: Rp :: Up :: nil) <= 3) by (solve_hyps_max HAQpRpUpeq HAQpRpUpM3).
	assert(HAQQpRpUpDDpOoeq : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LAQQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAQQpRpUpDDpOomtmp : rk(A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HAQQpRpUpDDpOoeq HAQQpRpUpDDpOom4).
	assert(HQpRpUpeq : rk(Qp :: Rp :: Up :: nil) = 3) by (apply LQpRpUp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HQpRpUpmtmp : rk(Qp :: Rp :: Up :: nil) >= 3) by (solve_hyps_min HQpRpUpeq HQpRpUpm3).
	assert(Hincl : incl (Qp :: Rp :: Up :: nil) (list_inter (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Qp :: Rp :: Up :: Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Qp :: Rp :: Up :: nil) ++ (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAQQpRpUpDDpOomtmp;try rewrite HT2 in HAQQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Qp :: Rp :: Up :: nil) (Q :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Qp :: Rp :: Up :: nil) 4 3 3 HAQQpRpUpDDpOomtmp HQpRpUpmtmp HAQpRpUpMtmp Hincl); apply HT.
}

assert(HQQpRpUpDDpOoM : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQQpRpUpDDpOom : rk(Q :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HQQpRpUpDDpOoeq HQQpRpUpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LQPpQpRpUpDDpOo *)
(* dans la couche 0 *)
Lemma LBQPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUpDDpOo requis par la preuve de (?)BQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUpDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUpDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUpDDpOoeq HABQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUpDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUpDDpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUpDDpOom : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUpDDpOoeq HBQPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour PpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour QPpRp requis par la preuve de (?)QPpRp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HQPpRpm2 : rk(Q :: Pp :: Rp :: nil) >= 2).
{
	assert(HBPRPpRpeq : rk(B :: P :: R :: Pp :: Rp :: nil) = 3) by (apply LBPRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPRPpRpMtmp : rk(B :: P :: R :: Pp :: Rp :: nil) <= 3) by (solve_hyps_max HBPRPpRpeq HBPRPpRpM3).
	assert(HBPQRPpRpeq : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) = 4) by (apply LBPQRPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPQRPpRpmtmp : rk(B :: P :: Q :: R :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HBPQRPpRpeq HBPQRPpRpm4).
	assert(HPpRpmtmp : rk(Pp :: Rp :: nil) >= 1) by (solve_hyps_min HPpRpeq HPpRpm1).
	assert(Hincl : incl (Pp :: Rp :: nil) (list_inter (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: P :: Q :: R :: Pp :: Rp :: nil) (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Q :: Pp :: Rp :: B :: P :: R :: Pp :: Rp :: nil) ((Q :: Pp :: Rp :: nil) ++ (B :: P :: R :: Pp :: Rp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBPQRPpRpmtmp;try rewrite HT2 in HBPQRPpRpmtmp.
	assert(HT := rule_2 (Q :: Pp :: Rp :: nil) (B :: P :: R :: Pp :: Rp :: nil) (Pp :: Rp :: nil) 4 1 3 HBPQRPpRpmtmp HPpRpmtmp HBPRPpRpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour QPpQpRpUpDDpOo requis par la preuve de (?)QPpQpRpUpDDpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Q :: Pp :: Rp ::  de rang :  2 et 3 	 A : A :: B :: C :: Q :: Pp :: Rp ::   de rang : 4 et 4 *)
assert(HQPpQpRpUpDDpOom2 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABCQPpRpeq : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) = 4) by (apply LABCQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABCQPpRpMtmp : rk(A :: B :: C :: Q :: Pp :: Rp :: nil) <= 4) by (solve_hyps_max HABCQPpRpeq HABCQPpRpM4).
	assert(HABCQPpQpRpUpDDpOomtmp : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABCQPpQpRpUpDDpOoeq HABCQPpQpRpUpDDpOom4).
	assert(HQPpRpmtmp : rk(Q :: Pp :: Rp :: nil) >= 2) by (solve_hyps_min HQPpRpeq HQPpRpm2).
	assert(Hincl : incl (Q :: Pp :: Rp :: nil) (list_inter (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Q :: Pp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((A :: B :: C :: Q :: Pp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCQPpQpRpUpDDpOomtmp;try rewrite HT2 in HABCQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Q :: Pp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Q :: Pp :: Rp :: nil) 4 2 4 HABCQPpQpRpUpDDpOomtmp HQPpRpmtmp HABCQPpRpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HQPpQpRpUpDDpOom3 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPpQpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : B :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HQPpQpRpUpDDpOom4 : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HBPpQpRpeq : rk(B :: Pp :: Qp :: Rp :: nil) = 3) by (apply LBPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBPpQpRpMtmp : rk(B :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HBPpQpRpeq HBPpQpRpM3).
	assert(HBQPpQpRpUpDDpOoeq : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LBQPpQpRpUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpQpRpUpDDpOomtmp : rk(B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HBQPpQpRpUpDDpOoeq HBQPpQpRpUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Pp :: Qp :: Rp :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) ((B :: Pp :: Qp :: Rp :: nil) ++ (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBQPpQpRpUpDDpOomtmp;try rewrite HT2 in HBQPpQpRpUpDDpOomtmp.
	assert(HT := rule_4 (B :: Pp :: Qp :: Rp :: nil) (Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HBQPpQpRpUpDDpOomtmp HPpQpRpmtmp HBPpQpRpMtmp Hincl); apply HT.
}

assert(HQPpQpRpUpDDpOoM : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HQPpQpRpUpDDpOom : rk(Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HQPpQpRpUpDDpOoeq HQPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCQPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCQPpQpRpUpDDpOo requis par la preuve de (?)ABCQPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom2 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCQPpQpRpUpDDpOom3 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCQPpQpRpUpDDpOom4 : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABCQPpQpRpUpDDpOoM : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCQPpQpRpUpDDpOom : rk(A :: B :: C :: Q :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABCQPpQpRpUpDDpOoeq HABCQPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LPQRPpQpRpUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour PQRPpQpRpUpDDpOo requis par la preuve de (?)PQRPpQpRpUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HPQRPpQpRpUpDDpOom3 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HPQRmtmp : rk(P :: Q :: R :: nil) >= 3) by (solve_hyps_min HPQReq HPQRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 3 3 HPQRmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HPQRPpQpRpUpDDpOom4 : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HPQRRpeq : rk(P :: Q :: R :: Rp :: nil) = 4) by (apply LPQRRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HPQRRpmtmp : rk(P :: Q :: R :: Rp :: nil) >= 4) by (solve_hyps_min HPQRRpeq HPQRRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (P :: Q :: R :: Rp :: nil) (P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo :: nil) 4 4 HPQRRpmtmp Hcomp Hincl);apply HT.
}

assert(HPQRPpQpRpUpDDpOoM : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HPQRPpQpRpUpDDpOom : rk(P :: Q :: R :: Pp :: Qp :: Rp :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HPQRPpQpRpUpDDpOoeq HPQRPpQpRpUpDDpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQPpQpRpUUpDDpOo *)
(* dans la couche 0 *)
Lemma LABQPpQpRpUUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABQPpQpRpUUpDDpOo requis par la preuve de (?)ABQPpQpRpUUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDDpOom2 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABQPpQpRpUUpDDpOom3 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HABQmtmp : rk(A :: B :: Q :: nil) >= 3) by (solve_hyps_min HABQeq HABQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 3 3 HABQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABQPpQpRpUUpDDpOom4 : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HABQPpRpeq : rk(A :: B :: Q :: Pp :: Rp :: nil) = 4) by (apply LABQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpRpmtmp : rk(A :: B :: Q :: Pp :: Rp :: nil) >= 4) by (solve_hyps_min HABQPpRpeq HABQPpRpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Q :: Pp :: Rp :: nil) (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 4 4 HABQPpRpmtmp Hcomp Hincl);apply HT.
}

assert(HABQPpQpRpUUpDDpOoM : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABQPpQpRpUUpDDpOom : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HABQPpQpRpUUpDDpOoeq HABQPpQpRpUUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQPpQpRpUUpDDpOo : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) = 4.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BQPpQpRpUUpDDpOo requis par la preuve de (?)BQPpQpRpUUpDDpOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDDpOom2 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 2).
{
	assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 2 2 HBQmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBQPpQpRpUUpDDpOom3 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 3).
{
	assert(HBQPpRpeq : rk(B :: Q :: Pp :: Rp :: nil) = 3) by (apply LBQPpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HBQPpRpmtmp : rk(B :: Q :: Pp :: Rp :: nil) >= 3) by (solve_hyps_min HBQPpRpeq HBQPpRpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Q :: Pp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) 3 3 HBQPpRpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  de rang :  4 et 4 	 AiB : Pp :: Qp :: Rp ::  de rang :  3 et 3 	 A : A :: Pp :: Qp :: Rp ::   de rang : 3 et 3 *)
assert(HBQPpQpRpUUpDDpOom4 : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4).
{
	assert(HAPpQpRpeq : rk(A :: Pp :: Qp :: Rp :: nil) = 3) by (apply LAPpQpRp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HAPpQpRpMtmp : rk(A :: Pp :: Qp :: Rp :: nil) <= 3) by (solve_hyps_max HAPpQpRpeq HAPpQpRpM3).
	assert(HABQPpQpRpUUpDDpOoeq : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) = 4) by (apply LABQPpQpRpUUpDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HABQPpQpRpUUpDDpOomtmp : rk(A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) >= 4) by (solve_hyps_min HABQPpQpRpUUpDDpOoeq HABQPpQpRpUUpDDpOom4).
	assert(HPpQpRpmtmp : rk(Pp :: Qp :: Rp :: nil) >= 3) by (solve_hyps_min HPpQpRpeq HPpQpRpm3).
	assert(Hincl : incl (Pp :: Qp :: Rp :: nil) (list_inter (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Pp :: Qp :: Rp :: B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) ((A :: Pp :: Qp :: Rp :: nil) ++ (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABQPpQpRpUUpDDpOomtmp;try rewrite HT2 in HABQPpQpRpUUpDDpOomtmp.
	assert(HT := rule_4 (A :: Pp :: Qp :: Rp :: nil) (B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo :: nil) (Pp :: Qp :: Rp :: nil) 4 3 3 HABQPpQpRpUUpDDpOomtmp HPpQpRpmtmp HAPpQpRpMtmp Hincl); apply HT.
}

assert(HBQPpQpRpUUpDDpOoM : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBQPpQpRpUUpDDpOom : rk(B :: Q :: Pp :: Qp :: Rp :: U :: Up :: D :: Dp :: Oo ::  nil) >= 1) by (solve_hyps_min HBQPpQpRpUUpDDpOoeq HBQPpQpRpUUpDDpOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDDp : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> rk(D :: Dp ::  nil) = 1.
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DDp requis par la preuve de (?)DDp pour la règle 3  *)
(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HDDpM1 : rk(D :: Dp :: nil) <= 1).
{
	assert(HADDpeq : rk(A :: D :: Dp :: nil) = 2) by (apply LADDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADDpMtmp : rk(A :: D :: Dp :: nil) <= 2) by (solve_hyps_max HADDpeq HADDpM2).
	assert(HDDpOoeq : rk(D :: Dp :: Oo :: nil) = 2) by (apply LDDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HDDpOoMtmp : rk(D :: Dp :: Oo :: nil) <= 2) by (solve_hyps_max HDDpOoeq HDDpOoM2).
	assert(HADDpOoeq : rk(A :: D :: Dp :: Oo :: nil) = 3) by (apply LADDpOo with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption).
	assert(HADDpOomtmp : rk(A :: D :: Dp :: Oo :: nil) >= 3) by (solve_hyps_min HADDpOoeq HADDpOom3).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (A :: D :: Dp :: nil) (D :: Dp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: Dp :: Oo :: nil) (A :: D :: Dp :: D :: Dp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Dp :: D :: Dp :: Oo :: nil) ((A :: D :: Dp :: nil) ++ (D :: Dp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADDpOomtmp;try rewrite HT2 in HADDpOomtmp.
	assert(HT := rule_3 (A :: D :: Dp :: nil) (D :: Dp :: Oo :: nil) (D :: Dp :: nil) 2 2 3 HADDpMtmp HDDpOoMtmp HADDpOomtmp Hincl);apply HT.
}


assert(HDDpM : rk(D :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDDpeq HDDpM2).
assert(HDDpm : rk(D :: Dp ::  nil) >= 1) by (solve_hyps_min HDDpeq HDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Theorem def_Conclusion : forall A B C P Q R Pp Qp Rp U Up D Dp Oo ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2 -> rk(A :: B :: Q ::  nil) = 3 -> rk(C :: P :: Q ::  nil) = 2 ->
rk(A :: B :: R ::  nil) = 3 -> rk(B :: P :: R ::  nil) = 2 -> rk(A :: Q :: R ::  nil) = 2 ->
rk(P :: Q :: R ::  nil) = 3 -> rk(A :: B :: Qp ::  nil) = 3 -> rk(C :: Pp :: Qp ::  nil) = 2 ->
rk(A :: B :: Rp ::  nil) = 3 -> rk(A :: B :: R :: Rp ::  nil) = 4 -> rk(B :: Pp :: Rp ::  nil) = 2 ->
rk(A :: Qp :: Rp ::  nil) = 2 -> rk(Pp :: Qp :: Rp ::  nil) = 3 -> rk(A :: P :: U ::  nil) = 2 ->
rk(B :: Q :: U ::  nil) = 2 -> rk(A :: Pp :: Up ::  nil) = 2 -> rk(B :: Qp :: Up ::  nil) = 2 ->
rk(R :: U :: D ::  nil) = 2 -> rk(Rp :: Up :: Dp ::  nil) = 2 -> rk(A :: B :: C :: D :: Dp ::  nil) = 2 ->
rk(P :: Pp :: Oo ::  nil) = 2 -> rk(Q :: Qp :: Oo ::  nil) = 2 -> 
	 rk(D :: Dp ::  nil) = 1  .
Proof.

intros A B C P Q R Pp Qp Rp U Up D Dp Oo 
HABeq HACeq HBCeq HABCeq HABQeq HCPQeq HABReq HBPReq HAQReq HPQReq
HABQpeq HCPpQpeq HABRpeq HABRRpeq HBPpRpeq HAQpRpeq HPpQpRpeq HAPUeq HBQUeq HAPpUpeq
HBQpUpeq HRUDeq HRpUpDpeq HABCDDpeq HPPpOoeq HQQpOoeq .
repeat split.

	apply LDDp with (A := A) (B := B) (C := C) (P := P) (Q := Q) (R := R) (Pp := Pp) (Qp := Qp) (Rp := Rp) (U := U) (Up := Up) (D := D) (Dp := Dp) (Oo := Oo) ; assumption.
Qed .
