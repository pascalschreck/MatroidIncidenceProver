Load "preamble5D.v".


(* dans la couche 0 *)
Lemma LAC : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: C ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AC requis par la preuve de (?)AC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HACm2 : rk(A :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HACp2mtmp : rk(A :: C :: p2 :: nil) >= 2) by (solve_hyps_min HACp2eq HACp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p2 :: nil) (A :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A :: p2 :: nil) ((A :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp2mtmp;try rewrite HT2 in HACp2mtmp.
	assert(HT := rule_2 (A :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HACp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCp1 *)
(* dans constructLemma(), requis par LCDEp1 *)
(* dans la couche 0 *)
Lemma LABCDEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 ::  nil) = 5.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDEp1 requis par la preuve de (?)ABCDEp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp1 requis par la preuve de (?)ABCDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp1M4 : rk(A :: B :: C :: D :: p1 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p1 :: nil) (D :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: C :: p1 :: nil) ((D :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HDMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1 requis par la preuve de (?)ABCDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDEp1M5 : rk(A :: B :: C :: D :: E :: p1 :: nil) <= 5).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCDp1Mtmp : rk(A :: B :: C :: D :: p1 :: nil) <= 4) by (solve_hyps_max HABCDp1eq HABCDp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (E :: A :: B :: C :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: D :: p1 :: nil) (nil) 1 4 0 HEMtmp HABCDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1m5 : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEp1M : rk(A :: B :: C :: D :: E :: p1 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1m : rk(A :: B :: C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HABCDEp1eq HABCDEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCDEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(C :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1 requis par la preuve de (?)ABCDED'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD' requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BE requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABEC' requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC' requis par la preuve de (?)ABEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p2 requis par la preuve de (?)ABC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p2 requis par la preuve de (?)ABCDEC'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p2m5 : rk(A :: B :: C :: D :: E :: C' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC' requis par la preuve de (?)ABC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABC'm2 : rk(A :: B :: C' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEC'p2mtmp : rk(A :: B :: C :: D :: E :: C' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEC'p2eq HABCDEC'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p2 :: nil) (A :: B :: C' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: C' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p2mtmp;try rewrite HT2 in HABCDEC'p2mtmp.
	assert(HT := rule_2 (A :: B :: C' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEC'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ACA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEC' requis par la preuve de (?)ABEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: B :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HABEC'm2 : rk(A :: B :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HABC'mtmp : rk(A :: B :: C' :: nil) >= 2) by (solve_hyps_min HABC'eq HABC'm2).
	assert(Hincl : incl (A :: B :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: B :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: B :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: B :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: B :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: B :: E :: C' :: nil) (A :: B :: C' :: nil) 5 2 5 HABCDEC'mtmp HABC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : B :: E ::  de rang :  1 et 2 	 A : A :: B :: E :: C' ::   de rang : 2 et 4 *)
assert(HBCDEp1m2 : rk(B :: C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABEC'Mtmp : rk(A :: B :: E :: C' :: nil) <= 4) by (solve_hyps_max HABEC'eq HABEC'M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBEmtmp : rk(B :: E :: nil) >= 1) by (solve_hyps_min HBEeq HBEm1).
	assert(Hincl : incl (B :: E :: nil) (list_inter (A :: B :: E :: C' :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (A :: B :: E :: C' :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: C' :: B :: C :: D :: E :: p1 :: nil) ((A :: B :: E :: C' :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (A :: B :: E :: C' :: nil) (B :: C :: D :: E :: p1 :: nil) (B :: E :: nil) 5 1 4 HABCDEC'p1mtmp HBEmtmp HABEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: D' ::   de rang : 1 et 2 *)
assert(HBCDEp1m3 : rk(B :: C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HAD'Mtmp : rk(A :: D' :: nil) <= 2) by (solve_hyps_max HAD'eq HAD'M2).
	assert(HABCDED'p1mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDED'p1eq HABCDED'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D' :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: nil) (A :: D' :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D' :: B :: C :: D :: E :: p1 :: nil) ((A :: D' :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1mtmp;try rewrite HT2 in HABCDED'p1mtmp.
	assert(HT := rule_4 (A :: D' :: nil) (B :: C :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDED'p1mtmp Hmtmp HAD'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: p1 ::   de rang : 2 et 2 *)
assert(HBCDEp1m4 : rk(B :: C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HAp1Mtmp : rk(A :: p1 :: nil) <= 2) by (solve_hyps_max HAp1eq HAp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: p1 :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: p1 :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p1 :: B :: C :: D :: E :: p1 :: nil) ((A :: p1 :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: p1 :: nil) (B :: C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HAp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : A :: B :: E :: C' ::   de rang : 2 et 4 *)
assert(HCDEp1m2 : rk(C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABEC'Mtmp : rk(A :: B :: E :: C' :: nil) <= 4) by (solve_hyps_max HABEC'eq HABEC'M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (A :: B :: E :: C' :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (A :: B :: E :: C' :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: C' :: C :: D :: E :: p1 :: nil) ((A :: B :: E :: C' :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (A :: B :: E :: C' :: nil) (C :: D :: E :: p1 :: nil) (E :: nil) 5 1 4 HABCDEC'p1mtmp HEmtmp HABEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: D :: E :: p1 ::  de rang :  4 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HCDEp1m3 : rk(C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HBCDEp1mtmp : rk(B :: C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HBCDEp1eq HBCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p1 :: nil) (B :: p1 :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: C :: D :: E :: p1 :: nil) ((B :: p1 :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDEp1mtmp;try rewrite HT2 in HBCDEp1mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (C :: D :: E :: p1 :: nil) (p1 :: nil) 4 1 2 HBCDEp1mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HCDEp1m4 : rk(C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: B :: p1 :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: C :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HCDEp1M : rk(C :: D :: E :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HCDEp1eq HCDEp1M4).
assert(HCDEp1m : rk(C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HCDEp1eq HCDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LCp1 *)
(* dans la couche 0 *)
Lemma LCp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(C :: p1 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DEp1 requis par la preuve de (?)Cp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m2 : rk(D :: E :: p1 :: nil) >= 2).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 3 1 2 HABDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cp1 requis par la preuve de (?)Cp1 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HCp1m2 : rk(C :: p1 :: nil) >= 2).
{
	assert(HDEp1Mtmp : rk(D :: E :: p1 :: nil) <= 3) by (solve_hyps_max HDEp1eq HDEp1M3).
	assert(HCDEp1eq : rk(C :: D :: E :: p1 :: nil) = 4) by (apply LCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCDEp1mtmp : rk(C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HCDEp1eq HCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: E :: p1 :: nil) (C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCDEp1mtmp;try rewrite HT2 in HCDEp1mtmp.
	assert(HT := rule_2 (C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 4 1 3 HCDEp1mtmp Hp1mtmp HDEp1Mtmp Hincl);apply HT.
}

assert(HCp1M : rk(C :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HCp1eq HCp1M2).
assert(HCp1m : rk(C :: p1 ::  nil) >= 1) by (solve_hyps_min HCp1eq HCp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LACp1 *)
(* dans la couche 0 *)
Lemma LACDEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: C :: D :: E :: p1 ::  nil) = 5.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1 requis par la preuve de (?)ABCDEA'B'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1m2 : rk(A :: C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1eq HABCDEA'B'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1mtmp;try rewrite HT2 in HABCDEA'B'p1mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1m3 : rk(A :: C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEC'p1mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1m4 : rk(A :: C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1m5 : rk(A :: C :: D :: E :: p1 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEp1M : rk(A :: C :: D :: E :: p1 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HACDEp1eq HACDEp1M5).
assert(HACDEp1m : rk(A :: C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HACDEp1eq HACDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LACp1 *)
(* dans la couche 0 *)
Lemma LDEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(D :: E :: p1 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m2 : rk(D :: E :: p1 :: nil) >= 2).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 3 1 2 HABDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : C :: D :: E :: p1 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m3 : rk(D :: E :: p1 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HCDEp1eq : rk(C :: D :: E :: p1 :: nil) = 4) by (apply LCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCDEp1mtmp : rk(C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HCDEp1eq HCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: E :: p1 :: nil) (C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCDEp1mtmp;try rewrite HT2 in HCDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 4 1 2 HCDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HDEp1M : rk(D :: E :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HDEp1eq HDEp1M3).
assert(HDEp1m : rk(D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HDEp1eq HDEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: C :: p1 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACp1 requis par la preuve de (?)ACp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACp1 requis par la preuve de (?)ACp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1m2 : rk(A :: C :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HACp1m3 : rk(A :: C :: p1 :: nil) >= 3).
{
	assert(HDEp1eq : rk(D :: E :: p1 :: nil) = 3) by (apply LDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDEp1Mtmp : rk(D :: E :: p1 :: nil) <= 3) by (solve_hyps_max HDEp1eq HDEp1M3).
	assert(HACDEp1eq : rk(A :: C :: D :: E :: p1 :: nil) = 5) by (apply LACDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACDEp1mtmp : rk(A :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HACDEp1eq HACDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: nil) (A :: C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: D :: E :: p1 :: nil) ((A :: C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1mtmp;try rewrite HT2 in HACDEp1mtmp.
	assert(HT := rule_2 (A :: C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 5 1 3 HACDEp1mtmp Hp1mtmp HDEp1Mtmp Hincl);apply HT.
}

assert(HACp1M : rk(A :: C :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HACp1eq HACp1M3).
assert(HACp1m : rk(A :: C :: p1 ::  nil) >= 1) by (solve_hyps_min HACp1eq HACp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LDp1 *)
(* dans la couche 0 *)
Lemma LADEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ACA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1m2 : rk(A :: D :: E :: p1 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: nil) (E :: nil) 5 1 4 HABCDEC'p1mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1m3 : rk(A :: D :: E :: p1 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1m4 : rk(A :: D :: E :: p1 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1eq : rk(A :: C :: D :: E :: p1 :: nil) = 5) by (apply LACDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACDEp1mtmp : rk(A :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HACDEp1eq HACDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: nil) (C :: p1 :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1mtmp;try rewrite HT2 in HACDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HACDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp1M : rk(A :: D :: E :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HADEp1eq HADEp1M4).
assert(HADEp1m : rk(A :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HADEp1eq HADEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LDp1 *)
(* dans la couche 0 *)
Lemma LDp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(D :: p1 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp1 requis par la preuve de (?)Dp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AEp1 requis par la preuve de (?)AEp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1m2 : rk(A :: E :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dp1 requis par la preuve de (?)Dp1 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HDp1m2 : rk(D :: p1 :: nil) >= 2).
{
	assert(HAEp1Mtmp : rk(A :: E :: p1 :: nil) <= 3) by (solve_hyps_max HAEp1eq HAEp1M3).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (D :: p1 :: A :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_2 (D :: p1 :: nil) (A :: E :: p1 :: nil) (p1 :: nil) 4 1 3 HADEp1mtmp Hp1mtmp HAEp1Mtmp Hincl);apply HT.
}

assert(HDp1M : rk(D :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HDp1eq HDp1M2).
assert(HDp1m : rk(D :: p1 ::  nil) >= 1) by (solve_hyps_min HDp1eq HDp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LADp1 *)
(* dans la couche 0 *)
Lemma LADp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: p1 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ep1 requis par la preuve de (?)ADp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADp1 requis par la preuve de (?)ADp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp1 requis par la preuve de (?)ADp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1m2 : rk(A :: D :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HADp1m3 : rk(A :: D :: p1 :: nil) >= 3).
{
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (A :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: E :: p1 :: nil) ((A :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_2 (A :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 2 HADEp1mtmp Hp1mtmp HEp1Mtmp Hincl);apply HT.
}

assert(HADp1M : rk(A :: D :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HADp1eq HADp1M3).
assert(HADp1m : rk(A :: D :: p1 ::  nil) >= 1) by (solve_hyps_min HADp1eq HADp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDp1 *)
(* dans la couche 0 *)
Lemma LABDEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: B :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HABDEp1m4 : rk(A :: B :: D :: E :: p1 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (C :: p1 :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: B :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: B :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HABDEp1M : rk(A :: B :: D :: E :: p1 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABDEp1eq HABDEp1M5).
assert(HABDEp1m : rk(A :: B :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HABDEp1eq HABDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDp1 *)
(* dans la couche 0 *)
Lemma LEp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(E :: p1 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ep1 requis par la preuve de (?)Ep1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HEp1m2 : rk(E :: p1 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (A :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: E :: p1 :: nil) ((A :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 3 HADEp1mtmp Hp1mtmp HADp1Mtmp Hincl); apply HT.
}

assert(HEp1M : rk(E :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HEp1eq HEp1M2).
assert(HEp1m : rk(E :: p1 ::  nil) >= 1) by (solve_hyps_min HEp1eq HEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDp1 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: B :: D :: p1 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABDp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABDp1m2 : rk(A :: B :: D :: p1 :: nil) >= 2).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: A' :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (E :: A' :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: D :: p1 :: nil) ((E :: A' :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: D :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HABDp1m3 : rk(A :: B :: D :: p1 :: nil) >= 3).
{
	assert(HEp1eq : rk(E :: p1 :: nil) = 2) by (apply LEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HABDEp1eq : rk(A :: B :: D :: E :: p1 :: nil) = 4) by (apply LABDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HABDEp1eq HABDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: E :: p1 :: nil) ((A :: B :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_2 (A :: B :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 2 HABDEp1mtmp Hp1mtmp HEp1Mtmp Hincl);apply HT.
}

assert(HABDp1M : rk(A :: B :: D :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABDp1eq HABDp1M4).
assert(HABDp1m : rk(A :: B :: D :: p1 ::  nil) >= 1) by (solve_hyps_min HABDp1eq HABDp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par Lp2p3 *)
(* dans constructLemma(), requis par LAEp2p3p4 *)
(* dans constructLemma(), requis par LADEp2p3p4 *)
(* dans la couche 0 *)
Lemma LAEp2p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: E :: p2 :: p4 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)AEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ABCDEC'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ABCDEA'B'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p4eq HABCDEA'B'p1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABCDED'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p4eq HABCDED'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p4mtmp;try rewrite HT2 in HABCDED'p1p2p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p4m2 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m3 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p4eq HABDEp1p2p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p4mtmp;try rewrite HT2 in HABDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m4 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p4 ::  de rang :  4 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HAEp2p4m2 : rk(A :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p2p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p4eq HADEp1p2p4m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p1 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: D :: p1 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: A :: E :: p2 :: p4 :: nil) ((A :: D :: p1 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p4mtmp;try rewrite HT2 in HADEp1p2p4mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (A :: E :: p2 :: p4 :: nil) (A :: nil) 4 1 3 HADEp1p2p4mtmp HAmtmp HADp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAEp2p4M3 : rk(A :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p4 :: nil) (p2 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 Hp2Mtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAEp2p4M2 : rk(A :: E :: p2 :: p4 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: E :: p4 :: nil) (A :: nil) 1 2 1 HAp2Mtmp HAEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAEp2p4M : rk(A :: E :: p2 :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HAEp2p4eq HAEp2p4M4).
assert(HAEp2p4m : rk(A :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp2p4eq HAEp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ADEp2p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ABCDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ABCDEA'p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p4m5 : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEA'p4mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p4M5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ABCDEC'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p4 requis par la preuve de (?)ABCDEA'B'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p4m2 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p4eq HABCDEA'B'p1p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p4mtmp;try rewrite HT2 in HABCDEA'B'p1p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p4m3 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p4eq HABCDEC'p1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p4mtmp;try rewrite HT2 in HABCDEC'p1p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp1p4M5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: C :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 Hp1Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m4 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p4M5 : rk(A :: C :: D :: E :: A' :: p4 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p4 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p4m4 : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: nil) 5 1 2 HABCDEA'p4mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADEp4M3 : rk(A :: D :: E :: p4 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p4 :: nil) (D :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: E :: p4 :: nil) ((D :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HDMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p4 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp4m2 : rk(A :: D :: E :: p4 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p4mtmp : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4) by (solve_hyps_min HACDEA'p4eq HACDEA'p4m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (C :: A' :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p4 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p4mtmp;try rewrite HT2 in HACDEA'p4mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p4 :: nil) (nil) 4 0 2 HACDEA'p4mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp4m3 : rk(A :: D :: E :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p4mtmp : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p4mtmp;try rewrite HT2 in HACDEp1p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p4 :: nil) (nil) 5 0 2 HACDEp1p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ABCDEC'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ABCDEA'B'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p4eq HABCDEA'B'p1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p2p4 requis par la preuve de (?)ABCDEC'p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp2p4m2 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p2p4eq HABCDEC'p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p2 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p2p4mtmp;try rewrite HT2 in HABCDEC'p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p2p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p4m3 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2p4M4 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: D :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: D :: E :: p4 :: nil) (nil) 1 3 0 Hp2Mtmp HADEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADEp2p4M3 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: D :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: D :: E :: p4 :: nil) (A :: nil) 1 3 1 HAp2Mtmp HADEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour DEp3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)DEp3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ABCDEp1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABCDEC'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p3p4 requis par la preuve de (?)ABCDEA'B'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p3p4m2 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p3p4eq HABCDEA'B'p1p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4m3 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4m4 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4m5 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour DEp3p4 requis par la preuve de (?)DEp3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: C :: p1 ::   de rang : 3 et 3 *)
assert(HDEp3p4m2 : rk(D :: E :: p3 :: p4 :: nil) >= 2).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACp1Mtmp : rk(A :: C :: p1 :: nil) <= 3) by (solve_hyps_max HACp1eq HACp1M3).
	assert(HACDEp1p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p3p4eq HACDEp1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: p1 :: nil) (D :: E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: C :: p1 :: D :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: D :: E :: p3 :: p4 :: nil) ((A :: C :: p1 :: nil) ++ (D :: E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p3p4mtmp;try rewrite HT2 in HACDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: C :: p1 :: nil) (D :: E :: p3 :: p4 :: nil) (nil) 5 0 3 HACDEp1p3p4mtmp Hmtmp HACp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ABCDEC'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ABCDEA'B'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p3p4eq HABCDEA'B'p1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p2p3p4 requis par la preuve de (?)ABCDEC'p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p2p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp2p3p4m2 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p2p3p4eq HABCDEC'p2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p2p3p4mtmp;try rewrite HT2 in HABCDEC'p2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p2p3p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p3p4m3 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p3p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADEp2p3p4M5 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HDEp3p4Mtmp : rk(D :: E :: p3 :: p4 :: nil) <= 4) by (solve_hyps_max HDEp3p4eq HDEp3p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (D :: E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: p2 :: D :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: E :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (D :: E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (D :: E :: p3 :: p4 :: nil) (nil) 1 4 0 HAp2Mtmp HDEp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2p3p4M4 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HADEp2p4Mtmp : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HADEp2p4eq HADEp2p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (p3 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: D :: E :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 1 3 0 Hp3Mtmp HADEp2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp2p3p4M3 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p2 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: E :: p2 :: p4 :: nil) (A :: nil) 2 2 1 HADp3Mtmp HAEp2p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp2p3p4M : rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HADEp2p3p4m : rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp2p3p4eq HADEp2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: E :: p2 :: p3 :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ep3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ABCDEC'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ABCDEA'B'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p3p4eq HABCDEA'B'p1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABCDED'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p3p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p3p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p3p4eq HABCDED'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p3p4mtmp;try rewrite HT2 in HABCDED'p1p2p3p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p3p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p3p4m2 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m3 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p3p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p3p4eq HABDEp1p2p3p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p3p4mtmp;try rewrite HT2 in HABDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HAEp2p3p4m2 : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p2p3p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4eq HADEp1p2p3p4m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p1 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p1 :: A :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: A :: E :: p2 :: p3 :: p4 :: nil) ((A :: D :: p1 :: nil) ++ (A :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4mtmp;try rewrite HT2 in HADEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil) (A :: nil) 4 1 3 HADEp1p2p3p4mtmp HAmtmp HADp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAEp2p3p4M4 : rk(A :: E :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HEp3p4Mtmp : rk(E :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max HEp3p4eq HEp3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (A :: p2 :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: E :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (E :: p3 :: p4 :: nil) (nil) 1 3 0 HAp2Mtmp HEp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HAEp2p3p4M3 : rk(A :: E :: p2 :: p3 :: p4 :: nil) <= 3).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: E :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: E :: p2 :: p4 :: nil) (nil) 1 2 0 Hp3Mtmp HAEp2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p2 :: p3 :: p4 ::  de rang :  3 et 3 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAEp2p3p4m3 : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADEp2p3p4eq : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) = 3) by (apply LADEp2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp2p3p4mtmp : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HADEp2p3p4eq HADEp2p3p4m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p2 :: p3 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp2p3p4mtmp;try rewrite HT2 in HADEp2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil) (A :: p3 :: nil) 3 2 2 HADEp2p3p4mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

assert(HAEp2p3p4M : rk(A :: E :: p2 :: p3 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HAEp2p3p4eq HAEp2p3p4M5).
assert(HAEp2p3p4m : rk(A :: E :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp2p3p4eq HAEp2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp2p3 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(p2 :: p3 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p2p3 requis par la preuve de (?)p2p3 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(Hp2p3m2 : rk(p2 :: p3 :: nil) >= 2).
{
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(HAEp2p3p4eq : rk(A :: E :: p2 :: p3 :: p4 :: nil) = 3) by (apply LAEp2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp2p3p4mtmp : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HAEp2p3p4eq HAEp2p3p4m3).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (p2 :: p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (p2 :: p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: p3 :: A :: E :: p2 :: p4 :: nil) ((p2 :: p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAEp2p3p4mtmp;try rewrite HT2 in HAEp2p3p4mtmp.
	assert(HT := rule_2 (p2 :: p3 :: nil) (A :: E :: p2 :: p4 :: nil) (p2 :: nil) 3 1 2 HAEp2p3p4mtmp Hp2mtmp HAEp2p4Mtmp Hincl);apply HT.
}

assert(Hp2p3M : rk(p2 :: p3 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max Hp2p3eq Hp2p3M2).
assert(Hp2p3m : rk(p2 :: p3 ::  nil) >= 1) by (solve_hyps_min Hp2p3eq Hp2p3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp2p3 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: p2 :: p3 ::  nil) = 2.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ap2p3 requis par la preuve de (?)Ap2p3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ap2p3 requis par la preuve de (?)Ap2p3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAp2p3M2 : rk(A :: p2 :: p3 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p2 :: p3 :: nil) (A :: p2 :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p3 :: nil) ((A :: p2 :: nil) ++ (p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p3 :: nil) (nil) 1 1 0 HAp2Mtmp Hp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp2p3m2 : rk(A :: p2 :: p3 :: nil) >= 2).
{
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p3 :: nil) (A :: p2 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p3 :: nil) (A :: p2 :: p3 :: nil) 2 2 HAp3mtmp Hcomp Hincl);apply HT.
}

assert(HAp2p3M : rk(A :: p2 :: p3 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HAp2p3eq HAp2p3M3).
assert(HAp2p3m : rk(A :: p2 :: p3 ::  nil) >= 1) by (solve_hyps_min HAp2p3eq HAp2p3m1).
intuition.
Qed.

(* dans constructLemma(), requis par LADEp4 *)
(* dans constructLemma(), requis par LACDEp1p4 *)
(* dans constructLemma(), requis par LABCDEp1p4 *)
(* dans la couche 0 *)
Lemma LABCDEp1p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) = 5.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ABCDEA'p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p4m5 : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEA'p4mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p4M5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp1p4M : rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1p4m : rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDEp1p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: C :: D :: E :: p1 :: p4 ::  nil) = 5.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ABCDEA'p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p4m5 : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEA'p4mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ABCDEC'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p4 requis par la preuve de (?)ABCDEA'B'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p4m2 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p4eq HABCDEA'B'p1p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p4mtmp;try rewrite HT2 in HABCDEA'B'p1p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p4m3 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p4eq HABCDEC'p1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p4mtmp;try rewrite HT2 in HABCDEC'p1p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp1p4M5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: C :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 Hp1Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m4 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p4eq : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) = 5) by (apply LABCDEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEp1p4M : rk(A :: C :: D :: E :: p1 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACDEp1p4m : rk(A :: C :: D :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ABCDEA'p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p4m5 : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEA'p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p4M5 : rk(A :: C :: D :: E :: A' :: p4 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p4 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p4m4 : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: nil) 5 1 2 HABCDEA'p4mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADEp4M3 : rk(A :: D :: E :: p4 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p4 :: nil) (D :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: E :: p4 :: nil) ((D :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HDMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p4 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp4m2 : rk(A :: D :: E :: p4 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p4mtmp : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4) by (solve_hyps_min HACDEA'p4eq HACDEA'p4m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (C :: A' :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p4 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p4mtmp;try rewrite HT2 in HACDEA'p4mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p4 :: nil) (nil) 4 0 2 HACDEA'p4mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp4m3 : rk(A :: D :: E :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p4eq : rk(A :: C :: D :: E :: p1 :: p4 :: nil) = 5) by (apply LACDEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACDEp1p4mtmp : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p4mtmp;try rewrite HT2 in HACDEp1p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p4 :: nil) (nil) 5 0 2 HACDEp1p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp4M : rk(A :: D :: E :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HADEp4eq HADEp4M4).
assert(HADEp4m : rk(A :: D :: E :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp4eq HADEp4m1).
intuition.
Qed.

(* dans constructLemma(), requis par LAEp1p4 *)
(* dans la couche 0 *)
Lemma LADEp1p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p1 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp1p4 requis par la preuve de (?)ADEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1p4 requis par la preuve de (?)ADEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ABDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p4 requis par la preuve de (?)ABCDEA'p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p4m5 : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEA'p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p4 requis par la preuve de (?)ACDEA'p4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p4M5 : rk(A :: C :: D :: E :: A' :: p4 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p4 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p4m4 : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p4 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p4 :: nil) (A' :: nil) 5 1 2 HABCDEA'p4mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADEp4M3 : rk(A :: D :: E :: p4 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p4 :: nil) (D :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: E :: p4 :: nil) ((D :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HDMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p4 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp4m2 : rk(A :: D :: E :: p4 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p4mtmp : rk(A :: C :: D :: E :: A' :: p4 :: nil) >= 4) by (solve_hyps_min HACDEA'p4eq HACDEA'p4m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p4 :: nil) (C :: A' :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p4 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p4mtmp;try rewrite HT2 in HACDEA'p4mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p4 :: nil) (nil) 4 0 2 HACDEA'p4mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABDEp1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp4 requis par la preuve de (?)ABDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp4 requis par la preuve de (?)ABDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp4 requis par la preuve de (?)ABDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp4 requis par la preuve de (?)ABEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp4M3 : rk(A :: B :: E :: p4 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p4 :: nil) (B :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: E :: p4 :: nil) ((B :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HBMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp4 requis par la preuve de (?)ABDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp4M4 : rk(A :: B :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABEp4Mtmp : rk(A :: B :: E :: p4 :: nil) <= 3) by (solve_hyps_max HABEp4eq HABEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p4 :: nil) (D :: A :: B :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: E :: p4 :: nil) ((D :: nil) ++ (A :: B :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HABEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp4m3 : rk(A :: B :: D :: E :: p4 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p4mtmp : rk(A :: B :: C :: D :: E :: A' :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'p4eq HABCDEA'p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p4 :: nil) (C :: A' :: A :: B :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p4 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p4mtmp;try rewrite HT2 in HABCDEA'p4mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEA'p4mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p4 requis par la preuve de (?)ABCDED'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p4 requis par la preuve de (?)ABCDEC'p1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ACA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p4 requis par la preuve de (?)ABDEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p4m2 : rk(A :: B :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p4eq HABCDEC'p1p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p4mtmp;try rewrite HT2 in HABCDEC'p1p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p4m3 : rk(A :: B :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p4eq HABCDED'p1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p4mtmp;try rewrite HT2 in HABCDED'p1p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1p4M5 : rk(A :: B :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HABDEp4Mtmp : rk(A :: B :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABDEp4eq HABDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: B :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: B :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: B :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: B :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: B :: D :: E :: p4 :: nil) (nil) 1 4 0 Hp1Mtmp HABDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABDEp1p4M4 : rk(A :: B :: D :: E :: p1 :: p4 :: nil) <= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: D :: E :: p4 :: nil) (A :: nil) 2 3 1 HABp1Mtmp HADEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADEp1p4 requis par la preuve de (?)ADEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp1p4 requis par la preuve de (?)ADEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp1p4 requis par la preuve de (?)ADEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p4m2 : rk(A :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p4eq HABCDEC'p1p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p4mtmp;try rewrite HT2 in HABCDEC'p1p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp1p4M4 : rk(A :: D :: E :: p1 :: p4 :: nil) <= 4).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: D :: E :: p4 :: nil) (nil) 1 3 0 Hp1Mtmp HADEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p4 ::  de rang :  3 et 4 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p4m3 : rk(A :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p4mtmp : rk(A :: B :: D :: E :: p1 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p4eq HABDEp1p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p4mtmp;try rewrite HT2 in HABDEp1p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p4m4 : rk(A :: D :: E :: p1 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p4eq : rk(A :: C :: D :: E :: p1 :: p4 :: nil) = 5) by (apply LACDEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACDEp1p4mtmp : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p4mtmp;try rewrite HT2 in HACDEp1p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp1p4M : rk(A :: D :: E :: p1 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HADEp1p4eq HADEp1p4M5).
assert(HADEp1p4m : rk(A :: D :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp1p4eq HADEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp1p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: E :: p1 :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp1p4 requis par la preuve de (?)AEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AEp1p4 requis par la preuve de (?)AEp1p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AEp1p4 requis par la preuve de (?)AEp1p4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAEp1p4M3 : rk(A :: E :: p1 :: p4 :: nil) <= 3).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p4 :: nil) (p1 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 Hp1Mtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1p4m2 : rk(A :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p4 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HAEp1p4m3 : rk(A :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HADEp1p4eq : rk(A :: D :: E :: p1 :: p4 :: nil) = 4) by (apply LADEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1p4mtmp : rk(A :: D :: E :: p1 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p4eq HADEp1p4m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p4 :: nil) (D :: p1 :: A :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: p4 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p4mtmp;try rewrite HT2 in HADEp1p4mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: E :: p1 :: p4 :: nil) (p1 :: nil) 4 1 2 HADEp1p4mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

assert(HAEp1p4M : rk(A :: E :: p1 :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HAEp1p4eq HAEp1p4M4).
assert(HAEp1p4m : rk(A :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp1p4eq HAEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp2p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p2 :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ABCDEC'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ABCDEA'B'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p4eq HABCDEA'B'p1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p2p4 requis par la preuve de (?)ABCDEC'p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp2p4m2 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p2p4eq HABCDEC'p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p2 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p2 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p2p4mtmp;try rewrite HT2 in HABCDEC'p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p2p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p4m3 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HADEp2p4M4 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HADEp4eq : rk(A :: D :: E :: p4 :: nil) = 3) by (apply LADEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: D :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: D :: E :: p4 :: nil) (nil) 1 3 0 Hp2Mtmp HADEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp2p4M3 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp4eq : rk(A :: D :: E :: p4 :: nil) = 3) by (apply LADEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: D :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: D :: E :: p4 :: nil) (A :: nil) 1 3 1 HAp2Mtmp HADEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp2p4M : rk(A :: D :: E :: p2 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HADEp2p4eq HADEp2p4M5).
assert(HADEp2p4m : rk(A :: D :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp2p4eq HADEp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp1p2p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: E :: p1 :: p2 :: p4 ::  nil) = 3.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AEp1p2p4 requis par la preuve de (?)AEp1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour AEp1p2p4 requis par la preuve de (?)AEp1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)AEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ABCDEC'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ABCDEA'B'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p4eq HABCDEA'B'p1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABCDED'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p4eq HABCDED'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p4mtmp;try rewrite HT2 in HABCDED'p1p2p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p4m2 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m3 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p4eq HABDEp1p2p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p4mtmp;try rewrite HT2 in HABDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m4 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour AEp1p2p4 requis par la preuve de (?)AEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour AEp1p2p4 requis par la preuve de (?)AEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1p2p4m2 : rk(A :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p4 ::  de rang :  4 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HAEp1p2p4m3 : rk(A :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HADEp1p2p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p4eq HADEp1p2p4m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p4 :: nil) (D :: p1 :: A :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: p2 :: p4 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p4mtmp;try rewrite HT2 in HADEp1p2p4mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 4 1 2 HADEp1p2p4mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HAEp1p2p4M4 : rk(A :: E :: p1 :: p2 :: p4 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HAEp1p4eq : rk(A :: E :: p1 :: p4 :: nil) = 3) by (apply LAEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp1p4Mtmp : rk(A :: E :: p1 :: p4 :: nil) <= 3) by (solve_hyps_max HAEp1p4eq HAEp1p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p4 :: nil) (p2 :: A :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: E :: p1 :: p4 :: nil) ((p2 :: nil) ++ (A :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: E :: p1 :: p4 :: nil) (nil) 1 3 0 Hp2Mtmp HAEp1p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HAEp1p2p4M3 : rk(A :: E :: p1 :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAEp1p4eq : rk(A :: E :: p1 :: p4 :: nil) = 3) by (apply LAEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp1p4Mtmp : rk(A :: E :: p1 :: p4 :: nil) <= 3) by (solve_hyps_max HAEp1p4eq HAEp1p4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p4 :: nil) (A :: p2 :: A :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: E :: p1 :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: E :: p1 :: p4 :: nil) (A :: nil) 1 3 1 HAp2Mtmp HAEp1p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAEp1p2p4M : rk(A :: E :: p1 :: p2 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HAEp1p2p4eq HAEp1p2p4M5).
assert(HAEp1p2p4m : rk(A :: E :: p1 :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp1p2p4eq HAEp1p2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp1p2p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p1 :: p2 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p4 requis par la preuve de (?)ABCDEC'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p4 requis par la preuve de (?)ABCDEA'B'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p4eq HABCDEA'B'p1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p4 requis par la preuve de (?)ABCDED'p1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p4eq HABCDED'p1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p4mtmp;try rewrite HT2 in HABCDED'p1p2p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p4m2 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p4eq HABCDEC'p1p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p4mtmp;try rewrite HT2 in HABCDEC'p1p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m3 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p4eq HABDEp1p2p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p4mtmp;try rewrite HT2 in HABDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m4 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HADEp1p2p4M5 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) <= 5).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HADEp1p4eq : rk(A :: D :: E :: p1 :: p4 :: nil) = 4) by (apply LADEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1p4Mtmp : rk(A :: D :: E :: p1 :: p4 :: nil) <= 4) by (solve_hyps_max HADEp1p4eq HADEp1p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p4 :: nil) (p2 :: A :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: D :: E :: p1 :: p4 :: nil) ((p2 :: nil) ++ (A :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: D :: E :: p1 :: p4 :: nil) (nil) 1 4 0 Hp2Mtmp HADEp1p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp1p2p4M4 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp1p4eq : rk(A :: D :: E :: p1 :: p4 :: nil) = 4) by (apply LADEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1p4Mtmp : rk(A :: D :: E :: p1 :: p4 :: nil) <= 4) by (solve_hyps_max HADEp1p4eq HADEp1p4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p2 :: A :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: D :: E :: p1 :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: D :: E :: p1 :: p4 :: nil) (A :: nil) 1 4 1 HAp2Mtmp HADEp1p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp1p2p4M : rk(A :: D :: E :: p1 :: p2 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HADEp1p2p4m : rk(A :: D :: E :: p1 :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp1p2p4eq HADEp1p2p4m1).
intuition.
Qed.

(* dans constructLemma(), requis par LAp1p2p3p4 *)
(* dans constructLemma(), requis par LAEp1p2p3p4 *)
(* dans la couche 0 *)
Lemma LADEp1p2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ABCDEC'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ABCDEA'B'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p3p4eq HABCDEA'B'p1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABCDED'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p3p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p3p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p3p4eq HABCDED'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p3p4mtmp;try rewrite HT2 in HABCDED'p1p2p3p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p3p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p3p4m2 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m3 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p3p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p3p4eq HABDEp1p2p3p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p3p4mtmp;try rewrite HT2 in HABDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HADEp1p2p3p4M5 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HADEp1p2p4eq : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) = 4) by (apply LADEp1p2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1p2p4Mtmp : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) <= 4) by (solve_hyps_max HADEp1p2p4eq HADEp1p2p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p3 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 1 4 0 Hp3Mtmp HADEp1p2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp1p2p3p4M4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAEp1p2p4eq : rk(A :: E :: p1 :: p2 :: p4 :: nil) = 3) by (apply LAEp1p2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp1p2p4Mtmp : rk(A :: E :: p1 :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HAEp1p2p4eq HAEp1p2p4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p1 :: p2 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil) (A :: nil) 2 3 1 HADp3Mtmp HAEp1p2p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp1p2p3p4M : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HADEp1p2p3p4m : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp1p2p3p4eq HADEp1p2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp1p2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: E :: p1 :: p2 :: p3 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour AEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ep1p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p3p4 requis par la preuve de (?)Ep1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ABCDEp1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABCDEC'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC' requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p3p4 requis par la preuve de (?)ABCDEA'B'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p2 requis par la preuve de (?)ABCDEA'p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p2m5 : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BA' requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'p2 requis par la preuve de (?)ACDEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEA'p2M5 : rk(A :: C :: D :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: C :: D :: E :: p2 :: nil) ((A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEA'p2m4 : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: A' :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HACDEA'p2mtmp : rk(A :: C :: D :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HACDEA'p2eq HACDEA'p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: p2 :: nil) (C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: D :: E :: p2 :: nil) ((C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'p2mtmp;try rewrite HT2 in HACDEA'p2mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEA'p2mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCA' requis par la preuve de (?)ABCA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCA'm2 : rk(A :: B :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCA'm3 : rk(A :: B :: C :: A' :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: A' :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: A' :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEA'p2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABA' requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: A' ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBA'Mtmp : rk(B :: A' :: nil) <= 2) by (solve_hyps_max HBA'eq HBA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A' :: A :: C :: D :: E :: p2 :: nil) ((B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEA'p2mtmp Hmtmp HBA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABA' requis par la preuve de (?)ABA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABA'm2 : rk(A :: B :: A' :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A' :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: A' :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: A' :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEA'p2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p2 requis par la preuve de (?)ABCEA'p2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p2M5 : rk(A :: B :: C :: E :: A' :: p2 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p2 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m2 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 2).
{
	assert(HABA'mtmp : rk(A :: B :: A' :: nil) >= 2) by (solve_hyps_min HABA'eq HABA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 2 2 HABA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p2m3 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 3).
{
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) 3 3 HABCA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p2 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p2m4 : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p2mtmp : rk(A :: B :: C :: D :: E :: A' :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEA'p2eq HABCDEA'p2m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p2 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p2 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p2mtmp;try rewrite HT2 in HABCDEA'p2mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p2 :: nil) (A' :: nil) 5 1 2 HABCDEA'p2mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA' requis par la preuve de (?)ABCEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEA'm2 : rk(A :: B :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCEA'B'C'D'E'mtmp HABCA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEA'm3 : rk(A :: B :: C :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HABCA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEA'm4 : rk(A :: B :: C :: E :: A' :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEA'p2mtmp : rk(A :: B :: C :: E :: A' :: p2 :: nil) >= 4) by (solve_hyps_min HABCEA'p2eq HABCEA'p2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p2 :: nil) (A :: B :: C :: E :: A' :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: A' :: A :: p2 :: nil) ((A :: B :: C :: E :: A' :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p2mtmp;try rewrite HT2 in HABCEA'p2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: A' :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEA'p2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B' requis par la preuve de (?)ABCEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCEA'B'm3 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCEA'mtmp : rk(A :: B :: C :: E :: A' :: nil) >= 4) by (solve_hyps_min HABCEA'eq HABCEA'm4).
	assert(Hincl : incl (A :: B :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (A :: B :: C :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HABCEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HABCEA'B'm4 : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: B :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: B :: C :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCA'B' requis par la preuve de (?)ABCA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: B :: C :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HABCA'B'm2 : rk(A :: B :: C :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HABCA'mtmp : rk(A :: B :: C :: A' :: nil) >= 3) by (solve_hyps_min HABCA'eq HABCA'm3).
	assert(Hincl : incl (A :: B :: C :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: nil) (A :: B :: C :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HABCA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HABCA'B'm3 : rk(A :: B :: C :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HABCEA'B'mtmp : rk(A :: B :: C :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HABCEA'B'eq HABCEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: nil) (E :: B' :: A :: B :: C :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: B :: C :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: B :: C :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'mtmp;try rewrite HT2 in HABCEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: B :: C :: A' :: B' :: nil) (B' :: nil) 4 1 2 HABCEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p3p4m2 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p3p4eq HABCDEA'B'p1p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4m3 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4m4 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4m5 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p3p4 requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p3p4 requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p3p4 requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p3p4 requis par la preuve de (?)ABCDED'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p3p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD' requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p3p4 requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p3p4 requis par la preuve de (?)ABDEp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p3p4m2 : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p3p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p3p4m3 : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p3p4eq HABCDED'p1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p3 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p3p4mtmp;try rewrite HT2 in HABCDED'p1p3p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p3p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p3p4 requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCEC' requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCC' requis par la preuve de (?)BCC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCC'm2 : rk(B :: C :: C' :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: C' :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: C' :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDEC'p1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEC' requis par la preuve de (?)BCEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : B :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HBCEC'm2 : rk(B :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HBCC'mtmp : rk(B :: C :: C' :: nil) >= 2) by (solve_hyps_min HBCC'eq HBCC'm2).
	assert(Hincl : incl (B :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: B :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (B :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (B :: C :: E :: C' :: nil) (B :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HBCC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCEC'm3 : rk(B :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (B :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: B :: p1 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (B :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCEC'p1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p3p4 requis par la preuve de (?)ADEp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p3p4m2 : rk(A :: D :: E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p3p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p3 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p3p4m3 : rk(A :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p3p4mtmp : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p3p4eq HABDEp1p3p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p3p4mtmp;try rewrite HT2 in HABDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p3p4m4 : rk(A :: D :: E :: p1 :: p3 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p3p4eq HACDEp1p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p3p4mtmp;try rewrite HT2 in HACDEp1p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p3p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Ep1p3p4 requis par la preuve de (?)Ep1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p3 :: p4 ::  de rang :  4 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HEp1p3p4m2 : rk(E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p3p4mtmp : rk(A :: D :: E :: p1 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p3p4eq HADEp1p3p4m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: D :: p1 :: nil) (E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: D :: p1 :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: E :: p1 :: p3 :: p4 :: nil) ((A :: D :: p1 :: nil) ++ (E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p3p4mtmp;try rewrite HT2 in HADEp1p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (E :: p1 :: p3 :: p4 :: nil) (p1 :: nil) 4 1 3 HADEp1p3p4mtmp Hp1mtmp HADp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour AEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p2p3p4 requis par la preuve de (?)ABCDEC'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'p1p2p3p4 requis par la preuve de (?)ABCDEA'B'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: A' :: B' ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCA'B'Mtmp : rk(A :: B :: C :: A' :: B' :: nil) <= 5) by (solve_hyps_max HABCA'B'eq HABCA'B'M5).
	assert(HABCDEA'B'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'p1p2p3p4eq HABCDEA'B'p1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A' :: B' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: A' :: B' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'p1p2p3p4mtmp;try rewrite HT2 in HABCDEA'B'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: A' :: B' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'p1p2p3p4mtmp HACmtmp HABCA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: C' ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBC'Mtmp : rk(B :: C' :: nil) <= 2) by (solve_hyps_max HBC'eq HBC'M2).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C' :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C' :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C' :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEC'p1p2p3p4mtmp Hmtmp HBC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDED'p1p2p3p4 requis par la preuve de (?)ABCDED'p1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDED'p1p2p3p4m5 : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDEp1p2p3p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HAEmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: D' ::   de rang : 1 et 2 *)
assert(HABDEp1p2p3p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCD'Mtmp : rk(C :: D' :: nil) <= 2) by (solve_hyps_max HCD'eq HCD'M2).
	assert(HABCDED'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDED'p1p2p3p4eq HABCDED'p1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: D' :: p1 :: p2 :: p3 :: p4 :: nil) (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D' :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: D' :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDED'p1p2p3p4mtmp;try rewrite HT2 in HABCDED'p1p2p3p4mtmp.
	assert(HT := rule_4 (C :: D' :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDED'p1p2p3p4mtmp Hmtmp HCD'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HADEp1p2p3p4m2 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCEC'Mtmp : rk(B :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HBCEC'eq HBCEC'M4).
	assert(HABCDEC'p1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p2p3p4eq HABCDEC'p1p2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: C' :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: C' :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p2p3p4mtmp;try rewrite HT2 in HABCDEC'p1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: C' :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDEC'p1p2p3p4mtmp HEmtmp HBCEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m3 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p3p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p3p4eq HABDEp1p2p3p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p3p4mtmp;try rewrite HT2 in HABDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour AEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour AEp1p2p3p4 requis par la preuve de (?)AEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1p2p3p4m2 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HAEp1p2p3p4m3 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HADEp1p2p3p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4eq HADEp1p2p3p4m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (D :: p1 :: A :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4mtmp;try rewrite HT2 in HADEp1p2p3p4mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 4 1 2 HADEp1p2p3p4mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAEp1p2p3p4M5 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HEp1p3p4Mtmp : rk(E :: p1 :: p3 :: p4 :: nil) <= 4) by (solve_hyps_max HEp1p3p4eq HEp1p3p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: E :: p1 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (E :: p1 :: p3 :: p4 :: nil) (nil) 1 4 0 HAp2Mtmp HEp1p3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HAEp1p2p3p4M4 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HAEp1p2p4eq : rk(A :: E :: p1 :: p2 :: p4 :: nil) = 3) by (apply LAEp1p2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp1p2p4Mtmp : rk(A :: E :: p1 :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HAEp1p2p4eq HAEp1p2p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p3 :: A :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: E :: p1 :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: E :: p1 :: p2 :: p4 :: nil) (nil) 1 3 0 Hp3Mtmp HAEp1p2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 4 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAEp1p2p3p4m4 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADEp1p2p3p4eq : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) = 4) by (apply LADEp1p2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADEp1p2p3p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4eq HADEp1p2p3p4m4).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4mtmp;try rewrite HT2 in HADEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p3 :: nil) 4 2 2 HADEp1p2p3p4mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

assert(HAEp1p2p3p4M : rk(A :: E :: p1 :: p2 :: p3 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HAEp1p2p3p4m : rk(A :: E :: p1 :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp1p2p3p4eq HAEp1p2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp1p2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(A :: p1 :: p2 :: p3 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADp1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Ap1p2p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p1p4 requis par la preuve de (?)Ap1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p4 requis par la preuve de (?)Ap1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Ap1p2p4 requis par la preuve de (?)Ap1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p4m2 : rk(A :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p4M3 : rk(A :: p1 :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p4Mtmp : rk(p1 :: p4 :: nil) <= 2) by (solve_hyps_max Hp1p4eq Hp1p4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p4 :: nil) (A :: p2 :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p4 :: nil) (nil) 1 2 0 HAp2Mtmp Hp1p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Dp1p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABDp1p3p4 requis par la preuve de (?)Dp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Dp3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABCDEC'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ACA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDp1p3p4m2 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: p1 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: nil) 5 1 4 HABCDEC'p1p3p4mtmp HAmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABDp1p3p4M5 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HDp3p4Mtmp : rk(D :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max HDp3p4eq HDp3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: p1 :: nil) (D :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: D :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (D :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (D :: p3 :: p4 :: nil) (nil) 2 3 0 HABp1Mtmp HDp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDp1p3p4m3 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Dp1p3p4 requis par la preuve de (?)Dp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: D :: p1 :: p3 :: p4 ::  de rang :  3 et 5 	 AiB : D :: p1 ::  de rang :  2 et 2 	 A : A :: B :: D :: p1 ::   de rang : 3 et 3 *)
assert(HDp1p3p4m2 : rk(D :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABDp1eq : rk(A :: B :: D :: p1 :: nil) = 3) by (apply LABDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(HABDp1p3p4mtmp : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDp1p3p4eq HABDp1p3p4m3).
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDp1mtmp : rk(D :: p1 :: nil) >= 2) by (solve_hyps_min HDp1eq HDp1m2).
	assert(Hincl : incl (D :: p1 :: nil) (list_inter (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: B :: D :: p1 :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: D :: p1 :: p3 :: p4 :: nil) ((A :: B :: D :: p1 :: nil) ++ (D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDp1p3p4mtmp;try rewrite HT2 in HABDp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p4 :: nil) (D :: p1 :: nil) 3 2 3 HABDp1p3p4mtmp HDp1mtmp HABDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1p2p3p4m2 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADp1p2p3p4m3 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADp1p2p3p4M5 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HDp1p3p4Mtmp : rk(D :: p1 :: p3 :: p4 :: nil) <= 4) by (solve_hyps_max HDp1p3p4eq HDp1p3p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: p1 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (D :: p1 :: p3 :: p4 :: nil) (nil) 1 4 0 HAp2Mtmp HDp1p3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADp1p2p3p4M4 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAp1p2p4Mtmp : rk(A :: p1 :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HAp1p2p4eq HAp1p2p4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: nil) (A :: nil) 2 3 1 HADp3Mtmp HAp1p2p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour p1p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p3p4m2 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p3p4M4 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p3p4Mtmp : rk(p1 :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max Hp1p3p4eq Hp1p3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p3 :: p4 :: nil) (nil) 1 3 0 HAp2Mtmp Hp1p3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 4 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p4m3 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADp1p2p3p4mtmp : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HADp1p2p3p4eq HADp1p2p3p4m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADp1p2p3p4mtmp;try rewrite HT2 in HADp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p3 :: nil) 3 2 2 HADp1p2p3p4mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 4 	 AiB : A :: p4 ::  de rang :  2 et 2 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p4m4 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAEp1p2p3p4eq : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) = 4) by (apply LAEp1p2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAEp1p2p3p4mtmp : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HAEp1p2p3p4eq HAEp1p2p3p4m4).
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hincl : incl (A :: p4 :: nil) (list_inter (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: E :: p4 :: nil) ++ (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAEp1p2p3p4mtmp;try rewrite HT2 in HAEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p4 :: nil) 4 2 2 HAEp1p2p3p4mtmp HAp4mtmp HAEp4Mtmp Hincl); apply HT.
}

assert(HAp1p2p3p4M : rk(A :: p1 :: p2 :: p3 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HAp1p2p3p4eq HAp1p2p3p4M5).
assert(HAp1p2p3p4m : rk(A :: p1 :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HAp1p2p3p4eq HAp1p2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp1p2p3p4 : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> rk(p1 :: p2 :: p3 :: p4 ::  nil) = 4.
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour p1p2p3p4 requis par la preuve de (?)p1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Ap1p2p3p4 requis par la preuve de (?)p1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADp1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Ap1p2p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p1p4 requis par la preuve de (?)Ap1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p4 requis par la preuve de (?)Ap1p2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Ap1p2p4 requis par la preuve de (?)Ap1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p4m2 : rk(A :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p4M3 : rk(A :: p1 :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p4Mtmp : rk(p1 :: p4 :: nil) <= 2) by (solve_hyps_max Hp1p4eq Hp1p4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p4 :: nil) (A :: p2 :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p4 :: nil) (nil) 1 2 0 HAp2Mtmp Hp1p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Dp1p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABDp1p3p4 requis par la preuve de (?)Dp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Dp3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1p3p4 requis par la preuve de (?)ABCDEC'p1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1p3p4m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEC' requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC'p1 requis par la preuve de (?)ABCDEC'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'p1m5 : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DC' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'p1 requis par la preuve de (?)ABCDEA'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'p1m5 : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DA' requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C'p1 requis par la preuve de (?)ABCDEA'B'C'p1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'p1m5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B' requis par la preuve de (?)ABCDEA'B' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BB' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CA' requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEA'p1 requis par la preuve de (?)ABDEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEA'p1M5 : rk(A :: B :: D :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: D :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : C :: A' ::   de rang : 1 et 2 *)
assert(HABDEA'p1m4 : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HCA'Mtmp : rk(C :: A' :: nil) <= 2) by (solve_hyps_max HCA'eq HCA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A' :: A :: B :: D :: E :: A' :: p1 :: nil) ((C :: A' :: nil) ++ (A :: B :: D :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (C :: A' :: nil) (A :: B :: D :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HCA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: A' :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABDEA'p1mtmp : rk(A :: B :: D :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABDEA'p1eq HABDEA'p1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: E :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEA'p1mtmp;try rewrite HT2 in HABDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEA'p1mtmp Hmtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ACA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEB'C'D'E' requis par la preuve de (?)ABCDEB'C'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEB'C'D'E'm5 : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACA' requis par la preuve de (?)ACA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACA'm2 : rk(A :: C :: A' :: nil) >= 2).
{
	assert(HABCDEB'C'D'E'Mtmp : rk(A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEB'C'D'E'eq HABCDEB'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A' :: A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) ((A :: C :: A' :: nil) ++ (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: A' :: nil) (A :: B :: C :: D :: E :: B' :: C' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEB'C'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'B'C'D'E' requis par la preuve de (?)ABCEA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEA'B'C'D'E'm2 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'B'C'D'E'm5 : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDA' requis par la preuve de (?)ACDA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDA'm2 : rk(A :: C :: D :: A' :: nil) >= 2).
{
	assert(HABCEA'B'C'D'E'Mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCEA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDA'm3 : rk(A :: C :: D :: A' :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: A' :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: A' :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEA'p1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EA' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDA'B'C'D'E' requis par la preuve de (?)ABCDA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDA'B'C'D'E'm2 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEA'B'C'D'E'mtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCDA'B'C'D'E'm5 : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) >= 5).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 6 1 2 HABCDEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCA'B'C'D'E' requis par la preuve de (?)ABCA'B'C'D'E' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCA'B'C'D'E'm3 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEA'B'C'D'E'mtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : E :: A' ::   de rang : 1 et 2 *)
assert(HABCA'B'C'D'E'm4 : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) >= 4).
{
	assert(HEA'Mtmp : rk(E :: A' :: nil) <= 2) by (solve_hyps_max HEA'eq HEA'M2).
	assert(HABCEA'B'C'D'E'mtmp : rk(A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 5) by (solve_hyps_min HABCEA'B'C'D'E'eq HABCEA'B'C'D'E'm5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: B' :: C' :: D' :: E' :: nil) (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'B'C'D'E'mtmp;try rewrite HT2 in HABCEA'B'C'D'E'mtmp.
	assert(HT := rule_4 (E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A' :: nil) 5 1 2 HABCEA'B'C'D'E'mtmp HA'mtmp HEA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEA' requis par la preuve de (?)ACDEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm2 : rk(A :: C :: D :: E :: A' :: nil) >= 2).
{
	assert(HABCA'B'C'D'E'Mtmp : rk(A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCA'B'C'D'E'eq HABCA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEA'm3 : rk(A :: C :: D :: E :: A' :: nil) >= 3).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: D :: A' :: nil) 6 3 6 HABCDEA'B'C'D'E'mtmp HACDA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEA'm4 : rk(A :: C :: D :: E :: A' :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA' requis par la preuve de (?)ABCDEA' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'm5 : rk(A :: B :: C :: D :: E :: A' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEA'B' requis par la preuve de (?)ACDEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: A' ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDEA'B'm3 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 3).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDEA'mtmp : rk(A :: C :: D :: E :: A' :: nil) >= 4) by (solve_hyps_min HACDEA'eq HACDEA'm4).
	assert(Hincl : incl (A :: C :: D :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (A :: C :: D :: E :: A' :: nil) 5 4 6 HABCDEA'B'mtmp HACDEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : B :: B' ::   de rang : 1 et 2 *)
assert(HACDEA'B'm4 : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4).
{
	assert(HBB'Mtmp : rk(B :: B' :: nil) <= 2) by (solve_hyps_max HBB'eq HBB'M2).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: B' :: A :: C :: D :: E :: A' :: B' :: nil) ((B :: B' :: nil) ++ (A :: C :: D :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (B :: B' :: nil) (A :: C :: D :: E :: A' :: B' :: nil) (B' :: nil) 5 1 2 HABCDEA'B'mtmp HB'mtmp HBB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EB' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDA'B' requis par la preuve de (?)ACDA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: D :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACDA'B'm2 : rk(A :: C :: D :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACDA'mtmp : rk(A :: C :: D :: A' :: nil) >= 3) by (solve_hyps_min HACDA'eq HACDA'm3).
	assert(Hincl : incl (A :: C :: D :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: D :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: D :: A' :: B' :: nil) (A :: C :: D :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACDA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : E :: B' ::   de rang : 1 et 2 *)
assert(HACDA'B'm3 : rk(A :: C :: D :: A' :: B' :: nil) >= 3).
{
	assert(HEB'Mtmp : rk(E :: B' :: nil) <= 2) by (solve_hyps_max HEB'eq HEB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (E :: B' :: A :: C :: D :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B' :: A :: C :: D :: A' :: B' :: nil) ((E :: B' :: nil) ++ (A :: C :: D :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (E :: B' :: nil) (A :: C :: D :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HEB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEC'p1 requis par la preuve de (?)ABCEC'p1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCEC'p1m2 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 2).
{
	assert(HACDA'B'Mtmp : rk(A :: C :: D :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACDA'B'eq HACDA'B'M5).
	assert(HABCDEA'B'C'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'p1eq HABCDEA'B'C'p1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: p1 :: nil) (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: A' :: B' :: A :: B :: C :: E :: C' :: p1 :: nil) ((A :: C :: D :: A' :: B' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'p1mtmp;try rewrite HT2 in HABCDEA'B'C'p1mtmp.
	assert(HT := rule_4 (A :: C :: D :: A' :: B' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'p1mtmp HACmtmp HACDA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEC'p1M5 : rk(A :: B :: C :: E :: C' :: p1 :: nil) <= 5).
{
	assert(HC'Mtmp : rk(C' :: nil) <= 1) by (solve_hyps_max HC'eq HC'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C' :: A :: B :: C :: E :: p1 :: nil) ((C' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HC'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 ::  de rang :  5 et 6 	 AiB : C' ::  de rang :  1 et 1 	 A : D :: C' ::   de rang : 1 et 2 *)
assert(HABCEC'p1m4 : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4).
{
	assert(HDC'Mtmp : rk(D :: C' :: nil) <= 2) by (solve_hyps_max HDC'eq HDC'M2).
	assert(HABCDEC'p1mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1eq HABCDEC'p1m5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: nil) (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: C' :: A :: B :: C :: E :: C' :: p1 :: nil) ((D :: C' :: nil) ++ (A :: B :: C :: E :: C' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1mtmp;try rewrite HT2 in HABCDEC'p1mtmp.
	assert(HT := rule_4 (D :: C' :: nil) (A :: B :: C :: E :: C' :: p1 :: nil) (C' :: nil) 5 1 2 HABCDEC'p1mtmp HC'mtmp HDC'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEC' requis par la preuve de (?)ABCDEC' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEC'm5 : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ACC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'D'E' requis par la preuve de (?)ABCDEA'B'D'E' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'D'E'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACC' requis par la preuve de (?)ACC' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACC'm2 : rk(A :: C :: C' :: nil) >= 2).
{
	assert(HABCDEA'B'D'E'Mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDEA'B'D'E'eq HABCDEA'B'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: C' :: A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) ((A :: C :: C' :: nil) ++ (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: C' :: nil) (A :: B :: C :: D :: E :: A' :: B' :: D' :: E' :: nil) (A :: C :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACmtmp HABCDEA'B'D'E'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEA'B'C' requis par la preuve de (?)ABCDEA'B'C' pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEA'B'C'm5 : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DB' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEA'p1 requis par la preuve de (?)ABCEA'p1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEA'p1M5 : rk(A :: B :: C :: E :: A' :: p1 :: nil) <= 5).
{
	assert(HA'Mtmp : rk(A' :: nil) <= 1) by (solve_hyps_max HA'eq HA'M1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A' :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A' :: A :: B :: C :: E :: p1 :: nil) ((A' :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A' :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HA'Mtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEA'p1m2 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 2).
{
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) 2 2 HACA'mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: p1 ::  de rang :  5 et 6 	 AiB : A' ::  de rang :  1 et 1 	 A : D :: A' ::   de rang : 1 et 2 *)
assert(HABCEA'p1m4 : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4).
{
	assert(HDA'Mtmp : rk(D :: A' :: nil) <= 2) by (solve_hyps_max HDA'eq HDA'M2).
	assert(HABCDEA'p1mtmp : rk(A :: B :: C :: D :: E :: A' :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEA'p1eq HABCDEA'p1m5).
	assert(HA'mtmp : rk(A' :: nil) >= 1) by (solve_hyps_min HA'eq HA'm1).
	assert(Hincl : incl (A' :: nil) (list_inter (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: p1 :: nil) (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A' :: A :: B :: C :: E :: A' :: p1 :: nil) ((D :: A' :: nil) ++ (A :: B :: C :: E :: A' :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'p1mtmp;try rewrite HT2 in HABCDEA'p1mtmp.
	assert(HT := rule_4 (D :: A' :: nil) (A :: B :: C :: E :: A' :: p1 :: nil) (A' :: nil) 5 1 2 HABCDEA'p1mtmp HA'mtmp HDA'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEA' requis par la preuve de (?)ACEA' pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEA'm2 : rk(A :: C :: E :: A' :: nil) >= 2).
{
	assert(HABCDA'B'C'D'E'Mtmp : rk(A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) <= 6) by (solve_hyps_max HABCDA'B'C'D'E'eq HABCDA'B'C'D'E'M6).
	assert(HABCDEA'B'C'D'E'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) >= 6) by (solve_hyps_min HABCDEA'B'C'D'E'eq HABCDEA'B'C'D'E'm6).
	assert(HACA'mtmp : rk(A :: C :: A' :: nil) >= 2) by (solve_hyps_min HACA'eq HACA'm2).
	assert(Hincl : incl (A :: C :: A' :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'D'E'mtmp;try rewrite HT2 in HABCDEA'B'C'D'E'mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: C :: D :: A' :: B' :: C' :: D' :: E' :: nil) (A :: C :: A' :: nil) 6 2 6 HABCDEA'B'C'D'E'mtmp HACA'mtmp HABCDA'B'C'D'E'Mtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEA'm3 : rk(A :: C :: E :: A' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEA'p1mtmp : rk(A :: B :: C :: E :: A' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEA'p1eq HABCEA'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: A' :: p1 :: nil) (A :: C :: E :: A' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: A :: B :: p1 :: nil) ((A :: C :: E :: A' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEA'p1mtmp;try rewrite HT2 in HABCEA'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: A' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEA'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEA'B' requis par la preuve de (?)ACEA'B' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' ::  de rang :  5 et 6 	 AiB : A :: C :: E :: A' ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: A' ::   de rang : 5 et 6 *)
assert(HACEA'B'm2 : rk(A :: C :: E :: A' :: B' :: nil) >= 2).
{
	assert(HABCDEA'Mtmp : rk(A :: B :: C :: D :: E :: A' :: nil) <= 6) by (solve_hyps_max HABCDEA'eq HABCDEA'M6).
	assert(HABCDEA'B'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'eq HABCDEA'B'm5).
	assert(HACEA'mtmp : rk(A :: C :: E :: A' :: nil) >= 3) by (solve_hyps_min HACEA'eq HACEA'm3).
	assert(Hincl : incl (A :: C :: E :: A' :: nil) (list_inter (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: nil) (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A' :: A :: C :: E :: A' :: B' :: nil) ((A :: B :: C :: D :: E :: A' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'mtmp;try rewrite HT2 in HABCDEA'B'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: A' :: nil) (A :: C :: E :: A' :: B' :: nil) (A :: C :: E :: A' :: nil) 5 3 6 HABCDEA'B'mtmp HACEA'mtmp HABCDEA'Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: A' :: B' ::  de rang :  4 et 6 	 AiB : B' ::  de rang :  1 et 1 	 A : D :: B' ::   de rang : 1 et 2 *)
assert(HACEA'B'm3 : rk(A :: C :: E :: A' :: B' :: nil) >= 3).
{
	assert(HDB'Mtmp : rk(D :: B' :: nil) <= 2) by (solve_hyps_max HDB'eq HDB'M2).
	assert(HACDEA'B'mtmp : rk(A :: C :: D :: E :: A' :: B' :: nil) >= 4) by (solve_hyps_min HACDEA'B'eq HACDEA'B'm4).
	assert(HB'mtmp : rk(B' :: nil) >= 1) by (solve_hyps_min HB'eq HB'm1).
	assert(Hincl : incl (B' :: nil) (list_inter (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: A' :: B' :: nil) (D :: B' :: A :: C :: E :: A' :: B' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B' :: A :: C :: E :: A' :: B' :: nil) ((D :: B' :: nil) ++ (A :: C :: E :: A' :: B' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEA'B'mtmp;try rewrite HT2 in HACDEA'B'mtmp.
	assert(HT := rule_4 (D :: B' :: nil) (A :: C :: E :: A' :: B' :: nil) (B' :: nil) 4 1 2 HACDEA'B'mtmp HB'mtmp HDB'Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDC' requis par la preuve de (?)ABCDC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: A' :: B' :: C' ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: A' :: B' ::   de rang : 3 et 5 *)
assert(HABCDC'm2 : rk(A :: B :: C :: D :: C' :: nil) >= 2).
{
	assert(HACEA'B'Mtmp : rk(A :: C :: E :: A' :: B' :: nil) <= 5) by (solve_hyps_max HACEA'B'eq HACEA'B'M5).
	assert(HABCDEA'B'C'mtmp : rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) >= 5) by (solve_hyps_min HABCDEA'B'C'eq HABCDEA'B'C'm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: A' :: B' :: C' :: nil) (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: A' :: B' :: A :: B :: C :: D :: C' :: nil) ((A :: C :: E :: A' :: B' :: nil) ++ (A :: B :: C :: D :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEA'B'C'mtmp;try rewrite HT2 in HABCDEA'B'C'mtmp.
	assert(HT := rule_4 (A :: C :: E :: A' :: B' :: nil) (A :: B :: C :: D :: C' :: nil) (A :: C :: nil) 5 2 5 HABCDEA'B'C'mtmp HACmtmp HACEA'B'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDC'm4 : rk(A :: B :: C :: D :: C' :: nil) >= 4).
{
	assert(HEC'Mtmp : rk(E :: C' :: nil) <= 2) by (solve_hyps_max HEC'eq HEC'M2).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HC'mtmp : rk(C' :: nil) >= 1) by (solve_hyps_min HC'eq HC'm1).
	assert(Hincl : incl (C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: C' :: nil) (E :: C' :: nil) (C' :: nil) 5 1 2 HABCDEC'mtmp HC'mtmp HEC'Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEC' requis par la preuve de (?)ACEC' pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' ::  de rang :  5 et 6 	 AiB : A :: C :: C' ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: C' ::   de rang : 4 et 5 *)
assert(HACEC'm2 : rk(A :: C :: E :: C' :: nil) >= 2).
{
	assert(HABCDC'Mtmp : rk(A :: B :: C :: D :: C' :: nil) <= 5) by (solve_hyps_max HABCDC'eq HABCDC'M5).
	assert(HABCDEC'mtmp : rk(A :: B :: C :: D :: E :: C' :: nil) >= 5) by (solve_hyps_min HABCDEC'eq HABCDEC'm5).
	assert(HACC'mtmp : rk(A :: C :: C' :: nil) >= 2) by (solve_hyps_min HACC'eq HACC'm2).
	assert(Hincl : incl (A :: C :: C' :: nil) (list_inter (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: nil) (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: C' :: A :: C :: E :: C' :: nil) ((A :: B :: C :: D :: C' :: nil) ++ (A :: C :: E :: C' :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'mtmp;try rewrite HT2 in HABCDEC'mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: C' :: nil) (A :: C :: E :: C' :: nil) (A :: C :: C' :: nil) 5 2 5 HABCDEC'mtmp HACC'mtmp HABCDC'Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEC'm3 : rk(A :: C :: E :: C' :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEC'p1mtmp : rk(A :: B :: C :: E :: C' :: p1 :: nil) >= 4) by (solve_hyps_min HABCEC'p1eq HABCEC'p1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: C' :: p1 :: nil) (A :: C :: E :: C' :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: p1 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEC'p1mtmp;try rewrite HT2 in HABCEC'p1mtmp.
	assert(HT := rule_2 (A :: C :: E :: C' :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEC'p1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDp1p3p4 requis par la preuve de (?)ABDp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C :: E :: C' ::   de rang : 3 et 4 *)
assert(HABDp1p3p4m2 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACEC'Mtmp : rk(A :: C :: E :: C' :: nil) <= 4) by (solve_hyps_max HACEC'eq HACEC'M4).
	assert(HABCDEC'p1p3p4mtmp : rk(A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEC'p1p3p4eq HABCDEC'p1p3p4m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: C' :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: C' :: p1 :: p3 :: p4 :: nil) (A :: C :: E :: C' :: A :: B :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: C' :: A :: B :: D :: p1 :: p3 :: p4 :: nil) ((A :: C :: E :: C' :: nil) ++ (A :: B :: D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEC'p1p3p4mtmp;try rewrite HT2 in HABCDEC'p1p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: C' :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: nil) 5 1 4 HABCDEC'p1p3p4mtmp HAmtmp HACEC'Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABDp1p3p4M5 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HDp3p4Mtmp : rk(D :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max HDp3p4eq HDp3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: p1 :: nil) (D :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: D :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (D :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (D :: p3 :: p4 :: nil) (nil) 2 3 0 HABp1Mtmp HDp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDp1p3p4m3 : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p4 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Dp1p3p4 requis par la preuve de (?)Dp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: D :: p1 :: p3 :: p4 ::  de rang :  3 et 5 	 AiB : D :: p1 ::  de rang :  2 et 2 	 A : A :: B :: D :: p1 ::   de rang : 3 et 3 *)
assert(HDp1p3p4m2 : rk(D :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABDp1eq : rk(A :: B :: D :: p1 :: nil) = 3) by (apply LABDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(HABDp1p3p4mtmp : rk(A :: B :: D :: p1 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDp1p3p4eq HABDp1p3p4m3).
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HDp1mtmp : rk(D :: p1 :: nil) >= 2) by (solve_hyps_min HDp1eq HDp1m2).
	assert(Hincl : incl (D :: p1 :: nil) (list_inter (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p4 :: nil) (A :: B :: D :: p1 :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: D :: p1 :: p3 :: p4 :: nil) ((A :: B :: D :: p1 :: nil) ++ (D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDp1p3p4mtmp;try rewrite HT2 in HABDp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p4 :: nil) (D :: p1 :: nil) 3 2 3 HABDp1p3p4mtmp HDp1mtmp HABDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADp1p2p3p4 requis par la preuve de (?)ADp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1p2p3p4m2 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADp1p2p3p4m3 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADp1p2p3p4M5 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HDp1p3p4Mtmp : rk(D :: p1 :: p3 :: p4 :: nil) <= 4) by (solve_hyps_max HDp1p3p4eq HDp1p3p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (D :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: D :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: p1 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (D :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (D :: p1 :: p3 :: p4 :: nil) (nil) 1 4 0 HAp2Mtmp HDp1p3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADp1p2p3p4M4 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAp1p2p4Mtmp : rk(A :: p1 :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HAp1p2p4eq HAp1p2p4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: nil) (A :: nil) 2 3 1 HADp3Mtmp HAp1p2p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour p1p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour Ap1p2p3p4 requis par la preuve de (?)Ap1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p3p4m2 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p3p4M4 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p3p4Mtmp : rk(p1 :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max Hp1p3p4eq Hp1p3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p3 :: p4 :: nil) (nil) 1 3 0 HAp2Mtmp Hp1p3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 4 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p4m3 : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADp1p2p3p4mtmp : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HADp1p2p3p4eq HADp1p2p3p4m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADp1p2p3p4mtmp;try rewrite HT2 in HADp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p3 :: nil) 3 2 2 HADp1p2p3p4mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour p1p2p3p4 requis par la preuve de (?)p1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour p1p2p3p4 requis par la preuve de (?)p1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 ::  de rang :  2 et 4 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(Hp1p2p3p4m2 : rk(p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAp1p2p3p4mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 2) by (solve_hyps_min HAp1p2p3p4eq HAp1p2p3p4m2).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4mtmp;try rewrite HT2 in HAp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: nil) (p2 :: nil) 2 1 1 HAp1p2p3p4mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 4 	 AiB : p2 :: p3 ::  de rang :  2 et 2 	 A : A :: p2 :: p3 ::   de rang : 2 et 2 *)
assert(Hp1p2p3p4m3 : rk(p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HAp2p3eq : rk(A :: p2 :: p3 :: nil) = 2) by (apply LAp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAp2p3Mtmp : rk(A :: p2 :: p3 :: nil) <= 2) by (solve_hyps_max HAp2p3eq HAp2p3M2).
	assert(HAp1p2p3p4mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HAp1p2p3p4eq HAp1p2p3p4m3).
	assert(Hp2p3eq : rk(p2 :: p3 :: nil) = 2) by (apply Lp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(Hp2p3mtmp : rk(p2 :: p3 :: nil) >= 2) by (solve_hyps_min Hp2p3eq Hp2p3m2).
	assert(Hincl : incl (p2 :: p3 :: nil) (list_inter (A :: p2 :: p3 :: nil) (p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: p3 :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p3 :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: p2 :: p3 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4mtmp;try rewrite HT2 in HAp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: p2 :: p3 :: nil) (p1 :: p2 :: p3 :: p4 :: nil) (p2 :: p3 :: nil) 3 2 2 HAp1p2p3p4mtmp Hp2p3mtmp HAp2p3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 4 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(Hp1p2p3p4m4 : rk(p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAp1p2p3p4eq : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) = 4) by (apply LAp1p2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption).
	assert(HAp1p2p3p4mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HAp1p2p3p4eq HAp1p2p3p4m4).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p2 :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4mtmp;try rewrite HT2 in HAp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: nil) (p2 :: nil) 4 1 1 HAp1p2p3p4mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

assert(Hp1p2p3p4M : rk(p1 :: p2 :: p3 :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max Hp1p2p3p4eq Hp1p2p3p4M4).
assert(Hp1p2p3p4m : rk(p1 :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min Hp1p2p3p4eq Hp1p2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Theorem def_Conclusion : forall A B C D E A' B' C' D' E' p1 p2 p3 p4 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(A' :: B' :: C' :: D' :: E' ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: A' :: B' :: C' :: D' :: E' ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(B :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p1 ::  nil) = 5 -> rk(A :: p2 ::  nil) = 1 -> rk(C :: p2 ::  nil) = 2 ->
rk(A :: C :: p2 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p2 ::  nil) = 5 -> rk(A :: p3 ::  nil) = 2 ->
rk(D :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(A' :: B' :: C' :: D' :: E' :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(E :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 ->
rk(A' :: B' :: C' :: D' :: E' :: p4 ::  nil) = 5 -> 
	 rk(p1 :: p2 :: p3 :: p4 ::  nil) = 4  .
Proof.

intros A B C D E A' B' C' D' E' p1 p2 p3 p4 
HABCDEeq HA'B'C'D'E'eq HABCDEA'B'C'D'E'eq HAp1eq HBp1eq HABp1eq HA'B'C'D'E'p1eq HAp2eq HCp2eq HACp2eq
HA'B'C'D'E'p2eq HAp3eq HDp3eq HADp3eq HA'B'C'D'E'p3eq HAp4eq HEp4eq HAEp4eq HA'B'C'D'E'p4eq .
repeat split.

	apply Lp1p2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (A' := A') (B' := B') (C' := C') (D' := D') (E' := E') (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) ; assumption.
Qed .
